#include <boost/algorithm/string/predicate.hpp>
#include <boost/lexical_cast.hpp>
#include <string>
#include <vector>

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/libraryIdentification/libraryIdentification.h line 18
namespace stringify { namespace LibraryIdentification {
    const char* DUPLICATE_OPTION(int64_t i) {
        switch (i) {
            case 0L: return "UNKNOWN";
            case 1L: return "COMBINE";
            case 2L: return "REPLACE";
            case 3L: return "NO_ADD";
            default: return "";
        }
    }

    std::string DUPLICATE_OPTION(int64_t i, const std::string &strip) {
        std::string s = DUPLICATE_OPTION(i);
        if (s.empty())
            s = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DUPLICATE_OPTION() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLibraryIdentificationDUPLICATE_OPTION(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LibraryIdentification::DUPLICATE_OPTION(i);
        if (retval.empty()) {
            retval = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LibraryIdentification::DUPLICATE_OPTION::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLibraryIdentificationDUPLICATE_OPTION() {
        return stringify::LibraryIdentification::DUPLICATE_OPTION();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/EditDistance/TreeEditDistance.h line 60
namespace stringify { namespace Rose { namespace EditDistance { namespace TreeEditDistance {
    const char* EditType(int64_t i) {
        switch (i) {
            case 0L: return "INSERT";
            case 1L: return "DELETE";
            case 2L: return "SUBSTITUTE";
            default: return "";
        }
    }

    std::string EditType(int64_t i, const std::string &strip) {
        std::string s = EditType(i);
        if (s.empty())
            s = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyEditDistanceTreeEditDistanceEditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::EditDistance::TreeEditDistance::EditType(i);
        if (retval.empty()) {
            retval = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::EditDistance::TreeEditDistance::EditType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEditDistanceTreeEditDistanceEditType() {
        return stringify::Rose::EditDistance::TreeEditDistance::EditType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/staticSingleAssignment/reachingDef.h line 18
namespace stringify { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReachingDefType() {
        return stringify::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 163
namespace stringify {
    const char* IRProcType(int64_t i) {
        switch (i) {
            case 0L: return "ProcType_PGM";
            case 1L: return "ProcType_SUB";
            case 2L: return "ProcType_FUNC";
            case 3L: return "ProcType_BDATA";
            case 4L: return "ProcType_ILLEGAL";
            default: return "";
        }
    }

    std::string IRProcType(int64_t i, const std::string &strip) {
        std::string s = IRProcType(i);
        if (s.empty())
            s = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRProcType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRProcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRProcType(i);
        if (retval.empty()) {
            retval = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRProcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRProcType() {
        return stringify::IRProcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 173
namespace stringify {
    const char* IRStmtType(int64_t i) {
        switch (i) {
            case 0L: return "SIMPLE";
            case 1L: return "COMPOUND";
            case 2L: return "LOOP";
            case 3L: return "END_TESTED_LOOP";
            case 4L: return "STRUCT_TWOWAY_CONDITIONAL";
            case 5L: return "STRUCT_MULTIWAY_CONDITIONAL";
            case 6L: return "USTRUCT_TWOWAY_CONDITIONAL_T";
            case 7L: return "USTRUCT_TWOWAY_CONDITIONAL_F";
            case 8L: return "USTRUCT_MULTIWAY_CONDITIONAL";
            case 9L: return "RETURN";
            case 10L: return "BREAK";
            case 11L: return "LOOP_CONTINUE";
            case 12L: return "ALTERNATE_PROC_ENTRY";
            case 13L: return "UNCONDITIONAL_JUMP";
            case 14L: return "UNCONDITIONAL_JUMP_I";
            case 15L: return "NONE";
            default: return "";
        }
    }

    std::string IRStmtType(int64_t i, const std::string &strip) {
        std::string s = IRStmtType(i);
        if (s.empty())
            s = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRStmtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRStmtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRStmtType(i);
        if (retval.empty()) {
            retval = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRStmtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRStmtType() {
        return stringify::IRStmtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h line 261
namespace stringify { namespace BaseGraph { namespace BiDirNodesIterator {
    const char* dirType(int64_t i) {
        switch (i) {
            case 0L: return "Forward";
            case 1L: return "Reverse";
            default: return "";
        }
    }

    std::string dirType(int64_t i, const std::string &strip) {
        std::string s = dirType(i);
        if (s.empty())
            s = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& dirType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBaseGraphBiDirNodesIterator_dirType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BaseGraph::BiDirNodesIterator::dirType(i);
        if (retval.empty()) {
            retval = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBaseGraphBiDirNodesIterator_dirType() {
        return stringify::BaseGraph::BiDirNodesIterator::dirType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h line 83
namespace stringify { namespace CFG {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "TRUE_EDGE";
            case 1L: return "FALLTHROUGH_EDGE";
            case 2L: return "FALSE_EDGE";
            case 3L: return "BACK_EDGE";
            case 4L: return "MULTIWAY_EDGE";
            case 5L: return "BREAK_EDGE";
            case 6L: return "CONTINUE_EDGE";
            case 7L: return "RETURN_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCFG_EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CFG::EdgeType(i);
        if (retval.empty()) {
            retval = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CFG::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCFG_EdgeType() {
        return stringify::CFG::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 63
namespace stringify { namespace RIFG {
    const char* EdgeDirection(int64_t i) {
        switch (i) {
            case 0L: return "ED_INCOMING";
            case 1L: return "ED_OUTGOING";
            default: return "";
        }
    }

    std::string EdgeDirection(int64_t i, const std::string &strip) {
        std::string s = EdgeDirection(i);
        if (s.empty())
            s = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_EdgeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::EdgeDirection(i);
        if (retval.empty()) {
            retval = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::EdgeDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_EdgeDirection() {
        return stringify::RIFG::EdgeDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 64
namespace stringify { namespace RIFG {
    const char* ForwardBackward(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string ForwardBackward(int64_t i, const std::string &strip) {
        std::string s = ForwardBackward(i);
        if (s.empty())
            s = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ForwardBackward() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_ForwardBackward(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::ForwardBackward(i);
        if (retval.empty()) {
            retval = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::ForwardBackward::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_ForwardBackward() {
        return stringify::RIFG::ForwardBackward();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 65
namespace stringify {
    const char* RITarjType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NOTHING";
            case 1L: return "RI_TARJ_ACYCLIC";
            case 2L: return "RI_TARJ_INTERVAL";
            case 3L: return "RI_TARJ_IRREDUCIBLE";
            default: return "";
        }
    }

    std::string RITarjType(int64_t i, const std::string &strip) {
        std::string s = RITarjType(i);
        if (s.empty())
            s = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjType(i);
        if (retval.empty()) {
            retval = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjType() {
        return stringify::RITarjType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 67
namespace stringify {
    const char* RITarjEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NORMAL";
            case 1L: return "RI_TARJ_LOOP_ENTRY";
            case 2L: return "RI_TARJ_IRRED_ENTRY";
            case 3L: return "RI_TARJ_ITERATE";
            default: return "";
        }
    }

    std::string RITarjEdgeType(int64_t i, const std::string &strip) {
        std::string s = RITarjEdgeType(i);
        if (s.empty())
            s = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjEdgeType(i);
        if (retval.empty()) {
            retval = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjEdgeType() {
        return stringify::RITarjEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h line 73
namespace stringify { namespace CallGraph {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCallGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CallGraph::EdgeType(i);
        if (retval.empty()) {
            retval = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CallGraph::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallGraphEdgeType() {
        return stringify::CallGraph::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h line 50
namespace stringify { namespace DominatorTreesAndDominanceFrontiers { namespace DominatorTree {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection() {
        return stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h line 63
namespace stringify { namespace TaintLattice {
    const char* Vertex(int64_t i) {
        switch (i) {
            case 0L: return "VERTEX_BOTTOM";
            case 1L: return "VERTEX_UNTAINTED";
            case 2L: return "VERTEX_TAINTED";
            default: return "";
        }
    }

    std::string Vertex(int64_t i, const std::string &strip) {
        std::string s = Vertex(i);
        if (s.empty())
            s = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Vertex() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaintLatticeVertex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TaintLattice::Vertex(i);
        if (retval.empty()) {
            retval = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TaintLattice::Vertex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaintLatticeVertex() {
        return stringify::TaintLattice::Vertex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h line 45
namespace stringify { namespace ConstrGraph {
    const char* levels(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "bottom";
            case 2L: return "constrKnown";
            case 3L: return "top";
            default: return "";
        }
    }

    std::string levels(int64_t i, const std::string &strip) {
        std::string s = levels(i);
        if (s.empty())
            s = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& levels() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyConstrGraph_levels(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstrGraph::levels(i);
        if (retval.empty()) {
            retval = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstrGraph::levels::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstrGraph_levels() {
        return stringify::ConstrGraph::levels();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h line 119
namespace stringify { namespace CGFunction { namespace iterator {
    const char* direction(int64_t i) {
        switch (i) {
            case 0L: return "fw";
            case 1L: return "bw";
            default: return "";
        }
    }

    std::string direction(int64_t i, const std::string &strip) {
        std::string s = direction(i);
        if (s.empty())
            s = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCGFunction_iterator_direction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CGFunction::iterator::direction(i);
        if (retval.empty()) {
            retval = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CGFunction::iterator::direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCGFunction_iterator_direction() {
        return stringify::CGFunction::iterator::direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 25
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* running_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_analysis_and_instrument";
            case 1L: return "e_static_counting";
            default: return "";
        }
    }

    std::string running_mode_enum(int64_t i, const std::string &strip) {
        std::string s = running_mode_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& running_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_running_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::running_mode_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::running_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_running_mode_enum() {
        return stringify::ArithmeticIntensityMeasurement::running_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 30
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* fp_operation_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_total";
            case 2L: return "e_plus";
            case 3L: return "e_minus";
            case 4L: return "e_multiply";
            case 5L: return "e_divide";
            default: return "";
        }
    }

    std::string fp_operation_kind_enum(int64_t i, const std::string &strip) {
        std::string s = fp_operation_kind_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fp_operation_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::fp_operation_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum() {
        return stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h line 19
namespace stringify { namespace ssa_unfiltered_cfg { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            case 3L: return "EXTERNAL_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_ssa_unfiltered_cfgReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ssa_unfiltered_cfg::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ssa_unfiltered_cfgReachingDefType() {
        return stringify::ssa_unfiltered_cfg::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 26
namespace stringify { namespace ReadWriteSets {
    const char* Globality(int64_t i) {
        switch (i) {
            case 0L: return "LOCALS";
            case 1L: return "PARAMETERS";
            case 2L: return "MEMBERS";
            case 3L: return "OTHER_CLASS_MEMBERS";
            case 4L: return "STATIC_MEMBERS";
            case 5L: return "FILE_SCOPE";
            case 6L: return "GLOBALS";
            case 7L: return "GLOBALITY_UNKNOWN";
            default: return "";
        }
    }

    std::string Globality(int64_t i, const std::string &strip) {
        std::string s = Globality(i);
        if (s.empty())
            s = "(ReadWriteSets::Globality)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Globality() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsGlobality(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::Globality(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::Globality)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::Globality::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsGlobality() {
        return stringify::ReadWriteSets::Globality();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 42
namespace stringify { namespace ReadWriteSets {
    const char* VarType(int64_t i) {
        switch (i) {
            case 0L: return "PRIMITIVES";
            case 1L: return "ARRAYS";
            case 2L: return "ARRAY_INDEX_EXPRESSIONS";
            case 3L: return "STRUCTS";
            case 4L: return "ARRAYS_OF_STRUCTS";
            case 5L: return "FUNCTIONS";
            case 6L: return "MEMBER_FUNCTIONS";
            case 7L: return "POINTERS";
            case 8L: return "VARTYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string VarType(int64_t i, const std::string &strip) {
        std::string s = VarType(i);
        if (s.empty())
            s = "(ReadWriteSets::VarType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VarType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsVarType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::VarType(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::VarType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::VarType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsVarType() {
        return stringify::ReadWriteSets::VarType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 58
namespace stringify { namespace ReadWriteSets {
    const char* AccessType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL";
            case 1L: return "FIELD_ACCESS";
            case 2L: return "ARRAY_INDEX";
            case 3L: return "ADDRESS_OF";
            case 4L: return "POINTER_DEREFERENCE";
            case 5L: return "POINTER_ARROW";
            case 6L: return "FUNCTION_POINTER_DEREF";
            case 7L: return "ACCESSTYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string AccessType(int64_t i, const std::string &strip) {
        std::string s = AccessType(i);
        if (s.empty())
            s = "(ReadWriteSets::AccessType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AccessType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsAccessType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::AccessType(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::AccessType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::AccessType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsAccessType() {
        return stringify::ReadWriteSets::AccessType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 31
namespace stringify { namespace PtrAliasAnalysis {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::COLOR(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisCOLOR() {
        return stringify::PtrAliasAnalysis::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 33
namespace stringify { namespace PtrAliasAnalysis {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "REVERSE_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisTRAVERSAL_TYPE() {
        return stringify::PtrAliasAnalysis::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 274
namespace stringify { namespace CollectAliasRelations {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::COLOR(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsCOLOR() {
        return stringify::CollectAliasRelations::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 275
namespace stringify { namespace CollectAliasRelations {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "NON_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsTRAVERSAL_TYPE() {
        return stringify::CollectAliasRelations::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/PDG.h line 32
namespace stringify { namespace SDG { namespace PDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_PDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::PDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::PDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_PDGEdgeEdgeType() {
        return stringify::SDG::PDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 21
namespace stringify { namespace SDG { namespace SDGNode {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "Entry";
            case 1L: return "ASTNode";
            case 2L: return "FunctionCall";
            case 3L: return "ActualIn";
            case 4L: return "ActualOut";
            case 5L: return "FormalIn";
            case 6L: return "FormalOut";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGNodeNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGNode::NodeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGNode::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGNodeNodeType() {
        return stringify::SDG::SDGNode::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 48
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            case 2L: return "ParameterIn";
            case 3L: return "ParameterOut";
            case 4L: return "Call";
            case 5L: return "Summary";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeEdgeType() {
        return stringify::SDG::SDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 58
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* ControlDependenceType(int64_t i) {
        switch (i) {
            case 0L: return "cdTrue";
            case 1L: return "cdFalse";
            case 2L: return "cdCase";
            case 3L: return "cdDefault";
            default: return "";
        }
    }

    std::string ControlDependenceType(int64_t i, const std::string &strip) {
        std::string s = ControlDependenceType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ControlDependenceType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeControlDependenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::ControlDependenceType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeControlDependenceType() {
        return stringify::SDG::SDGEdge::ControlDependenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h line 13
namespace stringify { namespace DominatorTreesAndDominanceFrontiers {
    const char* Dir_ection(int64_t i) {
        switch (i) {
            case 0L: return "PRE_DOMINATOR";
            case 1L: return "POST_DOMINATOR";
            default: return "";
        }
    }

    std::string Dir_ection(int64_t i, const std::string &strip) {
        std::string s = Dir_ection(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Dir_ection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDir_ection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::Dir_ection(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDir_ection() {
        return stringify::DominatorTreesAndDominanceFrontiers::Dir_ection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractMemoryObject/memory_object_impl.h line 82
namespace stringify { namespace AbstractMemoryObject { namespace IndexSet {
    const char* Index_type(int64_t i) {
        switch (i) {
            case 0L: return "Integer_type";
            case 1L: return "Unknown_type";
            default: return "";
        }
    }

    std::string Index_type(int64_t i, const std::string &strip) {
        std::string s = Index_type(i);
        if (s.empty())
            s = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Index_type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyAbstractMemoryObjectIndexSetIndex_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AbstractMemoryObject::IndexSet::Index_type(i);
        if (retval.empty()) {
            retval = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAbstractMemoryObjectIndexSetIndex_type() {
        return stringify::AbstractMemoryObject::IndexSet::Index_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 319
namespace stringify { namespace Rose { namespace Snippet {
    const char* InsertMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BODY";
            case 1L: return "INSERT_STMTS";
            default: return "";
        }
    }

    std::string InsertMechanism(int64_t i, const std::string &strip) {
        std::string s = InsertMechanism(i);
        if (s.empty())
            s = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetInsertMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::InsertMechanism(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::InsertMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetInsertMechanism() {
        return stringify::Rose::Snippet::InsertMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 329
namespace stringify { namespace Rose { namespace Snippet {
    const char* LocalDeclarationPosition(int64_t i) {
        switch (i) {
            case 0L: return "LOCDECLS_AT_BEGINNING";
            case 1L: return "LOCDECLS_AT_END";
            case 2L: return "LOCDECLS_AT_CURSOR";
            default: return "";
        }
    }

    std::string LocalDeclarationPosition(int64_t i, const std::string &strip) {
        std::string s = LocalDeclarationPosition(i);
        if (s.empty())
            s = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LocalDeclarationPosition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetLocalDeclarationPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::LocalDeclarationPosition(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::LocalDeclarationPosition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetLocalDeclarationPosition() {
        return stringify::Rose::Snippet::LocalDeclarationPosition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 52
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "StatementScope";
            case 2L: return "SurroundingScope";
            case 3L: return "Preamble";
            case 4L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 66
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfCurrentScope";
            case 3L: return "BeforeCurrentPosition";
            case 4L: return "ReplaceCurrentPosition";
            case 5L: return "AfterCurrentPosition";
            case 6L: return "BottomOfCurrentScope";
            case 7L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 79
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "CurrentLocationTopOfScope";
            case 3L: return "CurrentLocationAfter";
            case 4L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            case 6L: return "CurrentLocationBottomOfScope";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 141
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "SurroundingScope";
            case 2L: return "ParentScope";
            case 3L: return "NestedLoopScope";
            case 4L: return "NestedConditionalScope";
            case 5L: return "FunctionScope";
            case 6L: return "FileScope";
            case 7L: return "GlobalScope";
            case 8L: return "Preamble";
            case 9L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 162
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfScope";
            case 3L: return "TopOfIncludeRegion";
            case 4L: return "BottomOfIncludeRegion";
            case 5L: return "BeforeCurrentPosition";
            case 6L: return "ReplaceCurrentPosition";
            case 7L: return "AfterCurrentPosition";
            case 8L: return "BottomOfScope";
            case 9L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 176
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "GlobalScopeTopOfScope";
            case 3L: return "GlobalScopeTopOfIncludeRegion";
            case 4L: return "GlobalScopeBottomOfIncludeRegion";
            case 5L: return "GlobalScopeBeforeCurrentPosition";
            case 6L: return "GlobalScopeReplaceCurrentPosition";
            case 7L: return "FunctionScopePreamble";
            case 8L: return "FunctionScopeTopOfScope";
            case 9L: return "FunctionScopeBeforeCurrentPosition";
            case 10L: return "FunctionScopeReplaceCurrentPosition";
            case 11L: return "FunctionScopeAfterCurrentPosition";
            case 12L: return "FunctionScopeBottomOfScope";
            case 13L: return "GlobalScopeAfterCurrentPosition";
            case 14L: return "GlobalScopeBottomOfScope";
            case 15L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h line 40
namespace stringify { namespace FunctionCallInfo {
    const char* InsertionMode(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BEFORE";
            case 1L: return "APPEND_SCOPE";
            case 2L: return "INVALID";
            default: return "";
        }
    }

    std::string InsertionMode(int64_t i, const std::string &strip) {
        std::string s = InsertionMode(i);
        if (s.empty())
            s = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertionMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFunctionCallInfoInsertionMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FunctionCallInfo::InsertionMode(i);
        if (retval.empty()) {
            retval = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FunctionCallInfo::InsertionMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFunctionCallInfoInsertionMode() {
        return stringify::FunctionCallInfo::InsertionMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_lowering.h line 37
namespace stringify { namespace OmpSupport {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gomp";
            case 1L: return "e_omni";
            case 2L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_rtl_enum() {
        return stringify::OmpSupport::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/xomp.c line 63
namespace stringify {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_undefined";
            case 1L: return "e_gomp";
            case 2L: return "e_omni";
            case 3L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_rtl_enum() {
        return stringify::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C line 17
namespace stringify {
    const char* defaultEnumFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_constructor";
            case 2L: return "e_destructor";
            case 3L: return "e_copy_constructor";
            case 4L: return "e_assignment_operator";
            case 5L: return "e_last_type";
            default: return "";
        }
    }

    std::string defaultEnumFunctionType(int64_t i, const std::string &strip) {
        std::string s = defaultEnumFunctionType(i);
        if (s.empty())
            s = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& defaultEnumFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_defaultEnumFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::defaultEnumFunctionType(i);
        if (retval.empty()) {
            retval = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "defaultEnumFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_defaultEnumFunctionType() {
        return stringify::defaultEnumFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/AstUtilInterface.h line 15
namespace stringify { namespace AstUtilInterface {
    const char* OperatorSideEffect(int64_t i) {
        switch (i) {
            case 0L: return "Modify";
            case 1L: return "Read";
            case 2L: return "Kill";
            case 3L: return "Call";
            case 4L: return "Decl";
            case 5L: return "Allocate";
            case 6L: return "Free";
            case 7L: return "Parameter";
            case 8L: return "Return";
            default: return "";
        }
    }

    std::string OperatorSideEffect(int64_t i, const std::string &strip) {
        std::string s = OperatorSideEffect(i);
        if (s.empty())
            s = "(AstUtilInterface::OperatorSideEffect)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OperatorSideEffect() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUtilInterfaceOperatorSideEffect(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUtilInterface::OperatorSideEffect(i);
        if (retval.empty()) {
            retval = "(AstUtilInterface::OperatorSideEffect)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUtilInterface::OperatorSideEffect::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUtilInterfaceOperatorSideEffect() {
        return stringify::AstUtilInterface::OperatorSideEffect();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/astInterface/AstInterface.h line 19
namespace stringify { namespace AstNodePtr {
    const char* SpecialAstType(int64_t i) {
        switch (i) {
            case 0L: return "SG_AST";
            case 1L: return "UNKNOWN_AST";
            case 2L: return "NULL_AST";
            default: return "";
        }
    }

    std::string SpecialAstType(int64_t i, const std::string &strip) {
        std::string s = SpecialAstType(i);
        if (s.empty())
            s = "(AstNodePtr::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SpecialAstType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodePtrSpecialAstType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodePtr::SpecialAstType(i);
        if (retval.empty()) {
            retval = "(AstNodePtr::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodePtr::SpecialAstType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodePtrSpecialAstType() {
        return stringify::AstNodePtr::SpecialAstType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/astInterface/AstInterface.h line 66
namespace stringify { namespace AstNodeType {
    const char* SpecialAstType(int64_t i) {
        switch (i) {
            case 0L: return "SG_TYPE";
            case 1L: return "UNKNOWN_TYPE";
            case 2L: return "NULL_TYPE";
            default: return "";
        }
    }

    std::string SpecialAstType(int64_t i, const std::string &strip) {
        std::string s = SpecialAstType(i);
        if (s.empty())
            s = "(AstNodeType::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SpecialAstType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeTypeSpecialAstType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeType::SpecialAstType(i);
        if (retval.empty()) {
            retval = "(AstNodeType::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeType::SpecialAstType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeTypeSpecialAstType() {
        return stringify::AstNodeType::SpecialAstType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/dependenceTracking/dependence_table.h line 103
namespace stringify { namespace AstUtilInterface { namespace CollectTransitiveDependences {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "CollectForward";
            case 1L: return "CollectBackward";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(AstUtilInterface::CollectTransitiveDependences::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyAstUtilInterfaceCollectTransitiveDependencesDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUtilInterface::CollectTransitiveDependences::Direction(i);
        if (retval.empty()) {
            retval = "(AstUtilInterface::CollectTransitiveDependences::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUtilInterface::CollectTransitiveDependences::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUtilInterfaceCollectTransitiveDependencesDirection() {
        return stringify::AstUtilInterface::CollectTransitiveDependences::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.h line 41
namespace stringify { namespace AstAttribute {
    const char* OwnershipPolicy(int64_t i) {
        switch (i) {
            case 0L: return "CONTAINER_OWNERSHIP";
            case 1L: return "NO_OWNERSHIP";
            case 2L: return "CUSTOM_OWNERSHIP";
            case 3L: return "UNKNOWN_OWNERSHIP";
            default: return "";
        }
    }

    std::string OwnershipPolicy(int64_t i, const std::string &strip) {
        std::string s = OwnershipPolicy(i);
        if (s.empty())
            s = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OwnershipPolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeOwnershipPolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttribute::OwnershipPolicy(i);
        if (retval.empty()) {
            retval = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttribute::OwnershipPolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeOwnershipPolicy() {
        return stringify::AstAttribute::OwnershipPolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.C line 21
namespace stringify {
    const char* WarningType(int64_t i) {
        switch (i) {
            case 0L: return "HAS_MEMORY_LEAK";
            case 1L: return "HAS_UNKNOWN_OWNERSHIP";
            case 2L: return "HAS_NULL_COPY";
            case 3L: return "HAS_SELF_COPY";
            case 4L: return "HAS_NO_CLASS_NAME";
            default: return "";
        }
    }

    std::string WarningType(int64_t i, const std::string &strip) {
        std::string s = WarningType(i);
        if (s.empty())
            s = "(WarningType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WarningType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyWarningType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::WarningType(i);
        if (retval.empty()) {
            retval = "(WarningType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "WarningType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyWarningType() {
        return stringify::WarningType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstRestructure.h line 22
namespace stringify { namespace AstUnparseAttribute {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 5L: return "replace";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUnparseAttributeRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUnparseAttribute::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUnparseAttribute::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUnparseAttributeRelativePositionType() {
        return stringify::AstUnparseAttribute::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 10
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "NumberOfArgsInConstructor";
            case 2L: return "NumberOfOperands";
            case 3L: return "NumberOfArgsInScalarIndexingOperator";
            case 4L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeOneParameter() {
        return stringify::NumberQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 19
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "NumberOfArgsInParanthesisOperator";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NumberQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 133
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclarations";
            case 2L: return "VariableTypes";
            case 3L: return "FunctionDeclarations";
            case 4L: return "MemberFunctionDeclarations";
            case 5L: return "ClassDeclarations";
            case 6L: return "StructDeclarations";
            case 7L: return "UnionDeclarations";
            case 8L: return "Arguments";
            case 9L: return "ClassFields";
            case 10L: return "StructFields";
            case 11L: return "UnionFields";
            case 12L: return "StructDefinitions";
            case 13L: return "TypedefDeclarations";
            case 14L: return "AnonymousTypedefs";
            case 15L: return "AnonymousTypedefClassDeclarations";
            case 16L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeOneParameter() {
        return stringify::NodeQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 154
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "FunctionDeclarationFromDefinition";
            case 2L: return "ClassDeclarationFromName";
            case 3L: return "ClassDeclarationsFromTypeName";
            case 4L: return "PragmaDeclarationFromName";
            case 5L: return "VariableDeclarationFromName";
            case 6L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NodeQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 74
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableNames";
            case 2L: return "VariableTypeNames";
            case 3L: return "FunctionDeclarationNames";
            case 4L: return "MemberFunctionDeclarationNames";
            case 5L: return "ClassDeclarationNames";
            case 6L: return "ArgumentNames";
            case 7L: return "ClassFieldNames";
            case 8L: return "UnionFieldNames";
            case 9L: return "StructFieldNames";
            case 10L: return "FunctionReferenceNames";
            case 11L: return "StructNames";
            case 12L: return "UnionNames";
            case 13L: return "TypedefDeclarationNames";
            case 14L: return "TypeNames";
            case 15L: return "END_OF_NAME_TYPE_LIST";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeOneParameter() {
        return stringify::NameQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 94
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "VariableNamesWithTypeName";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NameQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/astQuery.h line 81
namespace stringify { namespace AstQueryNamespace {
    const char* QueryDepth(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeQueryDepth";
            case 1L: return "ChildrenOnly";
            case 2L: return "AllNodes";
            case 3L: return "ExtractTypes";
            case 4L: return "END_OF_NODE_TYPE_LIST_QUERY_DEPTH";
            default: return "";
        }
    }

    std::string QueryDepth(int64_t i, const std::string &strip) {
        std::string s = QueryDepth(i);
        if (s.empty())
            s = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QueryDepth() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstQueryNamespaceQueryDepth(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstQueryNamespace::QueryDepth(i);
        if (retval.empty()) {
            retval = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstQueryNamespace::QueryDepth::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstQueryNamespaceQueryDepth() {
        return stringify::AstQueryNamespace::QueryDepth();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/booleanQuery.h line 43
namespace stringify { namespace BooleanQuery {
    const char* TypeOfQueryType(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclaration";
            case 2L: return "Type";
            case 3L: return "FunctionDeclaration";
            case 4L: return "MemberFunctionDeclaration";
            case 5L: return "ClassDeclaration";
            case 6L: return "Argument";
            case 7L: return "Field";
            case 8L: return "UnionedField";
            case 9L: return "Struct";
            case 10L: return "ContainedInSubtreeOfType";
            case 11L: return "END_OF_BOOLEAN_QUERY_TYPE";
            default: return "";
        }
    }

    std::string TypeOfQueryType(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryType(i);
        if (s.empty())
            s = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyBooleanQueryTypeOfQueryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BooleanQuery::TypeOfQueryType(i);
        if (retval.empty()) {
            retval = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BooleanQuery::TypeOfQueryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBooleanQueryTypeOfQueryType() {
        return stringify::BooleanQuery::TypeOfQueryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 174
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* AggregateType(int64_t i) {
        switch (i) {
            case 0L: return "AT_UNKNOWN";
            case 1L: return "AT_SINGLE";
            case 2L: return "AT_ARRAY";
            case 3L: return "AT_STRUCT";
            case 4L: return "AT_STRING_LITERAL";
            default: return "";
        }
    }

    std::string AggregateType(int64_t i, const std::string &strip) {
        std::string s = AggregateType(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingAggregateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::AggregateType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::AggregateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingAggregateType() {
        return stringify::CodeThorn::VariableIdMapping::AggregateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 175
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* VariableScope(int64_t i) {
        switch (i) {
            case 0L: return "VS_UNKNOWN";
            case 1L: return "VS_LOCAL";
            case 2L: return "VS_FUNPARAM";
            case 3L: return "VS_GLOBAL";
            case 4L: return "VS_MEMBER";
            default: return "";
        }
    }

    std::string VariableScope(int64_t i, const std::string &strip) {
        std::string s = VariableScope(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariableScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingVariableScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::VariableScope(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::VariableScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingVariableScope() {
        return stringify::CodeThorn::VariableIdMapping::VariableScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 15
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* LabelType(int64_t i) {
        switch (i) {
            case 1L: return "LABEL_UNDEF";
            case 2L: return "LABEL_OTHER";
            case 100L: return "LABEL_FUNCTIONCALL";
            case 101L: return "LABEL_FUNCTIONCALLRETURN";
            case 102L: return "LABEL_FUNCTIONENTRY";
            case 103L: return "LABEL_FUNCTIONEXIT";
            case 104L: return "LABEL_BLOCKBEGIN";
            case 105L: return "LABEL_BLOCKEND";
            case 106L: return "LABEL_EMPTY_STMT";
            case 107L: return "LABEL_FORK";
            case 108L: return "LABEL_JOIN";
            case 109L: return "LABEL_WORKSHARE";
            case 110L: return "LABEL_BARRIER";
            default: return "";
        }
    }

    std::string LabelType(int64_t i, const std::string &strip) {
        std::string s = LabelType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LabelType() {
        static const int64_t values[] = {
            1L,
            2L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyLabelType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::LabelType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::LabelType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyLabelType() {
        return stringify::CodeThorn::LabelProperty::LabelType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 50
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* IOType(int64_t i) {
        switch (i) {
            case 0L: return "LABELIO_NONE";
            case 1L: return "LABELIO_STDIN";
            case 2L: return "LABELIO_STDOUTVAR";
            case 3L: return "LABELIO_STDOUTCONST";
            case 4L: return "LABELIO_STDERR";
            default: return "";
        }
    }

    std::string IOType(int64_t i, const std::string &strip) {
        std::string s = IOType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IOType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyIOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::IOType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::IOType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyIOType() {
        return stringify::CodeThorn::LabelProperty::IOType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/SgNodeHelper.h line 542
namespace stringify { namespace SgNodeHelper { namespace Pattern { namespace OutputTarget {
    const char* OType(int64_t i) {
        switch (i) {
            case 0L: return "VAR";
            case 1L: return "INT";
            case 2L: return "UNKNOWNPRINTF";
            case 3L: return "UNKNOWNOPERATION";
            default: return "";
        }
    }

    std::string OType(int64_t i, const std::string &strip) {
        std::string s = OType(i);
        if (s.empty())
            s = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySgNodeHelperPatternOutputTargetOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgNodeHelper::Pattern::OutputTarget::OType(i);
        if (retval.empty()) {
            retval = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgNodeHelperPatternOutputTargetOType() {
        return stringify::SgNodeHelper::Pattern::OutputTarget::OType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 40
namespace stringify { namespace MatchStatus {
    const char* PatternMatchMode(int64_t i) {
        switch (i) {
            case 0L: return "MATCHMODE_SHALLOW";
            case 1L: return "MATCHMODE_DEEP";
            case 2L: return "MATCHMODE_SINGLE";
            default: return "";
        }
    }

    std::string PatternMatchMode(int64_t i, const std::string &strip) {
        std::string s = PatternMatchMode(i);
        if (s.empty())
            s = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternMatchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusPatternMatchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::PatternMatchMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::PatternMatchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusPatternMatchMode() {
        return stringify::MatchStatus::PatternMatchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 41
namespace stringify { namespace MatchStatus {
    const char* CheckNodeMode(int64_t i) {
        switch (i) {
            case 0L: return "NODECHECKMODE_TYPEID";
            case 1L: return "NODECHECKMODE_VARIANT";
            default: return "";
        }
    }

    std::string CheckNodeMode(int64_t i, const std::string &strip) {
        std::string s = CheckNodeMode(i);
        if (s.empty())
            s = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CheckNodeMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusCheckNodeMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::CheckNodeMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::CheckNodeMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusCheckNodeMode() {
        return stringify::MatchStatus::CheckNodeMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/matcherparser.h line 49
namespace stringify {
    const char* yytokentype(int64_t i) {
        switch (i) {
            case 258L: return "ALTERNATION";
            case 259L: return "NOT";
            case 260L: return "AND";
            case 261L: return "XOR";
            case 262L: return "OR";
            case 263L: return "NEQ";
            case 264L: return "EQ";
            case 265L: return "C_NEQ";
            case 266L: return "C_EQ";
            case 267L: return "WHERE";
            case 268L: return "TRUE";
            case 269L: return "FALSE";
            case 270L: return "IDENT";
            case 271L: return "VARIABLE";
            case 272L: return "INTEGER";
            case 273L: return "SQ_STRING";
            case 274L: return "NULL_NODE";
            case 275L: return "DOTDOT";
            default: return "";
        }
    }

    std::string yytokentype(int64_t i, const std::string &strip) {
        std::string s = yytokentype(i);
        if (s.empty())
            s = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& yytokentype() {
        static const int64_t values[] = {
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_yytokentype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::yytokentype(i);
        if (retval.empty()) {
            retval = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "yytokentype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_yytokentype() {
        return stringify::yytokentype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp line 156
namespace stringify { namespace ClangToSageTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToSageTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToSageTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToSageTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToSageTranslatorLanguage() {
        return stringify::ClangToSageTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 156
namespace stringify { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 228
namespace stringify { namespace ClangToDotTranslator { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyClangToDotTranslatorClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/ast2dot.hpp line 11
namespace stringify { namespace dot {
    const char* attr_set(int64_t i) {
        switch (i) {
            case 0L: return "simple";
            case 1L: return "types";
            case 3L: return "moretypes";
            case 4L: return "decllinks";
            case 5L: return "balanced";
            case 8L: return "symbols";
            case 16L: return "builtins";
            case 31L: return "full";
            default: return "";
        }
    }

    std::string attr_set(int64_t i, const std::string &strip) {
        std::string s = attr_set(i);
        if (s.empty())
            s = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attr_set() {
        static const int64_t values[] = {
            0L,
            1L,
            3L,
            4L,
            5L,
            8L,
            16L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_dot_attr_set(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::dot::attr_set(i);
        if (retval.empty()) {
            retval = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "dot::attr_set::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_dot_attr_set() {
        return stringify::dot::attr_set();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/csharpBuilder.h line 10
namespace stringify { namespace csharp_translator {
    const char* SeqKind(int64_t i) {
        switch (i) {
            case 2L: return "GLOBALSCOPESEQ";
            case 3L: return "CLASSMEMBERSEQ";
            case 4L: return "PARAMETERSEQ";
            case 5L: return "METHODBODYSEQ";
            case 6L: return "EXPRLISTSEQ";
            case 7L: return "IFSTMT";
            case 8L: return "FORSTMT";
            case 9L: return "WHILESTMT";
            default: return "";
        }
    }

    std::string SeqKind(int64_t i, const std::string &strip) {
        std::string s = SeqKind(i);
        if (s.empty())
            s = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SeqKind() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_csharp_translatorSeqKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::csharp_translator::SeqKind(i);
        if (retval.empty()) {
            retval = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "csharp_translator::SeqKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_csharp_translatorSeqKind() {
        return stringify::csharp_translator::SeqKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Jovial_ROSE_Connection/Jovial_to_ROSE_translation.h line 11
namespace stringify { namespace Jovial_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 1L: return "e_unknown";
            case 9999L: return "e_exponentiateOperator";
            case 10000L: return "e_plusOperator";
            case 10001L: return "e_minusOperator";
            case 10002L: return "e_modOperator";
            case 10003L: return "e_multiplyOperator";
            case 10004L: return "e_divideOperator";
            case 10005L: return "e_notOperator";
            case 10006L: return "e_andOperator";
            case 10007L: return "e_orOperator";
            case 10008L: return "e_xorOperator";
            case 10009L: return "e_equivOperator";
            case 10010L: return "e_lessThanOperator";
            case 10011L: return "e_greaterThanOperator";
            case 10012L: return "e_lessThanOrEqualOperator";
            case 10013L: return "e_greaterThanOrEqualOperator";
            case 10014L: return "e_equalOperator";
            case 10015L: return "e_notEqualOperator";
            case 10016L: return "e_derefOperator";
            case 10017L: return "e_assignOperator";
            case 10018L: return "e_unaryPlusOperator";
            case 10019L: return "e_unaryMinusOperator";
            case 10020L: return "e_notAnOperator";
            case 10021L: return "e_literalExpression";
            case 10022L: return "e_referenceExpression";
            case 10023L: return "e_by_phrase_expr";
            case 10024L: return "e_then_phrase_expr";
            case 10025L: return "e_while_phrase_expr";
            case 10026L: return "e_words_per_entry_w";
            case 10027L: return "e_words_per_entry_v";
            case 10028L: return "e_for_while_by_stmt";
            case 10029L: return "e_for_while_then_stmt";
            case 10030L: return "e_for_by_while_stmt";
            case 10031L: return "e_for_then_while_stmt";
            case 10032L: return "e_simple_block_type_declaration";
            case 10033L: return "e_block_type_declaration";
            case 10034L: return "e_simple_table_type_declaration";
            case 10035L: return "e_table_type_declaration";
            case 10036L: return "e_anonymous_declaration";
            case 10037L: return "e_compool_directive_stmt";
            case 10038L: return "e_reducible_directive_stmt";
            case 10039L: return "e_order_directive_stmt";
            case 10040L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            1L,
            9999L,
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L,
            10023L,
            10024L,
            10025L,
            10026L,
            10027L,
            10028L,
            10029L,
            10030L,
            10031L,
            10032L,
            10033L,
            10034L,
            10035L,
            10036L,
            10037L,
            10038L,
            10039L,
            10040L
        };
        static const std::vector<int64_t> retval(values, values + 43);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyJovial_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Jovial_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Jovial_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyJovial_ROSE_TranslationExpressionKind() {
        return stringify::Jovial_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Jovial_ROSE_Connection/preprocess.C line 32
namespace stringify { namespace Jovial {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "start_token";
            case 1L: return "E1";
            case 2L: return "F";
            case 3L: return "I";
            case 4L: return "N";
            case 5L: return "E2";
            case 6L: return "WS";
            case 7L: return "name_start";
            case 8L: return "name";
            case 9L: return "close_paren";
            case 10L: return "define_quote1";
            case 11L: return "define_quote2";
            case 12L: return "end_comment_quote1";
            case 13L: return "end_comment_quote2";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Jovial::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyJovialState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Jovial::State(i);
        if (retval.empty()) {
            retval = "(Jovial::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Jovial::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyJovialState() {
        return stringify::Jovial::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Flang_ROSE_Connection/sage-build.C line 72
namespace stringify {
    const char* Order(int64_t i) {
        switch (i) {
            case 0L: return "begin";
            case 1L: return "end";
            default: return "";
        }
    }

    std::string Order(int64_t i, const std::string &strip) {
        std::string s = Order(i);
        if (s.empty())
            s = "(Order)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Order() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Order(i);
        if (retval.empty()) {
            retval = "(Order)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Order::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOrder() {
        return stringify::Order();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 146
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* OperandDefn(int64_t i) {
        switch (i) {
            case 0L: return "od_none";
            case 1L: return "od_AL";
            case 2L: return "od_AX";
            case 3L: return "od_EAX";
            case 4L: return "od_RAX";
            case 5L: return "od_DX";
            case 6L: return "od_CS";
            case 7L: return "od_DS";
            case 8L: return "od_ES";
            case 9L: return "od_FS";
            case 10L: return "od_GS";
            case 11L: return "od_SS";
            case 12L: return "od_rel8";
            case 13L: return "od_rel16";
            case 14L: return "od_rel32";
            case 15L: return "od_rel64";
            case 16L: return "od_ptr16_16";
            case 17L: return "od_ptr16_32";
            case 18L: return "od_ptr16_64";
            case 19L: return "od_r8";
            case 20L: return "od_r16";
            case 21L: return "od_r32";
            case 22L: return "od_r64";
            case 23L: return "od_imm8";
            case 24L: return "od_imm16";
            case 25L: return "od_imm32";
            case 26L: return "od_imm64";
            case 27L: return "od_r_m8";
            case 28L: return "od_r_m16";
            case 29L: return "od_r_m32";
            case 30L: return "od_r_m64";
            case 31L: return "od_m";
            case 32L: return "od_m8";
            case 33L: return "od_m16";
            case 34L: return "od_m32";
            case 35L: return "od_m64";
            case 36L: return "od_m128";
            case 37L: return "od_m16_16";
            case 38L: return "od_m16_32";
            case 39L: return "od_m16_64";
            case 40L: return "od_m16a16";
            case 41L: return "od_m16a32";
            case 42L: return "od_m32a32";
            case 43L: return "od_m16a64";
            case 44L: return "od_moffs8";
            case 45L: return "od_moffs16";
            case 46L: return "od_moffs32";
            case 47L: return "od_moffs64";
            case 48L: return "od_sreg";
            case 49L: return "od_m32fp";
            case 50L: return "od_m64fp";
            case 51L: return "od_m80fp";
            case 52L: return "od_st0";
            case 53L: return "od_st1";
            case 54L: return "od_st2";
            case 55L: return "od_st3";
            case 56L: return "od_st4";
            case 57L: return "od_st5";
            case 58L: return "od_st6";
            case 59L: return "od_st7";
            case 60L: return "od_sti";
            case 61L: return "od_mm";
            case 62L: return "od_mm_m32";
            case 63L: return "od_mm_m64";
            case 64L: return "od_xmm";
            case 65L: return "od_xmm_m16";
            case 66L: return "od_xmm_m32";
            case 67L: return "od_xmm_m64";
            case 68L: return "od_xmm_m128";
            case 69L: return "od_XMM0";
            case 70L: return "od_0";
            case 71L: return "od_1";
            case 72L: return "od_m80";
            case 73L: return "od_dec";
            case 74L: return "od_m80bcd";
            case 75L: return "od_m2byte";
            case 76L: return "od_m14_28byte";
            case 77L: return "od_m94_108byte";
            case 78L: return "od_m512byte";
            case 79L: return "od_r16_m16";
            case 80L: return "od_r32_m8";
            case 81L: return "od_r32_m16";
            case 82L: return "od_r64_m16";
            case 83L: return "od_CR0";
            case 84L: return "od_CR7";
            case 85L: return "od_CR8";
            case 86L: return "od_CR0CR7";
            case 87L: return "od_DR0DR7";
            case 88L: return "od_reg";
            case 89L: return "od_CL";
            default: return "";
        }
    }

    std::string OperandDefn(int64_t i, const std::string &strip) {
        std::string s = OperandDefn(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OperandDefn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L
        };
        static const std::vector<int64_t> retval(values, values + 90);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86OperandDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::OperandDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86OperandDefn() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 387
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* MemoryReferencePattern(int64_t i) {
        switch (i) {
            case 0L: return "mrp_unknown";
            case 1L: return "mrp_disp";
            case 2L: return "mrp_index";
            case 3L: return "mrp_index_disp";
            case 4L: return "mrp_base";
            case 5L: return "mrp_base_disp";
            case 6L: return "mrp_base_index";
            case 7L: return "mrp_base_index_disp";
            default: return "";
        }
    }

    std::string MemoryReferencePattern(int64_t i, const std::string &strip) {
        std::string s = MemoryReferencePattern(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryReferencePattern() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/Assembler.h line 80
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Assembler {
    const char* EncodingType(int64_t i) {
        switch (i) {
            case 0L: return "ET_SHORTEST";
            case 1L: return "ET_LONGEST";
            case 2L: return "ET_MATCHES";
            default: return "";
        }
    }

    std::string EncodingType(int64_t i, const std::string &strip) {
        std::string s = EncodingType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EncodingType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerEncodingType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Assembler::EncodingType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Assembler::EncodingType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerEncodingType() {
        return stringify::Rose::BinaryAnalysis::Assembler::EncodingType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86Init.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "x86_unknown_instruction";
            case 1L: return "x86_aaa";
            case 2L: return "x86_aad";
            case 3L: return "x86_aam";
            case 4L: return "x86_aas";
            case 5L: return "x86_adc";
            case 6L: return "x86_add";
            case 7L: return "x86_addpd";
            case 8L: return "x86_addps";
            case 9L: return "x86_addsd";
            case 10L: return "x86_addss";
            case 11L: return "x86_addsubpd";
            case 12L: return "x86_addsubps";
            case 13L: return "x86_and";
            case 14L: return "x86_andnpd";
            case 15L: return "x86_andnps";
            case 16L: return "x86_andpd";
            case 17L: return "x86_andps";
            case 18L: return "x86_arpl";
            case 19L: return "x86_blendpd";
            case 20L: return "x86_blendps";
            case 21L: return "x86_blendvpd";
            case 22L: return "x86_blendvps";
            case 23L: return "x86_bound";
            case 24L: return "x86_bsf";
            case 25L: return "x86_bsr";
            case 26L: return "x86_bswap";
            case 27L: return "x86_bt";
            case 28L: return "x86_btc";
            case 29L: return "x86_btr";
            case 30L: return "x86_bts";
            case 31L: return "x86_call";
            case 32L: return "x86_cbw";
            case 33L: return "x86_cdq";
            case 34L: return "x86_cdqe";
            case 35L: return "x86_clc";
            case 36L: return "x86_cld";
            case 37L: return "x86_clflush";
            case 38L: return "x86_clgi";
            case 39L: return "x86_cli";
            case 40L: return "x86_clts";
            case 41L: return "x86_cmc";
            case 42L: return "x86_cmova";
            case 43L: return "x86_cmovae";
            case 44L: return "x86_cmovb";
            case 45L: return "x86_cmovbe";
            case 46L: return "x86_cmove";
            case 47L: return "x86_cmovg";
            case 48L: return "x86_cmovge";
            case 49L: return "x86_cmovl";
            case 50L: return "x86_cmovle";
            case 51L: return "x86_cmovne";
            case 52L: return "x86_cmovno";
            case 53L: return "x86_cmovns";
            case 54L: return "x86_cmovo";
            case 55L: return "x86_cmovpe";
            case 56L: return "x86_cmovpo";
            case 57L: return "x86_cmovs";
            case 58L: return "x86_cmp";
            case 59L: return "x86_cmppd";
            case 60L: return "x86_cmpps";
            case 61L: return "x86_cmpsb";
            case 62L: return "x86_cmpsd";
            case 63L: return "x86_cmpsq";
            case 64L: return "x86_cmpss";
            case 65L: return "x86_cmpsw";
            case 66L: return "x86_cmpxchg";
            case 67L: return "x86_cmpxchg16b";
            case 68L: return "x86_cmpxchg8b";
            case 69L: return "x86_comisd";
            case 70L: return "x86_comiss";
            case 71L: return "x86_cpuid";
            case 72L: return "x86_cqo";
            case 73L: return "x86_crc32";
            case 74L: return "x86_cvtdq2pd";
            case 75L: return "x86_cvtdq2ps";
            case 76L: return "x86_cvtpd2dq";
            case 77L: return "x86_cvtpd2pi";
            case 78L: return "x86_cvtpd2ps";
            case 79L: return "x86_cvtpi2pd";
            case 80L: return "x86_cvtpi2ps";
            case 81L: return "x86_cvtps2dq";
            case 82L: return "x86_cvtps2pd";
            case 83L: return "x86_cvtps2pi";
            case 84L: return "x86_cvtsd2si";
            case 85L: return "x86_cvtsd2ss";
            case 86L: return "x86_cvtsi2sd";
            case 87L: return "x86_cvtsi2ss";
            case 88L: return "x86_cvtss2sd";
            case 89L: return "x86_cvtss2si";
            case 90L: return "x86_cvttpd2dq";
            case 91L: return "x86_cvttpd2pi";
            case 92L: return "x86_cvttps2dq";
            case 93L: return "x86_cvttps2pi";
            case 94L: return "x86_cvttsd2si";
            case 95L: return "x86_cvttss2si";
            case 96L: return "x86_cwd";
            case 97L: return "x86_cwde";
            case 98L: return "x86_daa";
            case 99L: return "x86_das";
            case 100L: return "x86_dec";
            case 101L: return "x86_div";
            case 102L: return "x86_divpd";
            case 103L: return "x86_divps";
            case 104L: return "x86_divsd";
            case 105L: return "x86_divss";
            case 106L: return "x86_dppd";
            case 107L: return "x86_dpps";
            case 108L: return "x86_emms";
            case 109L: return "x86_enter";
            case 110L: return "x86_extractps";
            case 111L: return "x86_extrq";
            case 112L: return "x86_f2xm1";
            case 113L: return "x86_fabs";
            case 114L: return "x86_fadd";
            case 115L: return "x86_faddp";
            case 116L: return "x86_farcall";
            case 117L: return "x86_farjmp";
            case 118L: return "x86_fbld";
            case 119L: return "x86_fbstp";
            case 120L: return "x86_fchs";
            case 121L: return "x86_fcmovb";
            case 122L: return "x86_fcmovbe";
            case 123L: return "x86_fcmove";
            case 124L: return "x86_fcmovnb";
            case 125L: return "x86_fcmovnbe";
            case 126L: return "x86_fcmovne";
            case 127L: return "x86_fcmovnu";
            case 128L: return "x86_fcmovu";
            case 129L: return "x86_fcom";
            case 130L: return "x86_fcomi";
            case 131L: return "x86_fcomip";
            case 132L: return "x86_fcomp";
            case 133L: return "x86_fcompp";
            case 134L: return "x86_fcos";
            case 135L: return "x86_fdecstp";
            case 136L: return "x86_fdiv";
            case 137L: return "x86_fdivp";
            case 138L: return "x86_fdivr";
            case 139L: return "x86_fdivrp";
            case 140L: return "x86_femms";
            case 141L: return "x86_ffree";
            case 142L: return "x86_fiadd";
            case 143L: return "x86_ficom";
            case 144L: return "x86_ficomp";
            case 145L: return "x86_fidiv";
            case 146L: return "x86_fidivr";
            case 147L: return "x86_fild";
            case 148L: return "x86_fimul";
            case 149L: return "x86_fincstp";
            case 150L: return "x86_fist";
            case 151L: return "x86_fistp";
            case 152L: return "x86_fisttp";
            case 153L: return "x86_fisub";
            case 154L: return "x86_fisubr";
            case 155L: return "x86_fld";
            case 156L: return "x86_fld1";
            case 157L: return "x86_fldcw";
            case 158L: return "x86_fldenv";
            case 159L: return "x86_fldl2e";
            case 160L: return "x86_fldl2t";
            case 161L: return "x86_fldlg2";
            case 162L: return "x86_fldln2";
            case 163L: return "x86_fldpi";
            case 164L: return "x86_fldz";
            case 165L: return "x86_fmul";
            case 166L: return "x86_fmulp";
            case 167L: return "x86_fnclex";
            case 168L: return "x86_fninit";
            case 169L: return "x86_fnop";
            case 170L: return "x86_fnsave";
            case 171L: return "x86_fnstcw";
            case 172L: return "x86_fnstenv";
            case 173L: return "x86_fnstsw";
            case 174L: return "x86_fpatan";
            case 175L: return "x86_fprem";
            case 176L: return "x86_fprem1";
            case 177L: return "x86_fptan";
            case 178L: return "x86_frndint";
            case 179L: return "x86_frstor";
            case 180L: return "x86_fscale";
            case 181L: return "x86_fsin";
            case 182L: return "x86_fsincos";
            case 183L: return "x86_fsqrt";
            case 184L: return "x86_fst";
            case 185L: return "x86_fstp";
            case 186L: return "x86_fsub";
            case 187L: return "x86_fsubp";
            case 188L: return "x86_fsubr";
            case 189L: return "x86_fsubrp";
            case 190L: return "x86_ftst";
            case 191L: return "x86_fucom";
            case 192L: return "x86_fucomi";
            case 193L: return "x86_fucomip";
            case 194L: return "x86_fucomp";
            case 195L: return "x86_fucompp";
            case 196L: return "x86_fwait";
            case 197L: return "x86_fxam";
            case 198L: return "x86_fxch";
            case 199L: return "x86_fxrstor";
            case 200L: return "x86_fxsave";
            case 201L: return "x86_fxtract";
            case 202L: return "x86_fyl2x";
            case 203L: return "x86_fyl2xp1";
            case 204L: return "x86_getsec";
            case 205L: return "x86_haddpd";
            case 206L: return "x86_haddps";
            case 207L: return "x86_hlt";
            case 208L: return "x86_hsubpd";
            case 209L: return "x86_hsubps";
            case 210L: return "x86_idiv";
            case 211L: return "x86_imul";
            case 212L: return "x86_in";
            case 213L: return "x86_inc";
            case 214L: return "x86_insb";
            case 215L: return "x86_insd";
            case 216L: return "x86_insertps";
            case 217L: return "x86_insertq";
            case 218L: return "x86_insw";
            case 219L: return "x86_int";
            case 220L: return "x86_int1";
            case 221L: return "x86_int3";
            case 222L: return "x86_into";
            case 223L: return "x86_invd";
            case 224L: return "x86_invept";
            case 225L: return "x86_invlpg";
            case 226L: return "x86_invlpga";
            case 227L: return "x86_invvpid";
            case 228L: return "x86_iret";
            case 229L: return "x86_ja";
            case 230L: return "x86_jae";
            case 231L: return "x86_jb";
            case 232L: return "x86_jbe";
            case 233L: return "x86_jcxz";
            case 234L: return "x86_je";
            case 235L: return "x86_jecxz";
            case 236L: return "x86_jg";
            case 237L: return "x86_jge";
            case 238L: return "x86_jl";
            case 239L: return "x86_jle";
            case 240L: return "x86_jmp";
            case 241L: return "x86_jmpe";
            case 242L: return "x86_jne";
            case 243L: return "x86_jno";
            case 244L: return "x86_jns";
            case 245L: return "x86_jo";
            case 246L: return "x86_jpe";
            case 247L: return "x86_jpo";
            case 248L: return "x86_jrcxz";
            case 249L: return "x86_js";
            case 250L: return "x86_lahf";
            case 251L: return "x86_lar";
            case 252L: return "x86_lddqu";
            case 253L: return "x86_ldmxcsr";
            case 254L: return "x86_lds";
            case 255L: return "x86_lea";
            case 256L: return "x86_leave";
            case 257L: return "x86_les";
            case 258L: return "x86_lfence";
            case 259L: return "x86_lfs";
            case 260L: return "x86_lgdt";
            case 261L: return "x86_lgs";
            case 262L: return "x86_lidt";
            case 263L: return "x86_lldt";
            case 264L: return "x86_lmsw";
            case 265L: return "x86_lock";
            case 266L: return "x86_lodsb";
            case 267L: return "x86_lodsd";
            case 268L: return "x86_lodsq";
            case 269L: return "x86_lodsw";
            case 270L: return "x86_loop";
            case 271L: return "x86_loopnz";
            case 272L: return "x86_loopz";
            case 273L: return "x86_lsl";
            case 274L: return "x86_lss";
            case 275L: return "x86_ltr";
            case 276L: return "x86_lzcnt";
            case 277L: return "x86_maskmovq";
            case 278L: return "x86_maxpd";
            case 279L: return "x86_maxps";
            case 280L: return "x86_maxsd";
            case 281L: return "x86_maxss";
            case 282L: return "x86_mfence";
            case 283L: return "x86_minpd";
            case 284L: return "x86_minps";
            case 285L: return "x86_minsd";
            case 286L: return "x86_minss";
            case 287L: return "x86_monitor";
            case 288L: return "x86_mov";
            case 289L: return "x86_movapd";
            case 290L: return "x86_movaps";
            case 291L: return "x86_movbe";
            case 292L: return "x86_movd";
            case 293L: return "x86_movddup";
            case 294L: return "x86_movdq2q";
            case 295L: return "x86_movdqa";
            case 296L: return "x86_movdqu";
            case 297L: return "x86_movhlps";
            case 298L: return "x86_movhpd";
            case 299L: return "x86_movhps";
            case 300L: return "x86_movlhps";
            case 301L: return "x86_movlpd";
            case 302L: return "x86_movlps";
            case 303L: return "x86_movmskpd";
            case 304L: return "x86_movmskps";
            case 305L: return "x86_movntdq";
            case 306L: return "x86_movntdqa";
            case 307L: return "x86_movnti";
            case 308L: return "x86_movntpd";
            case 309L: return "x86_movntps";
            case 310L: return "x86_movntq";
            case 311L: return "x86_movntsd";
            case 312L: return "x86_movntss";
            case 313L: return "x86_movq";
            case 314L: return "x86_movq2dq";
            case 315L: return "x86_movsb";
            case 316L: return "x86_movsd";
            case 317L: return "x86_movsd_sse";
            case 318L: return "x86_movshdup";
            case 319L: return "x86_movsldup";
            case 320L: return "x86_movsq";
            case 321L: return "x86_movss";
            case 322L: return "x86_movsw";
            case 323L: return "x86_movsx";
            case 324L: return "x86_movsxd";
            case 325L: return "x86_movupd";
            case 326L: return "x86_movups";
            case 327L: return "x86_movzx";
            case 328L: return "x86_mpsadbw";
            case 329L: return "x86_mul";
            case 330L: return "x86_mulpd";
            case 331L: return "x86_mulps";
            case 332L: return "x86_mulsd";
            case 333L: return "x86_mulss";
            case 334L: return "x86_mwait";
            case 335L: return "x86_neg";
            case 336L: return "x86_nop";
            case 337L: return "x86_not";
            case 338L: return "x86_or";
            case 339L: return "x86_orpd";
            case 340L: return "x86_orps";
            case 341L: return "x86_out";
            case 342L: return "x86_outs";
            case 343L: return "x86_outsb";
            case 344L: return "x86_outsd";
            case 345L: return "x86_outsw";
            case 346L: return "x86_pabsb";
            case 347L: return "x86_pabsd";
            case 348L: return "x86_pabsw";
            case 349L: return "x86_packssdw";
            case 350L: return "x86_packsswb";
            case 351L: return "x86_packusdw";
            case 352L: return "x86_packuswb";
            case 353L: return "x86_paddb";
            case 354L: return "x86_paddd";
            case 355L: return "x86_paddq";
            case 356L: return "x86_paddsb";
            case 357L: return "x86_paddsw";
            case 358L: return "x86_paddusb";
            case 359L: return "x86_paddusw";
            case 360L: return "x86_paddw";
            case 361L: return "x86_palignr";
            case 362L: return "x86_pand";
            case 363L: return "x86_pandn";
            case 364L: return "x86_pause";
            case 365L: return "x86_pavgb";
            case 366L: return "x86_pavgusb";
            case 367L: return "x86_pavgw";
            case 368L: return "x86_pblendvb";
            case 369L: return "x86_pblendw";
            case 370L: return "x86_pcmpeqb";
            case 371L: return "x86_pcmpeqd";
            case 372L: return "x86_pcmpeqq";
            case 373L: return "x86_pcmpeqw";
            case 374L: return "x86_pcmpestri";
            case 375L: return "x86_pcmpestrm";
            case 376L: return "x86_pcmpgtb";
            case 377L: return "x86_pcmpgtd";
            case 378L: return "x86_pcmpgtq";
            case 379L: return "x86_pcmpgtw";
            case 380L: return "x86_pcmpistri";
            case 381L: return "x86_pcmpistrm";
            case 382L: return "x86_pextrb";
            case 383L: return "x86_pextrd";
            case 384L: return "x86_pextrq";
            case 385L: return "x86_pextrw";
            case 386L: return "x86_pf2id";
            case 387L: return "x86_pf2iw";
            case 388L: return "x86_pfacc";
            case 389L: return "x86_pfadd";
            case 390L: return "x86_pfcmpeq";
            case 391L: return "x86_pfcmpge";
            case 392L: return "x86_pfcmpgt";
            case 393L: return "x86_pfmax";
            case 394L: return "x86_pfmin";
            case 395L: return "x86_pfmul";
            case 396L: return "x86_pfnacc";
            case 397L: return "x86_pfpnacc";
            case 398L: return "x86_pfrcp";
            case 399L: return "x86_pfrcpit1";
            case 400L: return "x86_pfrcpit2";
            case 401L: return "x86_pfrsqit1";
            case 402L: return "x86_pfrsqrt";
            case 403L: return "x86_pfsub";
            case 404L: return "x86_pfsubr";
            case 405L: return "x86_phaddd";
            case 406L: return "x86_phaddsw";
            case 407L: return "x86_phaddw";
            case 408L: return "x86_phminposuw";
            case 409L: return "x86_phsubd";
            case 410L: return "x86_phsubsw";
            case 411L: return "x86_phsubw";
            case 412L: return "x86_pi2fd";
            case 413L: return "x86_pi2fw";
            case 414L: return "x86_pinsrb";
            case 415L: return "x86_pinsrd";
            case 416L: return "x86_pinsrq";
            case 417L: return "x86_pinsrw";
            case 418L: return "x86_pmaddubsw";
            case 419L: return "x86_pmaddwd";
            case 420L: return "x86_pmaxsb";
            case 421L: return "x86_pmaxsd";
            case 422L: return "x86_pmaxsw";
            case 423L: return "x86_pmaxub";
            case 424L: return "x86_pmaxud";
            case 425L: return "x86_pmaxuw";
            case 426L: return "x86_pminsb";
            case 427L: return "x86_pminsd";
            case 428L: return "x86_pminsw";
            case 429L: return "x86_pminub";
            case 430L: return "x86_pminud";
            case 431L: return "x86_pminuw";
            case 432L: return "x86_pmovmskb";
            case 433L: return "x86_pmovsxbd";
            case 434L: return "x86_pmovsxbq";
            case 435L: return "x86_pmovsxbw";
            case 436L: return "x86_pmovsxdq";
            case 437L: return "x86_pmovsxwd";
            case 438L: return "x86_pmovsxwq";
            case 439L: return "x86_pmovzxbd";
            case 440L: return "x86_pmovzxbq";
            case 441L: return "x86_pmovzxbw";
            case 442L: return "x86_pmovzxdq";
            case 443L: return "x86_pmovzxwd";
            case 444L: return "x86_pmovzxwq";
            case 445L: return "x86_pmuldq";
            case 446L: return "x86_pmulhrsw";
            case 447L: return "x86_pmulhrw";
            case 448L: return "x86_pmulhuw";
            case 449L: return "x86_pmulhw";
            case 450L: return "x86_pmulld";
            case 451L: return "x86_pmullw";
            case 452L: return "x86_pmuludq";
            case 453L: return "x86_pop";
            case 454L: return "x86_popa";
            case 455L: return "x86_popad";
            case 456L: return "x86_popcnt";
            case 457L: return "x86_popf";
            case 458L: return "x86_popfd";
            case 459L: return "x86_popfq";
            case 460L: return "x86_por";
            case 461L: return "x86_prefetch";
            case 462L: return "x86_prefetchnta";
            case 463L: return "x86_prefetcht0";
            case 464L: return "x86_prefetcht1";
            case 465L: return "x86_prefetcht2";
            case 466L: return "x86_prefetchw";
            case 467L: return "x86_psadbw";
            case 468L: return "x86_pshufb";
            case 469L: return "x86_pshufd";
            case 470L: return "x86_pshufhw";
            case 471L: return "x86_pshuflw";
            case 472L: return "x86_pshufw";
            case 473L: return "x86_psignb";
            case 474L: return "x86_psignd";
            case 475L: return "x86_psignw";
            case 476L: return "x86_pslld";
            case 477L: return "x86_pslldq";
            case 478L: return "x86_psllq";
            case 479L: return "x86_psllw";
            case 480L: return "x86_psrad";
            case 481L: return "x86_psraq";
            case 482L: return "x86_psraw";
            case 483L: return "x86_psrld";
            case 484L: return "x86_psrldq";
            case 485L: return "x86_psrlq";
            case 486L: return "x86_psrlw";
            case 487L: return "x86_psubb";
            case 488L: return "x86_psubd";
            case 489L: return "x86_psubq";
            case 490L: return "x86_psubsb";
            case 491L: return "x86_psubsw";
            case 492L: return "x86_psubusb";
            case 493L: return "x86_psubusw";
            case 494L: return "x86_psubw";
            case 495L: return "x86_pswapd";
            case 496L: return "x86_ptest";
            case 497L: return "x86_punpckhbw";
            case 498L: return "x86_punpckhdq";
            case 499L: return "x86_punpckhqdq";
            case 500L: return "x86_punpckhwd";
            case 501L: return "x86_punpcklbw";
            case 502L: return "x86_punpckldq";
            case 503L: return "x86_punpcklqdq";
            case 504L: return "x86_punpcklwd";
            case 505L: return "x86_push";
            case 506L: return "x86_pusha";
            case 507L: return "x86_pushad";
            case 508L: return "x86_pushf";
            case 509L: return "x86_pushfd";
            case 510L: return "x86_pushfq";
            case 511L: return "x86_pxor";
            case 512L: return "x86_rcl";
            case 513L: return "x86_rcpps";
            case 514L: return "x86_rcpss";
            case 515L: return "x86_rcr";
            case 516L: return "x86_rdmsr";
            case 517L: return "x86_rdpmc";
            case 518L: return "x86_rdtsc";
            case 519L: return "x86_rdtscp";
            case 520L: return "x86_rep_insb";
            case 521L: return "x86_rep_insd";
            case 522L: return "x86_rep_insw";
            case 523L: return "x86_rep_lodsb";
            case 524L: return "x86_rep_lodsd";
            case 525L: return "x86_rep_lodsq";
            case 526L: return "x86_rep_lodsw";
            case 527L: return "x86_rep_movsb";
            case 528L: return "x86_rep_movsd";
            case 529L: return "x86_rep_movsq";
            case 530L: return "x86_rep_movsw";
            case 531L: return "x86_rep_outsb";
            case 532L: return "x86_rep_outsd";
            case 533L: return "x86_rep_outsw";
            case 534L: return "x86_rep_stosb";
            case 535L: return "x86_rep_stosd";
            case 536L: return "x86_rep_stosq";
            case 537L: return "x86_rep_stosw";
            case 538L: return "x86_repe_cmpsb";
            case 539L: return "x86_repe_cmpsd";
            case 540L: return "x86_repe_cmpsq";
            case 541L: return "x86_repe_cmpsw";
            case 542L: return "x86_repe_scasb";
            case 543L: return "x86_repe_scasd";
            case 544L: return "x86_repe_scasq";
            case 545L: return "x86_repe_scasw";
            case 546L: return "x86_repne_cmpsb";
            case 547L: return "x86_repne_cmpsd";
            case 548L: return "x86_repne_cmpsq";
            case 549L: return "x86_repne_cmpsw";
            case 550L: return "x86_repne_scasb";
            case 551L: return "x86_repne_scasd";
            case 552L: return "x86_repne_scasq";
            case 553L: return "x86_repne_scasw";
            case 554L: return "x86_ret";
            case 555L: return "x86_retf";
            case 556L: return "x86_rol";
            case 557L: return "x86_ror";
            case 558L: return "x86_roundpd";
            case 559L: return "x86_roundps";
            case 560L: return "x86_roundsd";
            case 561L: return "x86_roundss";
            case 562L: return "x86_rsm";
            case 563L: return "x86_rsqrtps";
            case 564L: return "x86_rsqrtss";
            case 565L: return "x86_sahf";
            case 566L: return "x86_salc";
            case 567L: return "x86_sar";
            case 568L: return "x86_sbb";
            case 569L: return "x86_scasb";
            case 570L: return "x86_scasd";
            case 571L: return "x86_scasq";
            case 572L: return "x86_scasw";
            case 573L: return "x86_seta";
            case 574L: return "x86_setae";
            case 575L: return "x86_setb";
            case 576L: return "x86_setbe";
            case 577L: return "x86_sete";
            case 578L: return "x86_setg";
            case 579L: return "x86_setge";
            case 580L: return "x86_setl";
            case 581L: return "x86_setle";
            case 582L: return "x86_setne";
            case 583L: return "x86_setno";
            case 584L: return "x86_setns";
            case 585L: return "x86_seto";
            case 586L: return "x86_setpe";
            case 587L: return "x86_setpo";
            case 588L: return "x86_sets";
            case 589L: return "x86_sfence";
            case 590L: return "x86_sgdt";
            case 591L: return "x86_shl";
            case 592L: return "x86_shld";
            case 593L: return "x86_shr";
            case 594L: return "x86_shrd";
            case 595L: return "x86_shufpd";
            case 596L: return "x86_shufps";
            case 597L: return "x86_sidt";
            case 598L: return "x86_skinit";
            case 599L: return "x86_sldt";
            case 600L: return "x86_smsw";
            case 601L: return "x86_sqrtpd";
            case 602L: return "x86_sqrtps";
            case 603L: return "x86_sqrtsd";
            case 604L: return "x86_sqrtss";
            case 605L: return "x86_stc";
            case 606L: return "x86_std";
            case 607L: return "x86_stgi";
            case 608L: return "x86_sti";
            case 609L: return "x86_stmxcsr";
            case 610L: return "x86_stos";
            case 611L: return "x86_stosb";
            case 612L: return "x86_stosd";
            case 613L: return "x86_stosq";
            case 614L: return "x86_stosw";
            case 615L: return "x86_str";
            case 616L: return "x86_sub";
            case 617L: return "x86_subpd";
            case 618L: return "x86_subps";
            case 619L: return "x86_subsd";
            case 620L: return "x86_subss";
            case 621L: return "x86_swapgs";
            case 622L: return "x86_syscall";
            case 623L: return "x86_sysenter";
            case 624L: return "x86_sysexit";
            case 625L: return "x86_sysret";
            case 626L: return "x86_test";
            case 627L: return "x86_ucomisd";
            case 628L: return "x86_ucomiss";
            case 629L: return "x86_ud2";
            case 630L: return "x86_unpckhpd";
            case 631L: return "x86_unpckhps";
            case 632L: return "x86_unpcklpd";
            case 633L: return "x86_unpcklps";
            case 634L: return "x86_verr";
            case 635L: return "x86_verw";
            case 636L: return "x86_vmcall";
            case 637L: return "x86_vmclear";
            case 638L: return "x86_vmlaunch";
            case 639L: return "x86_vmload";
            case 640L: return "x86_vmmcall";
            case 641L: return "x86_vmoff";
            case 642L: return "x86_vmptrld";
            case 643L: return "x86_vmptrst";
            case 644L: return "x86_vmread";
            case 645L: return "x86_vmresume";
            case 646L: return "x86_vmrun";
            case 647L: return "x86_vmsave";
            case 648L: return "x86_vmwrite";
            case 649L: return "x86_vmxoff";
            case 650L: return "x86_vmxon";
            case 651L: return "x86_wait";
            case 652L: return "x86_wbinvd";
            case 653L: return "x86_wrmsr";
            case 654L: return "x86_xadd";
            case 655L: return "x86_xchg";
            case 656L: return "x86_xgetbv";
            case 657L: return "x86_xlatb";
            case 658L: return "x86_xor";
            case 659L: return "x86_xorpd";
            case 660L: return "x86_xorps";
            case 661L: return "x86_xrstor";
            case 662L: return "x86_xsave";
            case 663L: return "x86_xsetbv";
            case 664L: return "x86_last_instruction";
            default: return "";
        }
    }

    std::string X86InstructionKind(int64_t i, const std::string &strip) {
        std::string s = X86InstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L
        };
        static const std::vector<int64_t> retval(values, values + 665);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionKind() {
        return stringify::Rose::BinaryAnalysis::X86InstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/ECJ_ROSE_Connection/JavaParserActionROSE.C line 4096
namespace stringify {
    const char* ops(int64_t i) {
        switch (i) {
            case 0L: return "ERROR_OPERATOR";
            case 2L: return "AND";
            case 3L: return "OR";
            case 4L: return "LESS";
            case 5L: return "LESS_EQUAL";
            case 6L: return "GREATER";
            case 7L: return "GREATER_EQUAL";
            case 8L: return "XOR";
            case 9L: return "DIVIDE";
            case 10L: return "LEFT_SHIFT";
            case 13L: return "MINUS";
            case 14L: return "PLUS";
            case 15L: return "MULTIPLY";
            case 16L: return "REMAINDER";
            case 17L: return "RIGHT_SHIFT";
            case 19L: return "UNSIGNED_RIGHT_SHIFT";
            case 100L: return "OR_OR";
            case 101L: return "AND_AND";
            case 102L: return "LAST_OPERATOR";
            default: return "";
        }
    }

    std::string ops(int64_t i, const std::string &strip) {
        std::string s = ops(i);
        if (s.empty())
            s = "(ops)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ops() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            13L,
            14L,
            15L,
            16L,
            17L,
            19L,
            100L,
            101L,
            102L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_ops(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ops(i);
        if (retval.empty()) {
            retval = "(ops)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ops::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ops() {
        return stringify::ops();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 14
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L
        };
        static const std::vector<int64_t> retval(values, values + 126);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 147
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 215
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 242
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_operators() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 321
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 10
namespace stringify {
    const char* ROSE_Fortran_Identifiers(int64_t i) {
        switch (i) {
            case 2L: return "ROSE_ABSTRACT";
            case 3L: return "ROSE_ACCESS";
            case 4L: return "ROSE_ACTION";
            case 5L: return "ROSE_ALLOCATE";
            case 6L: return "ROSE_ALLOCATABLE";
            case 7L: return "ROSE_ASSIGN";
            case 8L: return "ROSE_ASSOCIATE";
            case 9L: return "ROSE_ASYNCHRONOUS";
            case 10L: return "ROSE_BACKSPACE";
            case 11L: return "ROSE_BIND";
            case 12L: return "ROSE_BLANK";
            case 13L: return "ROSE_BLOCK_DATA";
            case 14L: return "ROSE_CALL";
            case 15L: return "ROSE_CHARACTER";
            case 16L: return "ROSE_CLASS";
            case 17L: return "ROSE_CLOSE";
            case 18L: return "ROSE_CONTINUE";
            case 19L: return "ROSE_CYCLE";
            case 20L: return "ROSE_CASE";
            case 21L: return "ROSE_COMMON";
            case 22L: return "ROSE_COMPLEX";
            case 23L: return "ROSE_CONTAINS";
            case 24L: return "ROSE_DEALLOCATE";
            case 25L: return "ROSE_DATA";
            case 26L: return "ROSE_DEFERRED";
            case 27L: return "ROSE_DELIM";
            case 28L: return "ROSE_DIMENSION";
            case 29L: return "ROSE_DO";
            case 30L: return "ROSE_DT";
            case 31L: return "ROSE_DOUBLEPRECISION";
            case 32L: return "ROSE_ENCODING";
            case 33L: return "ROSE_END_CASE";
            case 34L: return "ROSE_ENDDO";
            case 35L: return "ROSE_END_FILE";
            case 36L: return "ROSE_END_ENUM";
            case 37L: return "ROSE_END_INTERFACE";
            case 38L: return "ROSE_END_TYPE";
            case 39L: return "ROSE_ERR";
            case 40L: return "ROSE_ERRMSG";
            case 41L: return "ROSE_EXIT";
            case 42L: return "ROSE_ELSE";
            case 43L: return "ROSE_ELSEWHERE";
            case 44L: return "ROSE_ELSEIF";
            case 45L: return "ROSE_ENDIF";
            case 46L: return "ROSE_ENTRY";
            case 47L: return "ROSE_ENUM";
            case 49L: return "ROSE_ENUMERATOR";
            case 50L: return "ROSE_EQUIVALENCE";
            case 51L: return "ROSE_EXTERNAL";
            case 52L: return "ROSE_EXTENDS";
            case 53L: return "ROSE_FILE";
            case 54L: return "ROSE_FINAL";
            case 55L: return "ROSE_FMT";
            case 56L: return "ROSE_FORALL";
            case 57L: return "ROSE_FORM";
            case 58L: return "ROSE_FORMATTED";
            case 59L: return "ROSE_FORMAT";
            case 60L: return "ROSE_FLUSH";
            case 61L: return "ROSE_FUNCTION";
            case 62L: return "ROSE_GENERIC";
            case 63L: return "ROSE_GOTO";
            case 64L: return "ROSE_ID";
            case 65L: return "ROSE_IF";
            case 66L: return "ROSE_INQUIRE";
            case 67L: return "ROSE_INTEGER";
            case 68L: return "ROSE_IOMSG";
            case 69L: return "ROSE_IOSTAT";
            case 70L: return "ROSE_IMPLICIT";
            case 71L: return "ROSE_IMPLICIT_NONE";
            case 72L: return "ROSE_IMPORT";
            case 73L: return "ROSE_INTERFACE";
            case 74L: return "ROSE_INTENT";
            case 75L: return "ROSE_INTRINSIC";
            case 76L: return "ROSE_LEN";
            case 77L: return "ROSE_LOGICAL";
            case 78L: return "ROSE_KIND";
            case 79L: return "ROSE_MODULE_PROC";
            case 80L: return "ROSE_MODULE";
            case 81L: return "ROSE_NON_INTRINSIC";
            case 82L: return "ROSE_NON_OVERRIDABLE";
            case 83L: return "ROSE_NULL";
            case 84L: return "ROSE_NULLIFY";
            case 85L: return "ROSE_NAMELIST";
            case 86L: return "ROSE_NML";
            case 87L: return "ROSE_NONE";
            case 88L: return "ROSE_NOPASS";
            case 89L: return "ROSE_ONLY";
            case 90L: return "ROSE_OPTIONAL";
            case 91L: return "ROSE_PARAMETER";
            case 92L: return "ROSE_PASS";
            case 93L: return "ROSE_PAUSE";
            case 94L: return "ROSE_POINTER";
            case 96L: return "ROSE_PRINT";
            case 97L: return "ROSE_PRIVATE";
            case 98L: return "ROSE_PROCEDURE";
            case 99L: return "ROSE_PROGRAM";
            case 100L: return "ROSE_PROTECTED";
            case 101L: return "ROSE_READ";
            case 102L: return "ROSE_REAL";
            case 103L: return "ROSE_RETURN";
            case 104L: return "ROSE_REWIND";
            case 105L: return "ROSE_ROUND";
            case 106L: return "ROSE_SELECTCASE";
            case 107L: return "ROSE_SELECTTYPE";
            case 108L: return "ROSE_SEQUENCE";
            case 109L: return "ROSE_SAVE";
            case 110L: return "ROSE_SIGN";
            case 111L: return "ROSE_SIZE";
            case 112L: return "ROSE_SOURCE";
            case 113L: return "ROSE_STAT";
            case 114L: return "ROSE_STOP";
            case 115L: return "ROSE_SUBROUTINE";
            case 116L: return "ROSE_TARGET";
            case 117L: return "ROSE_THEN";
            case 118L: return "ROSE_DERIVED_DECL";
            case 119L: return "ROSE_TYPEIS";
            case 120L: return "ROSE_UNFORMATTED";
            case 121L: return "ROSE_UNIT";
            case 122L: return "ROSE_USE";
            case 123L: return "ROSE_VALUE";
            case 124L: return "ROSE_VOLATILE";
            case 125L: return "ROSE_WAIT";
            case 126L: return "ROSE_WHERE";
            case 127L: return "ROSE_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Identifiers(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Identifiers(i);
        if (s.empty())
            s = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Identifiers() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Identifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Identifiers(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Identifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Identifiers() {
        return stringify::ROSE_Fortran_Identifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 140
namespace stringify {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 1001L: return "ROSE_INTRINSIC_PLUS";
            case 1002L: return "ROSE_INTRINSIC_MINUS";
            case 1003L: return "ROSE_INTRINSIC_POWER";
            case 1004L: return "ROSE_INTRINSIC_CONCAT";
            case 1005L: return "ROSE_INTRINSIC_TIMES";
            case 1006L: return "ROSE_INTRINSIC_DIVIDE";
            case 1007L: return "ROSE_INTRINSIC_AND";
            case 1008L: return "ROSE_INTRINSIC_OR";
            case 1009L: return "ROSE_INTRINSIC_EQV";
            case 1010L: return "ROSE_INTRINSIC_NEQV";
            case 1011L: return "ROSE_INTRINSIC_EQ";
            case 1012L: return "ROSE_INTRINSIC_NE";
            case 1013L: return "ROSE_INTRINSIC_GE";
            case 1014L: return "ROSE_INTRINSIC_LE";
            case 1015L: return "ROSE_INTRINSIC_LT";
            case 1016L: return "ROSE_INTRINSIC_GT";
            case 1017L: return "ROSE_INTRINSIC_NOT";
            case 1018L: return "ROSE_INTRINSIC_OLDEQ";
            case 1019L: return "ROSE_INTRINSIC_OLDNE";
            case 1020L: return "ROSE_INTRINSIC_OLDGE";
            case 1021L: return "ROSE_INTRINSIC_OLDLE";
            case 1022L: return "ROSE_INTRINSIC_OLDLT";
            case 1023L: return "ROSE_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 167
namespace stringify {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 10001L: return "ROSE_FORT_COMMENTS";
            case 10002L: return "ROSE_STRING_LITERALS";
            case 10003L: return "ROSE_IDENTIFIER";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            10001L,
            10002L,
            10003L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/SageTreeBuilder.h line 55
namespace stringify { namespace Rose { namespace builder { namespace SageTreeBuilder {
    const char* LanguageEnum(int64_t i) {
        switch (i) {
            case 0L: return "Fortran";
            case 1L: return "Jovial";
            default: return "";
        }
    }

    std::string LanguageEnum(int64_t i, const std::string &strip) {
        std::string s = LanguageEnum(i);
        if (s.empty())
            s = "(Rose::builder::SageTreeBuilder::LanguageEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LanguageEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringify_builderSageTreeBuilderLanguageEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::builder::SageTreeBuilder::LanguageEnum(i);
        if (retval.empty()) {
            retval = "(Rose::builder::SageTreeBuilder::LanguageEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::builder::SageTreeBuilder::LanguageEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_builderSageTreeBuilderLanguageEnum() {
        return stringify::Rose::builder::SageTreeBuilder::LanguageEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/Tokens.h line 18
namespace stringify { namespace Rose { namespace builder {
    const char* JovialEnum(int64_t i) {
        switch (i) {
            case 0L: return "unknown";
            case 98L: return "define";
            case 99L: return "comment";
            default: return "";
        }
    }

    std::string JovialEnum(int64_t i, const std::string &strip) {
        std::string s = JovialEnum(i);
        if (s.empty())
            s = "(Rose::builder::JovialEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& JovialEnum() {
        static const int64_t values[] = {
            0L,
            98L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_builderJovialEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::builder::JovialEnum(i);
        if (retval.empty()) {
            retval = "(Rose::builder::JovialEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::builder::JovialEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_builderJovialEnum() {
        return stringify::Rose::builder::JovialEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 14
namespace stringify { namespace LanguageTranslation {
    const char* FunctionModifier(int64_t i) {
        switch (i) {
            case 0L: return "e_function_modifier_none";
            case 1L: return "e_function_modifier_reentrant";
            case 2L: return "e_function_modifier_recursive";
            case 3L: return "e_function_modifier_definition";
            case 4L: return "e_function_modifier_reference";
            case 5L: return "e_function_modifier_elemental";
            case 6L: return "e_function_modifier_impure";
            case 7L: return "e_function_modifier_module";
            case 8L: return "e_function_modifier_non_recursive";
            case 9L: return "e_function_modifier_pure";
            case 10L: return "e_function_modifier_cuda_host";
            case 11L: return "e_function_modifier_cuda_device";
            case 12L: return "e_function_modifier_cuda_host_device";
            case 13L: return "e_function_modifier_cuda_global";
            case 14L: return "e_function_modifier_cuda_grid_global";
            case 15L: return "e_function_modifier_last";
            default: return "";
        }
    }

    std::string FunctionModifier(int64_t i, const std::string &strip) {
        std::string s = FunctionModifier(i);
        if (s.empty())
            s = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionModifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationFunctionModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::FunctionModifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::FunctionModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationFunctionModifier() {
        return stringify::LanguageTranslation::FunctionModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 42
namespace stringify { namespace LanguageTranslation {
    const char* PackingSpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_packing_spec_unknown";
            case 1L: return "e_packing_spec_none";
            case 2L: return "e_packing_spec_mixed";
            case 3L: return "e_packing_spec_dense";
            default: return "";
        }
    }

    std::string PackingSpecifier(int64_t i, const std::string &strip) {
        std::string s = PackingSpecifier(i);
        if (s.empty())
            s = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PackingSpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationPackingSpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::PackingSpecifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::PackingSpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationPackingSpecifier() {
        return stringify::LanguageTranslation::PackingSpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 52
namespace stringify { namespace LanguageTranslation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_unknown";
            case 2L: return "e_access_modifier_public";
            case 3L: return "e_access_modifier_private";
            case 4L: return "e_storage_modifier_contiguous";
            case 5L: return "e_storage_modifier_external";
            case 6L: return "e_storage_modifier_static";
            case 7L: return "e_storage_modifier_location";
            case 8L: return "e_storage_modifier_jovial_def";
            case 9L: return "e_storage_modifier_jovial_ref";
            case 10L: return "e_type_modifier_list";
            case 11L: return "e_type_modifier_abstract";
            case 12L: return "e_type_modifier_allocatable";
            case 13L: return "e_type_modifier_asynchronous";
            case 14L: return "e_type_modifier_bind_c";
            case 15L: return "e_type_modifier_const";
            case 16L: return "e_type_modifier_intent_in";
            case 17L: return "e_type_modifier_intent_out";
            case 18L: return "e_type_modifier_intent_inout";
            case 19L: return "e_type_modifier_intrinsic";
            case 20L: return "e_type_modifier_optional";
            case 21L: return "e_type_modifier_parameter";
            case 22L: return "e_type_modifier_pointer";
            case 23L: return "e_type_modifier_protected";
            case 24L: return "e_type_modifier_round";
            case 25L: return "e_type_modifier_save";
            case 26L: return "e_type_modifier_target";
            case 27L: return "e_type_modifier_truncate";
            case 28L: return "e_type_modifier_volatile";
            case 29L: return "e_type_modifier_z";
            case 30L: return "e_param_binding_value";
            case 31L: return "e_param_binding_reference";
            case 32L: return "e_param_binding_result";
            case 33L: return "e_struct_modifier_list";
            case 34L: return "e_struct_item_modifier_list";
            case 35L: return "e_operator_assign";
            case 36L: return "e_operator_exponentiate";
            case 37L: return "e_operator_concatenate";
            case 38L: return "e_operator_add";
            case 39L: return "e_operator_subtract";
            case 40L: return "e_operator_mod";
            case 41L: return "e_operator_multiply";
            case 42L: return "e_operator_divide";
            case 43L: return "e_operator_and";
            case 44L: return "e_operator_or";
            case 45L: return "e_operator_xor";
            case 46L: return "e_operator_equiv";
            case 47L: return "e_operator_less_than";
            case 48L: return "e_operator_greater_than";
            case 49L: return "e_operator_less_or_equal";
            case 50L: return "e_operator_greater_or_equal";
            case 51L: return "e_operator_equality";
            case 52L: return "e_operator_not_equal";
            case 53L: return "e_operator_eqv";
            case 54L: return "e_operator_not_eqv";
            case 55L: return "e_operator_unary_plus";
            case 56L: return "e_operator_unary_minus";
            case 57L: return "e_operator_unary_not";
            case 58L: return "e_operator_unity";
            case 59L: return "e_literalExpression";
            case 60L: return "e_function_reference";
            case 61L: return "e_procedure_call";
            case 62L: return "e_argument_list";
            case 63L: return "e_argument_keyword";
            case 64L: return "e_variable_reference";
            case 65L: return "e_array_reference";
            case 66L: return "e_case_range";
            case 67L: return "e_case_selector";
            case 68L: return "e_array_shape";
            case 69L: return "e_explicit_shape";
            case 70L: return "e_assumed_or_implied_shape";
            case 71L: return "e_assumed_shape";
            case 72L: return "e_assumed_size";
            case 73L: return "e_array_subscripts";
            case 74L: return "e_array_index_triplet";
            case 75L: return "e_section_subscripts";
            case 76L: return "e_explicit_dimension";
            case 77L: return "e_star_dimension";
            case 78L: return "e_star_expression";
            case 79L: return "e_initializer";
            case 80L: return "e_struct_initializer";
            case 81L: return "e_switch_stmt";
            case 82L: return "e_end_switch_stmt";
            case 83L: return "e_case_option_stmt";
            case 84L: return "e_case_default_option_stmt";
            case 85L: return "e_end_proc_ref_stmt";
            case 86L: return "e_end_proc_def_stmt";
            case 87L: return "e_define_directive_stmt";
            case 88L: return "e_fortran_dimension_stmt";
            case 89L: return "e_fortran_import_stmt";
            case 90L: return "e_fortran_if_stmt";
            case 91L: return "e_fortran_if_then_stmt";
            case 92L: return "e_fortran_else_if_stmt";
            case 93L: return "e_fortran_else_stmt";
            case 94L: return "e_fortran_end_do_stmt";
            case 95L: return "e_fortran_do_concurrent_stmt";
            case 96L: return "e_fortran_concurrent_header";
            case 97L: return "e_fortran_concurrent_control";
            case 98L: return "e_fortran_concurrent_locality";
            case 99L: return "e_fortran_forall_stmt";
            case 100L: return "e_fortran_end_forall_stmt";
            case 101L: return "e_fortran_sync_all_stmt";
            case 102L: return "e_fortran_sync_images_stmt";
            case 103L: return "e_fortran_sync_memory_stmt";
            case 104L: return "e_fortran_sync_team_stmt";
            case 105L: return "e_fortran_lock_stmt";
            case 106L: return "e_fortran_unlock_stmt";
            case 107L: return "e_fortran_sync_stat_list";
            case 108L: return "e_fortran_sync_stat_stat";
            case 109L: return "e_fortran_sync_stat_errmsg";
            case 110L: return "e_fortran_stat_acquired_lock";
            case 111L: return "e_jovial_compool_stmt";
            case 112L: return "e_cuda_host";
            case 113L: return "e_cuda_device";
            case 114L: return "e_cuda_global_function";
            case 115L: return "e_cuda_grid_global";
            case 116L: return "e_cuda_global";
            case 117L: return "e_cuda_device_memory";
            case 118L: return "e_cuda_managed";
            case 119L: return "e_cuda_constant";
            case 120L: return "e_cuda_shared";
            case 121L: return "e_cuda_pinned";
            case 122L: return "e_cuda_texture";
            case 123L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationExpressionKind() {
        return stringify::LanguageTranslation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 47
namespace stringify {
    const char* Element_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Element";
            case 1L: return "A_Pragma";
            case 2L: return "A_Defining_Name";
            case 3L: return "A_Declaration";
            case 4L: return "A_Definition";
            case 5L: return "An_Expression";
            case 6L: return "An_Association";
            case 7L: return "A_Statement";
            case 8L: return "A_Path";
            case 9L: return "A_Clause";
            case 10L: return "An_Exception_Handler";
            default: return "";
        }
    }

    std::string Element_Kinds(int64_t i, const std::string &strip) {
        std::string s = Element_Kinds(i);
        if (s.empty())
            s = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Element_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}

namespace Rose {
    std::string stringifyElement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Element_Kinds(i);
        if (retval.empty()) {
            retval = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Element_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyElement_Kinds() {
        return stringify::Element_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 142
namespace stringify {
    const char* Operator_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Operator";
            case 1L: return "An_And_Operator";
            case 2L: return "An_Or_Operator";
            case 3L: return "An_Xor_Operator";
            case 4L: return "An_Equal_Operator";
            case 5L: return "A_Not_Equal_Operator";
            case 6L: return "A_Less_Than_Operator";
            case 7L: return "A_Less_Than_Or_Equal_Operator";
            case 8L: return "A_Greater_Than_Operator";
            case 9L: return "A_Greater_Than_Or_Equal_Operator";
            case 10L: return "A_Plus_Operator";
            case 11L: return "A_Minus_Operator";
            case 12L: return "A_Concatenate_Operator";
            case 13L: return "A_Unary_Plus_Operator";
            case 14L: return "A_Unary_Minus_Operator";
            case 15L: return "A_Multiply_Operator";
            case 16L: return "A_Divide_Operator";
            case 17L: return "A_Mod_Operator";
            case 18L: return "A_Rem_Operator";
            case 19L: return "An_Exponentiate_Operator";
            case 20L: return "An_Abs_Operator";
            case 21L: return "A_Not_Operator";
            default: return "";
        }
    }

    std::string Operator_Kinds(int64_t i, const std::string &strip) {
        std::string s = Operator_Kinds(i);
        if (s.empty())
            s = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOperator_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Operator_Kinds(i);
        if (retval.empty()) {
            retval = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Operator_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOperator_Kinds() {
        return stringify::Operator_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 172
namespace stringify {
    const char* Pragma_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Pragma";
            case 1L: return "An_All_Calls_Remote_Pragma";
            case 2L: return "An_Assert_Pragma";
            case 3L: return "An_Assertion_Policy_Pragma";
            case 4L: return "An_Asynchronous_Pragma";
            case 5L: return "An_Atomic_Pragma";
            case 6L: return "An_Atomic_Components_Pragma";
            case 7L: return "An_Attach_Handler_Pragma";
            case 8L: return "A_Controlled_Pragma";
            case 9L: return "A_Convention_Pragma";
            case 10L: return "A_CPU_Pragma";
            case 11L: return "A_Default_Storage_Pool_Pragma";
            case 12L: return "A_Detect_Blocking_Pragma";
            case 13L: return "A_Discard_Names_Pragma";
            case 14L: return "A_Dispatching_Domain_Pragma";
            case 15L: return "An_Elaborate_Pragma";
            case 16L: return "An_Elaborate_All_Pragma";
            case 17L: return "An_Elaborate_Body_Pragma";
            case 18L: return "An_Export_Pragma";
            case 19L: return "An_Independent_Pragma";
            case 20L: return "A_Independent_Components_Pragma";
            case 21L: return "An_Import_Pragma";
            case 22L: return "An_Inline_Pragma";
            case 23L: return "An_Inspection_Point_Pragma";
            case 24L: return "An_Interrupt_Handler_Pragma";
            case 25L: return "An_Interrupt_Priority_Pragma";
            case 26L: return "A_Linker_Options_Pragma";
            case 27L: return "A_List_Pragma";
            case 28L: return "A_Locking_Policy_Pragma";
            case 29L: return "A_No_Return_Pragma";
            case 30L: return "A_Normalize_Scalars_Pragma";
            case 31L: return "An_Optimize_Pragma";
            case 32L: return "A_Pack_Pragma";
            case 33L: return "A_Page_Pragma";
            case 34L: return "A_Partition_Elaboration_Policy_Pragma";
            case 35L: return "A_Preelaborable_Initialization_Pragma";
            case 36L: return "A_Preelaborate_Pragma";
            case 37L: return "A_Priority_Pragma";
            case 38L: return "A_Priority_Specific_Dispatching_Pragma";
            case 39L: return "A_Profile_Pragma";
            case 40L: return "A_Pure_Pragma";
            case 41L: return "A_Queuing_Policy_Pragma";
            case 42L: return "A_Relative_Deadline_Pragma";
            case 43L: return "A_Remote_Call_Interface_Pragma";
            case 44L: return "A_Remote_Types_Pragma";
            case 45L: return "A_Restrictions_Pragma";
            case 46L: return "A_Reviewable_Pragma";
            case 47L: return "A_Shared_Passive_Pragma";
            case 48L: return "A_Storage_Size_Pragma";
            case 49L: return "A_Suppress_Pragma";
            case 50L: return "A_Task_Dispatching_Policy_Pragma";
            case 51L: return "An_Unchecked_Union_Pragma";
            case 52L: return "An_Unsuppress_Pragma";
            case 53L: return "A_Volatile_Pragma";
            case 54L: return "A_Volatile_Components_Pragma";
            case 55L: return "An_Implementation_Defined_Pragma";
            default: return "";
        }
    }

    std::string Pragma_Kinds(int64_t i, const std::string &strip) {
        std::string s = Pragma_Kinds(i);
        if (s.empty())
            s = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Pragma_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L
        };
        static const std::vector<int64_t> retval(values, values + 56);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPragma_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Pragma_Kinds(i);
        if (retval.empty()) {
            retval = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Pragma_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPragma_Kinds() {
        return stringify::Pragma_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 246
namespace stringify {
    const char* Defining_Name_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Defining_Name";
            case 1L: return "A_Defining_Identifier";
            case 2L: return "A_Defining_Character_Literal";
            case 3L: return "A_Defining_Enumeration_Literal";
            case 4L: return "A_Defining_Operator_Symbol";
            case 5L: return "A_Defining_Expanded_Name";
            default: return "";
        }
    }

    std::string Defining_Name_Kinds(int64_t i, const std::string &strip) {
        std::string s = Defining_Name_Kinds(i);
        if (s.empty())
            s = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Defining_Name_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefining_Name_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Defining_Name_Kinds(i);
        if (retval.empty()) {
            retval = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Defining_Name_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefining_Name_Kinds() {
        return stringify::Defining_Name_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 287
namespace stringify {
    const char* Declaration_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration";
            case 1L: return "An_Ordinary_Type_Declaration";
            case 2L: return "A_Task_Type_Declaration";
            case 3L: return "A_Protected_Type_Declaration";
            case 4L: return "An_Incomplete_Type_Declaration";
            case 5L: return "A_Tagged_Incomplete_Type_Declaration";
            case 6L: return "A_Private_Type_Declaration";
            case 7L: return "A_Private_Extension_Declaration";
            case 8L: return "A_Subtype_Declaration";
            case 9L: return "A_Variable_Declaration";
            case 10L: return "A_Constant_Declaration";
            case 11L: return "A_Deferred_Constant_Declaration";
            case 12L: return "A_Single_Task_Declaration";
            case 13L: return "A_Single_Protected_Declaration";
            case 14L: return "An_Integer_Number_Declaration";
            case 15L: return "A_Real_Number_Declaration";
            case 16L: return "An_Enumeration_Literal_Specification";
            case 17L: return "A_Discriminant_Specification";
            case 18L: return "A_Component_Declaration";
            case 19L: return "A_Loop_Parameter_Specification";
            case 20L: return "A_Generalized_Iterator_Specification";
            case 21L: return "An_Element_Iterator_Specification";
            case 22L: return "A_Procedure_Declaration";
            case 23L: return "A_Function_Declaration";
            case 24L: return "A_Parameter_Specification";
            case 25L: return "A_Procedure_Body_Declaration";
            case 26L: return "A_Function_Body_Declaration";
            case 27L: return "A_Return_Variable_Specification";
            case 28L: return "A_Return_Constant_Specification";
            case 29L: return "A_Null_Procedure_Declaration";
            case 30L: return "An_Expression_Function_Declaration";
            case 31L: return "A_Package_Declaration";
            case 32L: return "A_Package_Body_Declaration";
            case 33L: return "An_Object_Renaming_Declaration";
            case 34L: return "An_Exception_Renaming_Declaration";
            case 35L: return "A_Package_Renaming_Declaration";
            case 36L: return "A_Procedure_Renaming_Declaration";
            case 37L: return "A_Function_Renaming_Declaration";
            case 38L: return "A_Generic_Package_Renaming_Declaration";
            case 39L: return "A_Generic_Procedure_Renaming_Declaration";
            case 40L: return "A_Generic_Function_Renaming_Declaration";
            case 41L: return "A_Task_Body_Declaration";
            case 42L: return "A_Protected_Body_Declaration";
            case 43L: return "An_Entry_Declaration";
            case 44L: return "An_Entry_Body_Declaration";
            case 45L: return "An_Entry_Index_Specification";
            case 46L: return "A_Procedure_Body_Stub";
            case 47L: return "A_Function_Body_Stub";
            case 48L: return "A_Package_Body_Stub";
            case 49L: return "A_Task_Body_Stub";
            case 50L: return "A_Protected_Body_Stub";
            case 51L: return "An_Exception_Declaration";
            case 52L: return "A_Choice_Parameter_Specification";
            case 53L: return "A_Generic_Procedure_Declaration";
            case 54L: return "A_Generic_Function_Declaration";
            case 55L: return "A_Generic_Package_Declaration";
            case 56L: return "A_Package_Instantiation";
            case 57L: return "A_Procedure_Instantiation";
            case 58L: return "A_Function_Instantiation";
            case 59L: return "A_Formal_Object_Declaration";
            case 60L: return "A_Formal_Type_Declaration";
            case 61L: return "A_Formal_Incomplete_Type_Declaration";
            case 62L: return "A_Formal_Procedure_Declaration";
            case 63L: return "A_Formal_Function_Declaration";
            case 64L: return "A_Formal_Package_Declaration";
            case 65L: return "A_Formal_Package_Declaration_With_Box";
            default: return "";
        }
    }

    std::string Declaration_Kinds(int64_t i, const std::string &strip) {
        std::string s = Declaration_Kinds(i);
        if (s.empty())
            s = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Kinds(i);
        if (retval.empty()) {
            retval = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Kinds() {
        return stringify::Declaration_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 391
namespace stringify {
    const char* Declaration_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration_Origin";
            case 1L: return "An_Explicit_Declaration";
            case 2L: return "An_Implicit_Predefined_Declaration";
            case 3L: return "An_Implicit_Inherited_Declaration";
            default: return "";
        }
    }

    std::string Declaration_Origins(int64_t i, const std::string &strip) {
        std::string s = Declaration_Origins(i);
        if (s.empty())
            s = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Origins(i);
        if (retval.empty()) {
            retval = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Origins() {
        return stringify::Declaration_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 407
namespace stringify {
    const char* Mode_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Mode";
            case 1L: return "A_Default_In_Mode";
            case 2L: return "An_In_Mode";
            case 3L: return "An_Out_Mode";
            case 4L: return "An_In_Out_Mode";
            default: return "";
        }
    }

    std::string Mode_Kinds(int64_t i, const std::string &strip) {
        std::string s = Mode_Kinds(i);
        if (s.empty())
            s = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyMode_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Mode_Kinds(i);
        if (retval.empty()) {
            retval = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Mode_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMode_Kinds() {
        return stringify::Mode_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 417
namespace stringify {
    const char* Subprogram_Default_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Default";
            case 1L: return "A_Name_Default";
            case 2L: return "A_Box_Default";
            case 3L: return "A_Null_Default";
            case 4L: return "A_Nil_Default";
            default: return "";
        }
    }

    std::string Subprogram_Default_Kinds(int64_t i, const std::string &strip) {
        std::string s = Subprogram_Default_Kinds(i);
        if (s.empty())
            s = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subprogram_Default_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifySubprogram_Default_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Subprogram_Default_Kinds(i);
        if (retval.empty()) {
            retval = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Subprogram_Default_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySubprogram_Default_Kinds() {
        return stringify::Subprogram_Default_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 814
namespace stringify {
    const char* Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Definition";
            case 1L: return "A_Type_Definition";
            case 2L: return "A_Subtype_Indication";
            case 3L: return "A_Constraint";
            case 4L: return "A_Component_Definition";
            case 5L: return "A_Discrete_Subtype_Definition";
            case 6L: return "A_Discrete_Range";
            case 7L: return "An_Unknown_Discriminant_Part";
            case 8L: return "A_Known_Discriminant_Part";
            case 9L: return "A_Record_Definition";
            case 10L: return "A_Null_Record_Definition";
            case 11L: return "A_Null_Component";
            case 12L: return "A_Variant_Part";
            case 13L: return "A_Variant";
            case 14L: return "An_Others_Choice";
            case 15L: return "An_Access_Definition";
            case 16L: return "A_Private_Type_Definition";
            case 17L: return "A_Tagged_Private_Type_Definition";
            case 18L: return "A_Private_Extension_Definition";
            case 19L: return "A_Task_Definition";
            case 20L: return "A_Protected_Definition";
            case 21L: return "A_Formal_Type_Definition";
            case 22L: return "An_Aspect_Specification";
            default: return "";
        }
    }

    std::string Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = Definition_Kinds(i);
        if (s.empty())
            s = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefinition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefinition_Kinds() {
        return stringify::Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 847
namespace stringify {
    const char* _Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Type_Definition";
            case 1L: return "A_Derived_Type_Definition";
            case 2L: return "A_Derived_Record_Extension_Definition";
            case 3L: return "An_Enumeration_Type_Definition";
            case 4L: return "A_Signed_Integer_Type_Definition";
            case 5L: return "A_Modular_Type_Definition";
            case 6L: return "A_Root_Type_Definition";
            case 7L: return "A_Floating_Point_Definition";
            case 8L: return "An_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Decimal_Fixed_Point_Definition";
            case 10L: return "An_Unconstrained_Array_Definition";
            case 11L: return "A_Constrained_Array_Definition";
            case 12L: return "A_Record_Type_Definition";
            case 13L: return "A_Tagged_Record_Type_Definition";
            case 14L: return "An_Interface_Type_Definition";
            case 15L: return "An_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Type_Kinds(i);
        if (s.empty())
            s = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Type_Kinds() {
        return stringify::_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 871
namespace stringify {
    const char* _Constraint_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Constraint";
            case 1L: return "A_Range_Attribute_Reference";
            case 2L: return "A_Simple_Expression_Range";
            case 3L: return "A_Digits_Constraint";
            case 4L: return "A_Delta_Constraint";
            case 5L: return "An_Index_Constraint";
            case 6L: return "A_Discriminant_Constraint";
            default: return "";
        }
    }

    std::string _Constraint_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Constraint_Kinds(i);
        if (s.empty())
            s = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Constraint_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Constraint_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Constraint_Kinds(i);
        if (retval.empty()) {
            retval = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Constraint_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Constraint_Kinds() {
        return stringify::_Constraint_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 881
namespace stringify {
    const char* _Interface_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Interface";
            case 1L: return "An_Ordinary_Interface";
            case 2L: return "A_Limited_Interface";
            case 3L: return "A_Task_Interface";
            case 4L: return "A_Protected_Interface";
            case 5L: return "A_Synchronized_Interface";
            default: return "";
        }
    }

    std::string _Interface_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Interface_Kinds(i);
        if (s.empty())
            s = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Interface_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Interface_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Interface_Kinds(i);
        if (retval.empty()) {
            retval = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Interface_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Interface_Kinds() {
        return stringify::_Interface_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 890
namespace stringify {
    const char* _Root_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Root_Type_Definition";
            case 1L: return "A_Root_Integer_Definition";
            case 2L: return "A_Root_Real_Definition";
            case 3L: return "A_Universal_Integer_Definition";
            case 4L: return "A_Universal_Real_Definition";
            case 5L: return "A_Universal_Fixed_Definition";
            default: return "";
        }
    }

    std::string _Root_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Root_Type_Kinds(i);
        if (s.empty())
            s = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Root_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Root_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Root_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Root_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Root_Type_Kinds() {
        return stringify::_Root_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 899
namespace stringify {
    const char* _Discrete_Range_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Discrete_Range";
            case 1L: return "A_Discrete_Subtype_Indication";
            case 2L: return "A_Discrete_Range_Attribute_Reference";
            case 3L: return "A_Discrete_Simple_Expression_Range";
            default: return "";
        }
    }

    std::string _Discrete_Range_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Discrete_Range_Kinds(i);
        if (s.empty())
            s = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Discrete_Range_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Discrete_Range_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Discrete_Range_Kinds(i);
        if (retval.empty()) {
            retval = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Discrete_Range_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Discrete_Range_Kinds() {
        return stringify::_Discrete_Range_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 906
namespace stringify {
    const char* _Formal_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Formal_Type_Definition";
            case 1L: return "A_Formal_Private_Type_Definition";
            case 2L: return "A_Formal_Tagged_Private_Type_Definition";
            case 3L: return "A_Formal_Derived_Type_Definition";
            case 4L: return "A_Formal_Discrete_Type_Definition";
            case 5L: return "A_Formal_Signed_Integer_Type_Definition";
            case 6L: return "A_Formal_Modular_Type_Definition";
            case 7L: return "A_Formal_Floating_Point_Definition";
            case 8L: return "A_Formal_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Formal_Decimal_Fixed_Point_Definition";
            case 10L: return "A_Formal_Interface_Type_Definition";
            case 11L: return "A_Formal_Unconstrained_Array_Definition";
            case 12L: return "A_Formal_Constrained_Array_Definition";
            case 13L: return "A_Formal_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Formal_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Formal_Type_Kinds(i);
        if (s.empty())
            s = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Formal_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Formal_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Formal_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Formal_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Formal_Type_Kinds() {
        return stringify::_Formal_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 928
namespace stringify {
    const char* _Access_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Type_Definition";
            case 1L: return "A_Pool_Specific_Access_To_Variable";
            case 2L: return "An_Access_To_Variable";
            case 3L: return "An_Access_To_Constant";
            case 4L: return "An_Access_To_Procedure";
            case 5L: return "An_Access_To_Protected_Procedure";
            case 6L: return "An_Access_To_Function";
            case 7L: return "An_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Type_Kinds(i);
        if (s.empty())
            s = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Type_Kinds() {
        return stringify::_Access_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 939
namespace stringify {
    const char* _Access_Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Definition";
            case 1L: return "An_Anonymous_Access_To_Variable";
            case 2L: return "An_Anonymous_Access_To_Constant";
            case 3L: return "An_Anonymous_Access_To_Procedure";
            case 4L: return "An_Anonymous_Access_To_Protected_Procedure";
            case 5L: return "An_Anonymous_Access_To_Function";
            case 6L: return "An_Anonymous_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Definition_Kinds(i);
        if (s.empty())
            s = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Definition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Definition_Kinds() {
        return stringify::_Access_Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1273
namespace stringify {
    const char* Expression_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Expression";
            case 1L: return "A_Box_Expression";
            case 2L: return "An_Integer_Literal";
            case 3L: return "A_Real_Literal";
            case 4L: return "A_String_Literal";
            case 5L: return "An_Identifier";
            case 6L: return "An_Operator_Symbol";
            case 7L: return "A_Character_Literal";
            case 8L: return "An_Enumeration_Literal";
            case 9L: return "An_Explicit_Dereference";
            case 10L: return "A_Function_Call";
            case 11L: return "An_Indexed_Component";
            case 12L: return "A_Slice";
            case 13L: return "A_Selected_Component";
            case 14L: return "An_Attribute_Reference";
            case 15L: return "A_Record_Aggregate";
            case 16L: return "An_Extension_Aggregate";
            case 17L: return "A_Positional_Array_Aggregate";
            case 18L: return "A_Named_Array_Aggregate";
            case 19L: return "An_And_Then_Short_Circuit";
            case 20L: return "An_Or_Else_Short_Circuit";
            case 21L: return "An_In_Membership_Test";
            case 22L: return "A_Not_In_Membership_Test";
            case 23L: return "A_Null_Literal";
            case 24L: return "A_Parenthesized_Expression";
            case 25L: return "A_Raise_Expression";
            case 26L: return "A_Type_Conversion";
            case 27L: return "A_Qualified_Expression";
            case 28L: return "An_Allocation_From_Subtype";
            case 29L: return "An_Allocation_From_Qualified_Expression";
            case 30L: return "A_Case_Expression";
            case 31L: return "An_If_Expression";
            case 32L: return "A_For_All_Quantified_Expression";
            case 33L: return "A_For_Some_Quantified_Expression";
            default: return "";
        }
    }

    std::string Expression_Kinds(int64_t i, const std::string &strip) {
        std::string s = Expression_Kinds(i);
        if (s.empty())
            s = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Expression_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}

namespace Rose {
    std::string stringifyExpression_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Expression_Kinds(i);
        if (retval.empty()) {
            retval = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Expression_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyExpression_Kinds() {
        return stringify::Expression_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1318
namespace stringify {
    const char* Attribute_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Attribute";
            case 1L: return "An_Access_Attribute";
            case 2L: return "An_Address_Attribute";
            case 3L: return "An_Adjacent_Attribute";
            case 4L: return "An_Aft_Attribute";
            case 5L: return "An_Alignment_Attribute";
            case 6L: return "A_Base_Attribute";
            case 7L: return "A_Bit_Order_Attribute";
            case 8L: return "A_Body_Version_Attribute";
            case 9L: return "A_Callable_Attribute";
            case 10L: return "A_Caller_Attribute";
            case 11L: return "A_Ceiling_Attribute";
            case 12L: return "A_Class_Attribute";
            case 13L: return "A_Component_Size_Attribute";
            case 14L: return "A_Compose_Attribute";
            case 15L: return "A_Constrained_Attribute";
            case 16L: return "A_Copy_Sign_Attribute";
            case 17L: return "A_Count_Attribute";
            case 18L: return "A_Definite_Attribute";
            case 19L: return "A_Delta_Attribute";
            case 20L: return "A_Denorm_Attribute";
            case 21L: return "A_Digits_Attribute";
            case 22L: return "An_Exponent_Attribute";
            case 23L: return "An_External_Tag_Attribute";
            case 24L: return "A_First_Attribute";
            case 25L: return "A_First_Bit_Attribute";
            case 26L: return "A_Floor_Attribute";
            case 27L: return "A_Fore_Attribute";
            case 28L: return "A_Fraction_Attribute";
            case 29L: return "An_Identity_Attribute";
            case 30L: return "An_Image_Attribute";
            case 31L: return "An_Input_Attribute";
            case 32L: return "A_Last_Attribute";
            case 33L: return "A_Last_Bit_Attribute";
            case 34L: return "A_Leading_Part_Attribute";
            case 35L: return "A_Length_Attribute";
            case 36L: return "A_Machine_Attribute";
            case 37L: return "A_Machine_Emax_Attribute";
            case 38L: return "A_Machine_Emin_Attribute";
            case 39L: return "A_Machine_Mantissa_Attribute";
            case 40L: return "A_Machine_Overflows_Attribute";
            case 41L: return "A_Machine_Radix_Attribute";
            case 42L: return "A_Machine_Rounds_Attribute";
            case 43L: return "A_Max_Attribute";
            case 44L: return "A_Max_Size_In_Storage_Elements_Attribute";
            case 45L: return "A_Min_Attribute";
            case 46L: return "A_Model_Attribute";
            case 47L: return "A_Model_Emin_Attribute";
            case 48L: return "A_Model_Epsilon_Attribute";
            case 49L: return "A_Model_Mantissa_Attribute";
            case 50L: return "A_Model_Small_Attribute";
            case 51L: return "A_Modulus_Attribute";
            case 52L: return "An_Output_Attribute";
            case 53L: return "A_Partition_ID_Attribute";
            case 54L: return "A_Pos_Attribute";
            case 55L: return "A_Position_Attribute";
            case 56L: return "A_Pred_Attribute";
            case 57L: return "A_Range_Attribute";
            case 58L: return "A_Read_Attribute";
            case 59L: return "A_Remainder_Attribute";
            case 60L: return "A_Round_Attribute";
            case 61L: return "A_Rounding_Attribute";
            case 62L: return "A_Safe_First_Attribute";
            case 63L: return "A_Safe_Last_Attribute";
            case 64L: return "A_Scale_Attribute";
            case 65L: return "A_Scaling_Attribute";
            case 66L: return "A_Signed_Zeros_Attribute";
            case 67L: return "A_Size_Attribute";
            case 68L: return "A_Small_Attribute";
            case 69L: return "A_Storage_Pool_Attribute";
            case 70L: return "A_Storage_Size_Attribute";
            case 71L: return "A_Succ_Attribute";
            case 72L: return "A_Tag_Attribute";
            case 73L: return "A_Terminated_Attribute";
            case 74L: return "A_Truncation_Attribute";
            case 75L: return "An_Unbiased_Rounding_Attribute";
            case 76L: return "An_Unchecked_Access_Attribute";
            case 77L: return "A_Val_Attribute";
            case 78L: return "A_Valid_Attribute";
            case 79L: return "A_Value_Attribute";
            case 80L: return "A_Version_Attribute";
            case 81L: return "A_Wide_Image_Attribute";
            case 82L: return "A_Wide_Value_Attribute";
            case 83L: return "A_Wide_Width_Attribute";
            case 84L: return "A_Width_Attribute";
            case 85L: return "A_Write_Attribute";
            case 86L: return "A_Machine_Rounding_Attribute";
            case 87L: return "A_Mod_Attribute";
            case 88L: return "A_Priority_Attribute";
            case 89L: return "A_Stream_Size_Attribute";
            case 90L: return "A_Wide_Wide_Image_Attribute";
            case 91L: return "A_Wide_Wide_Value_Attribute";
            case 92L: return "A_Wide_Wide_Width_Attribute";
            case 93L: return "A_Max_Alignment_For_Allocation_Attribute";
            case 94L: return "An_Overlaps_Storage_Attribute";
            case 95L: return "An_Implementation_Defined_Attribute";
            case 96L: return "An_Unknown_Attribute";
            default: return "";
        }
    }

    std::string Attribute_Kinds(int64_t i, const std::string &strip) {
        std::string s = Attribute_Kinds(i);
        if (s.empty())
            s = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Attribute_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L
        };
        static const std::vector<int64_t> retval(values, values + 97);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAttribute_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Attribute_Kinds(i);
        if (retval.empty()) {
            retval = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Attribute_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAttribute_Kinds() {
        return stringify::Attribute_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1544
namespace stringify {
    const char* Association_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Association";
            case 1L: return "A_Pragma_Argument_Association";
            case 2L: return "A_Discriminant_Association";
            case 3L: return "A_Record_Component_Association";
            case 4L: return "An_Array_Component_Association";
            case 5L: return "A_Parameter_Association";
            case 6L: return "A_Generic_Association";
            default: return "";
        }
    }

    std::string Association_Kinds(int64_t i, const std::string &strip) {
        std::string s = Association_Kinds(i);
        if (s.empty())
            s = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Association_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociation_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Association_Kinds(i);
        if (retval.empty()) {
            retval = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Association_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociation_Kinds() {
        return stringify::Association_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1593
namespace stringify {
    const char* Statement_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Statement";
            case 1L: return "A_Null_Statement";
            case 2L: return "An_Assignment_Statement";
            case 3L: return "An_If_Statement";
            case 4L: return "A_Case_Statement";
            case 5L: return "A_Loop_Statement";
            case 6L: return "A_While_Loop_Statement";
            case 7L: return "A_For_Loop_Statement";
            case 8L: return "A_Block_Statement";
            case 9L: return "An_Exit_Statement";
            case 10L: return "A_Goto_Statement";
            case 11L: return "A_Procedure_Call_Statement";
            case 12L: return "A_Return_Statement";
            case 13L: return "An_Extended_Return_Statement";
            case 14L: return "An_Accept_Statement";
            case 15L: return "An_Entry_Call_Statement";
            case 16L: return "A_Requeue_Statement";
            case 17L: return "A_Requeue_Statement_With_Abort";
            case 18L: return "A_Delay_Until_Statement";
            case 19L: return "A_Delay_Relative_Statement";
            case 20L: return "A_Terminate_Alternative_Statement";
            case 21L: return "A_Selective_Accept_Statement";
            case 22L: return "A_Timed_Entry_Call_Statement";
            case 23L: return "A_Conditional_Entry_Call_Statement";
            case 24L: return "An_Asynchronous_Select_Statement";
            case 25L: return "An_Abort_Statement";
            case 26L: return "A_Raise_Statement";
            case 27L: return "A_Code_Statement";
            default: return "";
        }
    }

    std::string Statement_Kinds(int64_t i, const std::string &strip) {
        std::string s = Statement_Kinds(i);
        if (s.empty())
            s = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statement_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyStatement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Statement_Kinds(i);
        if (retval.empty()) {
            retval = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Statement_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStatement_Kinds() {
        return stringify::Statement_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1741
namespace stringify {
    const char* Path_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Path";
            case 1L: return "An_If_Path";
            case 2L: return "An_Elsif_Path";
            case 3L: return "An_Else_Path";
            case 4L: return "A_Case_Path";
            case 5L: return "A_Select_Path";
            case 6L: return "An_Or_Path";
            case 7L: return "A_Then_Abort_Path";
            case 8L: return "A_Case_Expression_Path";
            case 9L: return "An_If_Expression_Path";
            case 10L: return "An_Elsif_Expression_Path";
            case 11L: return "An_Else_Expression_Path";
            default: return "";
        }
    }

    std::string Path_Kinds(int64_t i, const std::string &strip) {
        std::string s = Path_Kinds(i);
        if (s.empty())
            s = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Path_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPath_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Path_Kinds(i);
        if (retval.empty()) {
            retval = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Path_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPath_Kinds() {
        return stringify::Path_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1821
namespace stringify {
    const char* Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Clause";
            case 1L: return "A_Use_Package_Clause";
            case 2L: return "A_Use_Type_Clause";
            case 3L: return "A_Use_All_Type_Clause";
            case 4L: return "A_With_Clause";
            case 5L: return "A_Representation_Clause";
            case 6L: return "A_Component_Clause";
            default: return "";
        }
    }

    std::string Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = Clause_Kinds(i);
        if (s.empty())
            s = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyClause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClause_Kinds() {
        return stringify::Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1833
namespace stringify {
    const char* _Representation_Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Representation_Clause";
            case 1L: return "An_Attribute_Definition_Clause";
            case 2L: return "An_Enumeration_Representation_Clause";
            case 3L: return "A_Record_Representation_Clause";
            case 4L: return "An_At_Clause";
            default: return "";
        }
    }

    std::string _Representation_Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Representation_Clause_Kinds(i);
        if (s.empty())
            s = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Representation_Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Representation_Clause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Representation_Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Representation_Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Representation_Clause_Kinds() {
        return stringify::_Representation_Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1918
namespace stringify {
    const char* Enclosing_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_Enclosing";
            case 1L: return "Enclosing_Element";
            case 2L: return "Enclosing_Unit";
            default: return "";
        }
    }

    std::string Enclosing_Kinds(int64_t i, const std::string &strip) {
        std::string s = Enclosing_Kinds(i);
        if (s.empty())
            s = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Enclosing_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyEnclosing_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Enclosing_Kinds(i);
        if (retval.empty()) {
            retval = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Enclosing_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEnclosing_Kinds() {
        return stringify::Enclosing_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1970
namespace stringify {
    const char* Unit_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Unit";
            case 1L: return "A_Procedure";
            case 2L: return "A_Function";
            case 3L: return "A_Package";
            case 4L: return "A_Generic_Procedure";
            case 5L: return "A_Generic_Function";
            case 6L: return "A_Generic_Package";
            case 7L: return "A_Procedure_Instance";
            case 8L: return "A_Function_Instance";
            case 9L: return "A_Package_Instance";
            case 10L: return "A_Procedure_Renaming";
            case 11L: return "A_Function_Renaming";
            case 12L: return "A_Package_Renaming";
            case 13L: return "A_Generic_Procedure_Renaming";
            case 14L: return "A_Generic_Function_Renaming";
            case 15L: return "A_Generic_Package_Renaming";
            case 16L: return "A_Procedure_Body";
            case 17L: return "A_Function_Body";
            case 18L: return "A_Package_Body";
            case 19L: return "A_Procedure_Body_Subunit";
            case 20L: return "A_Function_Body_Subunit";
            case 21L: return "A_Package_Body_Subunit";
            case 22L: return "A_Task_Body_Subunit";
            case 23L: return "A_Protected_Body_Subunit";
            case 24L: return "A_Nonexistent_Declaration";
            case 25L: return "A_Nonexistent_Body";
            case 26L: return "A_Configuration_Compilation";
            case 27L: return "An_Unknown_Unit";
            default: return "";
        }
    }

    std::string Unit_Kinds(int64_t i, const std::string &strip) {
        std::string s = Unit_Kinds(i);
        if (s.empty())
            s = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Kinds(i);
        if (retval.empty()) {
            retval = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Kinds() {
        return stringify::Unit_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 2037
namespace stringify {
    const char* Unit_Classes(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Class";
            case 1L: return "A_Public_Declaration";
            case 2L: return "A_Public_Body";
            case 3L: return "A_Public_Declaration_And_Body";
            case 4L: return "A_Private_Declaration";
            case 5L: return "A_Private_Body";
            case 6L: return "A_Separate_Body";
            default: return "";
        }
    }

    std::string Unit_Classes(int64_t i, const std::string &strip) {
        std::string s = Unit_Classes(i);
        if (s.empty())
            s = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Classes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Classes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Classes(i);
        if (retval.empty()) {
            retval = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Classes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Classes() {
        return stringify::Unit_Classes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 2058
namespace stringify {
    const char* Unit_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Origin";
            case 1L: return "A_Predefined_Unit";
            case 2L: return "An_Implementation_Unit";
            case 3L: return "An_Application_Unit";
            default: return "";
        }
    }

    std::string Unit_Origins(int64_t i, const std::string &strip) {
        std::string s = Unit_Origins(i);
        if (s.empty())
            s = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Origins(i);
        if (retval.empty()) {
            retval = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Origins() {
        return stringify::Unit_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 12
namespace stringify { namespace ROSE_token_ids {
    const char* whitespace(int64_t i) {
        switch (i) {
            case 0L: return "T_NOTKNOWN";
            default: return "";
        }
    }

    std::string whitespace(int64_t i, const std::string &strip) {
        std::string s = whitespace(i);
        if (s.empty())
            s = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& whitespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_ids_whitespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::whitespace(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::whitespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_ids_whitespace() {
        return stringify::ROSE_token_ids::whitespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 21
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_keywords() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 159
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_alternate_tok(int64_t i) {
        switch (i) {
            case 0L: return "C_CXX_LEFT_CURLY_ALT";
            case 1L: return "C_CXX_RIGHT_CURLY_ALT";
            case 2L: return "C_CXX_LEFT_SQUARE_ALT";
            case 3L: return "C_CXX_RIGHT_SQUARE_ALT";
            case 4L: return "C_CXX_HASH_ALT";
            case 5L: return "C_CXX_HASH_HASH_ALT";
            case 6L: return "C_CXX_and_ALT";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_alternate_tok(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_alternate_tok(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_alternate_tok() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_alternate_tok(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_alternate_tok() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 171
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "C_CXX_COMMENTS";
            case 100001L: return "C_CXX_STRING_LITERALS";
            case 100002L: return "C_CXX_IDENTIFIER";
            case 100003L: return "C_CXX_PREPROCESSING_INFO";
            case 100004L: return "C_CXX_UNIDENTIFIED_TOKEN";
            case 100005L: return "C_CXX_SYNTAX";
            case 100006L: return "C_CXX_WHITESPACE";
            case 100007L: return "C_CXX_PRAGMA";
            case 100008L: return "C_CXX_ERROR";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L,
            100005L,
            100006L,
            100007L,
            100008L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_Additional_Info() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualBinCFG.h line 17
namespace stringify { namespace VirtualBinCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualBinCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualBinCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualBinCFG_EdgeConditionKind() {
        return stringify::VirtualBinCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualCFG.h line 47
namespace stringify { namespace VirtualCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            case 5L: return "eckDoConditionPassed";
            case 6L: return "eckDoConditionFailed";
            case 7L: return "eckForallIndicesInRange";
            case 8L: return "eckForallIndicesNotInRange";
            case 9L: return "eckComputedGotoCaseLabel";
            case 10L: return "eckArithmeticIfLess";
            case 11L: return "eckArithmeticIfEqual";
            case 12L: return "eckArithmeticIfGreater";
            case 13L: return "eckInterprocedural";
            case 14L: return "eckError";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualCFG_EdgeConditionKind() {
        return stringify::VirtualCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/OmpAttribute.h line 31
namespace stringify { namespace OmpSupport {
    const char* omp_construct_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_parallel";
            case 2L: return "e_for";
            case 3L: return "e_for_simd";
            case 4L: return "e_do";
            case 5L: return "e_workshare";
            case 6L: return "e_sections";
            case 7L: return "e_section";
            case 8L: return "e_single";
            case 9L: return "e_master";
            case 10L: return "e_critical";
            case 11L: return "e_barrier";
            case 12L: return "e_atomic";
            case 13L: return "e_flush";
            case 14L: return "e_target";
            case 15L: return "e_target_declare";
            case 16L: return "e_target_data";
            case 17L: return "e_target_update";
            case 18L: return "e_map";
            case 19L: return "e_device";
            case 20L: return "e_begin";
            case 21L: return "e_end";
            case 22L: return "e_threadprivate";
            case 23L: return "e_parallel_for";
            case 24L: return "e_parallel_for_simd";
            case 25L: return "e_parallel_do";
            case 26L: return "e_parallel_sections";
            case 27L: return "e_parallel_workshare";
            case 28L: return "e_task";
            case 29L: return "e_taskwait";
            case 30L: return "e_ordered_directive";
            case 31L: return "e_end_critical";
            case 32L: return "e_end_do";
            case 33L: return "e_end_master";
            case 34L: return "e_end_ordered";
            case 35L: return "e_end_parallel_do";
            case 36L: return "e_end_parallel_sections";
            case 37L: return "e_end_parallel_workshare";
            case 38L: return "e_end_parallel";
            case 39L: return "e_end_sections";
            case 40L: return "e_end_single";
            case 41L: return "e_end_task";
            case 42L: return "e_end_workshare";
            case 43L: return "e_default";
            case 44L: return "e_shared";
            case 45L: return "e_private";
            case 46L: return "e_firstprivate";
            case 47L: return "e_lastprivate";
            case 48L: return "e_copyin";
            case 49L: return "e_copyprivate";
            case 50L: return "e_proc_bind";
            case 51L: return "e_if";
            case 52L: return "e_num_threads";
            case 53L: return "e_nowait";
            case 54L: return "e_ordered_clause";
            case 55L: return "e_reduction";
            case 56L: return "e_schedule";
            case 57L: return "e_collapse";
            case 58L: return "e_untied";
            case 59L: return "e_mergeable";
            case 60L: return "e_final";
            case 61L: return "e_priority";
            case 62L: return "e_atomic_clause";
            case 63L: return "e_inbranch";
            case 64L: return "e_notinbranch";
            case 65L: return "e_depend";
            case 66L: return "e_default_none";
            case 67L: return "e_default_shared";
            case 68L: return "e_default_private";
            case 69L: return "e_default_firstprivate";
            case 70L: return "e_proc_bind_master";
            case 71L: return "e_proc_bind_close";
            case 72L: return "e_proc_bind_spread";
            case 73L: return "e_atomic_read";
            case 74L: return "e_atomic_write";
            case 75L: return "e_atomic_update";
            case 76L: return "e_atomic_capture";
            case 77L: return "e_reduction_plus";
            case 78L: return "e_reduction_mul";
            case 79L: return "e_reduction_minus";
            case 80L: return "e_reduction_bitand";
            case 81L: return "e_reduction_bitor";
            case 82L: return "e_reduction_bitxor";
            case 83L: return "e_reduction_logand";
            case 84L: return "e_reduction_logor";
            case 85L: return "e_reduction_and";
            case 86L: return "e_reduction_or";
            case 87L: return "e_reduction_eqv";
            case 88L: return "e_reduction_neqv";
            case 89L: return "e_reduction_max";
            case 90L: return "e_reduction_min";
            case 91L: return "e_reduction_iand";
            case 92L: return "e_reduction_ior";
            case 93L: return "e_reduction_ieor";
            case 94L: return "e_schedule_none";
            case 95L: return "e_schedule_static";
            case 96L: return "e_schedule_dynamic";
            case 97L: return "e_schedule_guided";
            case 98L: return "e_schedule_auto";
            case 99L: return "e_schedule_runtime";
            case 100L: return "e_map_alloc";
            case 101L: return "e_map_to";
            case 102L: return "e_map_from";
            case 103L: return "e_map_tofrom";
            case 104L: return "e_dist_data";
            case 105L: return "e_duplicate";
            case 106L: return "e_block";
            case 107L: return "e_cyclic";
            case 108L: return "e_simd";
            case 109L: return "e_declare_simd";
            case 110L: return "e_safelen";
            case 111L: return "e_simdlen";
            case 112L: return "e_uniform";
            case 113L: return "e_aligned";
            case 114L: return "e_linear";
            case 115L: return "e_depend_in";
            case 116L: return "e_depend_out";
            case 117L: return "e_depend_inout";
            case 118L: return "e_not_omp";
            default: return "";
        }
    }

    std::string omp_construct_enum(int64_t i, const std::string &strip) {
        std::string s = omp_construct_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_construct_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L
        };
        static const std::vector<int64_t> retval(values, values + 119);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_construct_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_construct_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_construct_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_construct_enum() {
        return stringify::OmpSupport::omp_construct_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 133
namespace stringify { namespace PreprocessingInfo {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 5L: return "end_of";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoRelativePositionType() {
        return stringify::PreprocessingInfo::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 155
namespace stringify { namespace PreprocessingInfo {
    const char* DirectiveType(int64_t i) {
        switch (i) {
            case 0L: return "CpreprocessorUnknownDeclaration";
            case 1L: return "C_StyleComment";
            case 2L: return "CplusplusStyleComment";
            case 3L: return "FortranStyleComment";
            case 4L: return "F90StyleComment";
            case 5L: return "AdaStyleComment";
            case 6L: return "JovialStyleComment";
            case 7L: return "CpreprocessorBlankLine";
            case 8L: return "CpreprocessorIncludeDeclaration";
            case 9L: return "CpreprocessorIncludeNextDeclaration";
            case 10L: return "CpreprocessorDefineDeclaration";
            case 11L: return "CpreprocessorUndefDeclaration";
            case 12L: return "CpreprocessorIfdefDeclaration";
            case 13L: return "CpreprocessorIfndefDeclaration";
            case 14L: return "CpreprocessorIfDeclaration";
            case 15L: return "CpreprocessorDeadIfDeclaration";
            case 16L: return "CpreprocessorElseDeclaration";
            case 17L: return "CpreprocessorElifDeclaration";
            case 18L: return "CpreprocessorEndifDeclaration";
            case 19L: return "CpreprocessorElsifDeclaration";
            case 20L: return "CpreprocessorEnd_ifDeclaration";
            case 21L: return "CpreprocessorLineDeclaration";
            case 22L: return "CpreprocessorErrorDeclaration";
            case 23L: return "CpreprocessorWarningDeclaration";
            case 24L: return "CpreprocessorEmptyDeclaration";
            case 25L: return "CSkippedToken";
            case 26L: return "CMacroCall";
            case 27L: return "CMacroCallStatement";
            case 28L: return "LineReplacement";
            case 29L: return "ClinkageSpecificationStart";
            case 30L: return "ClinkageSpecificationEnd";
            case 31L: return "CpreprocessorIdentDeclaration";
            case 32L: return "CpreprocessorCompilerGeneratedLinemarker";
            case 33L: return "RawText";
            case 34L: return "LastDirectiveType";
            default: return "";
        }
    }

    std::string DirectiveType(int64_t i, const std::string &strip) {
        std::string s = DirectiveType(i);
        if (s.empty())
            s = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DirectiveType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L
        };
        static const std::vector<int64_t> retval(values, values + 35);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoDirectiveType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::DirectiveType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::DirectiveType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoDirectiveType() {
        return stringify::PreprocessingInfo::DirectiveType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 537
namespace stringify { namespace ROSEAttributesList {
    const char* languageTypeEnum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_language";
            case 1L: return "e_C_language";
            case 2L: return "e_Cxx_language";
            case 3L: return "e_Fortran77_language";
            case 4L: return "e_Fortran9x_language";
            case 5L: return "e_Ada_language";
            case 6L: return "e_lastLanguage";
            default: return "";
        }
    }

    std::string languageTypeEnum(int64_t i, const std::string &strip) {
        std::string s = languageTypeEnum(i);
        if (s.empty())
            s = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageTypeEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSEAttributesList_languageTypeEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSEAttributesList::languageTypeEnum(i);
        if (retval.empty()) {
            retval = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSEAttributesList::languageTypeEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSEAttributesList_languageTypeEnum() {
        return stringify::ROSEAttributesList::languageTypeEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 30
namespace stringify {
    const char* omp_lock_hint_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_lock_hint_none";
            case 1L: return "omp_lock_hint_uncontended";
            case 2L: return "omp_lock_hint_contended";
            case 4L: return "omp_lock_hint_nonspeculative";
            case 8L: return "omp_lock_hint_speculative";
            default: return "";
        }
    }

    std::string omp_lock_hint_t(int64_t i, const std::string &strip) {
        std::string s = omp_lock_hint_t(i);
        if (s.empty())
            s = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_lock_hint_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_lock_hint_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_lock_hint_t(i);
        if (retval.empty()) {
            retval = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_lock_hint_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_lock_hint_t() {
        return stringify::omp_lock_hint_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 46
namespace stringify {
    const char* omp_sched_t(int64_t i) {
        switch (i) {
            case 1L: return "omp_sched_static";
            case 2L: return "omp_sched_dynamic";
            case 3L: return "omp_sched_guided";
            case 4L: return "omp_sched_auto";
            default: return "";
        }
    }

    std::string omp_sched_t(int64_t i, const std::string &strip) {
        std::string s = omp_sched_t(i);
        if (s.empty())
            s = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_sched_t() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_sched_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_sched_t(i);
        if (retval.empty()) {
            retval = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_sched_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_sched_t() {
        return stringify::omp_sched_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 57
namespace stringify {
    const char* omp_proc_bind_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_proc_bind_false";
            case 1L: return "omp_proc_bind_true";
            case 2L: return "omp_proc_bind_master";
            case 3L: return "omp_proc_bind_close";
            case 4L: return "omp_proc_bind_spread";
            default: return "";
        }
    }

    std::string omp_proc_bind_t(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_t(i);
        if (s.empty())
            s = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_proc_bind_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_proc_bind_t(i);
        if (retval.empty()) {
            retval = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_proc_bind_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_proc_bind_t() {
        return stringify::omp_proc_bind_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageInterface.h line 1965
namespace stringify { namespace SageInterface { namespace DeferredTransformation {
    const char* TransformationKind(int64_t i) {
        switch (i) {
            case 0L: return "e_error";
            case 1L: return "e_default";
            case 2L: return "e_outliner";
            case 3L: return "e_replaceStatement";
            case 4L: return "e_removeStatement";
            case 5L: return "e_replaceDefiningFunctionDeclarationWithFunctionPrototype";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string TransformationKind(int64_t i, const std::string &strip) {
        std::string s = TransformationKind(i);
        if (s.empty())
            s = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TransformationKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySageInterfaceDeferredTransformationTransformationKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageInterface::DeferredTransformation::TransformationKind(i);
        if (retval.empty()) {
            retval = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageInterface::DeferredTransformation::TransformationKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageInterfaceDeferredTransformationTransformationKind() {
        return stringify::SageInterface::DeferredTransformation::TransformationKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageBuilder.h line 138
namespace stringify { namespace SageBuilder {
    const char* SourcePositionClassification(int64_t i) {
        switch (i) {
            case 0L: return "e_sourcePositionError";
            case 1L: return "e_sourcePositionDefault";
            case 2L: return "e_sourcePositionTransformation";
            case 3L: return "e_sourcePositionCompilerGenerated";
            case 4L: return "e_sourcePositionNullPointers";
            case 5L: return "e_sourcePositionFrontendConstruction";
            case 6L: return "e_sourcePosition_last";
            default: return "";
        }
    }

    std::string SourcePositionClassification(int64_t i, const std::string &strip) {
        std::string s = SourcePositionClassification(i);
        if (s.empty())
            s = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SourcePositionClassification() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySageBuilderSourcePositionClassification(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageBuilder::SourcePositionClassification(i);
        if (retval.empty()) {
            retval = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageBuilder::SourcePositionClassification::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageBuilderSourcePositionClassification() {
        return stringify::SageBuilder::SourcePositionClassification();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 25
namespace stringify { namespace AstAttributeDOT {
    const char* DOTStyles(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTStyles";
            case 1L: return "filled";
            case 2L: return "not_filled";
            case 3L: return "END_OF_NODE_TYPE_LIST_DOTStyles";
            default: return "";
        }
    }

    std::string DOTStyles(int64_t i, const std::string &strip) {
        std::string s = DOTStyles(i);
        if (s.empty())
            s = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTStyles() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeDOT_DOTStyles(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttributeDOT::DOTStyles(i);
        if (retval.empty()) {
            retval = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttributeDOT::DOTStyles::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeDOT_DOTStyles() {
        return stringify::AstAttributeDOT::DOTStyles();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 90
namespace stringify { namespace DOTGraphNode {
    const char* DOTShapeTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTShapeTypes";
            case 1L: return "polygon";
            case 2L: return "ellipse";
            case 3L: return "record";
            case 4L: return "mrecord";
            case 5L: return "END_OF_NODE_TYPE_LIST_DOTShapeTypes";
            default: return "";
        }
    }

    std::string DOTShapeTypes(int64_t i, const std::string &strip) {
        std::string s = DOTShapeTypes(i);
        if (s.empty())
            s = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTShapeTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphNodeDOTShapeTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphNode::DOTShapeTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphNode::DOTShapeTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphNodeDOTShapeTypes() {
        return stringify::DOTGraphNode::DOTShapeTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 137
namespace stringify { namespace DOTGraphEdge {
    const char* DOTArrowTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementArrowTypes";
            case 1L: return "normal";
            case 2L: return "inv";
            case 3L: return "dot";
            case 4L: return "invdot";
            case 5L: return "odot";
            case 6L: return "invodot";
            case 7L: return "none";
            case 8L: return "tee";
            case 9L: return "empty";
            case 10L: return "invempty";
            case 11L: return "diamond";
            case 12L: return "odiamond";
            case 13L: return "ediamond";
            case 14L: return "crow";
            case 15L: return "box";
            case 16L: return "obox";
            case 17L: return "open";
            case 18L: return "halfopen";
            case 19L: return "vee";
            case 20L: return "END_OF_NODE_TYPE_LIST_DOTArrowTypes";
            default: return "";
        }
    }

    std::string DOTArrowTypes(int64_t i, const std::string &strip) {
        std::string s = DOTArrowTypes(i);
        if (s.empty())
            s = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTArrowTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphEdgeDOTArrowTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphEdge::DOTArrowTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphEdgeDOTArrowTypes() {
        return stringify::DOTGraphEdge::DOTArrowTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 12
namespace stringify { namespace AST_Graph {
    const char* pointerHandling(int64_t i) {
        switch (i) {
            case 0L: return "graph_NULL";
            case 1L: return "do_not_graph_NULL";
            default: return "";
        }
    }

    std::string pointerHandling(int64_t i, const std::string &strip) {
        std::string s = pointerHandling(i);
        if (s.empty())
            s = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& pointerHandling() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_pointerHandling(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::pointerHandling(i);
        if (retval.empty()) {
            retval = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::pointerHandling::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_pointerHandling() {
        return stringify::AST_Graph::pointerHandling();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 19
namespace stringify { namespace AST_Graph {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "memory_pool_traversal";
            case 1L: return "whole_graph_AST";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::traversalType(i);
        if (retval.empty()) {
            retval = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_traversalType() {
        return stringify::AST_Graph::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 1662
namespace stringify { namespace SgAsmRiscOperation {
    const char* RiscOperator(int64_t i) {
        switch (i) {
            case 0L: return "OP_NONE";
            case 1L: return "OP_bottom";
            case 2L: return "OP_undefined";
            case 3L: return "OP_unspecified";
            case 4L: return "OP_filterCallTarget";
            case 5L: return "OP_filterReturnTarget";
            case 6L: return "OP_filterIndirectJumpTarget";
            case 7L: return "OP_hlt";
            case 8L: return "OP_cpuid";
            case 9L: return "OP_rdtsc";
            case 10L: return "OP_and_";
            case 11L: return "OP_or_";
            case 12L: return "OP_xor_";
            case 13L: return "OP_invert";
            case 14L: return "OP_extract";
            case 15L: return "OP_concat";
            case 16L: return "OP_leastSignificantSetBit";
            case 17L: return "OP_mostSignificantSetBit";
            case 18L: return "OP_rotateLeft";
            case 19L: return "OP_rotateRight";
            case 20L: return "OP_shiftLeft";
            case 21L: return "OP_shiftRight";
            case 22L: return "OP_shiftRightArithmetic";
            case 23L: return "OP_equalToZero";
            case 24L: return "OP_ite";
            case 25L: return "OP_isEqual";
            case 26L: return "OP_isNotEqual";
            case 27L: return "OP_isUnsignedLessThan";
            case 28L: return "OP_isUnsignedLessThanOrEqual";
            case 29L: return "OP_isUnsignedGreaterThan";
            case 30L: return "OP_isUnsignedGreaterThanOrEqual";
            case 31L: return "OP_isSignedLessThan";
            case 32L: return "OP_isSignedLessThanOrEqual";
            case 33L: return "OP_isSignedGreaterThan";
            case 34L: return "OP_isSignedGreaterThanOrEqual";
            case 35L: return "OP_unsignedExtend";
            case 36L: return "OP_signExtend";
            case 37L: return "OP_add";
            case 38L: return "OP_addCarries";
            case 39L: return "OP_subtract";
            case 40L: return "OP_negate";
            case 41L: return "OP_signedDivide";
            case 42L: return "OP_signedModulo";
            case 43L: return "OP_signedMultiply";
            case 44L: return "OP_unsignedDivide";
            case 45L: return "OP_unsignedModulo";
            case 46L: return "OP_unsignedMultiply";
            case 47L: return "OP_interrupt";
            case 48L: return "OP_readRegister";
            case 49L: return "OP_peekRegister";
            case 50L: return "OP_writeRegister";
            case 51L: return "OP_readMemory";
            case 52L: return "OP_peekMemory";
            case 53L: return "OP_writeMemory";
            case 54L: return "OP_N_OPERATORS";
            default: return "";
        }
    }

    std::string RiscOperator(int64_t i, const std::string &strip) {
        std::string s = RiscOperator(i);
        if (s.empty())
            s = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RiscOperator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmRiscOperationRiscOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmRiscOperation::RiscOperator(i);
        if (retval.empty()) {
            retval = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmRiscOperation::RiscOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmRiscOperationRiscOperator() {
        return stringify::SgAsmRiscOperation::RiscOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 2250
namespace stringify { namespace SgAsmPESectionTableEntry {
    const char* PESectionFlags(int64_t i) {
        switch (i) {
            case 32L: return "OF_CODE";
            case 64L: return "OF_IDATA";
            case 128L: return "OF_UDATA";
            case 512L: return "OF_INFO";
            case 2048L: return "OF_REMOVE";
            case 4096L: return "OF_COMDAT";
            case 16384L: return "OF_NO_DEFER_SPEC_EXC";
            case 32768L: return "OF_GPREL";
            case 1048576L: return "OF_ALIGN_1";
            case 2097152L: return "OF_ALIGN_2";
            case 3145728L: return "OF_ALIGN_4";
            case 4194304L: return "OF_ALIGN_8";
            case 5242880L: return "OF_ALIGN_16";
            case 6291456L: return "OF_ALIGN_32";
            case 7340032L: return "OF_ALIGN_64";
            case 8388608L: return "OF_ALIGN_128";
            case 9437184L: return "OF_ALIGN_256";
            case 10485760L: return "OF_ALIGN_512";
            case 11534336L: return "OF_ALIGN_1k";
            case 12582912L: return "OF_ALIGN_2k";
            case 13631488L: return "OF_ALIGN_4k";
            case 14680064L: return "OF_ALIGN_8k";
            case 15728640L: return "OF_ALIGN_MASK";
            case 16777216L: return "OF_NRELOC_OVFL";
            case 33554432L: return "OF_DISCARDABLE";
            case 67108864L: return "OF_NO_CACHE";
            case 134217728L: return "OF_NO_PAGING";
            case 268435456L: return "OF_SHARED";
            case 536870912L: return "OF_EXECUTABLE";
            case 1073741824L: return "OF_READABLE";
            case 2147483648L: return "OF_WRITABLE";
            default: return "";
        }
    }

    std::string PESectionFlags(int64_t i, const std::string &strip) {
        std::string s = PESectionFlags(i);
        if (s.empty())
            s = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PESectionFlags() {
        static const int64_t values[] = {
            32L,
            64L,
            128L,
            512L,
            2048L,
            4096L,
            16384L,
            32768L,
            1048576L,
            2097152L,
            3145728L,
            4194304L,
            5242880L,
            6291456L,
            7340032L,
            8388608L,
            9437184L,
            10485760L,
            11534336L,
            12582912L,
            13631488L,
            14680064L,
            15728640L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPESectionTableEntryPESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPESectionTableEntry::PESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPESectionTableEntryPESectionFlags() {
        return stringify::SgAsmPESectionTableEntry::PESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 4122
namespace stringify { namespace SgAsmPEFileHeader {
    const char* HeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_PROGRAM";
            case 2L: return "HF_EXECUTABLE";
            case 512L: return "HF_FIXED";
            case 8192L: return "HF_LIBRARY";
            case 56829L: return "HF_RESERVED_MASK";
            default: return "";
        }
    }

    std::string HeaderFlags(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags() {
        static const int64_t values[] = {
            0L,
            2L,
            512L,
            8192L,
            56829L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::HeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderHeaderFlags() {
        return stringify::SgAsmPEFileHeader::HeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 4131
namespace stringify { namespace SgAsmPEFileHeader {
    const char* Subsystem(int64_t i) {
        switch (i) {
            case 0L: return "HF_SPEC_UNKNOWN";
            case 1L: return "HF_NATIVE";
            case 2L: return "HF_WINGUI";
            case 3L: return "HF_WINCHAR";
            case 5L: return "HF_OS2CHAR";
            case 7L: return "HF_POSIX";
            default: return "";
        }
    }

    std::string Subsystem(int64_t i, const std::string &strip) {
        std::string s = Subsystem(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subsystem() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderSubsystem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::Subsystem(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::Subsystem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderSubsystem() {
        return stringify::SgAsmPEFileHeader::Subsystem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 4141
namespace stringify { namespace SgAsmPEFileHeader {
    const char* DLLFlags(int64_t i) {
        switch (i) {
            case 1L: return "DLL_PROC_INIT";
            case 2L: return "DLL_PROC_TERM";
            case 4L: return "DLL_THRD_INIT";
            case 8L: return "DLL_THRD_TERM";
            case 65520L: return "DLL_RESERVED_MASK";
            default: return "";
        }
    }

    std::string DLLFlags(int64_t i, const std::string &strip) {
        std::string s = DLLFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DLLFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            65520L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderDLLFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::DLLFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderDLLFlags() {
        return stringify::SgAsmPEFileHeader::DLLFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 4150
namespace stringify { namespace SgAsmPEFileHeader {
    const char* PairPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PAIR_EXPORTS";
            case 1L: return "PAIR_IMPORTS";
            case 2L: return "PAIR_RESOURCES";
            case 3L: return "PAIR_EXCEPTIONS";
            case 4L: return "PAIR_CERTIFICATES";
            case 5L: return "PAIR_BASERELOCS";
            case 6L: return "PAIR_DEBUG";
            case 7L: return "PAIR_ARCHITECTURE";
            case 8L: return "PAIR_GLOBALPTR";
            case 9L: return "PAIR_TLS";
            case 10L: return "PAIR_LOADCONFIG";
            case 11L: return "PAIR_BOUNDIMPORT";
            case 12L: return "PAIR_IAT";
            case 13L: return "PAIR_DELAYIMPORT";
            case 14L: return "PAIR_CLRRUNTIME";
            case 15L: return "PAIR_RESERVED15";
            default: return "";
        }
    }

    std::string PairPurpose(int64_t i, const std::string &strip) {
        std::string s = PairPurpose(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PairPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderPairPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::PairPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderPairPurpose() {
        return stringify::SgAsmPEFileHeader::PairPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5527
namespace stringify { namespace SgAsmNullInstruction {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "null_unknown";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(SgAsmNullInstruction::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNullInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNullInstruction::Kind(i);
        if (retval.empty()) {
            retval = "(SgAsmNullInstruction::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNullInstruction::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNullInstructionKind() {
        return stringify::SgAsmNullInstruction::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 5707
namespace stringify { namespace SgAsmNESectionTableEntry {
    const char* NESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_CODE";
            case 1L: return "SF_DATA";
            case 2L: return "SF_ALLOC";
            case 4L: return "SF_LOAD";
            case 7L: return "SF_TYPE_MASK";
            case 16L: return "SF_MOVABLE";
            case 32L: return "SF_PURE";
            case 64L: return "SF_PRELOAD";
            case 128L: return "SF_NOT_WRITABLE";
            case 256L: return "SF_RELOCINFO";
            case 3592L: return "SF_RESERVED";
            case 4096L: return "SF_DISCARDABLE";
            case 61440L: return "SF_DISCARD";
            default: return "";
        }
    }

    std::string NESectionFlags(int64_t i, const std::string &strip) {
        std::string s = NESectionFlags(i);
        if (s.empty())
            s = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L,
            16L,
            32L,
            64L,
            128L,
            256L,
            3592L,
            4096L,
            61440L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNESectionTableEntryNESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNESectionTableEntry::NESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNESectionTableEntryNESectionFlags() {
        return stringify::SgAsmNESectionTableEntry::NESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6164
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocSrcType(int64_t i) {
        switch (i) {
            case 0L: return "RF_SRCTYPE_8OFF";
            case 2L: return "RF_SRCTYPE_WORDSEG";
            case 3L: return "RF_SRCTYPE_16PTR";
            case 5L: return "RF_SRCTYPE_16OFF";
            case 6L: return "RF_SRCTYPE_32PTR";
            case 7L: return "RF_SRCTYPE_32OFF";
            case 8L: return "RF_SRCTYPE_NEARCALL";
            case 11L: return "RF_SRCTYPE_48PTR";
            case 13L: return "RF_SRCTYPE_32OFF_b";
            default: return "";
        }
    }

    std::string NERelocSrcType(int64_t i, const std::string &strip) {
        std::string s = NERelocSrcType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocSrcType() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            5L,
            6L,
            7L,
            8L,
            11L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocSrcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocSrcType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocSrcType() {
        return stringify::SgAsmNERelocEntry::NERelocSrcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6176
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocTgtType(int64_t i) {
        switch (i) {
            case 0L: return "RF_TGTTYPE_IREF";
            case 1L: return "RF_TGTTYPE_IORD";
            case 2L: return "RF_TGTTYPE_INAME";
            case 3L: return "RF_TGTTYPE_OSFIXUP";
            default: return "";
        }
    }

    std::string NERelocTgtType(int64_t i, const std::string &strip) {
        std::string s = NERelocTgtType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocTgtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocTgtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocTgtType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocTgtType() {
        return stringify::SgAsmNERelocEntry::NERelocTgtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6183
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocModifiers(int64_t i) {
        switch (i) {
            case 1L: return "RF_MODIFIER_SINGLE";
            case 3L: return "RF_MODIFIER_MULTI";
            default: return "";
        }
    }

    std::string NERelocModifiers(int64_t i, const std::string &strip) {
        std::string s = NERelocModifiers(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocModifiers() {
        static const int64_t values[] = {
            1L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocModifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocModifiers(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocModifiers() {
        return stringify::SgAsmNERelocEntry::NERelocModifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6188
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocFlags(int64_t i) {
        switch (i) {
            case 1L: return "RF_ADDITIVE";
            case 2L: return "RF_RESERVED";
            case 4L: return "RF_2EXTRA";
            case 8L: return "RF_32ADD";
            case 16L: return "RF_16SECTION";
            case 32L: return "RF_8ORDINAL";
            default: return "";
        }
    }

    std::string NERelocFlags(int64_t i, const std::string &strip) {
        std::string s = NERelocFlags(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocFlags() {
        return stringify::SgAsmNERelocEntry::NERelocFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6892
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags1(int64_t i) {
        switch (i) {
            case 0L: return "HF1_NO_DATA";
            case 1L: return "HF1_SINGLE_DATA";
            case 2L: return "HF1_MULTIPLE_DATA";
            case 2048L: return "HF1_LOADER_SEGMENT";
            case 8192L: return "HF1_FATAL_ERRORS";
            case 22516L: return "HF1_RESERVED";
            case 32768L: return "HF1_LIBRARY";
            default: return "";
        }
    }

    std::string HeaderFlags1(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags1(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags1() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            2048L,
            8192L,
            22516L,
            32768L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags1(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags1(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags1() {
        return stringify::SgAsmNEFileHeader::HeaderFlags1();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 6903
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags2(int64_t i) {
        switch (i) {
            case 2L: return "HF2_PROTECTED_MODE";
            case 4L: return "HF2_PFONTS";
            case 8L: return "HF2_FASTLOAD";
            case 241L: return "HF2_RESERVED";
            default: return "";
        }
    }

    std::string HeaderFlags2(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags2(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags2() {
        static const int64_t values[] = {
            2L,
            4L,
            8L,
            241L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags2(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags2(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags2() {
        return stringify::SgAsmNEFileHeader::HeaderFlags2();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 7255
namespace stringify { namespace SgAsmNEEntryPoint {
    const char* NEEntryFlags(int64_t i) {
        switch (i) {
            case 0L: return "EF_ZERO";
            case 1L: return "EF_EXPORTED";
            case 2L: return "EF_GLOBAL";
            case 252L: return "EF_RESERVED";
            default: return "";
        }
    }

    std::string NEEntryFlags(int64_t i, const std::string &strip) {
        std::string s = NEEntryFlags(i);
        if (s.empty())
            s = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NEEntryFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            252L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEEntryPointNEEntryFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEEntryPoint::NEEntryFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEEntryPointNEEntryFlags() {
        return stringify::SgAsmNEEntryPoint::NEEntryFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 7710
namespace stringify { namespace SgAsmLESectionTableEntry {
    const char* LESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_TYPE_NORMAL";
            case 1L: return "SF_READABLE";
            case 2L: return "SF_WRITABLE";
            case 4L: return "SF_EXECUTABLE";
            case 8L: return "SF_RESOURCE";
            case 16L: return "SF_DISCARDABLE";
            case 32L: return "SF_SHARED";
            case 64L: return "SF_PRELOAD_PAGES";
            case 128L: return "SF_INVALID_PAGES";
            case 256L: return "SF_TYPE_ZERO";
            case 512L: return "SF_TYPE_RESIDENT";
            case 768L: return "SF_TYPE_RESCONT";
            case 1024L: return "SF_RES_LONG_LOCK";
            case 4096L: return "SF_1616_ALIAS";
            case 8192L: return "SF_BIG_BIT";
            case 16384L: return "SF_CODE_CONFORM";
            case 32768L: return "SF_IO_PRIV";
            case 4294903808L: return "SF_RESERVED";
            default: return "";
        }
    }

    std::string LESectionFlags(int64_t i, const std::string &strip) {
        std::string s = LESectionFlags(i);
        if (s.empty())
            s = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            16384L,
            32768L,
            4294903808L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLESectionTableEntryLESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLESectionTableEntry::LESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLESectionTableEntryLESectionFlags() {
        return stringify::SgAsmLESectionTableEntry::LESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 8783
namespace stringify { namespace SgAsmLEFileHeader {
    const char* LEFileHeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_MODTYPE_PROG";
            case 4L: return "HF_PROC_LIB_INIT";
            case 16L: return "HF_IFIXUPS_APPLIED";
            case 32L: return "HF_EFIXUPS_APPLIED";
            case 256L: return "HF_PM_WINDOW_NO";
            case 512L: return "HF_PM_WINDOW_OK";
            case 768L: return "HF_PM_WINDOW_USE";
            case 8192L: return "HF_NOT_LOADABLE";
            case 32768L: return "HF_MODTYPE_LIB";
            case 98304L: return "HF_MODTYPE_PLIB";
            case 131072L: return "HF_MODTYPE_PDEV";
            case 163840L: return "HF_MODTYPE_VDEV";
            case 229376L: return "HF_MODTYPE_MASK";
            case 1073741824L: return "HF_PROC_LIB_TERM";
            case 3220987083L: return "HF_RESERVED";
            default: return "";
        }
    }

    std::string LEFileHeaderFlags(int64_t i, const std::string &strip) {
        std::string s = LEFileHeaderFlags(i);
        if (s.empty())
            s = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LEFileHeaderFlags() {
        static const int64_t values[] = {
            0L,
            4L,
            16L,
            32L,
            256L,
            512L,
            768L,
            8192L,
            32768L,
            98304L,
            131072L,
            163840L,
            229376L,
            1073741824L,
            3220987083L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLEFileHeaderLEFileHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLEFileHeader::LEFileHeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLEFileHeaderLEFileHeaderFlags() {
        return stringify::SgAsmLEFileHeader::LEFileHeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 9448
namespace stringify { namespace SgAsmJvmStackMapVerificationType {
    const char* verification_type_tag(int64_t i) {
        switch (i) {
            case 0L: return "ITEM_Top";
            case 1L: return "ITEM_Integer";
            case 2L: return "ITEM_Float";
            case 3L: return "ITEM_Double";
            case 4L: return "ITEM_Long";
            case 5L: return "ITEM_Null";
            case 6L: return "ITEM_UninitializedThis";
            case 7L: return "ITEM_Object";
            case 8L: return "ITEM_Uninitialized";
            default: return "";
        }
    }

    std::string verification_type_tag(int64_t i, const std::string &strip) {
        std::string s = verification_type_tag(i);
        if (s.empty())
            s = "(SgAsmJvmStackMapVerificationType::verification_type_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& verification_type_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmJvmStackMapVerificationType_verification_type_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmJvmStackMapVerificationType::verification_type_tag(i);
        if (retval.empty()) {
            retval = "(SgAsmJvmStackMapVerificationType::verification_type_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmJvmStackMapVerificationType::verification_type_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmJvmStackMapVerificationType_verification_type_tag() {
        return stringify::SgAsmJvmStackMapVerificationType::verification_type_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 13029
namespace stringify { namespace SgAsmJvmConstantPoolEntry {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "CONSTANT_Utf8";
            case 3L: return "CONSTANT_Integer";
            case 4L: return "CONSTANT_Float";
            case 5L: return "CONSTANT_Long";
            case 6L: return "CONSTANT_Double";
            case 7L: return "CONSTANT_Class";
            case 8L: return "CONSTANT_String";
            case 9L: return "CONSTANT_Fieldref";
            case 10L: return "CONSTANT_Methodref";
            case 11L: return "CONSTANT_InterfaceMethodref";
            case 12L: return "CONSTANT_NameAndType";
            case 15L: return "CONSTANT_MethodHandle";
            case 16L: return "CONSTANT_MethodType";
            case 17L: return "CONSTANT_Dynamic";
            case 18L: return "CONSTANT_InvokeDynamic";
            case 19L: return "CONSTANT_Module";
            case 20L: return "CONSTANT_Package";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(SgAsmJvmConstantPoolEntry::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmJvmConstantPoolEntryKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmJvmConstantPoolEntry::Kind(i);
        if (retval.empty()) {
            retval = "(SgAsmJvmConstantPoolEntry::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmJvmConstantPoolEntry::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmJvmConstantPoolEntryKind() {
        return stringify::SgAsmJvmConstantPoolEntry::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15642
namespace stringify { namespace SgAsmGenericFile {
    const char* AddressSpace(int64_t i) {
        switch (i) {
            case 1L: return "ADDRSP_MEMORY";
            case 2L: return "ADDRSP_FILE";
            case 3L: return "ADDRSP_ALL";
            default: return "";
        }
    }

    std::string AddressSpace(int64_t i, const std::string &strip) {
        std::string s = AddressSpace(i);
        if (s.empty())
            s = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AddressSpace() {
        static const int64_t values[] = {
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileAddressSpace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::AddressSpace(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::AddressSpace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileAddressSpace() {
        return stringify::SgAsmGenericFile::AddressSpace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 15649
namespace stringify { namespace SgAsmGenericFile {
    const char* Elasticity(int64_t i) {
        switch (i) {
            case 0L: return "ELASTIC_NONE";
            case 1L: return "ELASTIC_UNREF";
            case 2L: return "ELASTIC_HOLE";
            default: return "";
        }
    }

    std::string Elasticity(int64_t i, const std::string &strip) {
        std::string s = Elasticity(i);
        if (s.empty())
            s = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Elasticity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileElasticity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::Elasticity(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::Elasticity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileElasticity() {
        return stringify::SgAsmGenericFile::Elasticity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 16449
namespace stringify { namespace SgAsmFunction {
    const char* MayReturn(int64_t i) {
        switch (i) {
            case 0L: return "RET_UNKNOWN";
            case 1L: return "RET_NEVER";
            case 2L: return "RET_SOMETIMES";
            case 3L: return "RET_ALWAYS";
            default: return "";
        }
    }

    std::string MayReturn(int64_t i, const std::string &strip) {
        std::string s = MayReturn(i);
        if (s.empty())
            s = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayReturn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionMayReturn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::MayReturn(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::MayReturn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionMayReturn() {
        return stringify::SgAsmFunction::MayReturn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 16459
namespace stringify { namespace SgAsmFunction {
    const char* FunctionReason(int64_t i) {
        switch (i) {
            case 0L: return "FUNC_NONE";
            case 1L: return "FUNC_INTERPADFUNC";
            case 2L: return "FUNC_PESCRAMBLER_DISPATCH";
            case 3L: return "FUNC_CONFIGURED";
            case 4L: return "FUNC_CMDLINE";
            case 5L: return "FUNC_SCAN_RO_DATA";
            case 6L: return "FUNC_INSN_RO_DATA";
            case 255L: return "FUNC_MISCMASK";
            case 16384L: return "FUNC_THUNK_TARGET";
            case 32768L: return "FUNC_EXCEPTION_HANDLER";
            case 65536L: return "FUNC_ENTRY_POINT";
            case 131072L: return "FUNC_CALL_TARGET";
            case 262144L: return "FUNC_CALL_INSN";
            case 524288L: return "FUNC_EH_FRAME";
            case 1048576L: return "FUNC_SYMBOL";
            case 2097152L: return "FUNC_PATTERN";
            case 4194304L: return "FUNC_GRAPH";
            case 8388608L: return "FUNC_USERDEF";
            case 16777216L: return "FUNC_PADDING";
            case 33554432L: return "FUNC_DISCONT";
            case 67108864L: return "FUNC_INSNHEAD";
            case 134217728L: return "FUNC_IMPORT";
            case 268435456L: return "FUNC_LEFTOVERS";
            case 536870912L: return "FUNC_INTRABLOCK";
            case 1073741824L: return "FUNC_THUNK";
            case 2147483648L: return "FUNC_EXPORT";
            case 4026499327L: return "FUNC_DEFAULT";
            default: return "";
        }
    }

    std::string FunctionReason(int64_t i, const std::string &strip) {
        std::string s = FunctionReason(i);
        if (s.empty())
            s = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L,
            16384L,
            32768L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4026499327L
        };
        static const std::vector<int64_t> retval(values, values + 27);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionFunctionReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::FunctionReason(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::FunctionReason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionFunctionReason() {
        return stringify::SgAsmFunction::FunctionReason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 16546
namespace stringify { namespace SgAsmFunction {
    const char* function_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_standard";
            case 2L: return "e_library";
            case 3L: return "e_imported";
            case 4L: return "e_thunk";
            case 5L: return "e_last";
            default: return "";
        }
    }

    std::string function_kind_enum(int64_t i, const std::string &strip) {
        std::string s = function_kind_enum(i);
        if (s.empty())
            s = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunction_function_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::function_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::function_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunction_function_kind_enum() {
        return stringify::SgAsmFunction::function_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 17102
namespace stringify { namespace SgAsmFloatType {
    const char* Flag(int64_t i) {
        switch (i) {
            case 1L: return "GRADUAL_UNDERFLOW";
            case 2L: return "IMPLICIT_BIT_CONVENTION";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(SgAsmFloatType::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFloatTypeFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFloatType::Flag(i);
        if (retval.empty()) {
            retval = "(SgAsmFloatType::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFloatType::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFloatTypeFlag() {
        return stringify::SgAsmFloatType::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 19374
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymBinding(int64_t i) {
        switch (i) {
            case 0L: return "STB_LOCAL";
            case 1L: return "STB_GLOBAL";
            case 2L: return "STB_WEAK";
            default: return "";
        }
    }

    std::string ElfSymBinding(int64_t i, const std::string &strip) {
        std::string s = ElfSymBinding(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymBinding() {
        return stringify::SgAsmElfSymbol::ElfSymBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 19380
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymType(int64_t i) {
        switch (i) {
            case 0L: return "STT_NOTYPE";
            case 1L: return "STT_OBJECT";
            case 2L: return "STT_FUNC";
            case 3L: return "STT_SECTION";
            case 4L: return "STT_FILE";
            case 5L: return "STT_COMMON";
            case 6L: return "STT_TLS";
            case 10L: return "STT_IFUNC";
            default: return "";
        }
    }

    std::string ElfSymType(int64_t i, const std::string &strip) {
        std::string s = ElfSymType(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymType() {
        return stringify::SgAsmElfSymbol::ElfSymType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 19966
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentType(int64_t i) {
        switch (i) {
            case 0L: return "PT_NULL";
            case 1L: return "PT_LOAD";
            case 2L: return "PT_DYNAMIC";
            case 3L: return "PT_INTERP";
            case 4L: return "PT_NOTE";
            case 5L: return "PT_SHLIB";
            case 6L: return "PT_PHDR";
            case 7L: return "PT_TLS";
            case 1610612736L: return "PT_LOOS";
            case 1685382480L: return "PT_GNU_EH_FRAME";
            case 1685382481L: return "PT_GNU_STACK";
            case 1685382482L: return "PT_GNU_RELRO";
            case 1694766464L: return "PT_PAX_FLAGS";
            case 1879048186L: return "PT_SUNWBSS";
            case 1879048187L: return "PT_SUNWSTACK";
            case 1879048191L: return "PT_HIOS";
            case 1879048192L: return "PT_LOPROC";
            case 2147483647L: return "PT_HIPROC";
            default: return "";
        }
    }

    std::string SegmentType(int64_t i, const std::string &strip) {
        std::string s = SegmentType(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1610612736L,
            1685382480L,
            1685382481L,
            1685382482L,
            1694766464L,
            1879048186L,
            1879048187L,
            1879048191L,
            1879048192L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentType() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 19994
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentFlags(int64_t i) {
        switch (i) {
            case 0L: return "PF_NONE";
            case 1L: return "PF_XPERM";
            case 2L: return "PF_WPERM";
            case 4L: return "PF_RPERM";
            case 1048568L: return "PF_RESERVED";
            case 267386880L: return "PF_OS_MASK";
            case 4026531840L: return "PF_PROC_MASK";
            default: return "";
        }
    }

    std::string SegmentFlags(int64_t i, const std::string &strip) {
        std::string s = SegmentFlags(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            1048568L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentFlags() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 20435
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionType(int64_t i) {
        switch (i) {
            case 0L: return "SHT_NULL";
            case 1L: return "SHT_PROGBITS";
            case 2L: return "SHT_SYMTAB";
            case 3L: return "SHT_STRTAB";
            case 4L: return "SHT_RELA";
            case 5L: return "SHT_HASH";
            case 6L: return "SHT_DYNAMIC";
            case 7L: return "SHT_NOTE";
            case 8L: return "SHT_NOBITS";
            case 9L: return "SHT_REL";
            case 10L: return "SHT_SHLIB";
            case 11L: return "SHT_DYNSYM";
            case 1610612736L: return "SHT_LOOS";
            case 1879048189L: return "SHT_GNU_verdef";
            case 1879048190L: return "SHT_GNU_verneed";
            case 1879048191L: return "SHT_GNU_versym";
            case 1879048192L: return "SHT_LOPROC";
            case 2147483647L: return "SHT_HIPROC";
            case 2147483648L: return "SHT_LOUSER";
            case 4294967295L: return "SHT_HIUSER";
            default: return "";
        }
    }

    std::string SectionType(int64_t i, const std::string &strip) {
        std::string s = SectionType(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            1610612736L,
            1879048189L,
            1879048190L,
            1879048191L,
            1879048192L,
            2147483647L,
            2147483648L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionType() {
        return stringify::SgAsmElfSectionTableEntry::SectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 20462
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SHF_NULL";
            case 1L: return "SHF_WRITE";
            case 2L: return "SHF_ALLOC";
            case 4L: return "SHF_EXECINSTR";
            case 16L: return "SHF_MERGE";
            case 32L: return "SHF_STRINGS";
            case 64L: return "SHF_INFO_LINK";
            case 128L: return "SHF_LINK_ORDER";
            case 256L: return "SHF_OS_NONCONFORMING";
            case 512L: return "SHF_GROUP";
            case 1024L: return "SHF_TLS";
            case 267386880L: return "SHF_MASKOS";
            case 4026531840L: return "SHF_MASKPROC";
            default: return "";
        }
    }

    std::string SectionFlags(int64_t i, const std::string &strip) {
        std::string s = SectionFlags(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionFlags() {
        return stringify::SgAsmElfSectionTableEntry::SectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 21097
namespace stringify { namespace SgAsmElfRelocEntry {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "R_386_NONE";
            case 1L: return "R_386_32";
            case 2L: return "R_386_PC32";
            case 3L: return "R_386_GOT32";
            case 4L: return "R_386_PLT32";
            case 5L: return "R_386_COPY";
            case 6L: return "R_386_GLOB_DAT";
            case 7L: return "R_386_JMP_SLOT";
            case 8L: return "R_386_RELATIVE";
            case 9L: return "R_386_GOTOFF";
            case 10L: return "R_386_GOTPC";
            case 11L: return "R_386_32PLT";
            case 14L: return "R_386_TLS_TPOFF";
            case 15L: return "R_386_TLS_IE";
            case 16L: return "R_386_TLS_GOTIE";
            case 17L: return "R_386_TLS_LE";
            case 18L: return "R_386_TLS_GD";
            case 19L: return "R_386_TLS_LDM";
            case 20L: return "R_386_16";
            case 21L: return "R_386_PC16";
            case 22L: return "R_386_8";
            case 23L: return "R_386_PC8";
            case 24L: return "R_386_TLS_GD_32";
            case 25L: return "R_386_TLS_GD_PUSH";
            case 26L: return "R_386_TLS_GD_CALL";
            case 27L: return "R_386_TLS_GD_POP";
            case 28L: return "R_386_TLS_LDM_32";
            case 29L: return "R_386_TLS_LDM_PUSH";
            case 30L: return "R_386_TLS_LDM_CALL";
            case 31L: return "R_386_TLS_LDM_POP";
            case 32L: return "R_386_TLS_LDO_32";
            case 33L: return "R_386_TLS_IE_32";
            case 34L: return "R_386_TLS_LE_32";
            case 35L: return "R_386_TLS_DTPMOD32";
            case 36L: return "R_386_TLS_DTPOFF32";
            case 37L: return "R_386_TLS_TPOFF32";
            case 100L: return "R_X86_64_NONE";
            case 101L: return "R_X86_64_64";
            case 102L: return "R_X86_64_PC32";
            case 103L: return "R_X86_64_GOT32";
            case 104L: return "R_X86_64_PLT32";
            case 105L: return "R_X86_64_COPY";
            case 106L: return "R_X86_64_GLOB_DAT";
            case 107L: return "R_X86_64_JUMP_SLOT";
            case 108L: return "R_X86_64_RELATIVE";
            case 109L: return "R_X86_64_GOTPCREL";
            case 110L: return "R_X86_64_32";
            case 111L: return "R_X86_64_32S";
            case 112L: return "R_X86_64_16";
            case 113L: return "R_X86_64_PC16";
            case 114L: return "R_X86_64_8";
            case 115L: return "R_X86_64_PC8";
            case 116L: return "R_X86_64_DTPMOD64";
            case 117L: return "R_X86_64_DTPOFF64";
            case 118L: return "R_X86_64_TPOFF64";
            case 119L: return "R_X86_64_TLSGD";
            case 120L: return "R_X86_64_TLSLD";
            case 121L: return "R_X86_64_DTPOFF32";
            case 122L: return "R_X86_64_GOTTPOFF";
            case 123L: return "R_X86_64_TPOFF32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfRelocEntryRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfRelocEntry::RelocType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfRelocEntry::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfRelocEntryRelocType() {
        return stringify::SgAsmElfRelocEntry::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 21801
namespace stringify { namespace SgAsmElfFileHeader {
    const char* ObjectType(int64_t i) {
        switch (i) {
            case 0L: return "ET_NONE";
            case 1L: return "ET_REL";
            case 2L: return "ET_EXEC";
            case 3L: return "ET_DYN";
            case 4L: return "ET_CORE";
            case 65024L: return "ET_LOOS";
            case 65279L: return "ET_HIOS";
            case 65280L: return "ET_LOPROC";
            case 65535L: return "ET_HIPROC";
            default: return "";
        }
    }

    std::string ObjectType(int64_t i, const std::string &strip) {
        std::string s = ObjectType(i);
        if (s.empty())
            s = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ObjectType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            65024L,
            65279L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfFileHeaderObjectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfFileHeader::ObjectType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfFileHeader::ObjectType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfFileHeaderObjectType() {
        return stringify::SgAsmElfFileHeader::ObjectType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 23347
namespace stringify { namespace SgAsmElfDynamicEntry {
    const char* EntryType(int64_t i) {
        switch (i) {
            case 0L: return "DT_NULL";
            case 1L: return "DT_NEEDED";
            case 2L: return "DT_PLTRELSZ";
            case 3L: return "DT_PLTGOT";
            case 4L: return "DT_HASH";
            case 5L: return "DT_STRTAB";
            case 6L: return "DT_SYMTAB";
            case 7L: return "DT_RELA";
            case 8L: return "DT_RELASZ";
            case 9L: return "DT_RELAENT";
            case 10L: return "DT_STRSZ";
            case 11L: return "DT_SYMENT";
            case 12L: return "DT_INIT";
            case 13L: return "DT_FINI";
            case 14L: return "DT_SONAME";
            case 15L: return "DT_RPATH";
            case 16L: return "DT_SYMBOLIC";
            case 17L: return "DT_REL";
            case 18L: return "DT_RELSZ";
            case 19L: return "DT_RELENT";
            case 20L: return "DT_PLTREL";
            case 21L: return "DT_DEBUG";
            case 22L: return "DT_TEXTREL";
            case 23L: return "DT_JMPREL";
            case 24L: return "DT_BIND_NOW";
            case 25L: return "DT_INIT_ARRAY";
            case 26L: return "DT_FINI_ARRAY";
            case 27L: return "DT_INIT_ARRAYSZ";
            case 28L: return "DT_FINI_ARRAYSZ";
            case 29L: return "DT_RUNPATH";
            case 30L: return "DT_FLAGS";
            case 32L: return "DT_PREINIT_ARRAY";
            case 33L: return "DT_PREINIT_ARRAYSZ";
            case 34L: return "DT_NUM";
            case 1879047669L: return "DT_GNU_PRELINKED";
            case 1879047670L: return "DT_GNU_CONFLICTSZ";
            case 1879047671L: return "DT_GNU_LIBLISTSZ";
            case 1879047672L: return "DT_CHECKSUM";
            case 1879047673L: return "DT_PLTPADSZ";
            case 1879047674L: return "DT_MOVEENT";
            case 1879047675L: return "DT_MOVESZ";
            case 1879047676L: return "DT_FEATURE_1";
            case 1879047677L: return "DT_POSFLAG_1";
            case 1879047678L: return "DT_SYMINSZ";
            case 1879047679L: return "DT_SYMINENT";
            case 1879047925L: return "DT_GNU_HASH";
            case 1879047926L: return "DT_TLSDESC_PLT";
            case 1879047927L: return "DT_TLSDESC_GOT";
            case 1879047928L: return "DT_GNU_CONFLICT";
            case 1879047929L: return "DT_GNU_LIBLIST";
            case 1879047930L: return "DT_CONFIG";
            case 1879047931L: return "DT_DEPAUDIT";
            case 1879047932L: return "DT_AUDIT";
            case 1879047933L: return "DT_PLTPAD";
            case 1879047934L: return "DT_MOVETAB";
            case 1879047935L: return "DT_SYMINFO";
            case 1879048176L: return "DT_VERSYM";
            case 1879048185L: return "DT_RELACOUNT";
            case 1879048186L: return "DT_RELCOUNT";
            case 1879048187L: return "DT_FLAGS_1";
            case 1879048188L: return "DT_VERDEF";
            case 1879048189L: return "DT_VERDEFNUM";
            case 1879048190L: return "DT_VERNEED";
            case 1879048191L: return "DT_VERNEEDNUM";
            case 2147483645L: return "DT_AUXILIARY";
            case 2147483647L: return "DT_FILTER";
            default: return "";
        }
    }

    std::string EntryType(int64_t i, const std::string &strip) {
        std::string s = EntryType(i);
        if (s.empty())
            s = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EntryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            32L,
            33L,
            34L,
            1879047669L,
            1879047670L,
            1879047671L,
            1879047672L,
            1879047673L,
            1879047674L,
            1879047675L,
            1879047676L,
            1879047677L,
            1879047678L,
            1879047679L,
            1879047925L,
            1879047926L,
            1879047927L,
            1879047928L,
            1879047929L,
            1879047930L,
            1879047931L,
            1879047932L,
            1879047933L,
            1879047934L,
            1879047935L,
            1879048176L,
            1879048185L,
            1879048186L,
            1879048187L,
            1879048188L,
            1879048189L,
            1879048190L,
            1879048191L,
            2147483645L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfDynamicEntryEntryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfDynamicEntry::EntryType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfDynamicEntryEntryType() {
        return stringify::SgAsmElfDynamicEntry::EntryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 30505
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolDefState(int64_t i) {
        switch (i) {
            case 0L: return "SYM_UNDEFINED";
            case 1L: return "SYM_TENTATIVE";
            case 2L: return "SYM_DEFINED";
            default: return "";
        }
    }

    std::string SymbolDefState(int64_t i, const std::string &strip) {
        std::string s = SymbolDefState(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolDefState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolDefState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolDefState(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolDefState() {
        return stringify::SgAsmGenericSymbol::SymbolDefState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 30512
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolType(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_TYPE";
            case 1L: return "SYM_DATA";
            case 2L: return "SYM_FUNC";
            case 3L: return "SYM_SECTION";
            case 4L: return "SYM_FILE";
            case 5L: return "SYM_ARRAY";
            case 6L: return "SYM_TLS";
            case 7L: return "SYM_REGISTER";
            case 8L: return "SYM_COMMON";
            case 9L: return "SYM_IFUNC";
            default: return "";
        }
    }

    std::string SymbolType(int64_t i, const std::string &strip) {
        std::string s = SymbolType(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolType(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolType() {
        return stringify::SgAsmGenericSymbol::SymbolType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 30526
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolBinding(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_BINDING";
            case 1L: return "SYM_LOCAL";
            case 2L: return "SYM_GLOBAL";
            case 3L: return "SYM_WEAK";
            default: return "";
        }
    }

    std::string SymbolBinding(int64_t i, const std::string &strip) {
        std::string s = SymbolBinding(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolBinding() {
        return stringify::SgAsmGenericSymbol::SymbolBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 31438
namespace stringify { namespace SgAsmGenericSection {
    const char* SectionPurpose(int64_t i) {
        switch (i) {
            case 0L: return "SP_UNSPECIFIED";
            case 1L: return "SP_PROGRAM";
            case 2L: return "SP_HEADER";
            case 3L: return "SP_SYMTAB";
            case 4L: return "SP_OTHER";
            default: return "";
        }
    }

    std::string SectionPurpose(int64_t i, const std::string &strip) {
        std::string s = SectionPurpose(i);
        if (s.empty())
            s = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSectionSectionPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSection::SectionPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSection::SectionPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSectionSectionPurpose() {
        return stringify::SgAsmGenericSection::SectionPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 35885
namespace stringify { namespace SgAsmCilMetadataHeap {
    const char* ReferenceKind(int64_t i) {
        switch (i) {
            case 1L: return "e_ref_string_heap";
            case 2L: return "e_ref_guid_heap";
            case 4L: return "e_ref_blob_heap";
            case 8L: return "e_ref_assembly_ref";
            case 16L: return "e_ref_type_def";
            case 32L: return "e_ref_event";
            case 64L: return "e_ref_field";
            case 128L: return "e_ref_generic_param";
            case 256L: return "e_ref_module_ref";
            case 512L: return "e_ref_method_def";
            case 1024L: return "e_ref_param";
            case 2048L: return "e_ref_property";
            case 4096L: return "e_ref_has_constant";
            case 8192L: return "e_ref_has_custom_attribute";
            case 16384L: return "e_ref_has_decl_security";
            case 32768L: return "e_ref_has_field_marshall";
            case 65536L: return "e_ref_has_semantics";
            case 131072L: return "e_ref_method_def_or_ref";
            case 262144L: return "e_ref_type_def_or_ref";
            case 524288L: return "e_ref_implementation";
            case 1048576L: return "e_ref_member_forwarded";
            case 2097152L: return "e_ref_member_ref_parent";
            case 4194304L: return "e_ref_type_or_method_def";
            case 8388608L: return "e_ref_custom_attribute_type";
            case 16777216L: return "e_ref_resolution_scope";
            case 33554432L: return "e_ref_last";
            default: return "";
        }
    }

    std::string ReferenceKind(int64_t i, const std::string &strip) {
        std::string s = ReferenceKind(i);
        if (s.empty())
            s = "(SgAsmCilMetadataHeap::ReferenceKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ReferenceKind() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            2048L,
            4096L,
            8192L,
            16384L,
            32768L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L
        };
        static const std::vector<int64_t> retval(values, values + 26);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmCilMetadataHeapReferenceKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmCilMetadataHeap::ReferenceKind(i);
        if (retval.empty()) {
            retval = "(SgAsmCilMetadataHeap::ReferenceKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmCilMetadataHeap::ReferenceKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmCilMetadataHeapReferenceKind() {
        return stringify::SgAsmCilMetadataHeap::ReferenceKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 41238
namespace stringify { namespace SgAsmBlock {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "BLK_NONE";
            case 1L: return "BLK_FINDDATA";
            case 2L: return "BLK_POSTFUNC";
            case 255L: return "BLK_MISCMASK";
            case 65536L: return "BLK_ENTRY_POINT";
            case 131072L: return "BLK_PADDING";
            case 524288L: return "BLK_FRAGMENT";
            case 1048576L: return "BLK_CFGHEAD";
            case 2097152L: return "BLK_USERDEF";
            case 4194304L: return "BLK_LEFTOVERS";
            case 8388608L: return "BLK_JUMPTABLE";
            case 16777216L: return "BLK_GRAPH1";
            case 33554432L: return "BLK_GRAPH2";
            case 67108864L: return "BLK_GRAPH3";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            255L,
            65536L,
            131072L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmBlockReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmBlock::Reason(i);
        if (retval.empty()) {
            retval = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmBlock::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmBlockReason() {
        return stringify::SgAsmBlock::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 42736
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecFamily(int64_t i) {
        switch (i) {
            case 0L: return "FAMILY_UNSPECIFIED";
            case 1L: return "FAMILY_DOS";
            case 2L: return "FAMILY_ELF";
            case 3L: return "FAMILY_JVM";
            case 4L: return "FAMILY_LE";
            case 5L: return "FAMILY_LX";
            case 6L: return "FAMILY_NE";
            case 7L: return "FAMILY_PE";
            default: return "";
        }
    }

    std::string ExecFamily(int64_t i, const std::string &strip) {
        std::string s = ExecFamily(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecFamily() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecFamily(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecFamily() {
        return stringify::SgAsmExecutableFileFormat::ExecFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 42748
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecABI(int64_t i) {
        switch (i) {
            case 0L: return "ABI_UNSPECIFIED";
            case 1L: return "ABI_OTHER";
            case 2L: return "ABI_86OPEN";
            case 3L: return "ABI_AIX";
            case 4L: return "ABI_ARM";
            case 5L: return "ABI_FREEBSD";
            case 6L: return "ABI_HPUX";
            case 7L: return "ABI_IRIX";
            case 8L: return "ABI_HURD";
            case 9L: return "ABI_JVM";
            case 10L: return "ABI_LINUX";
            case 11L: return "ABI_MODESTO";
            case 12L: return "ABI_MONTEREY";
            case 13L: return "ABI_MSDOS";
            case 14L: return "ABI_NT";
            case 15L: return "ABI_NETBSD";
            case 16L: return "ABI_OS2";
            case 17L: return "ABI_SOLARIS";
            case 18L: return "ABI_SYSV";
            case 19L: return "ABI_TRU64";
            case 20L: return "ABI_WIN386";
            default: return "";
        }
    }

    std::string ExecABI(int64_t i, const std::string &strip) {
        std::string s = ExecABI(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecABI() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecABI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecABI(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecABI() {
        return stringify::SgAsmExecutableFileFormat::ExecABI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 42773
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* InsSetArchitecture(int64_t i) {
        switch (i) {
            case 0L: return "ISA_UNSPECIFIED";
            case 256L: return "ISA_IA32_Family";
            case 257L: return "ISA_IA32_286";
            case 258L: return "ISA_IA32_386";
            case 259L: return "ISA_IA32_486";
            case 260L: return "ISA_IA32_Pentium";
            case 261L: return "ISA_IA32_Cyrix6x86";
            case 262L: return "ISA_IA32_AMDK5";
            case 263L: return "ISA_IA32_PentiumPro";
            case 264L: return "ISA_IA32_PentiumII";
            case 265L: return "ISA_IA32_Athlon";
            case 266L: return "ISA_IA32_Pentium4";
            case 267L: return "ISA_IA32_PentiumM";
            case 512L: return "ISA_X8664_Family";
            case 513L: return "ISA_X8664_Athlon64";
            case 514L: return "ISA_X8664_Prescott";
            case 515L: return "ISA_X8664_IntelCore";
            case 516L: return "ISA_X8664_AMDPhenom";
            case 768L: return "ISA_SPARC_Family";
            case 769L: return "ISA_SPARC_V7";
            case 770L: return "ISA_SPARC_V8";
            case 771L: return "ISA_SPARC_V8E";
            case 772L: return "ISA_SPARC_V9";
            case 773L: return "ISA_SPARC_V9JPS1";
            case 774L: return "ISA_SPARC_V9UA";
            case 775L: return "ISA_SPARC_V9JPS2";
            case 1024L: return "ISA_M68K_Family";
            case 1025L: return "ISA_M68K_68000";
            case 1026L: return "ISA_M68K_68EC000";
            case 1027L: return "ISA_M68K_68HC000";
            case 1028L: return "ISA_M68K_68008";
            case 1029L: return "ISA_M68K_68010";
            case 1030L: return "ISA_M68K_68012";
            case 1031L: return "ISA_M68K_68020";
            case 1032L: return "ISA_M68K_68EC020";
            case 1033L: return "ISA_M68K_68030";
            case 1034L: return "ISA_M68K_68EC030";
            case 1035L: return "ISA_M68K_68040";
            case 1036L: return "ISA_M68K_68EC040";
            case 1037L: return "ISA_M68K_68LC040";
            case 1038L: return "ISA_M68K_68060";
            case 1039L: return "ISA_M68K_ColdFire";
            case 1040L: return "ISA_M68K_DragonBall";
            case 1280L: return "ISA_M88K_Family";
            case 1281L: return "ISA_M88K_88100";
            case 1282L: return "ISA_M88K_88110";
            case 1283L: return "ISA_M88K_88110MP";
            case 1284L: return "ISA_M88K_88120";
            case 1536L: return "ISA_MIPS_Family";
            case 1537L: return "ISA_MIPS_MarkI";
            case 1538L: return "ISA_MIPS_MarkII";
            case 1539L: return "ISA_MIPS_MarkIII";
            case 1540L: return "ISA_MIPS_R2000";
            case 1541L: return "ISA_MIPS_R3000";
            case 1542L: return "ISA_MIPS_R4000";
            case 1543L: return "ISA_MIPS_R4200";
            case 1544L: return "ISA_MIPS_R4300";
            case 1545L: return "ISA_MIPS_R4600";
            case 1546L: return "ISA_MIPS_R4650";
            case 1547L: return "ISA_MIPS_R4700";
            case 1548L: return "ISA_MIPS_R5000";
            case 1549L: return "ISA_MIPS_RM7000";
            case 1550L: return "ISA_MIPS_R8000";
            case 1551L: return "ISA_MIPS_R10000";
            case 1552L: return "ISA_MIPS_R12000";
            case 1553L: return "ISA_MIPS_R14000";
            case 1554L: return "ISA_MIPS_R16000";
            case 1555L: return "ISA_MIPS_R16000A";
            case 1556L: return "ISA_MIPS_16";
            case 1557L: return "ISA_MIPS_FPU";
            case 1558L: return "ISA_MIPS_16FPU";
            case 1792L: return "ISA_I860_Family";
            case 1793L: return "ISA_I860_860XR";
            case 1794L: return "ISA_I860_860XP";
            case 2048L: return "ISA_IA64_Family";
            case 2049L: return "ISA_IA64_Itanium";
            case 2050L: return "ISA_IA64_Itanium2";
            case 2304L: return "ISA_ARM_Family";
            case 2305L: return "ISA_ARM_ARM1";
            case 2306L: return "ISA_ARM_ARM2";
            case 2307L: return "ISA_ARM_ARM3";
            case 2308L: return "ISA_ARM_ARM6";
            case 2309L: return "ISA_ARM_ARM7";
            case 2310L: return "ISA_ARM_ARM7TDMI";
            case 2311L: return "ISA_ARM_StrongARM";
            case 2312L: return "ISA_ARM_ARM8";
            case 2313L: return "ISA_ARM_ARM9TDMI";
            case 2314L: return "ISA_ARM_ARM9E";
            case 2315L: return "ISA_ARM_ARM10E";
            case 2316L: return "ISA_ARM_XScale";
            case 2317L: return "ISA_ARM_ARM11";
            case 2318L: return "ISA_ARM_Cortex";
            case 2319L: return "ISA_ARM_A64";
            case 2560L: return "ISA_JVM";
            case 61440L: return "ISA_OTHER_Family";
            case 61441L: return "ISA_ATT_WE_32100";
            case 61442L: return "ISA_IBM_System_370";
            case 61443L: return "ISA_HPPA";
            case 61444L: return "ISA_Fujitsu_VPP500";
            case 61445L: return "ISA_Sun_v8plus";
            case 61446L: return "ISA_PowerPC";
            case 61447L: return "ISA_PowerPC_64bit";
            case 61448L: return "ISA_IBM_S390";
            case 61449L: return "ISA_NEC_V800_series";
            case 61450L: return "ISA_Fujitsu_FR20";
            case 61451L: return "ISA_TRW_RH_32";
            case 61452L: return "ISA_Motorola_RCE";
            case 61454L: return "ISA_Digital_Alpha_fake";
            case 61455L: return "ISA_Hitachi_SH";
            case 61456L: return "ISA_Siemens_Tricore";
            case 61457L: return "ISA_Argonaut_RISC_Core";
            case 61458L: return "ISA_Hitachi_H8_300";
            case 61459L: return "ISA_Hitachi_H8_300H";
            case 61460L: return "ISA_Hitachi_H8S";
            case 61461L: return "ISA_Hitachi_H8_500";
            case 61462L: return "ISA_Stanford_MIPS_X";
            case 61463L: return "ISA_Motorola_M68HC12";
            case 61464L: return "ISA_Fujitsu_MMA_Multimedia_Accelerator";
            case 61465L: return "ISA_Siemens_PCP";
            case 61466L: return "ISA_Sony_nCPU_embeeded_RISC";
            case 61467L: return "ISA_Denso_NDR1_microprocessor";
            case 61468L: return "ISA_Motorola_Start_Core_processor";
            case 61469L: return "ISA_Toyota_ME16_processor";
            case 61470L: return "ISA_STMicroelectronic_ST100_processor";
            case 61471L: return "ISA_Advanced_Logic_Corp_Tinyj_emb_family";
            case 61472L: return "ISA_AMD_x86_64_architecture";
            case 61473L: return "ISA_Sony_DSP_Processor";
            case 61474L: return "ISA_Siemens_FX66_microcontroller";
            case 61475L: return "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller";
            case 61476L: return "ISA_STMicroelectronics_ST7_8bit_microcontroller";
            case 61477L: return "ISA_Motorola_MC68HC16_microcontroller";
            case 61478L: return "ISA_Motorola_MC68HC11_microcontroller";
            case 61479L: return "ISA_Motorola_MC68HC08_microcontroller";
            case 61480L: return "ISA_Motorola_MC68HC05_microcontroller";
            case 61481L: return "ISA_Silicon_Graphics_SVx";
            case 61482L: return "ISA_STMicroelectronics_ST19_8bit_microcontroller";
            case 61483L: return "ISA_Digital_VAX";
            case 61484L: return "ISA_Axis_Communications_32bit_embedded_processor";
            case 61485L: return "ISA_Infineon_Technologies_32bit_embedded_processor";
            case 61486L: return "ISA_Element_14_64bit_DSP_Processor";
            case 61487L: return "ISA_LSI_Logic_16bit_DSP_Processor";
            case 61488L: return "ISA_Donald_Knuths_educational_64bit_processor";
            case 61489L: return "ISA_Harvard_University_machine_independent_object_files";
            case 61490L: return "ISA_SiTera_Prism";
            case 61491L: return "ISA_Atmel_AVR_8bit_microcontroller";
            case 61492L: return "ISA_Fujitsu_FR30";
            case 61493L: return "ISA_Mitsubishi_D10V";
            case 61494L: return "ISA_Mitsubishi_D30V";
            case 61495L: return "ISA_NEC_v850";
            case 61496L: return "ISA_Mitsubishi_M32R";
            case 61497L: return "ISA_Matsushita_MN10300";
            case 61498L: return "ISA_Matsushita_MN10200";
            case 61499L: return "ISA_picoJava";
            case 61500L: return "ISA_OpenRISC_32bit_embedded_processor";
            case 61501L: return "ISA_ARC_Cores_Tangent_A5";
            case 61502L: return "ISA_Tensilica_Xtensa_Architecture";
            case 61503L: return "ISA_Digital_Alpha";
            case 61504L: return "ISA_Matsushita_AM33";
            case 61505L: return "ISA_EFI_ByteCode";
            case 65280L: return "ISA_FAMILY_MASK";
            case 65535L: return "ISA_OTHER";
            default: return "";
        }
    }

    std::string InsSetArchitecture(int64_t i, const std::string &strip) {
        std::string s = InsSetArchitecture(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsSetArchitecture() {
        static const int64_t values[] = {
            0L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            512L,
            513L,
            514L,
            515L,
            516L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1792L,
            1793L,
            1794L,
            2048L,
            2049L,
            2050L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2560L,
            61440L,
            61441L,
            61442L,
            61443L,
            61444L,
            61445L,
            61446L,
            61447L,
            61448L,
            61449L,
            61450L,
            61451L,
            61452L,
            61454L,
            61455L,
            61456L,
            61457L,
            61458L,
            61459L,
            61460L,
            61461L,
            61462L,
            61463L,
            61464L,
            61465L,
            61466L,
            61467L,
            61468L,
            61469L,
            61470L,
            61471L,
            61472L,
            61473L,
            61474L,
            61475L,
            61476L,
            61477L,
            61478L,
            61479L,
            61480L,
            61481L,
            61482L,
            61483L,
            61484L,
            61485L,
            61486L,
            61487L,
            61488L,
            61489L,
            61490L,
            61491L,
            61492L,
            61493L,
            61494L,
            61495L,
            61496L,
            61497L,
            61498L,
            61499L,
            61500L,
            61501L,
            61502L,
            61503L,
            61504L,
            61505L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 161);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatInsSetArchitecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::InsSetArchitecture(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatInsSetArchitecture() {
        return stringify::SgAsmExecutableFileFormat::InsSetArchitecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/binaryInstruction.C line 42955
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PURPOSE_UNSPECIFIED";
            case 1L: return "PURPOSE_OTHER";
            case 2L: return "PURPOSE_EXECUTABLE";
            case 3L: return "PURPOSE_LIBRARY";
            case 4L: return "PURPOSE_CORE_DUMP";
            case 5L: return "PURPOSE_OS_SPECIFIC";
            case 6L: return "PURPOSE_PROC_SPECIFIC";
            default: return "";
        }
    }

    std::string ExecPurpose(int64_t i, const std::string &strip) {
        std::string s = ExecPurpose(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecPurpose() {
        return stringify::SgAsmExecutableFileFormat::ExecPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 106
namespace stringify { namespace AstNodeClass {
    const char* locationInTree(int64_t i) {
        switch (i) {
            case 0L: return "LOCAL_LIST";
            case 1L: return "SUBTREE_LIST";
            default: return "";
        }
    }

    std::string locationInTree(int64_t i, const std::string &strip) {
        std::string s = locationInTree(i);
        if (s.empty())
            s = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& locationInTree() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_locationInTree(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::locationInTree(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::locationInTree::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_locationInTree() {
        return stringify::AstNodeClass::locationInTree();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 112
namespace stringify { namespace AstNodeClass {
    const char* includeExcludeMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INCLUDE_LIST";
            case 1L: return "EXCLUDE_LIST";
            default: return "";
        }
    }

    std::string includeExcludeMechanism(int64_t i, const std::string &strip) {
        std::string s = includeExcludeMechanism(i);
        if (s.empty())
            s = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& includeExcludeMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_includeExcludeMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::includeExcludeMechanism(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::includeExcludeMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_includeExcludeMechanism() {
        return stringify::AstNodeClass::includeExcludeMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 333
namespace stringify { namespace AstNodeClass {
    const char* TypeEvaluation(int64_t i) {
        switch (i) {
            case 0L: return "CHAR_POINTER";
            case 1L: return "CONST_CHAR_POINTER";
            case 2L: return "ATTACHEDPREPROCESSINGINFOTYPE";
            case 3L: return "ROSE_HASH_MULTIMAP";
            case 4L: return "ROSE_GRAPH_HASH_MULTIMAP";
            case 5L: return "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP";
            case 6L: return "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP";
            case 7L: return "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP";
            case 8L: return "ROSE_GRAPH_INTEGER_NODE_HASH_MAP";
            case 9L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP";
            case 10L: return "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP";
            case 11L: return "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP";
            case 12L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP";
            case 13L: return "SGCLASS_POINTER";
            case 14L: return "ROSEATTRUBUTESLISTCONTAINER";
            case 15L: return "SGCLASS_POINTER_LIST";
            case 16L: return "SGCLASS_POINTER_VECTOR";
            case 17L: return "SGCLASS_POINTER_VECTOR_NAMED_LIST";
            case 18L: return "STL_CONTAINER";
            case 19L: return "STL_SET";
            case 20L: return "STL_MULTIMAP";
            case 21L: return "STL_MAP";
            case 22L: return "STRING";
            case 23L: return "SGNAME";
            case 24L: return "BIT_VECTOR";
            case 25L: return "MODIFIERCLASS";
            case 26L: return "MODIFIERCLASS_WITHOUTEASYSTORAGE";
            case 27L: return "ASTATTRIBUTEMECHANISM";
            case 28L: return "TO_HANDLE";
            case 29L: return "OSTREAM";
            case 30L: return "ENUM_TYPE";
            case 31L: return "BASIC_DATA_TYPE";
            case 32L: return "SKIP_TYPE";
            case 33L: return "SGCLASS_POINTER_LIST_POINTER";
            default: return "";
        }
    }

    std::string TypeEvaluation(int64_t i, const std::string &strip) {
        std::string s = TypeEvaluation(i);
        if (s.empty())
            s = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeEvaluation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClassTypeEvaluation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::TypeEvaluation(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::TypeEvaluation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClassTypeEvaluation() {
        return stringify::AstNodeClass::TypeEvaluation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 91
namespace stringify {
    const char* ConstructParamEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_CONSTRUCTOR_PARAMETER";
            case 1L: return "CONSTRUCTOR_PARAMETER";
            default: return "";
        }
    }

    std::string ConstructParamEnum(int64_t i, const std::string &strip) {
        std::string s = ConstructParamEnum(i);
        if (s.empty())
            s = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConstructParamEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyConstructParamEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstructParamEnum(i);
        if (retval.empty()) {
            retval = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstructParamEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstructParamEnum() {
        return stringify::ConstructParamEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 96
namespace stringify {
    const char* BuildAccessEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_ACCESS_FUNCTIONS";
            case 1L: return "BUILD_ACCESS_FUNCTIONS";
            case 2L: return "BUILD_FLAG_ACCESS_FUNCTIONS";
            case 3L: return "BUILD_LIST_ACCESS_FUNCTIONS";
            default: return "";
        }
    }

    std::string BuildAccessEnum(int64_t i, const std::string &strip) {
        std::string s = BuildAccessEnum(i);
        if (s.empty())
            s = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BuildAccessEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyBuildAccessEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BuildAccessEnum(i);
        if (retval.empty()) {
            retval = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BuildAccessEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBuildAccessEnum() {
        return stringify::BuildAccessEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 104
namespace stringify {
    const char* CopyConfigEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_COPY_DATA";
            case 1L: return "COPY_DATA";
            case 2L: return "CLONE_PTR";
            case 3L: return "CLONE_TREE";
            default: return "";
        }
    }

    std::string CopyConfigEnum(int64_t i, const std::string &strip) {
        std::string s = CopyConfigEnum(i);
        if (s.empty())
            s = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CopyConfigEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCopyConfigEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CopyConfigEnum(i);
        if (retval.empty()) {
            retval = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CopyConfigEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCopyConfigEnum() {
        return stringify::CopyConfigEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 125
namespace stringify {
    const char* TraversalEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_TRAVERSAL";
            case 1L: return "NO_TRAVERSAL";
            default: return "";
        }
    }

    std::string TraversalEnum(int64_t i, const std::string &strip) {
        std::string s = TraversalEnum(i);
        if (s.empty())
            s = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyTraversalEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TraversalEnum(i);
        if (retval.empty()) {
            retval = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TraversalEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTraversalEnum() {
        return stringify::TraversalEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 130
namespace stringify {
    const char* DeleteEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_DELETE";
            case 1L: return "NO_DELETE";
            default: return "";
        }
    }

    std::string DeleteEnum(int64_t i, const std::string &strip) {
        std::string s = DeleteEnum(i);
        if (s.empty())
            s = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DeleteEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeleteEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DeleteEnum(i);
        if (retval.empty()) {
            retval = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DeleteEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeleteEnum() {
        return stringify::DeleteEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/stringifyEnums.C line 39
namespace stringify {
    const char* Generate(int64_t i) {
        switch (i) {
            case 0L: return "GENERATE_NOTHING";
            case 1L: return "GENERATE_DECLARATIONS";
            case 2L: return "GENERATE_DEFINITIONS";
            default: return "";
        }
    }

    std::string Generate(int64_t i, const std::string &strip) {
        std::string s = Generate(i);
        if (s.empty())
            s = "(Generate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Generate() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyGenerate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Generate(i);
        if (retval.empty()) {
            retval = "(Generate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Generate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenerate() {
        return stringify::Generate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/stringifyEnums.C line 46
namespace stringify {
    const char* Flag(int64_t i) {
        switch (i) {
            case 2L: return "NO_CHECK";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            2L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Flag(i);
        if (retval.empty()) {
            retval = "(Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFlag() {
        return stringify::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Graph.h line 645
namespace stringify { namespace Sawyer { namespace Container { namespace Graph {
    const char* EdgePhase(int64_t i) {
        switch (i) {
            case 0L: return "IN_EDGES";
            case 1L: return "OUT_EDGES";
            case 2L: return "N_PHASES";
            default: return "";
        }
    }

    std::string EdgePhase(int64_t i, const std::string &strip) {
        std::string s = EdgePhase(i);
        if (s.empty())
            s = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgePhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerGraphEdgePhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Graph::EdgePhase(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerGraphEdgePhase() {
        return stringify::Sawyer::Container::Graph::EdgePhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Tree.h line 44
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "ENTER";
            case 1L: return "LEAVE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalEvent() {
        return stringify::Sawyer::Tree::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Tree.h line 252
namespace stringify { namespace Sawyer { namespace Tree { namespace Vertex {
    const char* Link(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Link(int64_t i, const std::string &strip) {
        std::string s = Link(i);
        if (s.empty())
            s = "(Sawyer::Tree::Vertex::Link)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Link() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerTreeVertexLink(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::Vertex::Link(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::Vertex::Link)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::Vertex::Link::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeVertexLink() {
        return stringify::Sawyer::Tree::Vertex::Link();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/GraphAlgorithm.h line 478
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* CsiNextAction(int64_t i) {
        switch (i) {
            case 0L: return "CSI_CONTINUE";
            case 1L: return "CSI_ABORT";
            default: return "";
        }
    }

    std::string CsiNextAction(int64_t i, const std::string &strip) {
        std::string s = CsiNextAction(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CsiNextAction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmCsiNextAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::CsiNextAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::CsiNextAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmCsiNextAction() {
        return stringify::Sawyer::Container::Algorithm::CsiNextAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 313
namespace stringify { namespace Sawyer { namespace Message {
    const char* Importance(int64_t i) {
        switch (i) {
            case 0L: return "DEBUG";
            case 1L: return "TRACE";
            case 2L: return "WHERE";
            case 3L: return "MARCH";
            case 4L: return "INFO";
            case 5L: return "WARN";
            case 6L: return "ERROR";
            case 7L: return "FATAL";
            case 8L: return "N_IMPORTANCE";
            default: return "";
        }
    }

    std::string Importance(int64_t i, const std::string &strip) {
        std::string s = Importance(i);
        if (s.empty())
            s = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Importance() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageImportance(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Importance(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Importance::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageImportance() {
        return stringify::Sawyer::Message::Importance();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 343
namespace stringify { namespace Sawyer { namespace Message {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "COLOR_BLACK";
            case 1L: return "COLOR_RED";
            case 2L: return "COLOR_GREEN";
            case 3L: return "COLOR_YELLOW";
            case 4L: return "COLOR_BLUE";
            case 5L: return "COLOR_MAGENTA";
            case 6L: return "COLOR_CYAN";
            case 7L: return "COLOR_WHITE";
            case 8L: return "COLOR_DEFAULT";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageAnsiColor() {
        return stringify::Sawyer::Message::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 990
namespace stringify { namespace Sawyer { namespace Message { namespace Prefix {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "SOMETIMES";
            case 2L: return "ALWAYS";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerMessagePrefixWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Prefix::When(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Prefix::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessagePrefixWhen() {
        return stringify::Sawyer::Message::Prefix::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Clexer.h line 26
namespace stringify { namespace Sawyer { namespace Language { namespace Clexer {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_CHAR";
            case 4L: return "TOK_STRING";
            case 5L: return "TOK_NUMBER";
            case 6L: return "TOK_WORD";
            case 7L: return "TOK_CPP";
            case 8L: return "TOK_COMMENT";
            case 9L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerLanguageClexerTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Language::Clexer::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Language::Clexer::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerLanguageClexerTokenType() {
        return stringify::Sawyer::Language::Clexer::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 151
namespace stringify { namespace Sawyer { namespace Yaml { namespace Exception {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "InternalError";
            case 1L: return "ParsingError";
            case 2L: return "OperationError";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Exception::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlException_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Exception::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Exception::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Exception::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlException_eType() {
        return stringify::Sawyer::Yaml::Exception::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 256
namespace stringify { namespace Sawyer { namespace Yaml { namespace Iterator {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Iterator::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlIterator_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Iterator::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Iterator::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Iterator::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlIterator_eType() {
        return stringify::Sawyer::Yaml::Iterator::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 313
namespace stringify { namespace Sawyer { namespace Yaml { namespace ConstIterator {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::ConstIterator::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlConstIterator_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::ConstIterator::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::ConstIterator::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::ConstIterator::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlConstIterator_eType() {
        return stringify::Sawyer::Yaml::ConstIterator::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 330
namespace stringify { namespace Sawyer { namespace Yaml { namespace Node {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            case 3L: return "ScalarType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Node::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlNode_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Node::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Node::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Node::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlNode_eType() {
        return stringify::Sawyer::Yaml::Node::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Database.h line 293
namespace stringify { namespace Sawyer { namespace Database { namespace Statement {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "UNBOUND";
            case 1L: return "READY";
            case 2L: return "EXECUTING";
            case 3L: return "FINISHED";
            case 4L: return "DEAD";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDatabaseStatementState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Database::Statement::State(i);
        if (retval.empty()) {
            retval = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Database::Statement::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDatabaseStatementState() {
        return stringify::Sawyer::Database::Statement::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 173
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SortOrder(int64_t i) {
        switch (i) {
            case 0L: return "INSERTION_ORDER";
            case 1L: return "DOCKEY_ORDER";
            default: return "";
        }
    }

    std::string SortOrder(int64_t i, const std::string &strip) {
        std::string s = SortOrder(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SortOrder() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSortOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SortOrder(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SortOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSortOrder() {
        return stringify::Sawyer::CommandLine::SortOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 186
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* Canonical(int64_t i) {
        switch (i) {
            case 0L: return "CANONICAL";
            case 1L: return "NONCANONICAL";
            case 2L: return "ALL_STRINGS";
            default: return "";
        }
    }

    std::string Canonical(int64_t i, const std::string &strip) {
        std::string s = Canonical(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Canonical() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineCanonical(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Canonical(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Canonical::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineCanonical() {
        return stringify::Sawyer::CommandLine::Canonical();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 194
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* ShowGroupName(int64_t i) {
        switch (i) {
            case 0L: return "SHOW_GROUP_OPTIONAL";
            case 1L: return "SHOW_GROUP_REQUIRED";
            case 2L: return "SHOW_GROUP_NONE";
            case 3L: return "SHOW_GROUP_INHERIT";
            default: return "";
        }
    }

    std::string ShowGroupName(int64_t i, const std::string &strip) {
        std::string s = ShowGroupName(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowGroupName() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineShowGroupName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::ShowGroupName(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::ShowGroupName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineShowGroupName() {
        return stringify::Sawyer::CommandLine::ShowGroupName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 202
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SwitchSkipping(int64_t i) {
        switch (i) {
            case 0L: return "SKIP_NEVER";
            case 1L: return "SKIP_WEAK";
            case 2L: return "SKIP_STRONG";
            default: return "";
        }
    }

    std::string SwitchSkipping(int64_t i, const std::string &strip) {
        std::string s = SwitchSkipping(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SwitchSkipping() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSwitchSkipping(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SwitchSkipping(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SwitchSkipping::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSwitchSkipping() {
        return stringify::Sawyer::CommandLine::SwitchSkipping();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 2010
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* WhichValue(int64_t i) {
        switch (i) {
            case 0L: return "SAVE_NONE";
            case 1L: return "SAVE_ONE";
            case 2L: return "SAVE_LAST";
            case 3L: return "SAVE_FIRST";
            case 4L: return "SAVE_ALL";
            case 5L: return "SAVE_AUGMENTED";
            default: return "";
        }
    }

    std::string WhichValue(int64_t i, const std::string &strip) {
        std::string s = WhichValue(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhichValue() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineWhichValue(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::WhichValue(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::WhichValue::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineWhichValue() {
        return stringify::Sawyer::CommandLine::WhichValue();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 3065
namespace stringify { namespace Sawyer { namespace CommandLine { namespace Parser {
    const char* GroupingFlags(int64_t i) {
        switch (i) {
            case 0L: return "DEFAULT_GROUPING";
            case 1L: return "PROHIBIT_EMPTY_GROUPS";
            case 2L: return "SPLIT_SINGLE_GROUP";
            default: return "";
        }
    }

    std::string GroupingFlags(int64_t i, const std::string &strip) {
        std::string s = GroupingFlags(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GroupingFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerCommandLineParserGroupingFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Parser::GroupingFlags(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Parser::GroupingFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineParserGroupingFlags() {
        return stringify::Sawyer::CommandLine::Parser::GroupingFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/DocumentMarkup.h line 42
namespace stringify { namespace Sawyer { namespace Document { namespace Markup {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_DATA";
            case 1L: return "TOK_FUNCTION";
            case 2L: return "TOK_LEFT";
            case 3L: return "TOK_RIGHT";
            case 4L: return "TOK_BLANK_LINE";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDocumentMarkupTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Document::Markup::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Document::Markup::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDocumentMarkupTokenType() {
        return stringify::Sawyer::Document::Markup::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/GraphTraversal.h line 39
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "NO_EVENT";
            case 1L: return "ENTER_VERTEX";
            case 2L: return "ENTER_EDGE";
            case 4L: return "DISCOVER_VERTEX";
            case 8L: return "LEAVE_EDGE";
            case 16L: return "LEAVE_VERTEX";
            case 32L: return "FOLLOW_EDGE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmTraversalEvent() {
        return stringify::Sawyer::Container::Algorithm::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Access.h line 19
namespace stringify { namespace Sawyer { namespace Access {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "EXECUTABLE";
            case 2L: return "WRITABLE";
            case 4L: return "READABLE";
            case 8L: return "IMMUTABLE";
            case 16L: return "PRIVATE";
            case 255L: return "RESERVED_MASK";
            case 4294967040L: return "USERDEF_MASK";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            255L,
            4294967040L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerAccessAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Access::Access(i);
        if (retval.empty()) {
            retval = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Access::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerAccessAccess() {
        return stringify::Sawyer::Access::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 25
namespace stringify { namespace Rose { namespace StringUtility {
    const char* OSType(int64_t i) {
        switch (i) {
            case 0L: return "OS_TYPE_UNKNOWN";
            case 1L: return "OS_TYPE_LINUX";
            case 2L: return "OS_TYPE_OSX";
            case 3L: return "OS_TYPE_WINDOWS";
            case 4L: return "OS_TPYE_WINDOWSXP";
            default: return "";
        }
    }

    std::string OSType(int64_t i, const std::string &strip) {
        std::string s = OSType(i);
        if (s.empty())
            s = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OSType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityOSType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::OSType(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::OSType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityOSType() {
        return stringify::Rose::StringUtility::OSType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 150
namespace stringify { namespace Rose { namespace StringUtility {
    const char* FileNameLocation(int64_t i) {
        switch (i) {
            case 0L: return "FILENAME_LOCATION_UNKNOWN";
            case 1L: return "FILENAME_LOCATION_USER";
            case 2L: return "FILENAME_LOCATION_LIBRARY";
            case 3L: return "FILENAME_LOCATION_NOT_EXIST";
            default: return "";
        }
    }

    std::string FileNameLocation(int64_t i, const std::string &strip) {
        std::string s = FileNameLocation(i);
        if (s.empty())
            s = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FileNameLocation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityFileNameLocation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::FileNameLocation(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::FileNameLocation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityFileNameLocation() {
        return stringify::Rose::StringUtility::FileNameLocation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/MSTL/DOTGeneration.h line 48
namespace stringify { namespace DOTGeneration {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "PREORDER";
            case 1L: return "POSTORDER";
            case 2L: return "TOPDOWN";
            case 3L: return "BOTTOMUP";
            case 4L: return "TOPDOWNBOTTOMUP";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGeneration_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGeneration::traversalType(i);
        if (retval.empty()) {
            retval = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGeneration::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGeneration_traversalType() {
        return stringify::DOTGeneration::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRSelect.h line 26
namespace stringify { namespace qrs { namespace QRSelect {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Combo";
            case 1L: return "Box";
            case 2L: return "Check";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSelectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSelect::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSelect::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSelectType() {
        return stringify::qrs::QRSelect::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QREdit.h line 28
namespace stringify { namespace qrs { namespace QREdit {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Line";
            case 1L: return "Box";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQREditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QREdit::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QREdit::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQREditType() {
        return stringify::qrs::QREdit::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRButtons.h line 29
namespace stringify { namespace qrs { namespace QRButtons {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "Toggle";
            case 2L: return "Check";
            case 3L: return "Radio";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRButtonsType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRButtons::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRButtons::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRButtonsType() {
        return stringify::qrs::QRButtons::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qeditor.h line 65
namespace stringify { namespace qrs { namespace QEditor {
    const char* TypeSel(int64_t i) {
        switch (i) {
            case 1000L: return "sel0";
            case 2000L: return "sel1";
            default: return "";
        }
    }

    std::string TypeSel(int64_t i, const std::string &strip) {
        std::string s = TypeSel(i);
        if (s.empty())
            s = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeSel() {
        static const int64_t values[] = {
            1000L,
            2000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQEditorTypeSel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QEditor::TypeSel(i);
        if (retval.empty()) {
            retval = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QEditor::TypeSel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQEditorTypeSel() {
        return stringify::qrs::QEditor::TypeSel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/QRSourceBox.h line 39
namespace stringify { namespace qrs { namespace QRSourceBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbGoto";
            case 6L: return "tbLookup";
            case 7L: return "tbZoomIn";
            case 8L: return "tbZoomOut";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSourceBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSourceBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSourceBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSourceBoxToolbarIdx() {
        return stringify::qrs::QRSourceBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qsourcecolorizer.h line 257
namespace stringify { namespace qrs { namespace QSourceColorizer {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "PreProcessor";
            case 2L: return "Keyword";
            case 3L: return "BuiltInClass";
            case 4L: return "Operator";
            case 5L: return "Comment";
            case 6L: return "Constant";
            case 7L: return "String";
            case 1000L: return "Custom";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1000L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQSourceColorizerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QSourceColorizer::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QSourceColorizer::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQSourceColorizerType() {
        return stringify::qrs::QSourceColorizer::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 122
namespace stringify { namespace qrs { namespace Q3TextStringChar {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Regular";
            case 1L: return "Custom";
            case 2L: return "Anchor";
            case 3L: return "CustomAnchor";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextStringCharType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextStringChar::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextStringChar::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextStringCharType() {
        return stringify::qrs::Q3TextStringChar::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 366
namespace stringify { namespace qrs { namespace Q3TextCursor {
    const char* Operation(int64_t i) {
        switch (i) {
            case 0L: return "EnterBegin";
            case 1L: return "EnterEnd";
            case 2L: return "Next";
            case 3L: return "Prev";
            case 4L: return "Up";
            case 5L: return "Down";
            default: return "";
        }
    }

    std::string Operation(int64_t i, const std::string &strip) {
        std::string s = Operation(i);
        if (s.empty())
            s = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCursorOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCursor::Operation(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCursor::Operation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCursorOperation() {
        return stringify::qrs::Q3TextCursor::Operation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 390
namespace stringify { namespace qrs { namespace Q3TextCommand {
    const char* Commands(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Insert";
            case 2L: return "Delete";
            case 3L: return "Format";
            case 4L: return "Style";
            default: return "";
        }
    }

    std::string Commands(int64_t i, const std::string &strip) {
        std::string s = Commands(i);
        if (s.empty())
            s = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Commands() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCommandCommands(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCommand::Commands(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCommand::Commands::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCommandCommands() {
        return stringify::qrs::Q3TextCommand::Commands();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 451
namespace stringify { namespace qrs { namespace Q3TextCustomItem {
    const char* Placement(int64_t i) {
        switch (i) {
            case 0L: return "PlaceInline";
            case 1L: return "PlaceLeft";
            case 2L: return "PlaceRight";
            default: return "";
        }
    }

    std::string Placement(int64_t i, const std::string &strip) {
        std::string s = Placement(i);
        if (s.empty())
            s = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Placement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCustomItemPlacement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCustomItem::Placement(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCustomItem::Placement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCustomItemPlacement() {
        return stringify::qrs::Q3TextCustomItem::Placement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 724
namespace stringify { namespace qrs { namespace Q3TextDocument {
    const char* SelectionIds(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            case 32000L: return "Temp";
            default: return "";
        }
    }

    std::string SelectionIds(int64_t i, const std::string &strip) {
        std::string s = SelectionIds(i);
        if (s.empty())
            s = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionIds() {
        static const int64_t values[] = {
            0L,
            32000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextDocumentSelectionIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextDocument::SelectionIds(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextDocument::SelectionIds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextDocumentSelectionIds() {
        return stringify::qrs::Q3TextDocument::SelectionIds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1380
namespace stringify { namespace qrs { namespace Q3TextPreProcessor {
    const char* Ids(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            default: return "";
        }
    }

    std::string Ids(int64_t i, const std::string &strip) {
        std::string s = Ids(i);
        if (s.empty())
            s = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ids() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextPreProcessorIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextPreProcessor::Ids(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextPreProcessor::Ids::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextPreProcessorIds() {
        return stringify::qrs::Q3TextPreProcessor::Ids();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1400
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* Flags(int64_t i) {
        switch (i) {
            case 0L: return "NoFlags";
            case 1L: return "Bold";
            case 2L: return "Italic";
            case 4L: return "Underline";
            case 8L: return "Family";
            case 16L: return "Size";
            case 32L: return "Color";
            case 64L: return "Misspelled";
            case 128L: return "VAlign";
            case 256L: return "StrikeOut";
            case 287L: return "Font";
            case 511L: return "Format";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            287L,
            511L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::Flags(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatFlags() {
        return stringify::qrs::Q3TextFormat::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1415
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* VerticalAlignment(int64_t i) {
        switch (i) {
            case 0L: return "AlignNormal";
            case 1L: return "AlignSuperScript";
            case 2L: return "AlignSubScript";
            default: return "";
        }
    }

    std::string VerticalAlignment(int64_t i, const std::string &strip) {
        std::string s = VerticalAlignment(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VerticalAlignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatVerticalAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::VerticalAlignment(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::VerticalAlignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatVerticalAlignment() {
        return stringify::qrs::Q3TextFormat::VerticalAlignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/paragdata.h line 36
namespace stringify { namespace qrs { namespace Symbol {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Left";
            case 1L: return "Right";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Symbol::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Symbol::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsSymbolType() {
        return stringify::qrs::Symbol::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 37
namespace stringify { namespace qrs { namespace Paren {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Open";
            case 1L: return "Closed";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Paren::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Paren::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenType() {
        return stringify::qrs::Paren::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 48
namespace stringify { namespace qrs { namespace ParenMatcher {
    const char* Selection(int64_t i) {
        switch (i) {
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Selection(int64_t i, const std::string &strip) {
        std::string s = Selection(i);
        if (s.empty())
            s = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Selection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenMatcherSelection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::ParenMatcher::Selection(i);
        if (retval.empty()) {
            retval = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::ParenMatcher::Selection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenMatcherSelection() {
        return stringify::qrs::ParenMatcher::Selection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 40
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbHighlight";
            case 6L: return "tbLookup";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBoxToolbarIdx() {
        return stringify::qrs::QRTreeBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 107
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* popmenu_nodes_id(int64_t i) {
        switch (i) {
            case 0L: return "pm_set_root";
            case 1L: return "pm_set_default_root";
            case 2L: return "pm_remove";
            case 3L: return "pm_expand";
            case 4L: return "pm_collapse";
            case 5L: return "pm_expand_code";
            default: return "";
        }
    }

    std::string popmenu_nodes_id(int64_t i, const std::string &strip) {
        std::string s = popmenu_nodes_id(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& popmenu_nodes_id() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBox_popmenu_nodes_id(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::popmenu_nodes_id(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::popmenu_nodes_id::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBox_popmenu_nodes_id() {
        return stringify::qrs::QRTreeBox::popmenu_nodes_id();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 4744
namespace stringify { namespace nlohmann { namespace detail {
    const char* input_format_t(int64_t i) {
        switch (i) {
            case 0L: return "json";
            case 1L: return "cbor";
            case 2L: return "msgpack";
            case 3L: return "ubjson";
            case 4L: return "bson";
            default: return "";
        }
    }

    std::string input_format_t(int64_t i, const std::string &strip) {
        std::string s = input_format_t(i);
        if (s.empty())
            s = "(nlohmann::detail::input_format_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& input_format_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_input_format_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::input_format_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::input_format_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::input_format_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_input_format_t() {
        return stringify::nlohmann::detail::input_format_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 5909
namespace stringify { namespace nlohmann { namespace detail { namespace lexer_base {
    const char* token_type(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "literal_true";
            case 2L: return "literal_false";
            case 3L: return "literal_null";
            case 4L: return "value_string";
            case 5L: return "value_unsigned";
            case 6L: return "value_integer";
            case 7L: return "value_float";
            case 8L: return "begin_array";
            case 9L: return "begin_object";
            case 10L: return "end_array";
            case 11L: return "end_object";
            case 12L: return "name_separator";
            case 13L: return "value_separator";
            case 14L: return "parse_error";
            case 15L: return "end_of_input";
            case 16L: return "literal_or_value";
            default: return "";
        }
    }

    std::string token_type(int64_t i, const std::string &strip) {
        std::string s = token_type(i);
        if (s.empty())
            s = "(nlohmann::detail::lexer_base::token_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringify_nlohmann_detail_lexer_base_token_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::lexer_base::token_type(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::lexer_base::token_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::lexer_base::token_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_lexer_base_token_type() {
        return stringify::nlohmann::detail::lexer_base::token_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 7668
namespace stringify { namespace nlohmann { namespace detail {
    const char* cbor_tag_handler_t(int64_t i) {
        switch (i) {
            case 0L: return "error";
            case 1L: return "ignore";
            default: return "";
        }
    }

    std::string cbor_tag_handler_t(int64_t i, const std::string &strip) {
        std::string s = cbor_tag_handler_t(i);
        if (s.empty())
            s = "(nlohmann::detail::cbor_tag_handler_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cbor_tag_handler_t() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_cbor_tag_handler_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::cbor_tag_handler_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::cbor_tag_handler_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::cbor_tag_handler_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_cbor_tag_handler_t() {
        return stringify::nlohmann::detail::cbor_tag_handler_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 15469
namespace stringify { namespace nlohmann { namespace detail {
    const char* error_handler_t(int64_t i) {
        switch (i) {
            case 0L: return "strict";
            case 1L: return "replace";
            case 2L: return "ignore";
            default: return "";
        }
    }

    std::string error_handler_t(int64_t i, const std::string &strip) {
        std::string s = error_handler_t(i);
        if (s.empty())
            s = "(nlohmann::detail::error_handler_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& error_handler_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_error_handler_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::error_handler_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::error_handler_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::error_handler_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_error_handler_t() {
        return stringify::nlohmann::detail::error_handler_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 24668
namespace stringify { namespace nlohmann { namespace basic_json {
    const char* patch_operations(int64_t i) {
        switch (i) {
            case 0L: return "add";
            case 1L: return "remove";
            case 2L: return "replace";
            case 3L: return "move";
            case 4L: return "copy";
            case 5L: return "test";
            case 6L: return "invalid";
            default: return "";
        }
    }

    std::string patch_operations(int64_t i, const std::string &strip) {
        std::string s = patch_operations(i);
        if (s.empty())
            s = "(nlohmann::basic_json::patch_operations)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& patch_operations() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_basic_json_patch_operations(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::basic_json::patch_operations(i);
        if (retval.empty()) {
            retval = "(nlohmann::basic_json::patch_operations)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::basic_json::patch_operations::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_basic_json_patch_operations() {
        return stringify::nlohmann::basic_json::patch_operations();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/callbacks.h line 15
namespace stringify { namespace Rose { namespace Callbacks {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCallbacksDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Callbacks::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Callbacks::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallbacksDirection() {
        return stringify::Rose::Callbacks::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/transformationSupport.h line 37
namespace stringify { namespace TransformationSupport {
    const char* operatorCodeType(int64_t i) {
        switch (i) {
            case 0L: return "FUNCTION_CALL_OPERATOR_CODE";
            case 1L: return "ADD_OPERATOR_CODE";
            case 2L: return "SUBT_OPERATOR_CODE";
            case 3L: return "MULT_OPERATOR_CODE";
            case 4L: return "DIV_OPERATOR_CODE";
            case 5L: return "INTEGER_DIV_OPERATOR_CODE";
            case 6L: return "MOD_OPERATOR_CODE";
            case 7L: return "AND_OPERATOR_CODE";
            case 8L: return "OR_OPERATOR_CODE";
            case 9L: return "BITXOR_OPERATOR_CODE";
            case 10L: return "BITAND_OPERATOR_CODE";
            case 11L: return "BITOR_OPERATOR_CODE";
            case 12L: return "EQ_OPERATOR_CODE";
            case 13L: return "LT_OPERATOR_CODE";
            case 14L: return "GT_OPERATOR_CODE";
            case 15L: return "NE_OPERATOR_CODE";
            case 16L: return "LE_OPERATOR_CODE";
            case 17L: return "GE_OPERATOR_CODE";
            case 18L: return "ASSIGN_OPERATOR_CODE";
            case 19L: return "PLUS_ASSIGN_OPERATOR_CODE";
            case 20L: return "MINUS_ASSIGN_OPERATOR_CODE";
            case 21L: return "AND_ASSIGN_OPERATOR_CODE";
            case 22L: return "IOR_ASSIGN_OPERATOR_CODE";
            case 23L: return "MULT_ASSIGN_OPERATOR_CODE";
            case 24L: return "DIV_ASSIGN_OPERATOR_CODE";
            case 25L: return "MOD_ASSIGN_OPERATOR_CODE";
            case 26L: return "XOR_ASSIGN_OPERATOR_CODE";
            case 27L: return "PARENTHESIS_OPERATOR_CODE";
            case 28L: return "BRACKET_OPERATOR_CODE";
            case 29L: return "NOT_OPERATOR_CODE";
            case 30L: return "DEREFERENCE_OPERATOR_CODE";
            case 31L: return "ADDRESS_OPERATOR_CODE";
            case 32L: return "LSHIFT_OPERATOR_CODE";
            case 33L: return "RSHIFT_OPERATOR_CODE";
            case 34L: return "LSHIFT_ASSIGN_OPERATOR_CODE";
            case 35L: return "RSHIFT_ASSIGN_OPERATOR_CODE";
            case 36L: return "PREFIX_PLUSPLUS_OPERATOR_CODE";
            case 37L: return "POSTFIX_PLUSPLUS_OPERATOR_CODE";
            case 38L: return "PREFIX_MINUSMINUS_OPERATOR_CODE";
            case 39L: return "POSTFIX_MINUSMINUS_OPERATOR_CODE";
            case 99L: return "OPERATOR_CODE_LAST_TAG";
            default: return "";
        }
    }

    std::string operatorCodeType(int64_t i, const std::string &strip) {
        std::string s = operatorCodeType(i);
        if (s.empty())
            s = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& operatorCodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTransformationSupport_operatorCodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TransformationSupport::operatorCodeType(i);
        if (retval.empty()) {
            retval = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TransformationSupport::operatorCodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTransformationSupport_operatorCodeType() {
        return stringify::TransformationSupport::operatorCodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/utility_functions.C line 963
namespace stringify {
    const char* language_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_c";
            case 2L: return "e_cxx";
            case 3L: return "e_fortran";
            case 4L: return "e_last_language";
            default: return "";
        }
    }

    std::string language_enum(int64_t i, const std::string &strip) {
        std::string s = language_enum(i);
        if (s.empty())
            s = "(language_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& language_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_language_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::language_enum(i);
        if (retval.empty()) {
            retval = "(language_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "language_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_language_enum() {
        return stringify::language_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Ast.h line 138
namespace stringify { namespace Rosebud { namespace Ast { namespace CppStack {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "IF";
            case 1L: return "ELSE";
            case 2L: return "END";
            case 3L: return "OTHER";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rosebud::Ast::CppStack::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyRosebudAstCppStackType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Ast::CppStack::Type(i);
        if (retval.empty()) {
            retval = "(Rosebud::Ast::CppStack::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Ast::CppStack::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudAstCppStackType() {
        return stringify::Rosebud::Ast::CppStack::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Utility.h line 20
namespace stringify { namespace Rosebud {
    const char* Access(int64_t i) {
        switch (i) {
            case 0L: return "PRIVATE";
            case 1L: return "PROTECTED";
            case 2L: return "PUBLIC";
            case 3L: return "DEFAULT";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Rosebud::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Access(i);
        if (retval.empty()) {
            retval = "(Rosebud::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudAccess() {
        return stringify::Rosebud::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Utility.h line 95
namespace stringify { namespace Rosebud {
    const char* CamelCase(int64_t i) {
        switch (i) {
            case 0L: return "LOWER";
            case 1L: return "UPPER";
            case 2L: return "UNCHANGED";
            default: return "";
        }
    }

    std::string CamelCase(int64_t i, const std::string &strip) {
        std::string s = CamelCase(i);
        if (s.empty())
            s = "(Rosebud::CamelCase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CamelCase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudCamelCase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::CamelCase(i);
        if (retval.empty()) {
            retval = "(Rosebud::CamelCase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::CamelCase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudCamelCase() {
        return stringify::Rosebud::CamelCase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/BasicTypes.h line 472
namespace stringify { namespace Rosebud {
    const char* Expand(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "INTER";
            case 2L: return "PRIOR";
            default: return "";
        }
    }

    std::string Expand(int64_t i, const std::string &strip) {
        std::string s = Expand(i);
        if (s.empty())
            s = "(Rosebud::Expand)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Expand() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudExpand(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Expand(i);
        if (retval.empty()) {
            retval = "(Rosebud::Expand)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Expand::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudExpand() {
        return stringify::Rosebud::Expand();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/BasicTypes.h line 479
namespace stringify { namespace Rosebud {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "ALWAYS";
            case 2L: return "AUTO";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Rosebud::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::When(i);
        if (retval.empty()) {
            retval = "(Rosebud::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudWhen() {
        return stringify::Rosebud::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Defect.h line 27
namespace stringify { namespace Rose { namespace AST { namespace Defects {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "any";
            case 1L: return "integrity_edges";
            case 2L: return "integrity_declarations";
            case 3L: return "integrity_symbols";
            case 4L: return "integrity_types";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(Rose::AST::Defects::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_DefectsKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Defects::Kind(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Defects::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Defects::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_DefectsKind() {
        return stringify::Rose::AST::Defects::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Defect.h line 117
namespace stringify { namespace Rose { namespace AST { namespace Defects {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "invalid";
            case 1L: return "incompatible";
            case 2L: return "unallocated";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(Rose::AST::Defects::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_DefectsReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Defects::Reason(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Defects::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Defects::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_DefectsReason() {
        return stringify::Rose::AST::Defects::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 25
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace graphviz_t {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "tree";
            case 1L: return "graph";
            case 2L: return "unknown";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::graphviz_t::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_graphviz_tMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::graphviz_t::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::graphviz_t::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::graphviz_t::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_graphviz_tMode() {
        return stringify::Rose::AST::cmdline::graphviz_t::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 43
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace checker_t {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "all";
            case 1L: return "integrity";
            case 2L: return "integrity_edges";
            case 3L: return "integrity_declarations";
            case 4L: return "integrity_symbols";
            case 5L: return "integrity_types";
            case 6L: return "consistency";
            case 7L: return "unknown";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::checker_t::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_checker_tMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::checker_t::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::checker_t::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::checker_t::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_checker_tMode() {
        return stringify::Rose::AST::cmdline::checker_t::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 54
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace checker_t {
    const char* Effect(int64_t i) {
        switch (i) {
            case 0L: return "none";
            case 1L: return "summary";
            case 2L: return "report";
            case 3L: return "fail";
            case 4L: return "unknown";
            default: return "";
        }
    }

    std::string Effect(int64_t i, const std::string &strip) {
        std::string s = Effect(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::checker_t::Effect)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Effect() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_checker_tEffect(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::checker_t::Effect(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::checker_t::Effect)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::checker_t::Effect::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_checker_tEffect() {
        return stringify::Rose::AST::cmdline::checker_t::Effect();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Traversal.h line 19
namespace stringify { namespace Rose { namespace AST { namespace Traversal {
    const char* Order(int64_t i) {
        switch (i) {
            case 1L: return "PRE";
            case 2L: return "POST";
            default: return "";
        }
    }

    std::string Order(int64_t i, const std::string &strip) {
        std::string s = Order(i);
        if (s.empty())
            s = "(Rose::AST::Traversal::Order)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Order() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_TraversalOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Traversal::Order(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Traversal::Order)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Traversal::Order::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_TraversalOrder() {
        return stringify::Rose::AST::Traversal::Order();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/FormattedTable.h line 22
namespace stringify { namespace Rose { namespace FormattedTable {
    const char* Format(int64_t i) {
        switch (i) {
            case 0L: return "PLAIN";
            case 1L: return "HTML";
            case 2L: return "CSV";
            case 3L: return "SHELL";
            default: return "";
        }
    }

    std::string Format(int64_t i, const std::string &strip) {
        std::string s = Format(i);
        if (s.empty())
            s = "(Rose::FormattedTable::Format)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFormattedTableFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::FormattedTable::Format(i);
        if (retval.empty()) {
            retval = "(Rose::FormattedTable::Format)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::FormattedTable::Format::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormattedTableFormat() {
        return stringify::Rose::FormattedTable::Format();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/FormattedTable.h line 34
namespace stringify { namespace Rose { namespace FormattedTable {
    const char* Alignment(int64_t i) {
        switch (i) {
            case 0L: return "LEFT";
            case 1L: return "RIGHT";
            case 2L: return "CENTER";
            default: return "";
        }
    }

    std::string Alignment(int64_t i, const std::string &strip) {
        std::string s = Alignment(i);
        if (s.empty())
            s = "(Rose::FormattedTable::Alignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Alignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFormattedTableAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::FormattedTable::Alignment(i);
        if (retval.empty()) {
            retval = "(Rose::FormattedTable::Alignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::FormattedTable::Alignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormattedTableAlignment() {
        return stringify::Rose::FormattedTable::Alignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 11
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "mips_regclass_gpr";
            case 1L: return "mips_regclass_spr";
            case 2L: return "mips_regclass_fpr";
            case 3L: return "mips_regclass_fcsr";
            case 4L: return "mips_regclass_cp0gpr";
            case 5L: return "mips_regclass_cp2gpr";
            case 6L: return "mips_regclass_cp2spr";
            case 7L: return "mips_regclass_sgpr";
            case 8L: return "mips_regclass_hw";
            default: return "";
        }
    }

    std::string MipsRegisterClass(int64_t i, const std::string &strip) {
        std::string s = MipsRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsRegisterClass() {
        return stringify::Rose::BinaryAnalysis::MipsRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 24
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsFcsrMinors(int64_t i) {
        switch (i) {
            case 0L: return "mips_fcsr_all";
            case 1L: return "mips_fcsr_fccr";
            case 2L: return "mips_fcsr_fexr";
            case 3L: return "mips_fcsr_fenr";
            default: return "";
        }
    }

    std::string MipsFcsrMinors(int64_t i, const std::string &strip) {
        std::string s = MipsFcsrMinors(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsFcsrMinors() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsFcsrMinors(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsFcsrMinors(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsFcsrMinors::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsFcsrMinors() {
        return stringify::Rose::BinaryAnalysis::MipsFcsrMinors();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "mips_spr_hi";
            case 1L: return "mips_spr_lo";
            case 2L: return "mips_spr_pc";
            case 3L: return "mips_spr_fir";
            case 4L: return "mips_spr_fcsr";
            default: return "";
        }
    }

    std::string MipsSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = MipsSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 41
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInterruptMajor(int64_t i) {
        switch (i) {
            case 0L: return "mips_signal_exception";
            default: return "";
        }
    }

    std::string MipsInterruptMajor(int64_t i, const std::string &strip) {
        std::string s = MipsInterruptMajor(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInterruptMajor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInterruptMajor() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInterruptMajor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInterruptMajor(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInterruptMajor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInterruptMajor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInterruptMajor() {
        return stringify::Rose::BinaryAnalysis::MipsInterruptMajor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 46
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInterruptMinor(int64_t i) {
        switch (i) {
            case 0L: return "mips_breakpoint";
            case 1L: return "mips_integer_overflow";
            case 2L: return "mips_reserved_instruction";
            default: return "";
        }
    }

    std::string MipsInterruptMinor(int64_t i, const std::string &strip) {
        std::string s = MipsInterruptMinor(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInterruptMinor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInterruptMinor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInterruptMinor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInterruptMinor(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInterruptMinor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInterruptMinor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInterruptMinor() {
        return stringify::Rose::BinaryAnalysis::MipsInterruptMinor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 53
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsDataFormat(int64_t i) {
        switch (i) {
            case 0L: return "mips_fmt_w";
            case 1L: return "mips_fmt_l";
            case 2L: return "mips_fmt_s";
            case 3L: return "mips_fmt_d";
            case 4L: return "mips_fmt_ps";
            default: return "";
        }
    }

    std::string MipsDataFormat(int64_t i, const std::string &strip) {
        std::string s = MipsDataFormat(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsDataFormat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsDataFormat() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsDataFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsDataFormat(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsDataFormat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsDataFormat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsDataFormat() {
        return stringify::Rose::BinaryAnalysis::MipsDataFormat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 62
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "mips_unknown_instruction";
            case 1L: return "mips_abs_s";
            case 2L: return "mips_abs_d";
            case 3L: return "mips_abs_ps";
            case 4L: return "mips_add";
            case 5L: return "mips_add_s";
            case 6L: return "mips_add_d";
            case 7L: return "mips_add_ps";
            case 8L: return "mips_addi";
            case 9L: return "mips_addiu";
            case 10L: return "mips_addu";
            case 11L: return "mips_alnv_ps";
            case 12L: return "mips_and";
            case 13L: return "mips_andi";
            case 14L: return "mips_b";
            case 15L: return "mips_bal";
            case 16L: return "mips_bc1f";
            case 17L: return "mips_bc1fl";
            case 18L: return "mips_bc1t";
            case 19L: return "mips_bc1tl";
            case 20L: return "mips_bc2f";
            case 21L: return "mips_bc2fl";
            case 22L: return "mips_bc2t";
            case 23L: return "mips_bc2tl";
            case 24L: return "mips_beq";
            case 25L: return "mips_beql";
            case 26L: return "mips_bgez";
            case 27L: return "mips_bgezal";
            case 28L: return "mips_bgezall";
            case 29L: return "mips_bgezl";
            case 30L: return "mips_bgtz";
            case 31L: return "mips_bgtzl";
            case 32L: return "mips_blez";
            case 33L: return "mips_blezl";
            case 34L: return "mips_bltz";
            case 35L: return "mips_bltzal";
            case 36L: return "mips_bltzall";
            case 37L: return "mips_bltzl";
            case 38L: return "mips_bne";
            case 39L: return "mips_bnel";
            case 40L: return "mips_break";
            case 41L: return "mips_c_f_s";
            case 42L: return "mips_c_un_s";
            case 43L: return "mips_c_eq_s";
            case 44L: return "mips_c_ueq_s";
            case 45L: return "mips_c_olt_s";
            case 46L: return "mips_c_ult_s";
            case 47L: return "mips_c_ole_s";
            case 48L: return "mips_c_ule_s";
            case 49L: return "mips_c_sf_s";
            case 50L: return "mips_c_ngle_s";
            case 51L: return "mips_c_seq_s";
            case 52L: return "mips_c_ngl_s";
            case 53L: return "mips_c_lt_s";
            case 54L: return "mips_c_nge_s";
            case 55L: return "mips_c_le_s";
            case 56L: return "mips_c_ngt_s";
            case 57L: return "mips_c_f_d";
            case 58L: return "mips_c_un_d";
            case 59L: return "mips_c_eq_d";
            case 60L: return "mips_c_ueq_d";
            case 61L: return "mips_c_olt_d";
            case 62L: return "mips_c_ult_d";
            case 63L: return "mips_c_ole_d";
            case 64L: return "mips_c_ule_d";
            case 65L: return "mips_c_sf_d";
            case 66L: return "mips_c_ngle_d";
            case 67L: return "mips_c_seq_d";
            case 68L: return "mips_c_ngl_d";
            case 69L: return "mips_c_lt_d";
            case 70L: return "mips_c_nge_d";
            case 71L: return "mips_c_le_d";
            case 72L: return "mips_c_ngt_d";
            case 73L: return "mips_c_f_ps";
            case 74L: return "mips_c_un_ps";
            case 75L: return "mips_c_eq_ps";
            case 76L: return "mips_c_ueq_ps";
            case 77L: return "mips_c_olt_ps";
            case 78L: return "mips_c_ult_ps";
            case 79L: return "mips_c_ole_ps";
            case 80L: return "mips_c_ule_ps";
            case 81L: return "mips_c_sf_ps";
            case 82L: return "mips_c_ngle_ps";
            case 83L: return "mips_c_seq_ps";
            case 84L: return "mips_c_ngl_ps";
            case 85L: return "mips_c_lt_ps";
            case 86L: return "mips_c_nge_ps";
            case 87L: return "mips_c_le_ps";
            case 88L: return "mips_c_ngt_ps";
            case 89L: return "mips_cache";
            case 90L: return "mips_cachee";
            case 91L: return "mips_ceil_l_s";
            case 92L: return "mips_ceil_l_d";
            case 93L: return "mips_ceil_w_s";
            case 94L: return "mips_ceil_w_d";
            case 95L: return "mips_cfc1";
            case 96L: return "mips_cfc2";
            case 97L: return "mips_clo";
            case 98L: return "mips_clz";
            case 99L: return "mips_cop2";
            case 100L: return "mips_ctc1";
            case 101L: return "mips_ctc2";
            case 102L: return "mips_cvt_d_s";
            case 103L: return "mips_cvt_d_w";
            case 104L: return "mips_cvt_d_l";
            case 105L: return "mips_cvt_l_s";
            case 106L: return "mips_cvt_l_d";
            case 107L: return "mips_cvt_ps_s";
            case 108L: return "mips_cvt_s_d";
            case 109L: return "mips_cvt_s_w";
            case 110L: return "mips_cvt_s_l";
            case 111L: return "mips_cvt_s_pl";
            case 112L: return "mips_cvt_s_pu";
            case 113L: return "mips_cvt_w_s";
            case 114L: return "mips_cvt_w_d";
            case 115L: return "mips_di";
            case 116L: return "mips_div";
            case 117L: return "mips_div_s";
            case 118L: return "mips_div_d";
            case 119L: return "mips_divu";
            case 120L: return "mips_ehb";
            case 121L: return "mips_ei";
            case 122L: return "mips_eret";
            case 123L: return "mips_ext";
            case 124L: return "mips_floor_l_s";
            case 125L: return "mips_floor_l_d";
            case 126L: return "mips_floor_w_s";
            case 127L: return "mips_floor_w_d";
            case 128L: return "mips_ins";
            case 129L: return "mips_j";
            case 130L: return "mips_jal";
            case 131L: return "mips_jalr";
            case 132L: return "mips_jalr_hb";
            case 133L: return "mips_jalx";
            case 134L: return "mips_jr";
            case 135L: return "mips_jr_hb";
            case 136L: return "mips_lb";
            case 137L: return "mips_lbe";
            case 138L: return "mips_lbu";
            case 139L: return "mips_lbue";
            case 140L: return "mips_ldc1";
            case 141L: return "mips_ldc2";
            case 142L: return "mips_ldxc1";
            case 143L: return "mips_lh";
            case 144L: return "mips_lhe";
            case 145L: return "mips_lhu";
            case 146L: return "mips_lhue";
            case 147L: return "mips_ll";
            case 148L: return "mips_lle";
            case 149L: return "mips_lui";
            case 150L: return "mips_luxc1";
            case 151L: return "mips_lw";
            case 152L: return "mips_lwc1";
            case 153L: return "mips_lwc2";
            case 154L: return "mips_lwe";
            case 155L: return "mips_lwl";
            case 156L: return "mips_lwle";
            case 157L: return "mips_lwr";
            case 158L: return "mips_lwre";
            case 159L: return "mips_lwu";
            case 160L: return "mips_lwxc1";
            case 161L: return "mips_madd";
            case 162L: return "mips_madd_s";
            case 163L: return "mips_madd_d";
            case 164L: return "mips_madd_ps";
            case 165L: return "mips_maddu";
            case 166L: return "mips_mfc0";
            case 167L: return "mips_mfc1";
            case 168L: return "mips_mfc2";
            case 169L: return "mips_mfhc1";
            case 170L: return "mips_mfhc2";
            case 171L: return "mips_mfhi";
            case 172L: return "mips_mflo";
            case 173L: return "mips_mov_s";
            case 174L: return "mips_mov_d";
            case 175L: return "mips_mov_ps";
            case 176L: return "mips_movf";
            case 177L: return "mips_movf_s";
            case 178L: return "mips_movf_d";
            case 179L: return "mips_movf_ps";
            case 180L: return "mips_movn";
            case 181L: return "mips_movn_s";
            case 182L: return "mips_movn_d";
            case 183L: return "mips_movn_ps";
            case 184L: return "mips_movt";
            case 185L: return "mips_movt_s";
            case 186L: return "mips_movt_d";
            case 187L: return "mips_movt_ps";
            case 188L: return "mips_movz";
            case 189L: return "mips_movz_s";
            case 190L: return "mips_movz_d";
            case 191L: return "mips_movz_ps";
            case 192L: return "mips_msub";
            case 193L: return "mips_msub_s";
            case 194L: return "mips_msub_d";
            case 195L: return "mips_msub_ps";
            case 196L: return "mips_msubu";
            case 197L: return "mips_mtc0";
            case 198L: return "mips_mtc1";
            case 199L: return "mips_mtc2";
            case 200L: return "mips_mthc1";
            case 201L: return "mips_mthc2";
            case 202L: return "mips_mthi";
            case 203L: return "mips_mtlo";
            case 204L: return "mips_mul";
            case 205L: return "mips_mul_s";
            case 206L: return "mips_mul_d";
            case 207L: return "mips_mul_ps";
            case 208L: return "mips_mult";
            case 209L: return "mips_multu";
            case 210L: return "mips_neg_s";
            case 211L: return "mips_neg_d";
            case 212L: return "mips_neg_ps";
            case 213L: return "mips_nmadd_s";
            case 214L: return "mips_nmadd_d";
            case 215L: return "mips_nmadd_ps";
            case 216L: return "mips_nmsub_s";
            case 217L: return "mips_nmsub_d";
            case 218L: return "mips_nmsub_ps";
            case 219L: return "mips_nop";
            case 220L: return "mips_nor";
            case 221L: return "mips_or";
            case 222L: return "mips_ori";
            case 223L: return "mips_pause";
            case 224L: return "mips_pll_ps";
            case 225L: return "mips_plu_ps";
            case 226L: return "mips_pref";
            case 227L: return "mips_prefe";
            case 228L: return "mips_prefx";
            case 229L: return "mips_pul_ps";
            case 230L: return "mips_puu_ps";
            case 231L: return "mips_rdhwr";
            case 232L: return "mips_rdpgpr";
            case 233L: return "mips_recip_s";
            case 234L: return "mips_recip_d";
            case 235L: return "mips_rotr";
            case 236L: return "mips_rotrv";
            case 237L: return "mips_round_l_s";
            case 238L: return "mips_round_l_d";
            case 239L: return "mips_round_w_s";
            case 240L: return "mips_round_w_d";
            case 241L: return "mips_rsqrt_s";
            case 242L: return "mips_rsqrt_d";
            case 243L: return "mips_sb";
            case 244L: return "mips_sbe";
            case 245L: return "mips_sc";
            case 246L: return "mips_sce";
            case 247L: return "mips_sdc1";
            case 248L: return "mips_sdc2";
            case 249L: return "mips_sdxc1";
            case 250L: return "mips_seb";
            case 251L: return "mips_seh";
            case 252L: return "mips_sh";
            case 253L: return "mips_she";
            case 254L: return "mips_sll";
            case 255L: return "mips_sllv";
            case 256L: return "mips_slt";
            case 257L: return "mips_slti";
            case 258L: return "mips_sltiu";
            case 259L: return "mips_sltu";
            case 260L: return "mips_sqrt_s";
            case 261L: return "mips_sqrt_d";
            case 262L: return "mips_sra";
            case 263L: return "mips_srav";
            case 264L: return "mips_srl";
            case 265L: return "mips_srlv";
            case 266L: return "mips_ssnop";
            case 267L: return "mips_sub";
            case 268L: return "mips_sub_s";
            case 269L: return "mips_sub_d";
            case 270L: return "mips_sub_ps";
            case 271L: return "mips_subu";
            case 272L: return "mips_suxc1";
            case 273L: return "mips_sw";
            case 274L: return "mips_swc1";
            case 275L: return "mips_swc2";
            case 276L: return "mips_swe";
            case 277L: return "mips_swl";
            case 278L: return "mips_swle";
            case 279L: return "mips_swr";
            case 280L: return "mips_swre";
            case 281L: return "mips_swxc1";
            case 282L: return "mips_sync";
            case 283L: return "mips_synci";
            case 284L: return "mips_syscall";
            case 285L: return "mips_teq";
            case 286L: return "mips_teqi";
            case 287L: return "mips_tge";
            case 288L: return "mips_tgei";
            case 289L: return "mips_tgeiu";
            case 290L: return "mips_tgeu";
            case 291L: return "mips_tlbinv";
            case 292L: return "mips_tlbinvf";
            case 293L: return "mips_tlbp";
            case 294L: return "mips_tlbr";
            case 295L: return "mips_tlbwi";
            case 296L: return "mips_tlbwr";
            case 297L: return "mips_tlt";
            case 298L: return "mips_tlti";
            case 299L: return "mips_tltiu";
            case 300L: return "mips_tltu";
            case 301L: return "mips_tne";
            case 302L: return "mips_tnei";
            case 303L: return "mips_trunc_l_s";
            case 304L: return "mips_trunc_l_d";
            case 305L: return "mips_trunc_w_s";
            case 306L: return "mips_trunc_w_d";
            case 307L: return "mips_wait";
            case 308L: return "mips_wrpgpr";
            case 309L: return "mips_wsbh";
            case 310L: return "mips_xor";
            case 311L: return "mips_xori";
            case 312L: return "mips_last_instruction";
            default: return "";
        }
    }

    std::string MipsInstructionKind(int64_t i, const std::string &strip) {
        std::string s = MipsInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L
        };
        static const std::vector<int64_t> retval(values, values + 313);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInstructionKind() {
        return stringify::Rose::BinaryAnalysis::MipsInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 63
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace TypeStyle {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "FULL";
            case 1L: return "ABBREVIATED";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionTypeStyleFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionTypeStyleFlag() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 81
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression {
    const char* Operator(int64_t i) {
        switch (i) {
            case 0L: return "OP_ADD";
            case 1L: return "OP_AND";
            case 2L: return "OP_ASR";
            case 3L: return "OP_CONCAT";
            case 4L: return "OP_EQ";
            case 5L: return "OP_EXTRACT";
            case 6L: return "OP_INVERT";
            case 7L: return "OP_ITE";
            case 8L: return "OP_LET";
            case 9L: return "OP_LSSB";
            case 10L: return "OP_MSSB";
            case 11L: return "OP_NE";
            case 12L: return "OP_NEGATE";
            case 13L: return "OP_NOOP";
            case 14L: return "OP_OR";
            case 15L: return "OP_READ";
            case 16L: return "OP_ROL";
            case 17L: return "OP_ROR";
            case 18L: return "OP_SDIV";
            case 19L: return "OP_SET";
            case 20L: return "OP_SEXTEND";
            case 21L: return "OP_SGE";
            case 22L: return "OP_SGT";
            case 23L: return "OP_SHL0";
            case 24L: return "OP_SHL1";
            case 25L: return "OP_SHR0";
            case 26L: return "OP_SHR1";
            case 27L: return "OP_SLE";
            case 28L: return "OP_SLT";
            case 29L: return "OP_SMOD";
            case 30L: return "OP_SMUL";
            case 31L: return "OP_UDIV";
            case 32L: return "OP_UEXTEND";
            case 33L: return "OP_UGE";
            case 34L: return "OP_UGT";
            case 35L: return "OP_ULE";
            case 36L: return "OP_ULT";
            case 37L: return "OP_UMOD";
            case 38L: return "OP_UMUL";
            case 39L: return "OP_WRITE";
            case 40L: return "OP_XOR";
            case 41L: return "OP_ZEROP";
            case 42L: return "OP_FP_ABS";
            case 43L: return "OP_FP_NEGATE";
            case 44L: return "OP_FP_ADD";
            case 45L: return "OP_FP_MUL";
            case 46L: return "OP_FP_DIV";
            case 47L: return "OP_FP_MULADD";
            case 48L: return "OP_FP_SQRT";
            case 49L: return "OP_FP_MOD";
            case 50L: return "OP_FP_ROUND";
            case 51L: return "OP_FP_MIN";
            case 52L: return "OP_FP_MAX";
            case 53L: return "OP_FP_LE";
            case 54L: return "OP_FP_LT";
            case 55L: return "OP_FP_GE";
            case 56L: return "OP_FP_GT";
            case 57L: return "OP_FP_EQ";
            case 58L: return "OP_FP_ISNORM";
            case 59L: return "OP_FP_ISSUBNORM";
            case 60L: return "OP_FP_ISZERO";
            case 61L: return "OP_FP_ISINFINITE";
            case 62L: return "OP_FP_ISNAN";
            case 63L: return "OP_FP_ISNEG";
            case 64L: return "OP_FP_ISPOS";
            case 65L: return "OP_CONVERT";
            case 66L: return "OP_REINTERPRET";
            case 67L: return "OP_NONE";
            default: return "";
        }
    }

    std::string Operator(int64_t i, const std::string &strip) {
        std::string s = Operator(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Operator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L
        };
        static const std::vector<int64_t> retval(values, values + 68);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Operator(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Operator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Operator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionOperator() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Operator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 166
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace Formatter {
    const char* ShowComments(int64_t i) {
        switch (i) {
            case 0L: return "CMT_SILENT";
            case 1L: return "CMT_AFTER";
            case 2L: return "CMT_INSTEAD";
            case 3L: return "CMT_BEFORE";
            default: return "";
        }
    }

    std::string ShowComments(int64_t i, const std::string &strip) {
        std::string s = ShowComments(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowComments() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionFormatterShowComments(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionFormatterShowComments() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 187
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression {
    const char* VisitAction(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE";
            case 1L: return "TRUNCATE";
            case 2L: return "TERMINATE";
            default: return "";
        }
    }

    std::string VisitAction(int64_t i, const std::string &strip) {
        std::string s = VisitAction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::VisitAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VisitAction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionVisitAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::VisitAction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::VisitAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::VisitAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionVisitAction() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::VisitAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 229
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace Type {
    const char* TypeClass(int64_t i) {
        switch (i) {
            case 0L: return "INTEGER";
            case 1L: return "FP";
            case 2L: return "MEMORY";
            case 3L: return "INVALID";
            default: return "";
        }
    }

    std::string TypeClass(int64_t i, const std::string &strip) {
        std::string s = TypeClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionTypeTypeClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionTypeTypeClass() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 18
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kFamily(int64_t i) {
        switch (i) {
            case 1L: return "m68k_68000_only";
            case 2L: return "m68k_68ec000";
            case 4L: return "m68k_68hc000";
            case 7L: return "m68k_68000";
            case 8L: return "m68k_68008";
            case 16L: return "m68k_68010";
            case 32L: return "m68k_68012";
            case 255L: return "m68k_generation_1";
            case 256L: return "m68k_68020_only";
            case 512L: return "m68k_68ec020";
            case 768L: return "m68k_68020";
            case 1024L: return "m68k_68030_only";
            case 4096L: return "m68k_68ec030";
            case 8192L: return "m68k_68030";
            case 65280L: return "m68k_generation_2";
            case 65536L: return "m68k_68040_only";
            case 131072L: return "m68k_68ec040";
            case 262144L: return "m68k_68lc040";
            case 458752L: return "m68k_68040";
            case 16711680L: return "m68k_generation_3";
            case 16777216L: return "m68k_freescale_cpu32";
            case 33554432L: return "m68k_freescale_isaa";
            case 67108864L: return "m68k_freescale_isab";
            case 134217728L: return "m68k_freescale_isac";
            case 268435456L: return "m68k_freescale_fpu";
            case 536870912L: return "m68k_freescale_mac";
            case 1073741824L: return "m68k_freescale_emac";
            case 2147483648L: return "m68k_freescale_emacb";
            case 4278190080L: return "m68k_freescale";
            case 4294967295L: return "m68k_family";
            default: return "";
        }
    }

    std::string M68kFamily(int64_t i, const std::string &strip) {
        std::string s = M68kFamily(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kFamily() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            7L,
            8L,
            16L,
            32L,
            255L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            65280L,
            65536L,
            131072L,
            262144L,
            458752L,
            16711680L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4278190080L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kFamily(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kFamily() {
        return stringify::Rose::BinaryAnalysis::M68kFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 56
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "m68k_regclass_data";
            case 1L: return "m68k_regclass_addr";
            case 2L: return "m68k_regclass_fpr";
            case 3L: return "m68k_regclass_spr";
            case 4L: return "m68k_regclass_mac";
            case 5L: return "m68k_regclass_sup";
            default: return "";
        }
    }

    std::string M68kRegisterClass(int64_t i, const std::string &strip) {
        std::string s = M68kRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kRegisterClass() {
        return stringify::Rose::BinaryAnalysis::M68kRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 66
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_spr_pc";
            case 1L: return "m68k_spr_sr";
            case 2L: return "m68k_spr_fpcr";
            case 3L: return "m68k_spr_fpsr";
            case 4L: return "m68k_spr_fpiar";
            default: return "";
        }
    }

    std::string M68kSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 75
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kMacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_mac_macsr";
            case 1L: return "m68k_mac_acc0";
            case 2L: return "m68k_mac_acc1";
            case 3L: return "m68k_mac_acc2";
            case 4L: return "m68k_mac_acc3";
            case 5L: return "m68k_mac_ext01";
            case 6L: return "m68k_mac_ext23";
            case 7L: return "m68k_mac_ext0";
            case 8L: return "m68k_mac_ext1";
            case 9L: return "m68k_mac_ext2";
            case 10L: return "m68k_mac_ext3";
            case 11L: return "m68k_mac_mask";
            default: return "";
        }
    }

    std::string M68kMacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kMacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kMacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kMacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kMacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kMacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kMacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kMacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 91
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEmacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_emac_macsr";
            case 1L: return "m68k_emac_acc0";
            case 2L: return "m68k_emac_acc1";
            case 3L: return "m68k_emac_acc2";
            case 4L: return "m68k_emac_acc3";
            case 5L: return "m68k_emac_mask";
            default: return "";
        }
    }

    std::string M68kEmacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kEmacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEmacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEmacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEmacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEmacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEmacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kEmacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 101
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSupervisorRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_sup_vbr";
            case 1L: return "m68k_sup_ssp";
            case 2L: return "m68k_sup_sfc";
            case 3L: return "m68k_sup_dfc";
            case 4L: return "m68k_sup_cacr";
            case 5L: return "m68k_sup_asid";
            case 6L: return "m68k_sup_acr0";
            case 7L: return "m68k_sup_acr1";
            case 8L: return "m68k_sup_acr2";
            case 9L: return "m68k_sup_acr3";
            case 10L: return "m68k_sup_mmubar";
            case 11L: return "m68k_sup_rombar0";
            case 12L: return "m68k_sup_rombar1";
            case 13L: return "m68k_sup_rambar0";
            case 14L: return "m68k_sup_rambar1";
            case 15L: return "m68k_sup_mbar";
            case 16L: return "m68k_sup_mpcr";
            case 17L: return "m68k_sup_edrambar";
            case 18L: return "m68k_sup_secmbar";
            case 19L: return "m68k_sup_0_pcr1";
            case 20L: return "m68k_sup_0_pcr2";
            case 21L: return "m68k_sup_0_pcr3";
            case 22L: return "m68k_sup_1_pcr1";
            case 23L: return "m68k_sup_1_pcr2";
            case 24L: return "m68k_sup_1_pcr3";
            default: return "";
        }
    }

    std::string M68kSupervisorRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSupervisorRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSupervisorRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSupervisorRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSupervisorRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSupervisorRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSupervisorRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSupervisorRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 187
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEffectiveAddressMode(int64_t i) {
        switch (i) {
            case 0L: return "m68k_eam_unknown";
            case 1L: return "m68k_eam_drd";
            case 2L: return "m68k_eam_ard";
            case 3L: return "m68k_eam_rd";
            case 4L: return "m68k_eam_ari";
            case 8L: return "m68k_eam_inc";
            case 16L: return "m68k_eam_dec";
            case 32L: return "m68k_eam_dsp";
            case 60L: return "m68k_eam_ri";
            case 64L: return "m68k_eam_idx8";
            case 128L: return "m68k_eam_idxbd";
            case 192L: return "m68k_eam_idx";
            case 256L: return "m68k_eam_mpost";
            case 512L: return "m68k_eam_mpre";
            case 768L: return "m68k_eam_mi";
            case 1024L: return "m68k_eam_pcdsp";
            case 2048L: return "m68k_eam_pcidx8";
            case 4096L: return "m68k_eam_pcidxbd";
            case 6144L: return "m68k_eam_pcidx";
            case 8192L: return "m68k_eam_pcmpost";
            case 16384L: return "m68k_eam_pcmpre";
            case 24576L: return "m68k_eam_pcmi";
            case 29568L: return "m68k_eam_234";
            case 31744L: return "m68k_eam_pc";
            case 32768L: return "m68k_eam_absw";
            case 65536L: return "m68k_eam_absl";
            case 98304L: return "m68k_eam_abs";
            case 123903L: return "m68k_eam_alter";
            case 131044L: return "m68k_eam_control";
            case 131072L: return "m68k_eam_imm";
            case 262140L: return "m68k_eam_memory";
            case 262141L: return "m68k_eam_data";
            case 262143L: return "m68k_eam_all";
            default: return "";
        }
    }

    std::string M68kEffectiveAddressMode(int64_t i, const std::string &strip) {
        std::string s = M68kEffectiveAddressMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEffectiveAddressMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            60L,
            64L,
            128L,
            192L,
            256L,
            512L,
            768L,
            1024L,
            2048L,
            4096L,
            6144L,
            8192L,
            16384L,
            24576L,
            29568L,
            31744L,
            32768L,
            65536L,
            98304L,
            123903L,
            131044L,
            131072L,
            262140L,
            262141L,
            262143L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEffectiveAddressMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEffectiveAddressMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEffectiveAddressMode() {
        return stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 241
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kDataFormat(int64_t i) {
        switch (i) {
            case 0L: return "m68k_fmt_i32";
            case 1L: return "m68k_fmt_f32";
            case 2L: return "m68k_fmt_f96";
            case 3L: return "m68k_fmt_p96";
            case 4L: return "m68k_fmt_i16";
            case 5L: return "m68k_fmt_f64";
            case 6L: return "m68k_fmt_i8";
            case 255L: return "m68k_fmt_unknown";
            default: return "";
        }
    }

    std::string M68kDataFormat(int64_t i, const std::string &strip) {
        std::string s = M68kDataFormat(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kDataFormat() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kDataFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kDataFormat(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kDataFormat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kDataFormat() {
        return stringify::Rose::BinaryAnalysis::M68kDataFormat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 253
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "m68k_unknown_instruction";
            case 1L: return "m68k_abcd";
            case 2L: return "m68k_add";
            case 3L: return "m68k_adda";
            case 4L: return "m68k_addi";
            case 5L: return "m68k_addq";
            case 6L: return "m68k_addx";
            case 7L: return "m68k_and";
            case 8L: return "m68k_andi";
            case 9L: return "m68k_asl";
            case 10L: return "m68k_asr";
            case 11L: return "m68k_bcc";
            case 12L: return "m68k_bcs";
            case 13L: return "m68k_beq";
            case 14L: return "m68k_bge";
            case 15L: return "m68k_bgt";
            case 16L: return "m68k_bhi";
            case 17L: return "m68k_ble";
            case 18L: return "m68k_bls";
            case 19L: return "m68k_blt";
            case 20L: return "m68k_bmi";
            case 21L: return "m68k_bne";
            case 22L: return "m68k_bpl";
            case 23L: return "m68k_bvc";
            case 24L: return "m68k_bvs";
            case 25L: return "m68k_bchg";
            case 26L: return "m68k_bclr";
            case 27L: return "m68k_bfchg";
            case 28L: return "m68k_bfclr";
            case 29L: return "m68k_bfexts";
            case 30L: return "m68k_bfextu";
            case 31L: return "m68k_bfins";
            case 32L: return "m68k_bfset";
            case 33L: return "m68k_bftst";
            case 34L: return "m68k_bkpt";
            case 35L: return "m68k_bra";
            case 36L: return "m68k_bset";
            case 37L: return "m68k_bsr";
            case 38L: return "m68k_btst";
            case 39L: return "m68k_callm";
            case 40L: return "m68k_cas";
            case 41L: return "m68k_cas2";
            case 42L: return "m68k_chk";
            case 43L: return "m68k_chk2";
            case 44L: return "m68k_clr";
            case 45L: return "m68k_cmp";
            case 46L: return "m68k_cmp2";
            case 47L: return "m68k_cmpa";
            case 48L: return "m68k_cmpi";
            case 49L: return "m68k_cmpm";
            case 50L: return "m68k_cpusha";
            case 51L: return "m68k_cpushl";
            case 52L: return "m68k_cpushp";
            case 53L: return "m68k_dbt";
            case 54L: return "m68k_dbf";
            case 55L: return "m68k_dbhi";
            case 56L: return "m68k_dbls";
            case 57L: return "m68k_dbcc";
            case 58L: return "m68k_dbcs";
            case 59L: return "m68k_dbne";
            case 60L: return "m68k_dbeq";
            case 61L: return "m68k_dbvc";
            case 62L: return "m68k_dbvs";
            case 63L: return "m68k_dbpl";
            case 64L: return "m68k_dbmi";
            case 65L: return "m68k_dbge";
            case 66L: return "m68k_dblt";
            case 67L: return "m68k_dbgt";
            case 68L: return "m68k_dble";
            case 69L: return "m68k_divs";
            case 70L: return "m68k_divsl";
            case 71L: return "m68k_divu";
            case 72L: return "m68k_divul";
            case 73L: return "m68k_eor";
            case 74L: return "m68k_eori";
            case 75L: return "m68k_exg";
            case 76L: return "m68k_ext";
            case 77L: return "m68k_extb";
            case 78L: return "m68k_fabs";
            case 79L: return "m68k_fadd";
            case 80L: return "m68k_fbeq";
            case 81L: return "m68k_fbne";
            case 82L: return "m68k_fbgt";
            case 83L: return "m68k_fbngt";
            case 84L: return "m68k_fbge";
            case 85L: return "m68k_fbnge";
            case 86L: return "m68k_fblt";
            case 87L: return "m68k_fbnlt";
            case 88L: return "m68k_fble";
            case 89L: return "m68k_fbnle";
            case 90L: return "m68k_fbgl";
            case 91L: return "m68k_fbngl";
            case 92L: return "m68k_fbgle";
            case 93L: return "m68k_fbngle";
            case 94L: return "m68k_fbogt";
            case 95L: return "m68k_fbule";
            case 96L: return "m68k_fboge";
            case 97L: return "m68k_fbult";
            case 98L: return "m68k_fbolt";
            case 99L: return "m68k_fbuge";
            case 100L: return "m68k_fbole";
            case 101L: return "m68k_fbugt";
            case 102L: return "m68k_fbogl";
            case 103L: return "m68k_fbueq";
            case 104L: return "m68k_fbor";
            case 105L: return "m68k_fbun";
            case 106L: return "m68k_fbf";
            case 107L: return "m68k_fbt";
            case 108L: return "m68k_fbsf";
            case 109L: return "m68k_fbst";
            case 110L: return "m68k_fbseq";
            case 111L: return "m68k_fbsne";
            case 112L: return "m68k_fcmp";
            case 113L: return "m68k_fdabs";
            case 114L: return "m68k_fdadd";
            case 115L: return "m68k_fddiv";
            case 116L: return "m68k_fdiv";
            case 117L: return "m68k_fdmove";
            case 118L: return "m68k_fdmul";
            case 119L: return "m68k_fdneg";
            case 120L: return "m68k_fdsqrt";
            case 121L: return "m68k_fdsub";
            case 122L: return "m68k_fint";
            case 123L: return "m68k_fintrz";
            case 124L: return "m68k_fmove";
            case 125L: return "m68k_fmovem";
            case 126L: return "m68k_fmul";
            case 127L: return "m68k_fneg";
            case 128L: return "m68k_fnop";
            case 129L: return "m68k_fsabs";
            case 130L: return "m68k_fsadd";
            case 131L: return "m68k_fsdiv";
            case 132L: return "m68k_fsmove";
            case 133L: return "m68k_fsmul";
            case 134L: return "m68k_fsneg";
            case 135L: return "m68k_fsqrt";
            case 136L: return "m68k_fssqrt";
            case 137L: return "m68k_fssub";
            case 138L: return "m68k_fsub";
            case 139L: return "m68k_ftst";
            case 140L: return "m68k_illegal";
            case 141L: return "m68k_jmp";
            case 142L: return "m68k_jsr";
            case 143L: return "m68k_lea";
            case 144L: return "m68k_link";
            case 145L: return "m68k_lsl";
            case 146L: return "m68k_lsr";
            case 147L: return "m68k_mac";
            case 148L: return "m68k_mov3q";
            case 149L: return "m68k_movclr";
            case 150L: return "m68k_move";
            case 151L: return "m68k_move_acc";
            case 152L: return "m68k_move_accext";
            case 153L: return "m68k_move_ccr";
            case 154L: return "m68k_move_macsr";
            case 155L: return "m68k_move_mask";
            case 156L: return "m68k_move_sr";
            case 157L: return "m68k_move16";
            case 158L: return "m68k_movea";
            case 159L: return "m68k_movec";
            case 160L: return "m68k_movem";
            case 161L: return "m68k_movep";
            case 162L: return "m68k_moveq";
            case 163L: return "m68k_msac";
            case 164L: return "m68k_muls";
            case 165L: return "m68k_mulu";
            case 166L: return "m68k_mvs";
            case 167L: return "m68k_mvz";
            case 168L: return "m68k_nbcd";
            case 169L: return "m68k_neg";
            case 170L: return "m68k_negx";
            case 171L: return "m68k_nop";
            case 172L: return "m68k_not";
            case 173L: return "m68k_or";
            case 174L: return "m68k_ori";
            case 175L: return "m68k_pack";
            case 176L: return "m68k_pea";
            case 177L: return "m68k_rol";
            case 178L: return "m68k_ror";
            case 179L: return "m68k_roxl";
            case 180L: return "m68k_roxr";
            case 181L: return "m68k_rtd";
            case 182L: return "m68k_rtm";
            case 183L: return "m68k_rtr";
            case 184L: return "m68k_rts";
            case 185L: return "m68k_sbcd";
            case 186L: return "m68k_st";
            case 187L: return "m68k_sf";
            case 188L: return "m68k_shi";
            case 189L: return "m68k_sls";
            case 190L: return "m68k_scc";
            case 191L: return "m68k_scs";
            case 192L: return "m68k_sne";
            case 193L: return "m68k_seq";
            case 194L: return "m68k_svc";
            case 195L: return "m68k_svs";
            case 196L: return "m68k_spl";
            case 197L: return "m68k_smi";
            case 198L: return "m68k_sge";
            case 199L: return "m68k_slt";
            case 200L: return "m68k_sgt";
            case 201L: return "m68k_sle";
            case 202L: return "m68k_sub";
            case 203L: return "m68k_suba";
            case 204L: return "m68k_subi";
            case 205L: return "m68k_subq";
            case 206L: return "m68k_subx";
            case 207L: return "m68k_swap";
            case 208L: return "m68k_tas";
            case 209L: return "m68k_trap";
            case 210L: return "m68k_trapt";
            case 211L: return "m68k_trapf";
            case 212L: return "m68k_traphi";
            case 213L: return "m68k_trapls";
            case 214L: return "m68k_trapcc";
            case 215L: return "m68k_trapcs";
            case 216L: return "m68k_trapne";
            case 217L: return "m68k_trapeq";
            case 218L: return "m68k_trapvc";
            case 219L: return "m68k_trapvs";
            case 220L: return "m68k_trappl";
            case 221L: return "m68k_trapmi";
            case 222L: return "m68k_trapge";
            case 223L: return "m68k_traplt";
            case 224L: return "m68k_trapgt";
            case 225L: return "m68k_traple";
            case 226L: return "m68k_trapv";
            case 227L: return "m68k_tst";
            case 228L: return "m68k_unlk";
            case 229L: return "m68k_unpk";
            case 230L: return "m68k_last_instruction";
            default: return "";
        }
    }

    std::string M68kInstructionKind(int64_t i, const std::string &strip) {
        std::string s = M68kInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L
        };
        static const std::vector<int64_t> retval(values, values + 231);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kInstructionKind() {
        return stringify::Rose::BinaryAnalysis::M68kInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpressionParser.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpressionParser { namespace Token {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "LTPAREN";
            case 2L: return "RTPAREN";
            case 3L: return "BITVECTOR";
            case 4L: return "SYMBOL";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionParserTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionParserTokenType() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 14
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_TAG(int64_t i) {
        switch (i) {
            case 1L: return "DW_TAG_array_type";
            case 2L: return "DW_TAG_class_type";
            case 3L: return "DW_TAG_entry_point";
            case 4L: return "DW_TAG_enumeration_type";
            case 5L: return "DW_TAG_formal_parameter";
            case 8L: return "DW_TAG_imported_declaration";
            case 10L: return "DW_TAG_label";
            case 11L: return "DW_TAG_lexical_block";
            case 13L: return "DW_TAG_member";
            case 15L: return "DW_TAG_pointer_type";
            case 16L: return "DW_TAG_reference_type";
            case 17L: return "DW_TAG_compile_unit";
            case 18L: return "DW_TAG_string_type";
            case 19L: return "DW_TAG_structure_type";
            case 21L: return "DW_TAG_subroutine_type";
            case 22L: return "DW_TAG_typedef";
            case 23L: return "DW_TAG_union_type";
            case 24L: return "DW_TAG_unspecified_parameters";
            case 25L: return "DW_TAG_variant";
            case 26L: return "DW_TAG_common_block";
            case 27L: return "DW_TAG_common_inclusion";
            case 28L: return "DW_TAG_inheritance";
            case 29L: return "DW_TAG_inlined_subroutine";
            case 30L: return "DW_TAG_module";
            case 31L: return "DW_TAG_ptr_to_member_type";
            case 32L: return "DW_TAG_set_type";
            case 33L: return "DW_TAG_subrange_type";
            case 34L: return "DW_TAG_with_stmt";
            case 35L: return "DW_TAG_access_declaration";
            case 36L: return "DW_TAG_base_type";
            case 37L: return "DW_TAG_catch_block";
            case 38L: return "DW_TAG_const_type";
            case 39L: return "DW_TAG_constant";
            case 40L: return "DW_TAG_enumerator";
            case 41L: return "DW_TAG_file_type";
            case 42L: return "DW_TAG_friend";
            case 43L: return "DW_TAG_namelist";
            case 44L: return "DW_TAG_namelist_item";
            case 45L: return "DW_TAG_packed_type";
            case 46L: return "DW_TAG_subprogram";
            case 47L: return "DW_TAG_template_type_parameter";
            case 48L: return "DW_TAG_template_value_parameter";
            case 49L: return "DW_TAG_thrown_type";
            case 50L: return "DW_TAG_try_block";
            case 51L: return "DW_TAG_variant_part";
            case 52L: return "DW_TAG_variable";
            case 53L: return "DW_TAG_volatile_type";
            case 54L: return "DW_TAG_dwarf_procedure";
            case 55L: return "DW_TAG_restrict_type";
            case 56L: return "DW_TAG_interface_type";
            case 57L: return "DW_TAG_namespace";
            case 58L: return "DW_TAG_imported_module";
            case 59L: return "DW_TAG_unspecified_type";
            case 60L: return "DW_TAG_partial_unit";
            case 61L: return "DW_TAG_imported_unit";
            case 62L: return "DW_TAG_mutable_type";
            case 63L: return "DW_TAG_condition";
            case 64L: return "DW_TAG_shared_type";
            case 65L: return "DW_TAG_type_unit";
            case 66L: return "DW_TAG_rvalue_reference_type";
            case 67L: return "DW_TAG_template_alias";
            case 16512L: return "DW_TAG_lo_user";
            case 16513L: return "DW_TAG_MIPS_loop";
            case 16528L: return "DW_TAG_HP_array_descriptor";
            case 16641L: return "DW_TAG_format_label";
            case 16642L: return "DW_TAG_function_template";
            case 16643L: return "DW_TAG_class_template";
            case 16644L: return "DW_TAG_GNU_BINCL";
            case 16645L: return "DW_TAG_GNU_EINCL";
            case 16646L: return "DW_TAG_GNU_template_template_parameter";
            case 16647L: return "DW_TAG_GNU_template_parameter_pack";
            case 16648L: return "DW_TAG_GNU_formal_parameter_pack";
            case 16649L: return "DW_TAG_GNU_call_site";
            case 16650L: return "DW_TAG_GNU_call_site_parameter";
            case 16897L: return "DW_TAG_SUN_function_template";
            case 16898L: return "DW_TAG_SUN_class_template";
            case 16899L: return "DW_TAG_SUN_struct_template";
            case 16900L: return "DW_TAG_SUN_union_template";
            case 16901L: return "DW_TAG_SUN_indirect_inheritance";
            case 16902L: return "DW_TAG_SUN_codeflags";
            case 16903L: return "DW_TAG_SUN_memop_info";
            case 16904L: return "DW_TAG_SUN_omp_child_func";
            case 16905L: return "DW_TAG_SUN_rtti_descriptor";
            case 16906L: return "DW_TAG_SUN_dtor_info";
            case 16907L: return "DW_TAG_SUN_dtor";
            case 16908L: return "DW_TAG_SUN_f90_interface";
            case 16909L: return "DW_TAG_SUN_fortran_vax_structure";
            case 17151L: return "DW_TAG_SUN_hi";
            case 20737L: return "DW_TAG_ALTIUM_circ_type";
            case 20738L: return "DW_TAG_ALTIUM_mwa_circ_type";
            case 20739L: return "DW_TAG_ALTIUM_rev_carry_type";
            case 20753L: return "DW_TAG_ALTIUM_rom";
            case 34661L: return "DW_TAG_upc_shared_type";
            case 34662L: return "DW_TAG_upc_strict_type";
            case 34663L: return "DW_TAG_upc_relaxed_type";
            case 40960L: return "DW_TAG_PGI_kanji_type";
            case 40992L: return "DW_TAG_PGI_interface_block";
            case 65535L: return "DW_TAG_hi_user";
            default: return "";
        }
    }

    std::string DWARF_TAG(int64_t i, const std::string &strip) {
        std::string s = DWARF_TAG(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_TAG)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_TAG() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            8L,
            10L,
            11L,
            13L,
            15L,
            16L,
            17L,
            18L,
            19L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            16512L,
            16513L,
            16528L,
            16641L,
            16642L,
            16643L,
            16644L,
            16645L,
            16646L,
            16647L,
            16648L,
            16649L,
            16650L,
            16897L,
            16898L,
            16899L,
            16900L,
            16901L,
            16902L,
            16903L,
            16904L,
            16905L,
            16906L,
            16907L,
            16908L,
            16909L,
            17151L,
            20737L,
            20738L,
            20739L,
            20753L,
            34661L,
            34662L,
            34663L,
            40960L,
            40992L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 98);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_TAG(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_TAG(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_TAG)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_TAG::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_TAG() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_TAG();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 117
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_FORM(int64_t i) {
        switch (i) {
            case 1L: return "DW_FORM_addr";
            case 3L: return "DW_FORM_block2";
            case 4L: return "DW_FORM_block4";
            case 5L: return "DW_FORM_data2";
            case 6L: return "DW_FORM_data4";
            case 7L: return "DW_FORM_data8";
            case 8L: return "DW_FORM_string";
            case 9L: return "DW_FORM_block";
            case 10L: return "DW_FORM_block1";
            case 11L: return "DW_FORM_data1";
            case 12L: return "DW_FORM_flag";
            case 13L: return "DW_FORM_sdata";
            case 14L: return "DW_FORM_strp";
            case 15L: return "DW_FORM_udata";
            case 16L: return "DW_FORM_ref_addr";
            case 17L: return "DW_FORM_ref1";
            case 18L: return "DW_FORM_ref2";
            case 19L: return "DW_FORM_ref4";
            case 20L: return "DW_FORM_ref8";
            case 21L: return "DW_FORM_ref_udata";
            case 22L: return "DW_FORM_indirect";
            case 23L: return "DW_FORM_sec_offset";
            case 24L: return "DW_FORM_exprloc";
            case 25L: return "DW_FORM_flag_present";
            case 32L: return "DW_FORM_ref_sig8";
            default: return "";
        }
    }

    std::string DWARF_FORM(int64_t i, const std::string &strip) {
        std::string s = DWARF_FORM(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_FORM)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_FORM() {
        static const int64_t values[] = {
            1L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_FORM(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_FORM(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_FORM)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_FORM::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_FORM() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_FORM();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 146
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_AT(int64_t i) {
        switch (i) {
            case 1L: return "DW_AT_sibling";
            case 2L: return "DW_AT_location";
            case 3L: return "DW_AT_name";
            case 9L: return "DW_AT_ordering";
            case 10L: return "DW_AT_subscr_data";
            case 11L: return "DW_AT_byte_size";
            case 12L: return "DW_AT_bit_offset";
            case 13L: return "DW_AT_bit_size";
            case 15L: return "DW_AT_element_list";
            case 16L: return "DW_AT_stmt_list";
            case 17L: return "DW_AT_low_pc";
            case 18L: return "DW_AT_high_pc";
            case 19L: return "DW_AT_language";
            case 20L: return "DW_AT_member";
            case 21L: return "DW_AT_discr";
            case 22L: return "DW_AT_discr_value";
            case 23L: return "DW_AT_visibility";
            case 24L: return "DW_AT_import";
            case 25L: return "DW_AT_string_length";
            case 26L: return "DW_AT_common_reference";
            case 27L: return "DW_AT_comp_dir";
            case 28L: return "DW_AT_const_value";
            case 29L: return "DW_AT_containing_type";
            case 30L: return "DW_AT_default_value";
            case 32L: return "DW_AT_inline";
            case 33L: return "DW_AT_is_optional";
            case 34L: return "DW_AT_lower_bound";
            case 37L: return "DW_AT_producer";
            case 39L: return "DW_AT_prototyped";
            case 42L: return "DW_AT_return_addr";
            case 44L: return "DW_AT_start_scope";
            case 46L: return "DW_AT_stride_size";
            case 47L: return "DW_AT_upper_bound";
            case 49L: return "DW_AT_abstract_origin";
            case 50L: return "DW_AT_accessibility";
            case 51L: return "DW_AT_address_class";
            case 52L: return "DW_AT_artificial";
            case 53L: return "DW_AT_base_types";
            case 54L: return "DW_AT_calling_convention";
            case 55L: return "DW_AT_count";
            case 56L: return "DW_AT_data_member_location";
            case 57L: return "DW_AT_decl_column";
            case 58L: return "DW_AT_decl_file";
            case 59L: return "DW_AT_decl_line";
            case 60L: return "DW_AT_declaration";
            case 61L: return "DW_AT_discr_list";
            case 62L: return "DW_AT_encoding";
            case 63L: return "DW_AT_external";
            case 64L: return "DW_AT_frame_base";
            case 65L: return "DW_AT_friend";
            case 66L: return "DW_AT_identifier_case";
            case 67L: return "DW_AT_macro_info";
            case 68L: return "DW_AT_namelist_item";
            case 69L: return "DW_AT_priority";
            case 70L: return "DW_AT_segment";
            case 71L: return "DW_AT_specification";
            case 72L: return "DW_AT_static_link";
            case 73L: return "DW_AT_type";
            case 74L: return "DW_AT_use_location";
            case 75L: return "DW_AT_variable_parameter";
            case 76L: return "DW_AT_virtuality";
            case 77L: return "DW_AT_vtable_elem_location";
            case 78L: return "DW_AT_allocated";
            case 79L: return "DW_AT_associated";
            case 80L: return "DW_AT_data_location";
            case 81L: return "DW_AT_byte_stride";
            case 82L: return "DW_AT_entry_pc";
            case 83L: return "DW_AT_use_UTF8";
            case 84L: return "DW_AT_extension";
            case 85L: return "DW_AT_ranges";
            case 86L: return "DW_AT_trampoline";
            case 87L: return "DW_AT_call_column";
            case 88L: return "DW_AT_call_file";
            case 89L: return "DW_AT_call_line";
            case 90L: return "DW_AT_description";
            case 91L: return "DW_AT_binary_scale";
            case 92L: return "DW_AT_decimal_scale";
            case 93L: return "DW_AT_small";
            case 94L: return "DW_AT_decimal_sign";
            case 95L: return "DW_AT_digit_count";
            case 96L: return "DW_AT_picture_string";
            case 97L: return "DW_AT_mutable";
            case 98L: return "DW_AT_threads_scaled";
            case 99L: return "DW_AT_explicit";
            case 100L: return "DW_AT_object_pointer";
            case 101L: return "DW_AT_endianity";
            case 102L: return "DW_AT_elemental";
            case 103L: return "DW_AT_pure";
            case 104L: return "DW_AT_recursive";
            case 105L: return "DW_AT_signature";
            case 106L: return "DW_AT_main_subprogram";
            case 107L: return "DW_AT_data_bit_offset";
            case 108L: return "DW_AT_const_expr";
            case 109L: return "DW_AT_enum_class";
            case 110L: return "DW_AT_linkage_name";
            case 8192L: return "DW_AT_HP_block_index";
            case 8193L: return "DW_AT_MIPS_fde";
            case 8194L: return "DW_AT_MIPS_loop_begin";
            case 8195L: return "DW_AT_MIPS_tail_loop_begin";
            case 8196L: return "DW_AT_MIPS_epilog_begin";
            case 8197L: return "DW_AT_MIPS_loop_unroll_factor";
            case 8198L: return "DW_AT_MIPS_software_pipeline_depth";
            case 8199L: return "DW_AT_MIPS_linkage_name";
            case 8200L: return "DW_AT_MIPS_stride";
            case 8201L: return "DW_AT_MIPS_abstract_name";
            case 8202L: return "DW_AT_MIPS_clone_origin";
            case 8203L: return "DW_AT_MIPS_has_inlines";
            case 8204L: return "DW_AT_MIPS_stride_byte";
            case 8205L: return "DW_AT_MIPS_stride_elem";
            case 8206L: return "DW_AT_MIPS_ptr_dopetype";
            case 8207L: return "DW_AT_MIPS_allocatable_dopetype";
            case 8208L: return "DW_AT_MIPS_assumed_shape_dopetype";
            case 8209L: return "DW_AT_MIPS_assumed_size";
            case 8210L: return "DW_AT_HP_raw_data_ptr";
            case 8211L: return "DW_AT_HP_pass_by_reference";
            case 8212L: return "DW_AT_HP_opt_level";
            case 8213L: return "DW_AT_HP_prof_version_id";
            case 8214L: return "DW_AT_HP_opt_flags";
            case 8215L: return "DW_AT_HP_cold_region_low_pc";
            case 8216L: return "DW_AT_HP_cold_region_high_pc";
            case 8217L: return "DW_AT_HP_all_variables_modifiable";
            case 8218L: return "DW_AT_HP_linkage_name";
            case 8219L: return "DW_AT_HP_prof_flags";
            case 8230L: return "DW_AT_INTEL_other_endian";
            case 8449L: return "DW_AT_sf_names";
            case 8450L: return "DW_AT_src_info";
            case 8451L: return "DW_AT_mac_info";
            case 8452L: return "DW_AT_src_coords";
            case 8453L: return "DW_AT_body_begin";
            case 8454L: return "DW_AT_body_end";
            case 8455L: return "DW_AT_GNU_vector";
            case 8456L: return "DW_AT_GNU_guarded_by";
            case 8457L: return "DW_AT_GNU_pt_guarded_by";
            case 8458L: return "DW_AT_GNU_guarded";
            case 8459L: return "DW_AT_GNU_pt_guarded";
            case 8460L: return "DW_AT_GNU_locks_excluded";
            case 8461L: return "DW_AT_GNU_exclusive_locks_required";
            case 8462L: return "DW_AT_GNU_shared_locks_required";
            case 8463L: return "DW_AT_GNU_odr_signature";
            case 8464L: return "DW_AT_GNU_template_name";
            case 8465L: return "DW_AT_GNU_call_site_value";
            case 8466L: return "DW_AT_GNU_call_site_data_value";
            case 8467L: return "DW_AT_GNU_call_site_target";
            case 8468L: return "DW_AT_GNU_call_site_target_clobbered";
            case 8469L: return "DW_AT_GNU_tail_call";
            case 8470L: return "DW_AT_GNU_all_tail_call_sites";
            case 8471L: return "DW_AT_GNU_all_call_sites";
            case 8472L: return "DW_AT_GNU_all_source_call_sites";
            case 8705L: return "DW_AT_SUN_template";
            case 8706L: return "DW_AT_SUN_alignment";
            case 8707L: return "DW_AT_SUN_vtable";
            case 8708L: return "DW_AT_SUN_count_guarantee";
            case 8709L: return "DW_AT_SUN_command_line";
            case 8710L: return "DW_AT_SUN_vbase";
            case 8711L: return "DW_AT_SUN_compile_options";
            case 8712L: return "DW_AT_SUN_language";
            case 8713L: return "DW_AT_SUN_browser_file";
            case 8720L: return "DW_AT_SUN_vtable_abi";
            case 8721L: return "DW_AT_SUN_func_offsets";
            case 8722L: return "DW_AT_SUN_cf_kind";
            case 8723L: return "DW_AT_SUN_vtable_index";
            case 8724L: return "DW_AT_SUN_omp_tpriv_addr";
            case 8725L: return "DW_AT_SUN_omp_child_func";
            case 8726L: return "DW_AT_SUN_func_offset";
            case 8727L: return "DW_AT_SUN_memop_type_ref";
            case 8728L: return "DW_AT_SUN_profile_id";
            case 8729L: return "DW_AT_SUN_memop_signature";
            case 8736L: return "DW_AT_SUN_obj_dir";
            case 8737L: return "DW_AT_SUN_obj_file";
            case 8738L: return "DW_AT_SUN_original_name";
            case 8739L: return "DW_AT_SUN_hwcprof_signature";
            case 8740L: return "DW_AT_SUN_amd64_parmdump";
            case 8741L: return "DW_AT_SUN_part_link_name";
            case 8742L: return "DW_AT_SUN_link_name";
            case 8743L: return "DW_AT_SUN_pass_with_const";
            case 8744L: return "DW_AT_SUN_return_with_const";
            case 8745L: return "DW_AT_SUN_import_by_name";
            case 8746L: return "DW_AT_SUN_f90_pointer";
            case 8747L: return "DW_AT_SUN_pass_by_ref";
            case 8748L: return "DW_AT_SUN_f90_allocatable";
            case 8749L: return "DW_AT_SUN_f90_assumed_shape_array";
            case 8750L: return "DW_AT_SUN_c_vla";
            case 8752L: return "DW_AT_SUN_return_value_ptr";
            case 8753L: return "DW_AT_SUN_dtor_start";
            case 8754L: return "DW_AT_SUN_dtor_length";
            case 8755L: return "DW_AT_SUN_dtor_state_initial";
            case 8756L: return "DW_AT_SUN_dtor_state_final";
            case 8757L: return "DW_AT_SUN_dtor_state_deltas";
            case 8758L: return "DW_AT_SUN_import_by_lname";
            case 8759L: return "DW_AT_SUN_f90_use_only";
            case 8760L: return "DW_AT_SUN_namelist_spec";
            case 8761L: return "DW_AT_SUN_is_omp_child_func";
            case 8762L: return "DW_AT_SUN_fortran_main_alias";
            case 8763L: return "DW_AT_SUN_fortran_based";
            case 8960L: return "DW_AT_ALTIUM_loclist";
            case 8961L: return "DW_AT_use_GNAT_descriptive_type";
            case 8962L: return "DW_AT_GNAT_descriptive_type";
            case 12816L: return "DW_AT_upc_threads_scaled";
            case 14848L: return "DW_AT_PGI_lbase";
            case 14849L: return "DW_AT_PGI_soffset";
            case 14850L: return "DW_AT_PGI_lstride";
            case 16353L: return "DW_AT_APPLE_optimized";
            case 16354L: return "DW_AT_APPLE_flags";
            case 16355L: return "DW_AT_APPLE_isa";
            case 16356L: return "DW_AT_APPLE_block";
            case 16357L: return "DW_AT_APPLE_major_runtime_vers";
            case 16358L: return "DW_AT_APPLE_runtime_class";
            case 16359L: return "DW_AT_APPLE_omit_frame_ptr";
            case 16383L: return "DW_AT_hi_user";
            default: return "";
        }
    }

    std::string DWARF_AT(int64_t i, const std::string &strip) {
        std::string s = DWARF_AT(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_AT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_AT() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            9L,
            10L,
            11L,
            12L,
            13L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            32L,
            33L,
            34L,
            37L,
            39L,
            42L,
            44L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            8192L,
            8193L,
            8194L,
            8195L,
            8196L,
            8197L,
            8198L,
            8199L,
            8200L,
            8201L,
            8202L,
            8203L,
            8204L,
            8205L,
            8206L,
            8207L,
            8208L,
            8209L,
            8210L,
            8211L,
            8212L,
            8213L,
            8214L,
            8215L,
            8216L,
            8217L,
            8218L,
            8219L,
            8230L,
            8449L,
            8450L,
            8451L,
            8452L,
            8453L,
            8454L,
            8455L,
            8456L,
            8457L,
            8458L,
            8459L,
            8460L,
            8461L,
            8462L,
            8463L,
            8464L,
            8465L,
            8466L,
            8467L,
            8468L,
            8469L,
            8470L,
            8471L,
            8472L,
            8705L,
            8706L,
            8707L,
            8708L,
            8709L,
            8710L,
            8711L,
            8712L,
            8713L,
            8720L,
            8721L,
            8722L,
            8723L,
            8724L,
            8725L,
            8726L,
            8727L,
            8728L,
            8729L,
            8736L,
            8737L,
            8738L,
            8739L,
            8740L,
            8741L,
            8742L,
            8743L,
            8744L,
            8745L,
            8746L,
            8747L,
            8748L,
            8749L,
            8750L,
            8752L,
            8753L,
            8754L,
            8755L,
            8756L,
            8757L,
            8758L,
            8759L,
            8760L,
            8761L,
            8762L,
            8763L,
            8960L,
            8961L,
            8962L,
            12816L,
            14848L,
            14849L,
            14850L,
            16353L,
            16354L,
            16355L,
            16356L,
            16357L,
            16358L,
            16359L,
            16383L
        };
        static const std::vector<int64_t> retval(values, values + 209);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_AT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_AT(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_AT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_AT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_AT() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_AT();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 360
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_LANG(int64_t i) {
        switch (i) {
            case 1L: return "DW_LANG_C89";
            case 2L: return "DW_LANG_C";
            case 3L: return "DW_LANG_Ada83";
            case 4L: return "DW_LANG_C_plus_plus";
            case 5L: return "DW_LANG_Cobol74";
            case 6L: return "DW_LANG_Cobol85";
            case 7L: return "DW_LANG_Fortran77";
            case 8L: return "DW_LANG_Fortran90";
            case 9L: return "DW_LANG_Pascal83";
            case 10L: return "DW_LANG_Modula2";
            case 11L: return "DW_LANG_Java";
            case 12L: return "DW_LANG_C99";
            case 13L: return "DW_LANG_Ada95";
            case 14L: return "DW_LANG_Fortran95";
            case 15L: return "DW_LANG_PLI";
            case 16L: return "DW_LANG_ObjC";
            case 17L: return "DW_LANG_ObjC_plus_plus";
            case 18L: return "DW_LANG_UPC";
            case 19L: return "DW_LANG_D";
            case 20L: return "DW_LANG_Python";
            case 21L: return "DW_LANG_OpenCL";
            case 22L: return "DW_LANG_Go";
            case 23L: return "DW_LANG_Modula3";
            case 24L: return "DW_LANG_Haskel";
            case 32768L: return "DW_LANG_lo_user";
            case 32769L: return "DW_LANG_Mips_Assembler";
            case 34661L: return "DW_LANG_Upc";
            case 36865L: return "DW_LANG_SUN_Assembler";
            case 37121L: return "DW_LANG_ALTIUM_Assembler";
            case 65535L: return "DW_LANG_hi_user";
            default: return "";
        }
    }

    std::string DWARF_LANG(int64_t i, const std::string &strip) {
        std::string s = DWARF_LANG(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_LANG)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_LANG() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            32768L,
            32769L,
            34661L,
            36865L,
            37121L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_LANG(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_LANG(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_LANG)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_LANG::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_LANG() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_LANG();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/VxworksTerminal.h line 43
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace VxworksTerminal { namespace DataTransfer {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL";
            case 1L: return "DRAIN";
            case 2L: return "TERMINATE";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::VxworksTerminal::DataTransfer::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVxworksTerminalDataTransferState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::VxworksTerminal::DataTransfer::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::VxworksTerminal::DataTransfer::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::VxworksTerminal::DataTransfer::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVxworksTerminalDataTransferState() {
        return stringify::Rose::BinaryAnalysis::VxworksTerminal::DataTransfer::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SRecord.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Syntax(int64_t i) {
        switch (i) {
            case 0L: return "SREC_MOTOROLA";
            case 1L: return "SREC_INTEL";
            case 2L: return "SREC_UNKNOWN_SYNTAX";
            default: return "";
        }
    }

    std::string Syntax(int64_t i, const std::string &strip) {
        std::string s = Syntax(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Syntax() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordSyntax(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Syntax(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Syntax::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordSyntax() {
        return stringify::Rose::BinaryAnalysis::SRecord::Syntax();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SRecord.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "SREC_M_HEADER";
            case 1L: return "SREC_M_DATA16";
            case 2L: return "SREC_M_DATA24";
            case 3L: return "SREC_M_DATA32";
            case 4L: return "SREC_M_RESERVED";
            case 5L: return "SREC_M_COUNT16";
            case 6L: return "SREC_M_COUNT24";
            case 7L: return "SREC_M_START32";
            case 8L: return "SREC_M_START24";
            case 9L: return "SREC_M_START16";
            case 10L: return "SREC_I_DATA";
            case 11L: return "SREC_I_END";
            case 12L: return "SREC_I_EXTENDED_SA";
            case 13L: return "SREC_I_START_SA";
            case 14L: return "SREC_I_EXTENDED_LA";
            case 15L: return "SREC_I_START_LA";
            case 16L: return "SREC_UNKNOWN_TYPE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordType() {
        return stringify::Rose::BinaryAnalysis::SRecord::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/Base.h line 76
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace ArrowMargin { namespace CfgEndpoint {
    const char* End(int64_t i) {
        switch (i) {
            case 0L: return "Source";
            case 1L: return "Target";
            default: return "";
        }
    }

    std::string End(int64_t i, const std::string &strip) {
        std::string s = End(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::End)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& End() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserArrowMarginCfgEndpointEnd(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::End(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::End)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::End::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserArrowMarginCfgEndpointEnd() {
        return stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::End();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/Base.h line 77
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace ArrowMargin { namespace CfgEndpoint {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "CfgEdge";
            case 1L: return "CfgVertex";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserArrowMarginCfgEndpointType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserArrowMarginCfgEndpointType() {
        return stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::CfgEndpoint::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* OutputPart(int64_t i) {
        switch (i) {
            case 0L: return "FIRST_LINE";
            case 1L: return "LAST_LINE";
            case 2L: return "MIDDLE_LINE";
            case 3L: return "INTER_LINE";
            default: return "";
        }
    }

    std::string OutputPart(int64_t i, const std::string &strip) {
        std::string s = OutputPart(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OutputPart() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 91
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowStylePreset(int64_t i) {
        switch (i) {
            case 0L: return "UNICODE_1";
            case 1L: return "UNICODE_2";
            case 2L: return "ASCII_1";
            case 3L: return "ASCII_2";
            case 4L: return "ASCII_3";
            default: return "";
        }
    }

    std::string ArrowStylePreset(int64_t i, const std::string &strip) {
        std::string s = ArrowStylePreset(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowStylePreset() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 100
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowSide(int64_t i) {
        switch (i) {
            case 0L: return "LEFT";
            case 1L: return "RIGHT";
            default: return "";
        }
    }

    std::string ArrowSide(int64_t i, const std::string &strip) {
        std::string s = ArrowSide(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowSide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FunctionSimilarity.h line 73
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* CValKind(int64_t i) {
        switch (i) {
            case 0L: return "CARTESIAN_POINT";
            case 1L: return "ORDERED_LIST";
            default: return "";
        }
    }

    std::string CValKind(int64_t i, const std::string &strip) {
        std::string s = CValKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CValKind() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityCValKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::CValKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityCValKind() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FunctionSimilarity.h line 85
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* Statistic(int64_t i) {
        switch (i) {
            case 0L: return "AVERAGE";
            case 1L: return "MEDIAN";
            case 2L: return "MAXIMUM";
            default: return "";
        }
    }

    std::string Statistic(int64_t i, const std::string &strip) {
        std::string s = Statistic(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statistic() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityStatistic(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::Statistic::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityStatistic() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/ExecutionEvent.h line 69
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic { namespace ExecutionEvent {
    const char* Action(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "BULK_MEMORY_MAP";
            case 2L: return "BULK_MEMORY_UNMAP";
            case 3L: return "BULK_MEMORY_WRITE";
            case 4L: return "BULK_MEMORY_HASH";
            case 5L: return "MEMORY_WRITE";
            case 6L: return "BULK_REGISTER_WRITE";
            case 7L: return "REGISTER_WRITE";
            case 8L: return "OS_SYSCALL";
            case 9L: return "OS_SHARED_MEMORY";
            default: return "";
        }
    }

    std::string Action(int64_t i, const std::string &strip) {
        std::string s = Action(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Action() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicExecutionEventAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicExecutionEventAction() {
        return stringify::Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* Update(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Update(int64_t i, const std::string &strip) {
        std::string s = Update(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::Update)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Update() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicUpdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::Update(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::Update)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::Update::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicUpdate() {
        return stringify::Rose::BinaryAnalysis::Concolic::Update();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ShowEvents(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "INPUT";
            case 2L: return "ALL";
            default: return "";
        }
    }

    std::string ShowEvents(int64_t i, const std::string &strip) {
        std::string s = ShowEvents(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ShowEvents)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowEvents() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicShowEvents(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ShowEvents(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ShowEvents)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ShowEvents::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicShowEvents() {
        return stringify::Rose::BinaryAnalysis::Concolic::ShowEvents();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ShowAssertions(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string ShowAssertions(int64_t i, const std::string &strip) {
        std::string s = ShowAssertions(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ShowAssertions)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowAssertions() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicShowAssertions(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ShowAssertions(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ShowAssertions)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ShowAssertions::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicShowAssertions() {
        return stringify::Rose::BinaryAnalysis::Concolic::ShowAssertions();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* InputType(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "ARGC";
            case 2L: return "ARGV";
            case 3L: return "ENVP";
            case 4L: return "SYSCALL_RET";
            case 5L: return "SHMEM_READ";
            default: return "";
        }
    }

    std::string InputType(int64_t i, const std::string &strip) {
        std::string s = InputType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::InputType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InputType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicInputType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::InputType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::InputType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::InputType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicInputType() {
        return stringify::Rose::BinaryAnalysis::Concolic::InputType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* IoDirection(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string IoDirection(int64_t i, const std::string &strip) {
        std::string s = IoDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::IoDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicIoDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::IoDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::IoDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::IoDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicIoDirection() {
        return stringify::Rose::BinaryAnalysis::Concolic::IoDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 58
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::When(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicWhen() {
        return stringify::Rose::BinaryAnalysis::Concolic::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 64
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ConcolicPhase(int64_t i) {
        switch (i) {
            case 0L: return "REPLAY";
            case 1L: return "EMULATION";
            case 2L: return "POST_EMULATION";
            default: return "";
        }
    }

    std::string ConcolicPhase(int64_t i, const std::string &strip) {
        std::string s = ConcolicPhase(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ConcolicPhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConcolicPhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicConcolicPhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ConcolicPhase(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ConcolicPhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ConcolicPhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicConcolicPhase() {
        return stringify::Rose::BinaryAnalysis::Concolic::ConcolicPhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Reachability.h line 36
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Reachability {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "NOT_REACHABLE";
            case 1L: return "PROGRAM_ENTRY_POINT";
            case 2L: return "EXPORTED_FUNCTION";
            case 4L: return "SIGNAL_HANDLER";
            case 128L: return "ASSUMED";
            case 256L: return "EXPLICIT_MEM_CONSTANT";
            case 512L: return "EXPLICIT_INSN_CONSTANT";
            case 1024L: return "IMPLICIT_FUNC_CONSTANT";
            case 65536L: return "USER_DEFINED_0";
            case 131072L: return "USER_DEFINED_1";
            case 262144L: return "USER_DEFINED_2";
            case 524288L: return "USER_DEFINED_3";
            case 1048576L: return "USER_DEFINED_4";
            case 2097152L: return "USER_DEFINED_5";
            case 4194304L: return "USER_DEFINED_6";
            case 8388608L: return "USER_DEFINED_7";
            case 16777216L: return "USER_DEFINED_8";
            case 33554432L: return "USER_DEFINED_9";
            case 67108864L: return "USER_DEFINED_10";
            case 134217728L: return "USER_DEFINED_11";
            case 268435456L: return "USER_DEFINED_12";
            case 536870912L: return "USER_DEFINED_13";
            case 1073741824L: return "USER_DEFINED_14";
            case 2147483648L: return "USER_DEFINED_15";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            128L,
            256L,
            512L,
            1024L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisReachabilityReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Reachability::Reason(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Reachability::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisReachabilityReason() {
        return stringify::Rose::BinaryAnalysis::Reachability::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Aarch32.h line 25
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Aarch32 {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "V8";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Aarch32::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerAarch32Mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Aarch32::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Aarch32::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Aarch32::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerAarch32Mode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Aarch32::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Mips.h line 65
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Mips { namespace Decoder {
    const char* Architecture(int64_t i) {
        switch (i) {
            case 0L: return "Release1";
            case 1L: return "Release2";
            case 2L: return "Release3";
            case 3L: return "Micro";
            default: return "";
        }
    }

    std::string Architecture(int64_t i, const std::string &strip) {
        std::string s = Architecture(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Architecture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerMipsDecoderArchitecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerMipsDecoderArchitecture() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/X86.h line 150
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace X86 {
    const char* RegisterMode(int64_t i) {
        switch (i) {
            case 0L: return "rmLegacyByte";
            case 1L: return "rmRexByte";
            case 2L: return "rmWord";
            case 3L: return "rmDWord";
            case 4L: return "rmQWord";
            case 5L: return "rmSegment";
            case 6L: return "rmST";
            case 7L: return "rmMM";
            case 8L: return "rmXMM";
            case 9L: return "rmControl";
            case 10L: return "rmDebug";
            case 11L: return "rmReturnNull";
            default: return "";
        }
    }

    std::string RegisterMode(int64_t i, const std::string &strip) {
        std::string s = RegisterMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::X86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegisterMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86RegisterMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::X86::RegisterMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::X86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::X86::RegisterMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86RegisterMode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::X86::RegisterMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/X86.h line 155
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace X86 {
    const char* MMPrefix(int64_t i) {
        switch (i) {
            case 0L: return "mmNone";
            case 1L: return "mmF3";
            case 2L: return "mm66";
            case 3L: return "mmF2";
            default: return "";
        }
    }

    std::string MMPrefix(int64_t i, const std::string &strip) {
        std::string s = MMPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::X86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MMPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86MMPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::X86::MMPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::X86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::X86::MMPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86MMPrefix() {
        return stringify::Rose::BinaryAnalysis::Disassembler::X86::MMPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Aarch64.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Aarch64 {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "MODE_MCLASS";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Aarch64::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerAarch64Mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Aarch64::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Aarch64::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Aarch64::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerAarch64Mode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Aarch64::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 13
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionSize(int64_t i) {
        switch (i) {
            case 0L: return "x86_insnsize_none";
            case 1L: return "x86_insnsize_16";
            case 2L: return "x86_insnsize_32";
            case 3L: return "x86_insnsize_64";
            default: return "";
        }
    }

    std::string X86InstructionSize(int64_t i, const std::string &strip) {
        std::string s = X86InstructionSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionSize() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionSize() {
        return stringify::Rose::BinaryAnalysis::X86InstructionSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 21
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "x86_regclass_gpr";
            case 1L: return "x86_regclass_segment";
            case 2L: return "x86_regclass_cr";
            case 3L: return "x86_regclass_dr";
            case 4L: return "x86_regclass_st";
            case 5L: return "x86_regclass_xmm";
            case 6L: return "x86_regclass_ip";
            case 7L: return "x86_regclass_flags";
            default: return "";
        }
    }

    std::string X86RegisterClass(int64_t i, const std::string &strip) {
        std::string s = X86RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RegisterClass() {
        return stringify::Rose::BinaryAnalysis::X86RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86SegmentRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_segreg_es";
            case 1L: return "x86_segreg_cs";
            case 2L: return "x86_segreg_ss";
            case 3L: return "x86_segreg_ds";
            case 4L: return "x86_segreg_fs";
            case 5L: return "x86_segreg_gs";
            case 16L: return "x86_segreg_none";
            default: return "";
        }
    }

    std::string X86SegmentRegister(int64_t i, const std::string &strip) {
        std::string s = X86SegmentRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86SegmentRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86SegmentRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86SegmentRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86SegmentRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86SegmentRegister() {
        return stringify::Rose::BinaryAnalysis::X86SegmentRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86GeneralPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_gpr_ax";
            case 1L: return "x86_gpr_cx";
            case 2L: return "x86_gpr_dx";
            case 3L: return "x86_gpr_bx";
            case 4L: return "x86_gpr_sp";
            case 5L: return "x86_gpr_bp";
            case 6L: return "x86_gpr_si";
            case 7L: return "x86_gpr_di";
            case 8L: return "x86_gpr_r8";
            case 9L: return "x86_gpr_r9";
            case 10L: return "x86_gpr_r10";
            case 11L: return "x86_gpr_r11";
            case 12L: return "x86_gpr_r12";
            case 13L: return "x86_gpr_r13";
            case 14L: return "x86_gpr_r14";
            case 15L: return "x86_gpr_r15";
            default: return "";
        }
    }

    std::string X86GeneralPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = X86GeneralPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86GeneralPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86GeneralPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86GeneralPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86GeneralPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 65
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86StRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_st_0";
            case 1L: return "x86_st_1";
            case 2L: return "x86_st_2";
            case 3L: return "x86_st_3";
            case 4L: return "x86_st_4";
            case 5L: return "x86_st_5";
            case 6L: return "x86_st_6";
            case 7L: return "x86_st_7";
            case 8L: return "x86_st_nregs";
            default: return "";
        }
    }

    std::string X86StRegister(int64_t i, const std::string &strip) {
        std::string s = X86StRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86StRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86StRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86StRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86StRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86StRegister() {
        return stringify::Rose::BinaryAnalysis::X86StRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 78
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flags(int64_t i) {
        switch (i) {
            case 0L: return "x86_flags_status";
            case 1L: return "x86_flags_fpstatus";
            case 2L: return "x86_flags_fptag";
            case 3L: return "x86_flags_fpctl";
            case 4L: return "x86_flags_mxcsr";
            default: return "";
        }
    }

    std::string X86Flags(int64_t i, const std::string &strip) {
        std::string s = X86Flags(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flags(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flags() {
        return stringify::Rose::BinaryAnalysis::X86Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 87
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flag(int64_t i) {
        switch (i) {
            case 0L: return "x86_flag_cf";
            case 2L: return "x86_flag_pf";
            case 4L: return "x86_flag_af";
            case 6L: return "x86_flag_zf";
            case 7L: return "x86_flag_sf";
            case 8L: return "x86_flag_tf";
            case 9L: return "x86_flag_if";
            case 10L: return "x86_flag_df";
            case 11L: return "x86_flag_of";
            case 12L: return "x86_flag_iopl";
            case 14L: return "x86_flag_nt";
            case 16L: return "x86_flag_rf";
            case 17L: return "x86_flag_vm";
            case 18L: return "x86_flag_ac";
            case 19L: return "x86_flag_vif";
            case 20L: return "x86_flag_vip";
            case 21L: return "x86_flag_id";
            default: return "";
        }
    }

    std::string X86Flag(int64_t i, const std::string &strip) {
        std::string s = X86Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flag() {
        static const int64_t values[] = {
            0L,
            2L,
            4L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            14L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flag() {
        return stringify::Rose::BinaryAnalysis::X86Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 108
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86BranchPrediction(int64_t i) {
        switch (i) {
            case 0L: return "x86_branch_prediction_none";
            case 1L: return "x86_branch_prediction_taken";
            case 2L: return "x86_branch_prediction_not_taken";
            default: return "";
        }
    }

    std::string X86BranchPrediction(int64_t i, const std::string &strip) {
        std::string s = X86BranchPrediction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86BranchPrediction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86BranchPrediction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86BranchPrediction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86BranchPrediction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86BranchPrediction() {
        return stringify::Rose::BinaryAnalysis::X86BranchPrediction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 116
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RepeatPrefix(int64_t i) {
        switch (i) {
            case 0L: return "x86_repeat_none";
            case 1L: return "x86_repeat_repne";
            case 2L: return "x86_repeat_repe";
            default: return "";
        }
    }

    std::string X86RepeatPrefix(int64_t i, const std::string &strip) {
        std::string s = X86RepeatPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RepeatPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RepeatPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RepeatPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RepeatPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RepeatPrefix() {
        return stringify::Rose::BinaryAnalysis::X86RepeatPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 125
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Exception(int64_t i) {
        switch (i) {
            case 0L: return "x86_exception_int";
            case 1L: return "x86_exception_sysenter";
            case 2L: return "x86_exception_syscall";
            case 3L: return "x86_exception_de";
            case 4L: return "x86_exception_db";
            case 5L: return "x86_exception_bp";
            case 6L: return "x86_exception_of";
            case 7L: return "x86_exception_br";
            case 8L: return "x86_exception_ud";
            case 9L: return "x86_exception_nm";
            case 10L: return "x86_exception_df";
            case 11L: return "x86_exception_ts";
            case 12L: return "x86_exception_np";
            case 13L: return "x86_exception_ss";
            case 14L: return "x86_exception_gp";
            case 15L: return "x86_exception_pf";
            case 16L: return "x86_exception_mf";
            case 17L: return "x86_exception_ac";
            case 18L: return "x86_exception_mc";
            case 19L: return "x86_exception_xm";
            default: return "";
        }
    }

    std::string X86Exception(int64_t i, const std::string &strip) {
        std::string s = X86Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Exception() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Exception() {
        return stringify::Rose::BinaryAnalysis::X86Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/RegisterDictionary.h line 318
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace RegisterDictionary { namespace SortBySize {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "ASCENDING";
            case 1L: return "DESCENDING";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection() {
        return stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Partitioner.h line 1396
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Partitioner { namespace MayReturnVertexInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "INIT";
            case 1L: return "CALCULATING";
            case 2L: return "FINISHED";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/ModulesX86.h line 109
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace ModulesX86 { namespace SwitchSuccessors {
    const char* EntryType(int64_t i) {
        switch (i) {
            case 0L: return "ABSOLUTE";
            case 1L: return "RELATIVE";
            default: return "";
        }
    }

    std::string EntryType(int64_t i, const std::string &strip) {
        std::string s = EntryType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EntryType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ModulesX86SwitchSuccessorsEntryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ModulesX86SwitchSuccessorsEntryType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/DataFlow.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace DataFlow { namespace DfCfgVertex {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "BBLOCK";
            case 1L: return "FAKED_CALL";
            case 2L: return "FUNCRET";
            case 3L: return "INDET";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/CfgPath.h line 472
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Inliner {
    const char* HowInline(int64_t i) {
        switch (i) {
            case 0L: return "INLINE_NONE";
            case 1L: return "INLINE_NORMAL";
            case 2L: return "INLINE_USER";
            default: return "";
        }
    }

    std::string HowInline(int64_t i, const std::string &strip) {
        std::string s = HowInline(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HowInline() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2InlinerHowInline(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2InlinerHowInline() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Precision {
    const char* Level(int64_t i) {
        switch (i) {
            case 0L: return "LOW";
            case 1L: return "HIGH";
            default: return "";
        }
    }

    std::string Level(int64_t i, const std::string &strip) {
        std::string s = Level(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Level() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PrecisionLevel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Precision::Level::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PrecisionLevel() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace AllowParallelEdges {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 51
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* VertexType(int64_t i) {
        switch (i) {
            case 0L: return "V_BASIC_BLOCK";
            case 1L: return "V_UNDISCOVERED";
            case 2L: return "V_INDETERMINATE";
            case 3L: return "V_NONEXISTING";
            case 4L: return "V_USER_DEFINED";
            default: return "";
        }
    }

    std::string VertexType(int64_t i, const std::string &strip) {
        std::string s = VertexType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VertexType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2VertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::VertexType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::VertexType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2VertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::VertexType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 62
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 1L: return "E_NORMAL";
            case 2L: return "E_FUNCTION_CALL";
            case 4L: return "E_FUNCTION_RETURN";
            case 8L: return "E_CALL_RETURN";
            case 16L: return "E_FUNCTION_XFER";
            case 32L: return "E_USER_DEFINED";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2EdgeType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 86
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* Confidence(int64_t i) {
        switch (i) {
            case 0L: return "ASSUMED";
            case 1L: return "PROVED";
            default: return "";
        }
    }

    std::string Confidence(int64_t i, const std::string &strip) {
        std::string s = Confidence(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Confidence() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2Confidence(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Confidence(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Confidence::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2Confidence() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Confidence();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 92
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 179
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* MemoryDataAdjustment(int64_t i) {
        switch (i) {
            case 0L: return "DATA_IS_CONSTANT";
            case 1L: return "DATA_IS_INITIALIZED";
            case 2L: return "DATA_NO_CHANGE";
            default: return "";
        }
    }

    std::string MemoryDataAdjustment(int64_t i, const std::string &strip) {
        std::string s = MemoryDataAdjustment(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryDataAdjustment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 312
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* FunctionReturnAnalysis(int64_t i) {
        switch (i) {
            case 0L: return "MAYRETURN_DEFAULT_YES";
            case 1L: return "MAYRETURN_DEFAULT_NO";
            case 2L: return "MAYRETURN_ALWAYS_YES";
            case 3L: return "MAYRETURN_ALWAYS_NO";
            default: return "";
        }
    }

    std::string FunctionReturnAnalysis(int64_t i, const std::string &strip) {
        std::string s = FunctionReturnAnalysis(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReturnAnalysis() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/ModulesElf.h line 88
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace ModulesElf { namespace FixUndefinedSymbols {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Reference.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Reference {
    const char* Granularity(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "ADDRESS";
            case 2L: return "INSTRUCTION";
            case 3L: return "BASIC_BLOCK";
            case 4L: return "FUNCTION";
            default: return "";
        }
    }

    std::string Granularity(int64_t i, const std::string &strip) {
        std::string s = Granularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Granularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ReferenceGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Reference::Granularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ReferenceGranularity() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Modules.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace BasicBlockCallback {
    const char* Termination(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE_DISCOVERY";
            case 1L: return "TERMINATE_NOW";
            case 2L: return "TERMINATE_PRIOR";
            default: return "";
        }
    }

    std::string Termination(int64_t i, const std::string &strip) {
        std::string s = Termination(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Termination() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Function.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Function {
    const char* Ownership(int64_t i) {
        switch (i) {
            case 0L: return "OWN_UNOWNED";
            case 1L: return "OWN_EXPLICIT";
            case 2L: return "OWN_PROVISIONAL";
            default: return "";
        }
    }

    std::string Ownership(int64_t i, const std::string &strip) {
        std::string s = Ownership(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ownership() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionOwnership(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Function::Ownership::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionOwnership() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 18
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32Exception(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_exception_svc";
            case 1L: return "aarch32_exception_udf";
            case 2L: return "aarch32_exception_hvc";
            default: return "";
        }
    }

    std::string Aarch32Exception(int64_t i, const std::string &strip) {
        std::string s = Aarch32Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32Exception() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32Exception() {
        return stringify::Rose::BinaryAnalysis::Aarch32Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 25
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_regclass_gpr";
            case 1L: return "aarch32_regclass_sys";
            case 2L: return "aarch32_regclass_ext";
            case 3L: return "aarch32_regclass_coproc";
            case 4L: return "aarch32_regclass_debug";
            default: return "";
        }
    }

    std::string Aarch32RegisterClass(int64_t i, const std::string &strip) {
        std::string s = Aarch32RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32RegisterClass() {
        return stringify::Rose::BinaryAnalysis::Aarch32RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32GeneralPurposeRegister(int64_t i) {
        switch (i) {
            case 9L: return "aarch32_gpr_sb";
            case 10L: return "aarch32_gpr_sl";
            case 11L: return "aarch32_gpr_fp";
            case 12L: return "aarch32_gpr_ip";
            case 13L: return "aarch32_gpr_sp";
            case 14L: return "aarch32_gpr_lr";
            case 15L: return "aarch32_gpr_pc";
            default: return "";
        }
    }

    std::string Aarch32GeneralPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32GeneralPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32GeneralPurposeRegister() {
        static const int64_t values[] = {
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32GeneralPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32GeneralPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32DebugRegister(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_debug_didr";
            case 6L: return "aarch32_debug_wfar";
            case 7L: return "aarch32_debug_vcr";
            case 9L: return "aarch32_debug_ecr";
            case 10L: return "aarch32_debug_dsccr";
            case 11L: return "aarch32_debug_dsmcr";
            case 32L: return "aarch32_debug_dtrrx";
            case 33L: return "aarch32_debug_itr";
            case 34L: return "aarch32_debug_dscr";
            case 35L: return "aarch32_debug_dtrtx";
            case 36L: return "aarch32_debug_drcr";
            case 64L: return "aarch32_debug_bvr0";
            case 80L: return "aarch32_debug_bcr0";
            case 96L: return "aarch32_debug_wvr0";
            case 112L: return "aarch32_debug_wcr0";
            case 192L: return "aarch32_debug_oslar";
            case 193L: return "aarch32_debug_oslsr";
            case 194L: return "aarch32_debug_ossrr";
            case 196L: return "aarch32_debug_prcr";
            case 197L: return "aarch32_debug_prsr";
            case 960L: return "aarch32_debug_itctrl";
            case 1000L: return "aarch32_debug_claimset";
            case 1001L: return "aarch32_debug_claimclr";
            case 1004L: return "aarch32_debug_lar";
            case 1005L: return "aarch32_debug_lsr";
            case 1006L: return "aarch32_debug_authstatus";
            case 1010L: return "aarch32_debug_devid";
            case 1011L: return "aarch32_debug_devtype";
            case 1012L: return "aarch32_debug_peripheralid0";
            case 1020L: return "aarch32_debug_componentid0";
            case 2000L: return "aarch32_debug_drar";
            case 2001L: return "aarch32_debug_dsar";
            default: return "";
        }
    }

    std::string Aarch32DebugRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32DebugRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32DebugRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32DebugRegister() {
        static const int64_t values[] = {
            0L,
            6L,
            7L,
            9L,
            10L,
            11L,
            32L,
            33L,
            34L,
            35L,
            36L,
            64L,
            80L,
            96L,
            112L,
            192L,
            193L,
            194L,
            196L,
            197L,
            960L,
            1000L,
            1001L,
            1004L,
            1005L,
            1006L,
            1010L,
            1011L,
            1012L,
            1020L,
            2000L,
            2001L
        };
        static const std::vector<int64_t> retval(values, values + 32);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32DebugRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32DebugRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32DebugRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32DebugRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32DebugRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32DebugRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 103
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32SystemRegister(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_sys_r8_usr";
            case 1L: return "aarch32_sys_r8_fiq";
            case 2L: return "aarch32_sys_r9_usr";
            case 3L: return "aarch32_sys_r9_fiq";
            case 4L: return "aarch32_sys_r10_usr";
            case 5L: return "aarch32_sys_r10_fiq";
            case 6L: return "aarch32_sys_r11_usr";
            case 7L: return "aarch32_sys_r11_fiq";
            case 8L: return "aarch32_sys_r12_usr";
            case 9L: return "aarch32_sys_r12_fiq";
            case 10L: return "aarch32_sys_sp_hyp";
            case 11L: return "aarch32_sys_sp_svc";
            case 12L: return "aarch32_sys_sp_abt";
            case 13L: return "aarch32_sys_sp_und";
            case 14L: return "aarch32_sys_sp_mon";
            case 15L: return "aarch32_sys_sp_irq";
            case 16L: return "aarch32_sys_sp_fiq";
            case 17L: return "aarch32_sys_sp_usr";
            case 18L: return "aarch32_sys_lr_svc";
            case 19L: return "aarch32_sys_lr_abt";
            case 20L: return "aarch32_sys_lr_und";
            case 21L: return "aarch32_sys_lr_mon";
            case 22L: return "aarch32_sys_lr_irq";
            case 23L: return "aarch32_sys_lr_fiq";
            case 24L: return "aarch32_sys_lr_usr";
            case 25L: return "aarch32_sys_cpsr";
            case 26L: return "aarch32_sys_apsr";
            case 27L: return "aarch32_sys_spsr";
            case 28L: return "aarch32_sys_spsr_hyp";
            case 29L: return "aarch32_sys_spsr_svc";
            case 30L: return "aarch32_sys_spsr_abt";
            case 31L: return "aarch32_sys_spsr_und";
            case 32L: return "aarch32_sys_spsr_mon";
            case 33L: return "aarch32_sys_spsr_irq";
            case 34L: return "aarch32_sys_spsr_fiq";
            case 35L: return "aarch32_sys_ipsr";
            case 36L: return "aarch32_sys_iepsr";
            case 37L: return "aarch32_sys_iapsr";
            case 38L: return "aarch32_sys_eapsr";
            case 39L: return "aarch32_sys_psr";
            case 40L: return "aarch32_sys_msp";
            case 41L: return "aarch32_sys_psp";
            case 42L: return "aarch32_sys_primask";
            case 43L: return "aarch32_sys_control";
            case 44L: return "aarch32_sys_fpsid";
            case 45L: return "aarch32_sys_fpscr";
            case 46L: return "aarch32_sys_fpexc";
            case 47L: return "aarch32_sys_fpinst";
            case 48L: return "aarch32_sys_fpinst2";
            case 49L: return "aarch32_sys_mvfr0";
            case 50L: return "aarch32_sys_mvfr1";
            case 51L: return "aarch32_sys_mvfr2";
            case 52L: return "aarch32_sys_itstate";
            case 53L: return "aarch32_sys_unknown";
            default: return "";
        }
    }

    std::string Aarch32SystemRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32SystemRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32SystemRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32SystemRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L
        };
        static const std::vector<int64_t> retval(values, values + 54);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32SystemRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32SystemRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32SystemRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32SystemRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32SystemRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32SystemRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64Exception(int64_t i) {
        switch (i) {
            case 0L: return "brk";
            default: return "";
        }
    }

    std::string Aarch64Exception(int64_t i, const std::string &strip) {
        std::string s = Aarch64Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64Exception() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64Exception() {
        return stringify::Rose::BinaryAnalysis::Aarch64Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 42
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "aarch64_regclass_gpr";
            case 1L: return "aarch64_regclass_sp";
            case 2L: return "aarch64_regclass_ext";
            case 3L: return "aarch64_regclass_pc";
            case 4L: return "aarch64_regclass_cc";
            case 5L: return "aarch64_regclass_system";
            default: return "";
        }
    }

    std::string Aarch64RegisterClass(int64_t i, const std::string &strip) {
        std::string s = Aarch64RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64RegisterClass() {
        return stringify::Rose::BinaryAnalysis::Aarch64RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 57
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64SystemRegisters(int64_t i) {
        switch (i) {
            case 0L: return "aarch64_system_actlr";
            case 4L: return "aarch64_system_ccsidr";
            case 8L: return "aarch64_system_clidr";
            case 12L: return "aarch64_system_cntfrq";
            case 16L: return "aarch64_system_cntpct";
            case 20L: return "aarch64_system_cntkctl";
            case 24L: return "aarch64_system_cntp_cval";
            case 28L: return "aarch64_system_cpacr";
            case 32L: return "aarch64_system_csselr";
            case 36L: return "aarch64_system_cntp_ctl";
            case 40L: return "aarch64_system_ctr";
            case 44L: return "aarch64_system_dczid";
            case 48L: return "aarch64_system_elr";
            case 52L: return "aarch64_system_esr";
            case 56L: return "aarch64_system_far";
            case 60L: return "aarch64_system_hcr";
            case 64L: return "aarch64_system_mair";
            case 68L: return "aarch64_system_midr";
            case 72L: return "aarch64_system_mpidr";
            case 76L: return "aarch64_system_scr";
            case 80L: return "aarch64_system_sctlr";
            case 84L: return "aarch64_system_spsr";
            case 88L: return "aarch64_system_tcr";
            case 92L: return "aarch64_system_tpidr";
            case 96L: return "aarch64_system_tpidrr0";
            case 100L: return "aarch64_system_ttbr0";
            case 104L: return "aarch64_system_ttbr1";
            case 108L: return "aarch64_system_vbar";
            case 112L: return "aarch64_system_vtcr";
            case 116L: return "aarch64_system_vttbr";
            default: return "";
        }
    }

    std::string Aarch64SystemRegisters(int64_t i, const std::string &strip) {
        std::string s = Aarch64SystemRegisters(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64SystemRegisters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64SystemRegisters() {
        static const int64_t values[] = {
            0L,
            4L,
            8L,
            12L,
            16L,
            20L,
            24L,
            28L,
            32L,
            36L,
            40L,
            44L,
            48L,
            52L,
            56L,
            60L,
            64L,
            68L,
            72L,
            76L,
            80L,
            84L,
            88L,
            92L,
            96L,
            100L,
            104L,
            108L,
            112L,
            116L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64SystemRegisters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64SystemRegisters(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64SystemRegisters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64SystemRegisters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64SystemRegisters() {
        return stringify::Rose::BinaryAnalysis::Aarch64SystemRegisters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/TaintedFlow.h line 23
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Taintedness(int64_t i) {
        switch (i) {
            case 0L: return "BOTTOM";
            case 1L: return "NOT_TAINTED";
            case 2L: return "TAINTED";
            case 3L: return "TOP";
            default: return "";
        }
    }

    std::string Taintedness(int64_t i, const std::string &strip) {
        std::string s = Taintedness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Taintedness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowTaintedness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Taintedness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowTaintedness() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/TaintedFlow.h line 30
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Approximation(int64_t i) {
        switch (i) {
            case 0L: return "UNDER_APPROXIMATE";
            case 1L: return "OVER_APPROXIMATE";
            default: return "";
        }
    }

    std::string Approximation(int64_t i, const std::string &strip) {
        std::string s = Approximation(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Approximation() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowApproximation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Approximation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowApproximation() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/PointerDetection.h line 177
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace PointerDetection { namespace PointerDescriptor {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPointerDetectionPointerDescriptorDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPointerDetectionPointerDescriptorDirection() {
        return stringify::Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ConcreteLocation.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ConcreteLocation {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_LOCATION";
            case 1L: return "REGISTER";
            case 2L: return "RELATIVE";
            case 3L: return "ABSOLUTE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ConcreteLocation::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcreteLocationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ConcreteLocation::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ConcreteLocation::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ConcreteLocation::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcreteLocationType() {
        return stringify::Rose::BinaryAnalysis::ConcreteLocation::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ByteOrder.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ByteOrder {
    const char* Endianness(int64_t i) {
        switch (i) {
            case 0L: return "ORDER_UNSPECIFIED";
            case 1L: return "ORDER_LSB";
            case 2L: return "ORDER_MSB";
            default: return "";
        }
    }

    std::string Endianness(int64_t i, const std::string &strip) {
        std::string s = Endianness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Endianness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisByteOrderEndianness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ByteOrder::Endianness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ByteOrder::Endianness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisByteOrderEndianness() {
        return stringify::Rose::BinaryAnalysis::ByteOrder::Endianness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/HotPatch.h line 33
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PATCH_REGISTER";
            case 1L: return "PATCH_NONE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordType() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/HotPatch.h line 39
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "MATCH_CONTINUE";
            case 1L: return "MATCH_BREAK";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordBehavior() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsCil.h line 14
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* CilFamily(int64_t i) {
        switch (i) {
            case 4294967295L: return "Cil_family";
            default: return "";
        }
    }

    std::string CilFamily(int64_t i, const std::string &strip) {
        std::string s = CilFamily(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CilFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CilFamily() {
        static const int64_t values[] = {
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCilFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CilFamily(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CilFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CilFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCilFamily() {
        return stringify::Rose::BinaryAnalysis::CilFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsCil.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* CilInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "Cil_unknown_instruction";
            case 61440L: return "Cil_mono_icall";
            case 61441L: return "Cil_mono_objaddr";
            case 61442L: return "Cil_mono_ldptr";
            case 61443L: return "Cil_mono_vtaddr";
            case 61444L: return "Cil_mono_newobj";
            case 61445L: return "Cil_mono_retobj";
            case 61446L: return "Cil_mono_ldnativeobj";
            case 61447L: return "Cil_mono_cisinst";
            case 61448L: return "Cil_mono_ccastclass";
            case 61449L: return "Cil_mono_save_lmf";
            case 61450L: return "Cil_mono_restore_lmf";
            case 61451L: return "Cil_mono_classconst";
            case 61452L: return "Cil_mono_not_taken";
            case 61453L: return "Cil_mono_tls";
            case 61454L: return "Cil_mono_icall_addr";
            case 61455L: return "Cil_mono_dyn_call";
            case 61456L: return "Cil_mono_memory_barrier";
            case 61457L: return "Cil_unused71";
            case 61458L: return "Cil_unused72";
            case 61459L: return "Cil_mono_jit_icall_addr";
            case 61460L: return "Cil_mono_ldptr_int_req_flag";
            case 61461L: return "Cil_mono_ldptr_card_table";
            case 61462L: return "Cil_mono_ldptr_nursery_start";
            case 61463L: return "Cil_mono_ldptr_nursery_bits";
            case 61464L: return "Cil_mono_calli_extra_arg";
            case 61465L: return "Cil_mono_lddomain";
            case 61466L: return "Cil_mono_atomic_store_i4";
            case 61467L: return "Cil_mono_save_last_error";
            case 61468L: return "Cil_mono_get_rgctx_arg";
            case 61469L: return "Cil_mono_ldptr_prof_alloc_count";
            case 61470L: return "Cil_mono_ld_delegate_method_ptr";
            case 61471L: return "Cil_mono_rethrow";
            case 61472L: return "Cil_mono_get_sp";
            case 61473L: return "Cil_mono_methodconst";
            case 61474L: return "Cil_mono_pinvoke_addr_cache";
            case 61475L: return "Cil_last_instruction";
            case 65024L: return "Cil_arglist";
            case 65025L: return "Cil_ceq";
            case 65026L: return "Cil_cgt";
            case 65027L: return "Cil_cgt_un";
            case 65028L: return "Cil_clt";
            case 65029L: return "Cil_clt_un";
            case 65030L: return "Cil_ldftn";
            case 65031L: return "Cil_ldvirtftn";
            case 65032L: return "Cil_unused56";
            case 65033L: return "Cil_ldarg";
            case 65034L: return "Cil_ldarga";
            case 65035L: return "Cil_starg";
            case 65036L: return "Cil_ldloc";
            case 65037L: return "Cil_ldloca";
            case 65038L: return "Cil_stloc";
            case 65039L: return "Cil_localloc";
            case 65040L: return "Cil_unused57";
            case 65041L: return "Cil_endfilter";
            case 65042L: return "Cil_unaligned_";
            case 65043L: return "Cil_volatile_";
            case 65044L: return "Cil_tail_";
            case 65045L: return "Cil_initobj";
            case 65046L: return "Cil_constrained_";
            case 65047L: return "Cil_cpblk";
            case 65048L: return "Cil_initblk";
            case 65049L: return "Cil_no_";
            case 65050L: return "Cil_rethrow";
            case 65051L: return "Cil_unused";
            case 65052L: return "Cil_sizeof";
            case 65053L: return "Cil_refanytype";
            case 65054L: return "Cil_readonly_";
            case 65055L: return "Cil_unused53";
            case 65056L: return "Cil_unused54";
            case 65057L: return "Cil_unused55";
            case 65058L: return "Cil_unused70";
            case 65280L: return "Cil_nop";
            case 65281L: return "Cil_break";
            case 65282L: return "Cil_ldarg_0";
            case 65283L: return "Cil_ldarg_1";
            case 65284L: return "Cil_ldarg_2";
            case 65285L: return "Cil_ldarg_3";
            case 65286L: return "Cil_ldloc_0";
            case 65287L: return "Cil_ldloc_1";
            case 65288L: return "Cil_ldloc_2";
            case 65289L: return "Cil_ldloc_3";
            case 65290L: return "Cil_stloc_0";
            case 65291L: return "Cil_stloc_1";
            case 65292L: return "Cil_stloc_2";
            case 65293L: return "Cil_stloc_3";
            case 65294L: return "Cil_ldarg_s";
            case 65295L: return "Cil_ldarga_s";
            case 65296L: return "Cil_starg_s";
            case 65297L: return "Cil_ldloc_s";
            case 65298L: return "Cil_ldloca_s";
            case 65299L: return "Cil_stloc_s";
            case 65300L: return "Cil_ldnull";
            case 65301L: return "Cil_ldc_i4_m1";
            case 65302L: return "Cil_ldc_i4_0";
            case 65303L: return "Cil_ldc_i4_1";
            case 65304L: return "Cil_ldc_i4_2";
            case 65305L: return "Cil_ldc_i4_3";
            case 65306L: return "Cil_ldc_i4_4";
            case 65307L: return "Cil_ldc_i4_5";
            case 65308L: return "Cil_ldc_i4_6";
            case 65309L: return "Cil_ldc_i4_7";
            case 65310L: return "Cil_ldc_i4_8";
            case 65311L: return "Cil_ldc_i4_s";
            case 65312L: return "Cil_ldc_i4";
            case 65313L: return "Cil_ldc_i8";
            case 65314L: return "Cil_ldc_r4";
            case 65315L: return "Cil_ldc_r8";
            case 65316L: return "Cil_unused99";
            case 65317L: return "Cil_dup";
            case 65318L: return "Cil_pop";
            case 65319L: return "Cil_jmp";
            case 65320L: return "Cil_call";
            case 65321L: return "Cil_calli";
            case 65322L: return "Cil_ret";
            case 65323L: return "Cil_br_s";
            case 65324L: return "Cil_brfalse_s";
            case 65325L: return "Cil_brtrue_s";
            case 65326L: return "Cil_beq_s";
            case 65327L: return "Cil_bge_s";
            case 65328L: return "Cil_bgt_s";
            case 65329L: return "Cil_ble_s";
            case 65330L: return "Cil_blt_s";
            case 65331L: return "Cil_bne_un_s";
            case 65332L: return "Cil_bge_un_s";
            case 65333L: return "Cil_bgt_un_s";
            case 65334L: return "Cil_ble_un_s";
            case 65335L: return "Cil_blt_un_s";
            case 65336L: return "Cil_br";
            case 65337L: return "Cil_brfalse";
            case 65338L: return "Cil_brtrue";
            case 65339L: return "Cil_beq";
            case 65340L: return "Cil_bge";
            case 65341L: return "Cil_bgt";
            case 65342L: return "Cil_ble";
            case 65343L: return "Cil_blt";
            case 65344L: return "Cil_bne_un";
            case 65345L: return "Cil_bge_un";
            case 65346L: return "Cil_bgt_un";
            case 65347L: return "Cil_ble_un";
            case 65348L: return "Cil_blt_un";
            case 65349L: return "Cil_switch";
            case 65350L: return "Cil_ldind_i1";
            case 65351L: return "Cil_ldind_u1";
            case 65352L: return "Cil_ldind_i2";
            case 65353L: return "Cil_ldind_u2";
            case 65354L: return "Cil_ldind_i4";
            case 65355L: return "Cil_ldind_u4";
            case 65356L: return "Cil_ldind_i8";
            case 65357L: return "Cil_ldind_i";
            case 65358L: return "Cil_ldind_r4";
            case 65359L: return "Cil_ldind_r8";
            case 65360L: return "Cil_ldind_ref";
            case 65361L: return "Cil_stind_ref";
            case 65362L: return "Cil_stind_i1";
            case 65363L: return "Cil_stind_i2";
            case 65364L: return "Cil_stind_i4";
            case 65365L: return "Cil_stind_i8";
            case 65366L: return "Cil_stind_r4";
            case 65367L: return "Cil_stind_r8";
            case 65368L: return "Cil_add";
            case 65369L: return "Cil_sub";
            case 65370L: return "Cil_mul";
            case 65371L: return "Cil_div";
            case 65372L: return "Cil_div_un";
            case 65373L: return "Cil_rem";
            case 65374L: return "Cil_rem_un";
            case 65375L: return "Cil_and";
            case 65376L: return "Cil_or";
            case 65377L: return "Cil_xor";
            case 65378L: return "Cil_shl";
            case 65379L: return "Cil_shr";
            case 65380L: return "Cil_shr_un";
            case 65381L: return "Cil_neg";
            case 65382L: return "Cil_not";
            case 65383L: return "Cil_conv_i1";
            case 65384L: return "Cil_conv_i2";
            case 65385L: return "Cil_conv_i4";
            case 65386L: return "Cil_conv_i8";
            case 65387L: return "Cil_conv_r4";
            case 65388L: return "Cil_conv_r8";
            case 65389L: return "Cil_conv_u4";
            case 65390L: return "Cil_conv_u8";
            case 65391L: return "Cil_callvirt";
            case 65392L: return "Cil_cpobj";
            case 65393L: return "Cil_ldobj";
            case 65394L: return "Cil_ldstr";
            case 65395L: return "Cil_newobj";
            case 65396L: return "Cil_castclass";
            case 65397L: return "Cil_isinst";
            case 65398L: return "Cil_conv_r_un";
            case 65399L: return "Cil_unused58";
            case 65400L: return "Cil_unused1";
            case 65401L: return "Cil_unbox";
            case 65402L: return "Cil_throw";
            case 65403L: return "Cil_ldfld";
            case 65404L: return "Cil_ldflda";
            case 65405L: return "Cil_stfld";
            case 65406L: return "Cil_ldsfld";
            case 65407L: return "Cil_ldsflda";
            case 65408L: return "Cil_stsfld";
            case 65409L: return "Cil_stobj";
            case 65410L: return "Cil_conv_ovf_i1_un";
            case 65411L: return "Cil_conv_ovf_i2_un";
            case 65412L: return "Cil_conv_ovf_i4_un";
            case 65413L: return "Cil_conv_ovf_i8_un";
            case 65414L: return "Cil_conv_ovf_u1_un";
            case 65415L: return "Cil_conv_ovf_u2_un";
            case 65416L: return "Cil_conv_ovf_u4_un";
            case 65417L: return "Cil_conv_ovf_u8_un";
            case 65418L: return "Cil_conv_ovf_i_un";
            case 65419L: return "Cil_conv_ovf_u_un";
            case 65420L: return "Cil_box";
            case 65421L: return "Cil_newarr";
            case 65422L: return "Cil_ldlen";
            case 65423L: return "Cil_ldelema";
            case 65424L: return "Cil_ldelem_i1";
            case 65425L: return "Cil_ldelem_u1";
            case 65426L: return "Cil_ldelem_i2";
            case 65427L: return "Cil_ldelem_u2";
            case 65428L: return "Cil_ldelem_i4";
            case 65429L: return "Cil_ldelem_u4";
            case 65430L: return "Cil_ldelem_i8";
            case 65431L: return "Cil_ldelem_i";
            case 65432L: return "Cil_ldelem_r4";
            case 65433L: return "Cil_ldelem_r8";
            case 65434L: return "Cil_ldelem_ref";
            case 65435L: return "Cil_stelem_i";
            case 65436L: return "Cil_stelem_i1";
            case 65437L: return "Cil_stelem_i2";
            case 65438L: return "Cil_stelem_i4";
            case 65439L: return "Cil_stelem_i8";
            case 65440L: return "Cil_stelem_r4";
            case 65441L: return "Cil_stelem_r8";
            case 65442L: return "Cil_stelem_ref";
            case 65443L: return "Cil_ldelem";
            case 65444L: return "Cil_stelem";
            case 65445L: return "Cil_unbox_any";
            case 65446L: return "Cil_unused5";
            case 65447L: return "Cil_unused6";
            case 65448L: return "Cil_unused7";
            case 65449L: return "Cil_unused8";
            case 65450L: return "Cil_unused9";
            case 65451L: return "Cil_unused10";
            case 65452L: return "Cil_unused11";
            case 65453L: return "Cil_unused12";
            case 65454L: return "Cil_unused13";
            case 65455L: return "Cil_unused14";
            case 65456L: return "Cil_unused15";
            case 65457L: return "Cil_unused16";
            case 65458L: return "Cil_unused17";
            case 65459L: return "Cil_conv_ovf_i1";
            case 65460L: return "Cil_conv_ovf_u1";
            case 65461L: return "Cil_conv_ovf_i2";
            case 65462L: return "Cil_conv_ovf_u2";
            case 65463L: return "Cil_conv_ovf_i4";
            case 65464L: return "Cil_conv_ovf_u4";
            case 65465L: return "Cil_conv_ovf_i8";
            case 65466L: return "Cil_conv_ovf_u8";
            case 65467L: return "Cil_unused50";
            case 65468L: return "Cil_unused18";
            case 65469L: return "Cil_unused19";
            case 65470L: return "Cil_unused20";
            case 65471L: return "Cil_unused21";
            case 65472L: return "Cil_unused22";
            case 65473L: return "Cil_unused23";
            case 65474L: return "Cil_refanyval";
            case 65475L: return "Cil_ckfinite";
            case 65476L: return "Cil_unused24";
            case 65477L: return "Cil_unused25";
            case 65478L: return "Cil_mkrefany";
            case 65479L: return "Cil_unused59";
            case 65480L: return "Cil_unused60";
            case 65481L: return "Cil_unused61";
            case 65482L: return "Cil_unused62";
            case 65483L: return "Cil_unused63";
            case 65484L: return "Cil_unused64";
            case 65485L: return "Cil_unused65";
            case 65486L: return "Cil_unused66";
            case 65487L: return "Cil_unused67";
            case 65488L: return "Cil_ldtoken";
            case 65489L: return "Cil_conv_u2";
            case 65490L: return "Cil_conv_u1";
            case 65491L: return "Cil_conv_i";
            case 65492L: return "Cil_conv_ovf_i";
            case 65493L: return "Cil_conv_ovf_u";
            case 65494L: return "Cil_add_ovf";
            case 65495L: return "Cil_add_ovf_un";
            case 65496L: return "Cil_mul_ovf";
            case 65497L: return "Cil_mul_ovf_un";
            case 65498L: return "Cil_sub_ovf";
            case 65499L: return "Cil_sub_ovf_un";
            case 65500L: return "Cil_endfinally";
            case 65501L: return "Cil_leave";
            case 65502L: return "Cil_leave_s";
            case 65503L: return "Cil_stind_i";
            case 65504L: return "Cil_conv_u";
            case 65505L: return "Cil_unused26";
            case 65506L: return "Cil_unused27";
            case 65507L: return "Cil_unused28";
            case 65508L: return "Cil_unused29";
            case 65509L: return "Cil_unused30";
            case 65510L: return "Cil_unused31";
            case 65511L: return "Cil_unused32";
            case 65512L: return "Cil_unused33";
            case 65513L: return "Cil_unused34";
            case 65514L: return "Cil_unused35";
            case 65515L: return "Cil_unused36";
            case 65516L: return "Cil_unused37";
            case 65517L: return "Cil_unused38";
            case 65518L: return "Cil_unused39";
            case 65519L: return "Cil_unused40";
            case 65520L: return "Cil_unused41";
            case 65521L: return "Cil_unused42";
            case 65522L: return "Cil_unused43";
            case 65523L: return "Cil_unused44";
            case 65524L: return "Cil_unused45";
            case 65525L: return "Cil_unused46";
            case 65526L: return "Cil_unused47";
            case 65527L: return "Cil_unused48";
            case 65528L: return "Cil_prefix7";
            case 65529L: return "Cil_prefix6";
            case 65530L: return "Cil_prefix5";
            case 65531L: return "Cil_prefix4";
            case 65532L: return "Cil_prefix3";
            case 65533L: return "Cil_prefix2";
            case 65534L: return "Cil_prefix1";
            case 65535L: return "Cil_prefixref";
            default: return "";
        }
    }

    std::string CilInstructionKind(int64_t i, const std::string &strip) {
        std::string s = CilInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CilInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CilInstructionKind() {
        static const int64_t values[] = {
            0L,
            61440L,
            61441L,
            61442L,
            61443L,
            61444L,
            61445L,
            61446L,
            61447L,
            61448L,
            61449L,
            61450L,
            61451L,
            61452L,
            61453L,
            61454L,
            61455L,
            61456L,
            61457L,
            61458L,
            61459L,
            61460L,
            61461L,
            61462L,
            61463L,
            61464L,
            61465L,
            61466L,
            61467L,
            61468L,
            61469L,
            61470L,
            61471L,
            61472L,
            61473L,
            61474L,
            61475L,
            65024L,
            65025L,
            65026L,
            65027L,
            65028L,
            65029L,
            65030L,
            65031L,
            65032L,
            65033L,
            65034L,
            65035L,
            65036L,
            65037L,
            65038L,
            65039L,
            65040L,
            65041L,
            65042L,
            65043L,
            65044L,
            65045L,
            65046L,
            65047L,
            65048L,
            65049L,
            65050L,
            65051L,
            65052L,
            65053L,
            65054L,
            65055L,
            65056L,
            65057L,
            65058L,
            65280L,
            65281L,
            65282L,
            65283L,
            65284L,
            65285L,
            65286L,
            65287L,
            65288L,
            65289L,
            65290L,
            65291L,
            65292L,
            65293L,
            65294L,
            65295L,
            65296L,
            65297L,
            65298L,
            65299L,
            65300L,
            65301L,
            65302L,
            65303L,
            65304L,
            65305L,
            65306L,
            65307L,
            65308L,
            65309L,
            65310L,
            65311L,
            65312L,
            65313L,
            65314L,
            65315L,
            65316L,
            65317L,
            65318L,
            65319L,
            65320L,
            65321L,
            65322L,
            65323L,
            65324L,
            65325L,
            65326L,
            65327L,
            65328L,
            65329L,
            65330L,
            65331L,
            65332L,
            65333L,
            65334L,
            65335L,
            65336L,
            65337L,
            65338L,
            65339L,
            65340L,
            65341L,
            65342L,
            65343L,
            65344L,
            65345L,
            65346L,
            65347L,
            65348L,
            65349L,
            65350L,
            65351L,
            65352L,
            65353L,
            65354L,
            65355L,
            65356L,
            65357L,
            65358L,
            65359L,
            65360L,
            65361L,
            65362L,
            65363L,
            65364L,
            65365L,
            65366L,
            65367L,
            65368L,
            65369L,
            65370L,
            65371L,
            65372L,
            65373L,
            65374L,
            65375L,
            65376L,
            65377L,
            65378L,
            65379L,
            65380L,
            65381L,
            65382L,
            65383L,
            65384L,
            65385L,
            65386L,
            65387L,
            65388L,
            65389L,
            65390L,
            65391L,
            65392L,
            65393L,
            65394L,
            65395L,
            65396L,
            65397L,
            65398L,
            65399L,
            65400L,
            65401L,
            65402L,
            65403L,
            65404L,
            65405L,
            65406L,
            65407L,
            65408L,
            65409L,
            65410L,
            65411L,
            65412L,
            65413L,
            65414L,
            65415L,
            65416L,
            65417L,
            65418L,
            65419L,
            65420L,
            65421L,
            65422L,
            65423L,
            65424L,
            65425L,
            65426L,
            65427L,
            65428L,
            65429L,
            65430L,
            65431L,
            65432L,
            65433L,
            65434L,
            65435L,
            65436L,
            65437L,
            65438L,
            65439L,
            65440L,
            65441L,
            65442L,
            65443L,
            65444L,
            65445L,
            65446L,
            65447L,
            65448L,
            65449L,
            65450L,
            65451L,
            65452L,
            65453L,
            65454L,
            65455L,
            65456L,
            65457L,
            65458L,
            65459L,
            65460L,
            65461L,
            65462L,
            65463L,
            65464L,
            65465L,
            65466L,
            65467L,
            65468L,
            65469L,
            65470L,
            65471L,
            65472L,
            65473L,
            65474L,
            65475L,
            65476L,
            65477L,
            65478L,
            65479L,
            65480L,
            65481L,
            65482L,
            65483L,
            65484L,
            65485L,
            65486L,
            65487L,
            65488L,
            65489L,
            65490L,
            65491L,
            65492L,
            65493L,
            65494L,
            65495L,
            65496L,
            65497L,
            65498L,
            65499L,
            65500L,
            65501L,
            65502L,
            65503L,
            65504L,
            65505L,
            65506L,
            65507L,
            65508L,
            65509L,
            65510L,
            65511L,
            65512L,
            65513L,
            65514L,
            65515L,
            65516L,
            65517L,
            65518L,
            65519L,
            65520L,
            65521L,
            65522L,
            65523L,
            65524L,
            65525L,
            65526L,
            65527L,
            65528L,
            65529L,
            65530L,
            65531L,
            65532L,
            65533L,
            65534L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 328);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCilInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CilInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CilInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CilInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCilInstructionKind() {
        return stringify::Rose::BinaryAnalysis::CilInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 12
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcCapability(int64_t i) {
        switch (i) {
            case 1L: return "powerpc_capability_uisa";
            case 2L: return "powerpc_capability_vea";
            case 4L: return "powerpc_capability_oea";
            case 8L: return "powerpc_capability_440fpu";
            case 16L: return "powerpc_capability_uncategorized";
            case 23L: return "powerpc_capability_default";
            case 31L: return "powerpc_capability_all";
            default: return "";
        }
    }

    std::string PowerpcCapability(int64_t i, const std::string &strip) {
        std::string s = PowerpcCapability(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcCapability)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcCapability() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            23L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcCapability(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcCapability(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcCapability)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcCapability::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcCapability() {
        return stringify::Rose::BinaryAnalysis::PowerpcCapability();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 52
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcWordSize(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_32";
            case 1L: return "powerpc_64";
            default: return "";
        }
    }

    std::string PowerpcWordSize(int64_t i, const std::string &strip) {
        std::string s = PowerpcWordSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcWordSize() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcWordSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcWordSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcWordSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcWordSize() {
        return stringify::Rose::BinaryAnalysis::PowerpcWordSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 58
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_unknown_instruction";
            case 1L: return "powerpc_add";
            case 2L: return "powerpc_add_record";
            case 3L: return "powerpc_addo";
            case 4L: return "powerpc_addo_record";
            case 5L: return "powerpc_addc";
            case 6L: return "powerpc_addc_record";
            case 7L: return "powerpc_addco";
            case 8L: return "powerpc_addco_record";
            case 9L: return "powerpc_adde";
            case 10L: return "powerpc_adde_record";
            case 11L: return "powerpc_addeo";
            case 12L: return "powerpc_addeo_record";
            case 13L: return "powerpc_addi";
            case 14L: return "powerpc_addic";
            case 15L: return "powerpc_addic_record";
            case 16L: return "powerpc_addis";
            case 17L: return "powerpc_addme";
            case 18L: return "powerpc_addme_record";
            case 19L: return "powerpc_addmeo";
            case 20L: return "powerpc_addmeo_record";
            case 21L: return "powerpc_addze";
            case 22L: return "powerpc_addze_record";
            case 23L: return "powerpc_addzeo";
            case 24L: return "powerpc_addzeo_record";
            case 25L: return "powerpc_and";
            case 26L: return "powerpc_and_record";
            case 27L: return "powerpc_andc";
            case 28L: return "powerpc_andc_record";
            case 29L: return "powerpc_andi_record";
            case 30L: return "powerpc_andis_record";
            case 31L: return "powerpc_b";
            case 32L: return "powerpc_ba";
            case 33L: return "powerpc_bl";
            case 34L: return "powerpc_bla";
            case 35L: return "powerpc_bc";
            case 36L: return "powerpc_bca";
            case 37L: return "powerpc_bcl";
            case 38L: return "powerpc_bcla";
            case 39L: return "powerpc_bcctr";
            case 40L: return "powerpc_bcctrl";
            case 41L: return "powerpc_bclr";
            case 42L: return "powerpc_bclrl";
            case 43L: return "powerpc_cmp";
            case 44L: return "powerpc_cmpi";
            case 45L: return "powerpc_cmpl";
            case 46L: return "powerpc_cmpli";
            case 47L: return "powerpc_cntlzd";
            case 48L: return "powerpc_cntlzd_record";
            case 49L: return "powerpc_cntlzw";
            case 50L: return "powerpc_cntlzw_record";
            case 51L: return "powerpc_crand";
            case 52L: return "powerpc_crandc";
            case 53L: return "powerpc_creqv";
            case 54L: return "powerpc_crnand";
            case 55L: return "powerpc_crnor";
            case 56L: return "powerpc_cror";
            case 57L: return "powerpc_crorc";
            case 58L: return "powerpc_crxor";
            case 59L: return "powerpc_dcbf";
            case 60L: return "powerpc_dcba";
            case 61L: return "powerpc_dcbi";
            case 62L: return "powerpc_dcbst";
            case 63L: return "powerpc_dcbt";
            case 64L: return "powerpc_dcbtst";
            case 65L: return "powerpc_dcbz";
            case 66L: return "powerpc_divd";
            case 67L: return "powerpc_divd_record";
            case 68L: return "powerpc_divdo";
            case 69L: return "powerpc_divdo_record";
            case 70L: return "powerpc_divdu";
            case 71L: return "powerpc_divdu_record";
            case 72L: return "powerpc_divduo";
            case 73L: return "powerpc_divduo_record";
            case 74L: return "powerpc_divw";
            case 75L: return "powerpc_divw_record";
            case 76L: return "powerpc_divwo";
            case 77L: return "powerpc_divwo_record";
            case 78L: return "powerpc_divwu";
            case 79L: return "powerpc_divwu_record";
            case 80L: return "powerpc_divwuo";
            case 81L: return "powerpc_divwuo_record";
            case 82L: return "powerpc_dst";
            case 83L: return "powerpc_dstt";
            case 84L: return "powerpc_dstst";
            case 85L: return "powerpc_dststt";
            case 86L: return "powerpc_dss";
            case 87L: return "powerpc_dssall";
            case 88L: return "powerpc_eciwx";
            case 89L: return "powerpc_ecowx";
            case 90L: return "powerpc_eieio";
            case 91L: return "powerpc_eqv";
            case 92L: return "powerpc_eqv_record";
            case 93L: return "powerpc_extsb";
            case 94L: return "powerpc_extsb_record";
            case 95L: return "powerpc_extsh";
            case 96L: return "powerpc_extsh_record";
            case 97L: return "powerpc_extsw";
            case 98L: return "powerpc_extsw_record";
            case 99L: return "powerpc_fabs";
            case 100L: return "powerpc_fabs_record";
            case 101L: return "powerpc_fadd";
            case 102L: return "powerpc_fadd_record";
            case 103L: return "powerpc_fadds";
            case 104L: return "powerpc_fadds_record";
            case 105L: return "powerpc_fcfid";
            case 106L: return "powerpc_fcfid_record";
            case 107L: return "powerpc_fcmpo";
            case 108L: return "powerpc_fcmpu";
            case 109L: return "powerpc_fctid";
            case 110L: return "powerpc_fctid_record";
            case 111L: return "powerpc_fctidz";
            case 112L: return "powerpc_fctidz_record";
            case 113L: return "powerpc_fctiw";
            case 114L: return "powerpc_fctiw_record";
            case 115L: return "powerpc_fctiwz";
            case 116L: return "powerpc_fctiwz_record";
            case 117L: return "powerpc_fdiv";
            case 118L: return "powerpc_fdiv_record";
            case 119L: return "powerpc_fdivs";
            case 120L: return "powerpc_fdivs_record";
            case 121L: return "powerpc_fmadd";
            case 122L: return "powerpc_fmadd_record";
            case 123L: return "powerpc_fmadds";
            case 124L: return "powerpc_fmadds_record";
            case 125L: return "powerpc_fmr";
            case 126L: return "powerpc_fmr_record";
            case 127L: return "powerpc_fmsub";
            case 128L: return "powerpc_fmsub_record";
            case 129L: return "powerpc_fmsubs";
            case 130L: return "powerpc_fmsubs_record";
            case 131L: return "powerpc_fmul";
            case 132L: return "powerpc_fmul_record";
            case 133L: return "powerpc_fmuls";
            case 134L: return "powerpc_fmuls_record";
            case 135L: return "powerpc_fnabs";
            case 136L: return "powerpc_fnabs_record";
            case 137L: return "powerpc_fneg";
            case 138L: return "powerpc_fneg_record";
            case 139L: return "powerpc_fnmadd";
            case 140L: return "powerpc_fnmadd_record";
            case 141L: return "powerpc_fnmadds";
            case 142L: return "powerpc_fnmadds_record";
            case 143L: return "powerpc_fnmsub";
            case 144L: return "powerpc_fnmsub_record";
            case 145L: return "powerpc_fnmsubs";
            case 146L: return "powerpc_fnmsubs_record";
            case 147L: return "powerpc_fpmul";
            case 148L: return "powerpc_fxmul";
            case 149L: return "powerpc_fxpmul";
            case 150L: return "powerpc_fxsmul";
            case 151L: return "powerpc_fpadd";
            case 152L: return "powerpc_fpsub";
            case 153L: return "powerpc_fpre";
            case 154L: return "powerpc_fprsqrte";
            case 155L: return "powerpc_fpmr";
            case 156L: return "powerpc_fpabs";
            case 157L: return "powerpc_lfssx";
            case 158L: return "powerpc_fpneg";
            case 159L: return "powerpc_lfssux";
            case 160L: return "powerpc_fprsp";
            case 161L: return "powerpc_lfsdx";
            case 162L: return "powerpc_fpnabs";
            case 163L: return "powerpc_lfsdux";
            case 164L: return "powerpc_lfxsx";
            case 165L: return "powerpc_fsmr";
            case 166L: return "powerpc_lfxsux";
            case 167L: return "powerpc_lfxdx";
            case 168L: return "powerpc_fsabs";
            case 169L: return "powerpc_lfxdux";
            case 170L: return "powerpc_lfpsx";
            case 171L: return "powerpc_fsneg";
            case 172L: return "powerpc_lfpsux";
            case 173L: return "powerpc_lfpdx";
            case 174L: return "powerpc_fsnabs";
            case 175L: return "powerpc_lfpdux";
            case 176L: return "powerpc_stfpiwx";
            case 177L: return "powerpc_fxmr";
            case 178L: return "powerpc_fpctiw";
            case 179L: return "powerpc_stfssx";
            case 180L: return "powerpc_stfssux";
            case 181L: return "powerpc_fpctiwz";
            case 182L: return "powerpc_stfsdx";
            case 183L: return "powerpc_stfsdux";
            case 184L: return "powerpc_stfxsx";
            case 185L: return "powerpc_fsmtp";
            case 186L: return "powerpc_stfxsux";
            case 187L: return "powerpc_stfxdx";
            case 188L: return "powerpc_stfxdux";
            case 189L: return "powerpc_stfpsx";
            case 190L: return "powerpc_fsmfp";
            case 191L: return "powerpc_stfpsux";
            case 192L: return "powerpc_stfpdx";
            case 193L: return "powerpc_stfpdux";
            case 194L: return "powerpc_fpsel";
            case 195L: return "powerpc_fpmadd";
            case 196L: return "powerpc_fpmsub";
            case 197L: return "powerpc_fxmadd";
            case 198L: return "powerpc_fxcpmadd";
            case 199L: return "powerpc_fxcsmadd";
            case 200L: return "powerpc_fpnmadd";
            case 201L: return "powerpc_fxnmadd";
            case 202L: return "powerpc_fxcpnmadd";
            case 203L: return "powerpc_fxcsnmadd";
            case 204L: return "powerpc_fxcpnpma";
            case 205L: return "powerpc_fxmsub";
            case 206L: return "powerpc_fxcsnpma";
            case 207L: return "powerpc_fxcpmsub";
            case 208L: return "powerpc_fxcpnsma";
            case 209L: return "powerpc_fxcsmsub";
            case 210L: return "powerpc_fxcsnsma";
            case 211L: return "powerpc_fpnmsub";
            case 212L: return "powerpc_fxcxma";
            case 213L: return "powerpc_fxnmsub";
            case 214L: return "powerpc_fxcxnpma";
            case 215L: return "powerpc_fxcpnmsub";
            case 216L: return "powerpc_fxcxnsma";
            case 217L: return "powerpc_fxcsnmsub";
            case 218L: return "powerpc_fxcxnms";
            case 219L: return "powerpc_fre";
            case 220L: return "powerpc_fre_record";
            case 221L: return "powerpc_fres";
            case 222L: return "powerpc_fres_record";
            case 223L: return "powerpc_frsp";
            case 224L: return "powerpc_frsp_record";
            case 225L: return "powerpc_frsqrte";
            case 226L: return "powerpc_frsqrte_record";
            case 227L: return "powerpc_frsqrtes";
            case 228L: return "powerpc_frsqrtes_record";
            case 229L: return "powerpc_fsel";
            case 230L: return "powerpc_fsel_record";
            case 231L: return "powerpc_fsqrt";
            case 232L: return "powerpc_fsqrt_record";
            case 233L: return "powerpc_fsqrts";
            case 234L: return "powerpc_fsqrts_record";
            case 235L: return "powerpc_fsub";
            case 236L: return "powerpc_fsub_record";
            case 237L: return "powerpc_fsubs";
            case 238L: return "powerpc_fsubs_record";
            case 239L: return "powerpc_icbi";
            case 240L: return "powerpc_illegal";
            case 241L: return "powerpc_isync";
            case 242L: return "powerpc_lbz";
            case 243L: return "powerpc_lbzu";
            case 244L: return "powerpc_lbzux";
            case 245L: return "powerpc_lbzx";
            case 246L: return "powerpc_ld";
            case 247L: return "powerpc_ldarx";
            case 248L: return "powerpc_ldu";
            case 249L: return "powerpc_ldux";
            case 250L: return "powerpc_ldx";
            case 251L: return "powerpc_lfd";
            case 252L: return "powerpc_lfdu";
            case 253L: return "powerpc_lfdux";
            case 254L: return "powerpc_lfdx";
            case 255L: return "powerpc_lfs";
            case 256L: return "powerpc_lfsu";
            case 257L: return "powerpc_lfsux";
            case 258L: return "powerpc_lfsx";
            case 259L: return "powerpc_lha";
            case 260L: return "powerpc_lhau";
            case 261L: return "powerpc_lhaux";
            case 262L: return "powerpc_lhax";
            case 263L: return "powerpc_lhbrx";
            case 264L: return "powerpc_lhz";
            case 265L: return "powerpc_lhzu";
            case 266L: return "powerpc_lhzux";
            case 267L: return "powerpc_lhzx";
            case 268L: return "powerpc_lmw";
            case 269L: return "powerpc_lswi";
            case 270L: return "powerpc_lswx";
            case 271L: return "powerpc_lwa";
            case 272L: return "powerpc_lwarx";
            case 273L: return "powerpc_lwaux";
            case 274L: return "powerpc_lwax";
            case 275L: return "powerpc_lwbrx";
            case 276L: return "powerpc_lwz";
            case 277L: return "powerpc_lwzu";
            case 278L: return "powerpc_lwzux";
            case 279L: return "powerpc_lwzx";
            case 280L: return "powerpc_mcrf";
            case 281L: return "powerpc_mcrfs";
            case 282L: return "powerpc_mcrxr";
            case 283L: return "powerpc_mfcr";
            case 284L: return "powerpc_mffs";
            case 285L: return "powerpc_mffs_record";
            case 286L: return "powerpc_mfmsr";
            case 287L: return "powerpc_mfspr";
            case 288L: return "powerpc_mfsr";
            case 289L: return "powerpc_mfsrin";
            case 290L: return "powerpc_mftb";
            case 291L: return "powerpc_mtcrf";
            case 292L: return "powerpc_mtfsb0";
            case 293L: return "powerpc_mtfsb0_record";
            case 294L: return "powerpc_mtfsb1";
            case 295L: return "powerpc_mtfsb1_record";
            case 296L: return "powerpc_mtfsf";
            case 297L: return "powerpc_mtfsf_record";
            case 298L: return "powerpc_mtfsfi";
            case 299L: return "powerpc_mtfsfi_record";
            case 300L: return "powerpc_mtmsr";
            case 301L: return "powerpc_mtmsrd";
            case 302L: return "powerpc_mtspr";
            case 303L: return "powerpc_mtsr";
            case 304L: return "powerpc_mtsrd";
            case 305L: return "powerpc_mtsrdin";
            case 306L: return "powerpc_mtsrin";
            case 307L: return "powerpc_mulhd";
            case 308L: return "powerpc_mulhd_record";
            case 309L: return "powerpc_mulhdu";
            case 310L: return "powerpc_mulhdu_record";
            case 311L: return "powerpc_mulhw";
            case 312L: return "powerpc_mulhw_record";
            case 313L: return "powerpc_mulhwu";
            case 314L: return "powerpc_mulhwu_record";
            case 315L: return "powerpc_mulld";
            case 316L: return "powerpc_mulld_record";
            case 317L: return "powerpc_mulldo";
            case 318L: return "powerpc_mulldo_record";
            case 319L: return "powerpc_mulli";
            case 320L: return "powerpc_mullw";
            case 321L: return "powerpc_mullw_record";
            case 322L: return "powerpc_mullwo";
            case 323L: return "powerpc_mullwo_record";
            case 324L: return "powerpc_nand";
            case 325L: return "powerpc_nand_record";
            case 326L: return "powerpc_neg";
            case 327L: return "powerpc_neg_record";
            case 328L: return "powerpc_nego";
            case 329L: return "powerpc_nego_record";
            case 330L: return "powerpc_nor";
            case 331L: return "powerpc_nor_record";
            case 332L: return "powerpc_or";
            case 333L: return "powerpc_or_record";
            case 334L: return "powerpc_orc";
            case 335L: return "powerpc_orc_record";
            case 336L: return "powerpc_ori";
            case 337L: return "powerpc_oris";
            case 338L: return "powerpc_popcntb";
            case 339L: return "powerpc_rfi";
            case 340L: return "powerpc_rfid";
            case 341L: return "powerpc_rldcl";
            case 342L: return "powerpc_rldcl_record";
            case 343L: return "powerpc_rldcr";
            case 344L: return "powerpc_rldcr_record";
            case 345L: return "powerpc_rldic";
            case 346L: return "powerpc_rldic_record";
            case 347L: return "powerpc_rldicl";
            case 348L: return "powerpc_rldicl_record";
            case 349L: return "powerpc_rldicr";
            case 350L: return "powerpc_rldicr_record";
            case 351L: return "powerpc_rldimi";
            case 352L: return "powerpc_rldimi_record";
            case 353L: return "powerpc_rlwimi";
            case 354L: return "powerpc_rlwimi_record";
            case 355L: return "powerpc_rlwinm";
            case 356L: return "powerpc_rlwinm_record";
            case 357L: return "powerpc_rlwnm";
            case 358L: return "powerpc_rlwnm_record";
            case 359L: return "powerpc_sc";
            case 360L: return "powerpc_slbia";
            case 361L: return "powerpc_slbie";
            case 362L: return "powerpc_sld";
            case 363L: return "powerpc_sld_record";
            case 364L: return "powerpc_slw";
            case 365L: return "powerpc_slw_record";
            case 366L: return "powerpc_srad";
            case 367L: return "powerpc_srad_record";
            case 368L: return "powerpc_sradi";
            case 369L: return "powerpc_sradi_record";
            case 370L: return "powerpc_srd";
            case 371L: return "powerpc_srd_record";
            case 372L: return "powerpc_sraw";
            case 373L: return "powerpc_sraw_record";
            case 374L: return "powerpc_srawi";
            case 375L: return "powerpc_srawi_record";
            case 376L: return "powerpc_srw";
            case 377L: return "powerpc_srw_record";
            case 378L: return "powerpc_stb";
            case 379L: return "powerpc_stbu";
            case 380L: return "powerpc_stbux";
            case 381L: return "powerpc_stbx";
            case 382L: return "powerpc_std";
            case 383L: return "powerpc_stdcx_record";
            case 384L: return "powerpc_stdu";
            case 385L: return "powerpc_stdux";
            case 386L: return "powerpc_stdx";
            case 387L: return "powerpc_stfd";
            case 388L: return "powerpc_stfdu";
            case 389L: return "powerpc_stfdux";
            case 390L: return "powerpc_stfdx";
            case 391L: return "powerpc_stfiwx";
            case 392L: return "powerpc_stfs";
            case 393L: return "powerpc_stfsu";
            case 394L: return "powerpc_stfsux";
            case 395L: return "powerpc_stfsx";
            case 396L: return "powerpc_sth";
            case 397L: return "powerpc_sthbrx";
            case 398L: return "powerpc_sthu";
            case 399L: return "powerpc_sthux";
            case 400L: return "powerpc_sthx";
            case 401L: return "powerpc_stmw";
            case 402L: return "powerpc_stswi";
            case 403L: return "powerpc_stswx";
            case 404L: return "powerpc_stw";
            case 405L: return "powerpc_stwbrx";
            case 406L: return "powerpc_stwcx_record";
            case 407L: return "powerpc_stwu";
            case 408L: return "powerpc_stwux";
            case 409L: return "powerpc_stwx";
            case 410L: return "powerpc_subf";
            case 411L: return "powerpc_subf_record";
            case 412L: return "powerpc_subfo";
            case 413L: return "powerpc_subfo_record";
            case 414L: return "powerpc_subfc";
            case 415L: return "powerpc_subfc_record";
            case 416L: return "powerpc_subfco";
            case 417L: return "powerpc_subfco_record";
            case 418L: return "powerpc_subfe";
            case 419L: return "powerpc_subfe_record";
            case 420L: return "powerpc_subfeo";
            case 421L: return "powerpc_subfeo_record";
            case 422L: return "powerpc_subfic";
            case 423L: return "powerpc_subfme";
            case 424L: return "powerpc_subfme_record";
            case 425L: return "powerpc_subfmeo";
            case 426L: return "powerpc_subfmeo_record";
            case 427L: return "powerpc_subfze";
            case 428L: return "powerpc_subfze_record";
            case 429L: return "powerpc_subfzeo";
            case 430L: return "powerpc_subfzeo_record";
            case 431L: return "powerpc_sync";
            case 432L: return "powerpc_td";
            case 433L: return "powerpc_tdi";
            case 434L: return "powerpc_tlbia";
            case 435L: return "powerpc_tlbie";
            case 436L: return "powerpc_tlbsync";
            case 437L: return "powerpc_tw";
            case 438L: return "powerpc_twi";
            case 439L: return "powerpc_xor";
            case 440L: return "powerpc_xor_record";
            case 441L: return "powerpc_xori";
            case 442L: return "powerpc_xoris";
            case 443L: return "powerpc_last_instruction";
            default: return "";
        }
    }

    std::string PowerpcInstructionKind(int64_t i, const std::string &strip) {
        std::string s = PowerpcInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L
        };
        static const std::vector<int64_t> retval(values, values + 444);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcInstructionKind() {
        return stringify::Rose::BinaryAnalysis::PowerpcInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 506
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_regclass_unknown";
            case 1L: return "powerpc_regclass_gpr";
            case 2L: return "powerpc_regclass_fpr";
            case 3L: return "powerpc_regclass_cr";
            case 4L: return "powerpc_regclass_fpscr";
            case 5L: return "powerpc_regclass_spr";
            case 6L: return "powerpc_regclass_tbr";
            case 7L: return "powerpc_regclass_msr";
            case 8L: return "powerpc_regclass_sr";
            case 9L: return "powerpc_regclass_iar";
            case 10L: return "powerpc_regclass_pvr";
            case 11L: return "powerpc_last_register_class";
            default: return "";
        }
    }

    std::string PowerpcRegisterClass(int64_t i, const std::string &strip) {
        std::string s = PowerpcRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcRegisterClass() {
        return stringify::Rose::BinaryAnalysis::PowerpcRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 522
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcConditionRegisterAccessGranularity(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_condreggranularity_whole";
            case 1L: return "powerpc_condreggranularity_field";
            case 2L: return "powerpc_condreggranularity_bit";
            default: return "";
        }
    }

    std::string PowerpcConditionRegisterAccessGranularity(int64_t i, const std::string &strip) {
        std::string s = PowerpcConditionRegisterAccessGranularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcConditionRegisterAccessGranularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity() {
        return stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 529
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 1L: return "powerpc_spr_xer";
            case 8L: return "powerpc_spr_lr";
            case 9L: return "powerpc_spr_ctr";
            case 18L: return "powerpc_spr_dsisr";
            case 19L: return "powerpc_spr_dar";
            case 22L: return "powerpc_spr_dec";
            default: return "";
        }
    }

    std::string PowerpcSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcSpecialPurposeRegister() {
        static const int64_t values[] = {
            1L,
            8L,
            9L,
            18L,
            19L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 540
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcTimeBaseRegister(int64_t i) {
        switch (i) {
            case 268L: return "powerpc_tbr_tbl";
            case 269L: return "powerpc_tbr_tbu";
            default: return "";
        }
    }

    std::string PowerpcTimeBaseRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcTimeBaseRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcTimeBaseRegister() {
        static const int64_t values[] = {
            268L,
            269L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcTimeBaseRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcTimeBaseRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcTimeBaseRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h line 87
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace BaseSemantics {
    const char* AddressSpacePurpose(int64_t i) {
        switch (i) {
            case 0L: return "REGISTERS";
            case 1L: return "MEMORY";
            case 2L: return "INTERRUPTS";
            case 3L: return "USER";
            case 4L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string AddressSpacePurpose(int64_t i, const std::string &strip) {
        std::string s = AddressSpacePurpose(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::AddressSpacePurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AddressSpacePurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsAddressSpacePurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::AddressSpacePurpose(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::AddressSpacePurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::AddressSpacePurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsAddressSpacePurpose() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::AddressSpacePurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h line 105
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace BaseSemantics {
    const char* InputOutputProperty(int64_t i) {
        switch (i) {
            case 0L: return "IO_READ";
            case 1L: return "IO_WRITE";
            case 2L: return "IO_INIT";
            case 3L: return "IO_READ_BEFORE_WRITE";
            case 4L: return "IO_READ_AFTER_WRITE";
            case 5L: return "IO_READ_UNINITIALIZED";
            default: return "";
        }
    }

    std::string InputOutputProperty(int64_t i, const std::string &strip) {
        std::string s = InputOutputProperty(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InputOutputProperty() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsInputOutputProperty(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsInputOutputProperty() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/RiscOperators.h line 486
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace BaseSemantics { namespace RiscOperators {
    const char* IteStatus(int64_t i) {
        switch (i) {
            case 0L: return "NEITHER";
            case 1L: return "A";
            case 2L: return "B";
            case 3L: return "BOTH";
            default: return "";
        }
    }

    std::string IteStatus(int64_t i, const std::string &strip) {
        std::string s = IteStatus(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IteStatus() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsRiscOperatorsIteStatus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsRiscOperatorsIteStatus() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/IntervalSemantics.C line 925
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace IntervalSemantics {
    const char* Carry(int64_t i) {
        switch (i) {
            case 0L: return "C_FALSE";
            case 1L: return "C_TRUE";
            case 2L: return "C_UNKNOWN";
            default: return "";
        }
    }

    std::string Carry(int64_t i, const std::string &strip) {
        std::string s = Carry(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Carry() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsCarry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsCarry() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DataFlowSemantics.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DataFlowSemantics { namespace DataFlowEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "CLOBBER";
            case 1L: return "AUGMENT";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDataFlowSemanticsDataFlowEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDataFlowSemanticsDataFlowEdgeEdgeType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherPowerpc.C line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace UpdateCr {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsUpdateCrFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsUpdateCrFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherPowerpc.C line 36
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SaveLink {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSaveLinkFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSaveLinkFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherAarch32.h line 161
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherAarch32 {
    const char* SrType(int64_t i) {
        switch (i) {
            case 0L: return "LSL";
            case 1L: return "LSR";
            case 2L: return "ASR";
            case 3L: return "ROR";
            case 4L: return "RRX";
            default: return "";
        }
    }

    std::string SrType(int64_t i, const std::string &strip) {
        std::string s = SrType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SrType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32SrType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32SrType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherAarch32.h line 162
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherAarch32 {
    const char* BranchType(int64_t i) {
        switch (i) {
            case 0L: return "DIRCALL";
            case 1L: return "DIR";
            case 2L: return "INDCALL";
            case 3L: return "ERET";
            case 4L: return "DBGEXIT";
            case 5L: return "RET";
            case 6L: return "INDIR";
            case 7L: return "EXCEPTION";
            case 8L: return "RESET";
            case 9L: return "UNKNOWN";
            default: return "";
        }
    }

    std::string BranchType(int64_t i, const std::string &strip) {
        std::string s = BranchType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BranchType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32BranchType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32BranchType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 69
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics { namespace AllowSideEffects {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsAllowSideEffectsFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsAllowSideEffectsFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 705
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics {
    const char* WritersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_WRITERS";
            case 1L: return "TRACK_LATEST_WRITER";
            case 2L: return "TRACK_ALL_WRITERS";
            default: return "";
        }
    }

    std::string WritersMode(int64_t i, const std::string &strip) {
        std::string s = WritersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WritersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsWritersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsWritersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 712
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics {
    const char* DefinersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_DEFINERS";
            case 1L: return "TRACK_LATEST_DEFINER";
            case 2L: return "TRACK_ALL_DEFINERS";
            default: return "";
        }
    }

    std::string DefinersMode(int64_t i, const std::string &strip) {
        std::string s = DefinersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DefinersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsDefinersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsDefinersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherX86.h line 159
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherX86 {
    const char* AccessMode(int64_t i) {
        switch (i) {
            case 0L: return "READ_REGISTER";
            case 1L: return "PEEK_REGISTER";
            default: return "";
        }
    }

    std::string AccessMode(int64_t i, const std::string &strip) {
        std::string s = AccessMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AccessMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherX86AccessMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherX86AccessMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/TaintSemantics.h line 17
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace TaintSemantics {
    const char* Taintedness(int64_t i) {
        switch (i) {
            case 0L: return "BOTTOM";
            case 1L: return "UNTAINTED";
            case 2L: return "TAINTED";
            case 3L: return "TOP";
            default: return "";
        }
    }

    std::string Taintedness(int64_t i, const std::string &strip) {
        std::string s = Taintedness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Taintedness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsTaintSemanticsTaintedness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsTaintSemanticsTaintedness() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MagicNumber.h line 21
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MagicNumber {
    const char* Mechanism(int64_t i) {
        switch (i) {
            case 0L: return "FAST";
            case 1L: return "SLOW";
            case 2L: return "NONE";
            default: return "";
        }
    }

    std::string Mechanism(int64_t i, const std::string &strip) {
        std::string s = Mechanism(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mechanism() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMagicNumberMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MagicNumber::Mechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMagicNumberMechanism() {
        return stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SerialIo.h line 102
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Format(int64_t i) {
        switch (i) {
            case 0L: return "BINARY";
            case 1L: return "TEXT";
            case 2L: return "XML";
            default: return "";
        }
    }

    std::string Format(int64_t i, const std::string &strip) {
        std::string s = Format(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Format(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Format::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoFormat() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Format();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SerialIo.h line 113
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Savable(int64_t i) {
        switch (i) {
            case 0L: return "NO_OBJECT";
            case 1L: return "PARTITIONER";
            case 2L: return "AST";
            case 65534L: return "END_OF_DATA";
            case 65535L: return "ERROR";
            case 65536L: return "USER_DEFINED";
            case 4294967295L: return "USER_DEFINED_LAST";
            default: return "";
        }
    }

    std::string Savable(int64_t i, const std::string &strip) {
        std::string s = Savable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Savable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            65534L,
            65535L,
            65536L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoSavable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Savable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Savable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoSavable() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Savable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/PartitionerModel.h line 36
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker { namespace PartitionerModel { namespace Settings {
    const char* MemoryType(int64_t i) {
        switch (i) {
            case 0L: return "LIST";
            case 1L: return "MAP";
            default: return "";
        }
    }

    std::string MemoryType(int64_t i, const std::string &strip) {
        std::string s = MemoryType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerPartitionerModelSettingsMemoryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerPartitionerModelSettingsMemoryType() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 163
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* TestMode(int64_t i) {
        switch (i) {
            case 0L: return "OFF";
            case 1L: return "MAY";
            case 2L: return "MUST";
            default: return "";
        }
    }

    std::string TestMode(int64_t i, const std::string &strip) {
        std::string s = TestMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::TestMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TestMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerTestMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::TestMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::TestMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::TestMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerTestMode() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::TestMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 170
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* IoMode(int64_t i) {
        switch (i) {
            case 0L: return "WRITE";
            case 1L: return "READ";
            default: return "";
        }
    }

    std::string IoMode(int64_t i, const std::string &strip) {
        std::string s = IoMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::IoMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerIoMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::IoMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::IoMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::IoMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerIoMode() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::IoMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 176
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* Prune(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Prune(int64_t i, const std::string &strip) {
        std::string s = Prune(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::Prune)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Prune() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerPrune(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::Prune(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::Prune)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::Prune::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerPrune() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::Prune();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 182
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* WorkerState(int64_t i) {
        switch (i) {
            case 0L: return "STARTING";
            case 1L: return "WAITING";
            case 2L: return "WORKING";
            case 3L: return "FINISHED";
            default: return "";
        }
    }

    std::string WorkerState(int64_t i, const std::string &strip) {
        std::string s = WorkerState(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::WorkerState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WorkerState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerWorkerState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::WorkerState(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::WorkerState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::WorkerState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerWorkerState() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::WorkerState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Gdb.h line 172
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Gdb { namespace Response { namespace ResultRecord {
    const char* ResultClass(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "DONE";
            case 2L: return "RUNNING";
            case 3L: return "CONNECTED";
            case 4L: return "ERROR";
            case 5L: return "EXIT";
            default: return "";
        }
    }

    std::string ResultClass(int64_t i, const std::string &strip) {
        std::string s = ResultClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ResultClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseResultRecordResultClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseResultRecordResultClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* DetachMode(int64_t i) {
        switch (i) {
            case 0L: return "KILL";
            case 1L: return "DETACH";
            case 2L: return "CONTINUE";
            case 3L: return "NOTHING";
            default: return "";
        }
    }

    std::string DetachMode(int64_t i, const std::string &strip) {
        std::string s = DetachMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::DetachMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DetachMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxDetachMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::DetachMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::DetachMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::DetachMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxDetachMode() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::DetachMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* Flag(int64_t i) {
        switch (i) {
            case 1L: return "ATTACH";
            case 2L: return "REDIRECT_INPUT";
            case 4L: return "REDIRECT_OUTPUT";
            case 8L: return "REDIRECT_ERROR";
            case 16L: return "CLOSE_FILES";
            case 19L: return "DEFAULT_FLAGS";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxFlag() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 201
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* RegCacheType(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "REGS";
            case 2L: return "FPREGS";
            default: return "";
        }
    }

    std::string RegCacheType(int64_t i, const std::string &strip) {
        std::string s = RegCacheType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::RegCacheType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegCacheType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxRegCacheType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::RegCacheType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::RegCacheType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::RegCacheType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxRegCacheType() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::RegCacheType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/BasicTypes.h line 39
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger {
    const char* FilterActionFlag(int64_t i) {
        switch (i) {
            case 1L: return "REJECT";
            case 2L: return "STOP";
            default: return "";
        }
    }

    std::string FilterActionFlag(int64_t i, const std::string &strip) {
        std::string s = FilterActionFlag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::FilterActionFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FilterActionFlag() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerFilterActionFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::FilterActionFlag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::FilterActionFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::FilterActionFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerFilterActionFlag() {
        return stringify::Rose::BinaryAnalysis::Debugger::FilterActionFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_DIGITS";
            case 4L: return "TOK_SYMBOL";
            case 5L: return "TOK_STRING";
            case 6L: return "TOK_GDB";
            case 7L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseTokenType() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 68
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* ResultClass(int64_t i) {
        switch (i) {
            case 0L: return "DONE";
            case 1L: return "RUNNING";
            case 2L: return "CONNECTED";
            case 3L: return "ERROR";
            case 4L: return "EXIT";
            case 5L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string ResultClass(int64_t i, const std::string &strip) {
        std::string s = ResultClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ResultClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseResultClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseResultClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 71
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* AsyncClass(int64_t i) {
        switch (i) {
            case 0L: return "STOPPED";
            case 1L: return "RUNNING";
            case 2L: return "THREAD_GROUP_ADDED";
            case 3L: return "THREAD_GROUP_STARTED";
            case 4L: return "THREAD_GROUP_EXITED";
            case 5L: return "THREAD_CREATED";
            case 6L: return "THREAD_EXITED";
            case 7L: return "BREAKPOINT_MODIFIED";
            case 8L: return "OTHER";
            case 9L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string AsyncClass(int64_t i, const std::string &strip) {
        std::string s = AsyncClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AsyncClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseAsyncClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseAsyncClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Architecture/ArmAarch32.h line 56
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Architecture { namespace ArmAarch32 {
    const char* InstructionSet(int64_t i) {
        switch (i) {
            case 0L: return "T32";
            case 1L: return "A32";
            default: return "";
        }
    }

    std::string InstructionSet(int64_t i, const std::string &strip) {
        std::string s = InstructionSet(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InstructionSet() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArchitectureArmAarch32InstructionSet(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArchitectureArmAarch32InstructionSet() {
        return stringify::Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 137
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap { namespace Attach {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapAttachBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::Attach::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapAttachBoolean() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 144
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap {
    const char* Clobber(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Clobber(int64_t i, const std::string &strip) {
        std::string s = Clobber(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::Clobber)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Clobber() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapClobber(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::Clobber(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::Clobber)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::Clobber::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapClobber() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::Clobber();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 327
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap {
    const char* InsertFileMapMode(int64_t i) {
        switch (i) {
            case 0L: return "MAP_PRIVATE";
            case 1L: return "MAP_READWRITE";
            case 2L: return "MAP_RDONLY";
            default: return "";
        }
    }

    std::string InsertFileMapMode(int64_t i, const std::string &strip) {
        std::string s = InsertFileMapMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertFileMapMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapInsertFileMapMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapInsertFileMapMode() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/String.h line 198
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Strings {
    const char* State(int64_t i) {
        switch (i) {
            case -4L: return "ERROR_STATE";
            case -3L: return "INITIAL_STATE";
            case -2L: return "COMPLETED_STATE";
            case -1L: return "FINAL_STATE";
            case 0L: return "USER_DEFINED_0";
            case 1L: return "USER_DEFINED_1";
            case 2L: return "USER_DEFINED_2";
            case 128L: return "USER_DEFINED_MAX";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            -4L,
            -3L,
            -2L,
            -1L,
            0L,
            1L,
            2L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisStringsState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Strings::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Strings::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisStringsState() {
        return stringify::Rose::BinaryAnalysis::Strings::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Commit {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCommitBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Commit::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Commit::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCommitBoolean() {
        return stringify::Rose::BinaryAnalysis::Commit::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* AggregationDirection(int64_t i) {
        switch (i) {
            case 1L: return "AGGREGATE_PREDECESSORS";
            case 2L: return "AGGREGATE_SUCCESSORS";
            default: return "";
        }
    }

    std::string AggregationDirection(int64_t i, const std::string &strip) {
        std::string s = AggregationDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregationDirection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterAggregationDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::AggregationDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterAggregationDirection() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* NopPadding(int64_t i) {
        switch (i) {
            case 0L: return "PAD_NOP_BACK";
            case 1L: return "PAD_NOP_FRONT";
            case 2L: return "PAD_RANDOM_BACK";
            default: return "";
        }
    }

    std::string NopPadding(int64_t i, const std::string &strip) {
        std::string s = NopPadding(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NopPadding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterNopPadding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::NopPadding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterNopPadding() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "RELOC_INDEX_ABS_LE32";
            case 1L: return "RELOC_INDEX_ABS_LE32HI";
            case 2L: return "RELOC_INDEX_ABS_BE32";
            case 3L: return "RELOC_ADDR_REL_LE32";
            case 4L: return "RELOC_ADDR_REL_BE32";
            case 5L: return "RELOC_INSN_ABS_LE32";
            case 6L: return "RELOC_INSN_REL_LE32";
            case 7L: return "RELOC_INSN_REL_BE32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::RelocType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterRelocType() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/StackVariable.h line 23
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables { namespace StackVariable {
    const char* Purpose(int64_t i) {
        switch (i) {
            case 0L: return "RETURN_ADDRESS";
            case 1L: return "FRAME_POINTER";
            case 2L: return "STACK_POINTER";
            case 3L: return "SPILL_AREA";
            case 4L: return "NORMAL";
            case 5L: return "UNKNOWN";
            case 6L: return "OTHER";
            default: return "";
        }
    }

    std::string Purpose(int64_t i, const std::string &strip) {
        std::string s = Purpose(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::StackVariable::Purpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Purpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesStackVariablePurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::StackVariable::Purpose(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::StackVariable::Purpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::StackVariable::Purpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesStackVariablePurpose() {
        return stringify::Rose::BinaryAnalysis::Variables::StackVariable::Purpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/StackFrame.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables { namespace StackFrame {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "GROWS_UP";
            case 1L: return "GROWS_DOWN";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::StackFrame::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesStackFrameDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::StackFrame::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::StackFrame::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::StackFrame::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesStackFrameDirection() {
        return stringify::Rose::BinaryAnalysis::Variables::StackFrame::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/BasicTypes.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "READ";
            case 2L: return "WRITE";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::Access(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesAccess() {
        return stringify::Rose::BinaryAnalysis::Variables::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SearchMode(int64_t i) {
        switch (i) {
            case 0L: return "SEARCH_SINGLE_DFS";
            case 1L: return "SEARCH_SINGLE_BFS";
            case 2L: return "SEARCH_MULTI";
            default: return "";
        }
    }

    std::string SearchMode(int64_t i, const std::string &strip) {
        std::string s = SearchMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SearchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSearchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SearchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSearchMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* EdgeVisitOrder(int64_t i) {
        switch (i) {
            case 0L: return "VISIT_NATURAL";
            case 1L: return "VISIT_REVERSE";
            case 2L: return "VISIT_RANDOM";
            default: return "";
        }
    }

    std::string EdgeVisitOrder(int64_t i, const std::string &strip) {
        std::string s = EdgeVisitOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeVisitOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 57
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* IoMode(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string IoMode(int64_t i, const std::string &strip) {
        std::string s = IoMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathIoMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::IoMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathIoMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 60
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* MayOrMust(int64_t i) {
        switch (i) {
            case 0L: return "MAY";
            case 1L: return "MUST";
            default: return "";
        }
    }

    std::string MayOrMust(int64_t i, const std::string &strip) {
        std::string s = MayOrMust(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayOrMust() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathMayOrMust(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::MayOrMust::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathMayOrMust() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 180
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath { namespace PathProcessor {
    const char* Action(int64_t i) {
        switch (i) {
            case 0L: return "BREAK";
            case 1L: return "CONTINUE";
            default: return "";
        }
    }

    std::string Action(int64_t i, const std::string &strip) {
        std::string s = Action(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Action() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathPathProcessorAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathPathProcessorAction() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/BinaryLoader.h line 66
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* MappingContribution(int64_t i) {
        switch (i) {
            case 0L: return "CONTRIBUTE_NONE";
            case 1L: return "CONTRIBUTE_ADD";
            case 2L: return "CONTRIBUTE_SUB";
            default: return "";
        }
    }

    std::string MappingContribution(int64_t i, const std::string &strip) {
        std::string s = MappingContribution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MappingContribution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderMappingContribution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::MappingContribution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderMappingContribution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/BinaryLoader.h line 74
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* ConflictResolution(int64_t i) {
        switch (i) {
            case 0L: return "RESOLVE_THROW";
            case 1L: return "RESOLVE_OVERMAP";
            case 2L: return "RESOLVE_REMAP";
            case 3L: return "RESOLVE_REMAP_ABOVE";
            default: return "";
        }
    }

    std::string ConflictResolution(int64_t i, const std::string &strip) {
        std::string s = ConflictResolution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConflictResolution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderConflictResolution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::ConflictResolution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderConflictResolution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 55
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* LinkMode(int64_t i) {
        switch (i) {
            case 0L: return "LM_NONE";
            case 1L: return "LM_LIBRARY";
            case 2L: return "LM_EXECUTABLE";
            case 3L: return "LM_ANY";
            default: return "";
        }
    }

    std::string LinkMode(int64_t i, const std::string &strip) {
        std::string s = LinkMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LinkMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverLinkMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::LinkMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverLinkMode() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 67
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_TYPE";
            case 1L: return "BOOLEAN";
            case 2L: return "BIT_VECTOR";
            case 3L: return "MEM_STATE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverType() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 91
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Satisfiable(int64_t i) {
        switch (i) {
            case 0L: return "SAT_NO";
            case 1L: return "SAT_YES";
            case 2L: return "SAT_UNKNOWN";
            default: return "";
        }
    }

    std::string Satisfiable(int64_t i, const std::string &strip) {
        std::string s = Satisfiable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Satisfiable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverSatisfiable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Satisfiable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverSatisfiable() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackParameterOrder(int64_t i) {
        switch (i) {
            case 0L: return "LEFT_TO_RIGHT";
            case 1L: return "RIGHT_TO_LEFT";
            case 2L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackParameterOrder(int64_t i, const std::string &strip) {
        std::string s = StackParameterOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackParameterOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackParameterOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackParameterOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackParameterOrder() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackDirection(int64_t i) {
        switch (i) {
            case 0L: return "GROWS_UP";
            case 1L: return "GROWS_DOWN";
            default: return "";
        }
    }

    std::string StackDirection(int64_t i, const std::string &strip) {
        std::string s = StackDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackDirection() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackCleanup(int64_t i) {
        switch (i) {
            case 0L: return "BY_CALLER";
            case 1L: return "BY_CALLEE";
            case 2L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackCleanup(int64_t i, const std::string &strip) {
        std::string s = StackCleanup(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackCleanup() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackCleanup(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackCleanup::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackCleanup() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsJvm.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* JvmInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "nop";
            case 1L: return "aconst_null";
            case 2L: return "iconst_m1";
            case 3L: return "iconst_0";
            case 4L: return "iconst_1";
            case 5L: return "iconst_2";
            case 6L: return "iconst_3";
            case 7L: return "iconst_4";
            case 8L: return "iconst_5";
            case 9L: return "lconst_0";
            case 10L: return "lconst_1";
            case 11L: return "fconst_0";
            case 12L: return "fconst_1";
            case 13L: return "fconst_2";
            case 14L: return "dconst_0";
            case 15L: return "dconst_1";
            case 16L: return "bipush";
            case 17L: return "sipush";
            case 18L: return "ldc";
            case 19L: return "ldc_w";
            case 20L: return "ldc2_w";
            case 21L: return "iload";
            case 22L: return "lload";
            case 23L: return "fload";
            case 24L: return "dload";
            case 25L: return "aload";
            case 26L: return "iload_0";
            case 27L: return "iload_1";
            case 28L: return "iload_2";
            case 29L: return "iload_3";
            case 30L: return "lload_0";
            case 31L: return "lload_1";
            case 32L: return "lload_2";
            case 33L: return "lload_3";
            case 34L: return "fload_0";
            case 35L: return "fload_1";
            case 36L: return "fload_2";
            case 37L: return "fload_3";
            case 38L: return "dload_0";
            case 39L: return "dload_1";
            case 40L: return "dload_2";
            case 41L: return "dload_3";
            case 42L: return "aload_0";
            case 43L: return "aload_1";
            case 44L: return "aload_2";
            case 45L: return "aload_3";
            case 46L: return "iaload";
            case 47L: return "laload";
            case 48L: return "faload";
            case 49L: return "daload";
            case 50L: return "aaload";
            case 51L: return "baload";
            case 52L: return "caload";
            case 53L: return "saload";
            case 54L: return "istore";
            case 55L: return "lstore";
            case 56L: return "fstore";
            case 57L: return "dstore";
            case 58L: return "astore";
            case 59L: return "istore_0";
            case 60L: return "istore_1";
            case 61L: return "istore_2";
            case 62L: return "istore_3";
            case 63L: return "lstore_0";
            case 64L: return "lstore_1";
            case 65L: return "lstore_2";
            case 66L: return "lstore_3";
            case 67L: return "fstore_0";
            case 68L: return "fstore_1";
            case 69L: return "fstore_2";
            case 70L: return "fstore_3";
            case 71L: return "dstore_0";
            case 72L: return "dstore_1";
            case 73L: return "dstore_2";
            case 74L: return "dstore_3";
            case 75L: return "astore_0";
            case 76L: return "astore_1";
            case 77L: return "astore_2";
            case 78L: return "astore_3";
            case 79L: return "iastore";
            case 80L: return "lastore";
            case 81L: return "fastore";
            case 82L: return "dastore";
            case 83L: return "aastore";
            case 84L: return "bastore";
            case 85L: return "castore";
            case 86L: return "sastore";
            case 87L: return "pop";
            case 88L: return "pop2";
            case 89L: return "dup";
            case 90L: return "dup_x1";
            case 91L: return "dup_x2";
            case 92L: return "dup2";
            case 93L: return "dup2_x1";
            case 94L: return "dup2_x2";
            case 95L: return "swap";
            case 96L: return "iadd";
            case 97L: return "ladd";
            case 98L: return "fadd";
            case 99L: return "dadd";
            case 100L: return "isub";
            case 101L: return "lsub";
            case 102L: return "fsub";
            case 103L: return "dsub";
            case 104L: return "imul";
            case 105L: return "lmul";
            case 106L: return "fmul";
            case 107L: return "dmul";
            case 108L: return "idiv";
            case 109L: return "ldiv";
            case 110L: return "fdiv";
            case 111L: return "ddiv";
            case 112L: return "irem";
            case 113L: return "lrem";
            case 114L: return "frem";
            case 115L: return "drem";
            case 116L: return "ineg";
            case 117L: return "lneg";
            case 118L: return "fneg";
            case 119L: return "dneg";
            case 120L: return "ishl";
            case 121L: return "lshl";
            case 122L: return "ishr";
            case 123L: return "lshr";
            case 124L: return "iushr";
            case 125L: return "lushr";
            case 126L: return "iand";
            case 127L: return "land";
            case 128L: return "ior";
            case 129L: return "lor";
            case 130L: return "ixor";
            case 131L: return "lxor";
            case 132L: return "iinc";
            case 133L: return "i2l";
            case 134L: return "i2f";
            case 135L: return "i2d";
            case 136L: return "l2i";
            case 137L: return "l2f";
            case 138L: return "l2d";
            case 139L: return "f2i";
            case 140L: return "f2l";
            case 141L: return "f2d";
            case 142L: return "d2i";
            case 143L: return "d2l";
            case 144L: return "d2f";
            case 145L: return "i2b";
            case 146L: return "i2c";
            case 147L: return "i2s";
            case 148L: return "lcmp";
            case 149L: return "fcmpl";
            case 150L: return "fcmpg";
            case 151L: return "dcmpl";
            case 152L: return "dcmpg";
            case 153L: return "ifeq";
            case 154L: return "ifne";
            case 155L: return "iflt";
            case 156L: return "ifge";
            case 157L: return "ifgt";
            case 158L: return "ifle";
            case 159L: return "if_icmpeq";
            case 160L: return "if_icmpne";
            case 161L: return "if_icmplt";
            case 162L: return "if_icmpge";
            case 163L: return "if_icmpgt";
            case 164L: return "if_icmple";
            case 165L: return "if_acmpeq";
            case 166L: return "if_acmpne";
            case 167L: return "goto_";
            case 168L: return "jsr";
            case 169L: return "ret";
            case 170L: return "tableswitch";
            case 171L: return "lookupswitch";
            case 172L: return "ireturn";
            case 173L: return "lreturn";
            case 174L: return "freturn";
            case 175L: return "dreturn";
            case 176L: return "areturn";
            case 177L: return "return_";
            case 178L: return "getstatic";
            case 179L: return "putstatic";
            case 180L: return "getfield";
            case 181L: return "putfield";
            case 182L: return "invokevirtual";
            case 183L: return "invokespecial";
            case 184L: return "invokestatic";
            case 185L: return "invokeinterface";
            case 186L: return "invokedynamic";
            case 187L: return "new_";
            case 188L: return "newarray";
            case 189L: return "anewarray";
            case 190L: return "arraylength";
            case 191L: return "athrow";
            case 192L: return "checkcast";
            case 193L: return "instanceof";
            case 194L: return "monitorenter";
            case 195L: return "monitorexit";
            case 196L: return "wide";
            case 197L: return "multianewarray";
            case 198L: return "ifnull";
            case 199L: return "ifnonnull";
            case 200L: return "goto_w";
            case 201L: return "jsr_w";
            case 202L: return "breakpoint";
            case 254L: return "impdep1";
            case 255L: return "impdep2";
            case 666L: return "unknown";
            default: return "";
        }
    }

    std::string JvmInstructionKind(int64_t i, const std::string &strip) {
        std::string s = JvmInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::JvmInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& JvmInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            254L,
            255L,
            666L
        };
        static const std::vector<int64_t> retval(values, values + 206);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisJvmInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::JvmInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::JvmInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::JvmInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisJvmInstructionKind() {
        return stringify::Rose::BinaryAnalysis::JvmInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CodeGen/Object.h line 12
namespace stringify { namespace Rose { namespace CodeGen {
    const char* Object(int64_t i) {
        switch (i) {
            case 0L: return "a_namespace";
            case 1L: return "a_class";
            case 2L: return "a_typedef";
            case 3L: return "a_variable";
            case 4L: return "a_function";
            default: return "";
        }
    }

    std::string Object(int64_t i, const std::string &strip) {
        std::string s = Object(i);
        if (s.empty())
            s = "(Rose::CodeGen::Object)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Object() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeGenObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CodeGen::Object(i);
        if (retval.empty()) {
            retval = "(Rose::CodeGen::Object)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CodeGen::Object::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeGenObject() {
        return stringify::Rose::CodeGen::Object();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 22
namespace stringify { namespace Rose { namespace Color {
    const char* Enabled(int64_t i) {
        switch (i) {
            case 0L: return "OFF";
            case 1L: return "ON";
            case 2L: return "AUTO";
            default: return "";
        }
    }

    std::string Enabled(int64_t i, const std::string &strip) {
        std::string s = Enabled(i);
        if (s.empty())
            s = "(Rose::Color::Enabled)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Enabled() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorEnabled(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Enabled(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Enabled)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Enabled::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorEnabled() {
        return stringify::Rose::Color::Enabled();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 31
namespace stringify { namespace Rose { namespace Color {
    const char* Theme(int64_t i) {
        switch (i) {
            case 0L: return "DARK_ON_LIGHT";
            case 1L: return "LIGHT_ON_DARK";
            default: return "";
        }
    }

    std::string Theme(int64_t i, const std::string &strip) {
        std::string s = Theme(i);
        if (s.empty())
            s = "(Rose::Color::Theme)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Theme() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorTheme(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Theme(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Theme)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Theme::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorTheme() {
        return stringify::Rose::Color::Theme();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 49
namespace stringify { namespace Rose { namespace Color {
    const char* Layer(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "FOREGROUND";
            case 2L: return "BACKGROUND";
            default: return "";
        }
    }

    std::string Layer(int64_t i, const std::string &strip) {
        std::string s = Layer(i);
        if (s.empty())
            s = "(Rose::Color::Layer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Layer() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorLayer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Layer(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Layer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Layer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorLayer() {
        return stringify::Rose::Color::Layer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 366
namespace stringify { namespace Rose { namespace Color {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "CLEAR";
            case 1L: return "RED";
            case 2L: return "GREEN";
            case 3L: return "YELLOW";
            case 4L: return "BLUE";
            case 5L: return "MAGENTA";
            case 6L: return "CYAN";
            case 7L: return "GRAY";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorAnsiColor() {
        return stringify::Rose::Color::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CommandLine/SuffixMultiplierParser.h line 37
namespace stringify { namespace Rose { namespace CommandLine { namespace SuffixMultiplierParser {
    const char* Preferred(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Preferred(int64_t i, const std::string &strip) {
        std::string s = Preferred(i);
        if (s.empty())
            s = "(Rose::CommandLine::SuffixMultiplierParser::Preferred)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Preferred() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineSuffixMultiplierParserPreferred(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::SuffixMultiplierParser::Preferred(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::SuffixMultiplierParser::Preferred)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::SuffixMultiplierParser::Preferred::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineSuffixMultiplierParserPreferred() {
        return stringify::Rose::CommandLine::SuffixMultiplierParser::Preferred();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CommandLine/Parser.C line 32
namespace stringify { namespace Rose { namespace CommandLine { namespace FailedAssertionBehaviorAdjuster {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "ABORT_ON_FAILURE";
            case 1L: return "EXIT_ON_FAILURE";
            case 2L: return "THROW_ON_FAILURE";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior() {
        return stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Logger.h line 14
namespace stringify { namespace Rose { namespace Logger {
    const char* Level(int64_t i) {
        switch (i) {
            case 0L: return "debug";
            case 1L: return "info";
            case 2L: return "warning";
            case 3L: return "error";
            case 4L: return "fatal";
            case 5L: return "enter";
            case 6L: return "leave";
            default: return "";
        }
    }

    std::string Level(int64_t i, const std::string &strip) {
        std::string s = Level(i);
        if (s.empty())
            s = "(Rose::Logger::Level)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Level() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyLoggerLevel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Logger::Level(i);
        if (retval.empty()) {
            retval = "(Rose::Logger::Level)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Logger::Level::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLoggerLevel() {
        return stringify::Rose::Logger::Level();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Sarif/BasicTypes.h line 15
namespace stringify { namespace Rose { namespace Sarif {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "PASS";
            case 1L: return "OPEN";
            case 2L: return "INFORMATIONAL";
            case 3L: return "NOT_APPLICABLE";
            case 4L: return "REVIEW";
            case 5L: return "FAIL";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(Rose::Sarif::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySarifKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Sarif::Kind(i);
        if (retval.empty()) {
            retval = "(Rose::Sarif::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Sarif::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySarifKind() {
        return stringify::Rose::Sarif::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Sarif/BasicTypes.h line 25
namespace stringify { namespace Rose { namespace Sarif {
    const char* Severity(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "NOTE";
            case 2L: return "WARNING";
            case 3L: return "ERROR";
            default: return "";
        }
    }

    std::string Severity(int64_t i, const std::string &strip) {
        std::string s = Severity(i);
        if (s.empty())
            s = "(Rose::Sarif::Severity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Severity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySarifSeverity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Sarif::Severity(i);
        if (retval.empty()) {
            retval = "(Rose::Sarif::Severity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Sarif::Severity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySarifSeverity() {
        return stringify::Rose::Sarif::Severity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/failSafe/failSafePragma.h line 31
namespace stringify { namespace FailSafe {
    const char* fail_safe_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_region";
            case 2L: return "e_status_predicate";
            case 3L: return "e_data_predicate";
            case 4L: return "e_tolerance";
            case 5L: return "e_double_redundancy";
            case 6L: return "e_triple_redundancy";
            case 7L: return "e_save";
            case 8L: return "e_assert";
            case 9L: return "e_specifier";
            case 10L: return "e_region_reference";
            case 11L: return "e_error";
            case 12L: return "e_violation";
            case 13L: return "e_recover";
            case 14L: return "e_pre";
            case 15L: return "e_post";
            case 16L: return "e_type_ET1";
            case 17L: return "e_type_ET2";
            case 18L: return "e_violation_NaN";
            case 19L: return "e_violation_SECDED";
            case 20L: return "e_violation_SEGFAULT";
            case 21L: return "e_violation_ANY";
            case 22L: return "e_not_failsafe";
            default: return "";
        }
    }

    std::string fail_safe_enum(int64_t i, const std::string &strip) {
        std::string s = fail_safe_enum(i);
        if (s.empty())
            s = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fail_safe_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFailSafe_fail_safe_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FailSafe::fail_safe_enum(i);
        if (retval.empty()) {
            retval = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FailSafe::fail_safe_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFailSafe_fail_safe_enum() {
        return stringify::FailSafe::fail_safe_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/GenRepresentation.h line 23
namespace stringify { namespace GenRepresentation {
    const char* TypeOfPrint(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElement";
            case 1L: return "Container";
            case 2L: return "Contained";
            case 3L: return "END_OF_LIST";
            default: return "";
        }
    }

    std::string TypeOfPrint(int64_t i, const std::string &strip) {
        std::string s = TypeOfPrint(i);
        if (s.empty())
            s = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfPrint() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyGenRepresentationTypeOfPrint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::GenRepresentation::TypeOfPrint(i);
        if (retval.empty()) {
            retval = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "GenRepresentation::TypeOfPrint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenRepresentationTypeOfPrint() {
        return stringify::GenRepresentation::TypeOfPrint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/exampleTest.C line 3
namespace stringify {
    const char* controlEnum(int64_t i) {
        switch (i) {
            case 0L: return "BEGGINING_OF_ENUM";
            case 1L: return "typeInt";
            case 2L: return "typeChar";
            case 3L: return "typeTestStruct";
            case 4L: return "END_OF_ENUM";
            default: return "";
        }
    }

    std::string controlEnum(int64_t i, const std::string &strip) {
        std::string s = controlEnum(i);
        if (s.empty())
            s = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& controlEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_controlEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::controlEnum(i);
        if (retval.empty()) {
            retval = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "controlEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_controlEnum() {
        return stringify::controlEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h line 25
namespace stringify { namespace CompilerOutputWidget {
    const char* PatternType(int64_t i) {
        switch (i) {
            case 0L: return "Unknown";
            case 1L: return "Warning";
            case 2L: return "Error";
            default: return "";
        }
    }

    std::string PatternType(int64_t i, const std::string &strip) {
        std::string s = PatternType(i);
        if (s.empty())
            s = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCompilerOutputWidgetPatternType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CompilerOutputWidget::PatternType(i);
        if (retval.empty()) {
            retval = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CompilerOutputWidget::PatternType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCompilerOutputWidgetPatternType() {
        return stringify::CompilerOutputWidget::PatternType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h line 25
namespace stringify { namespace Task {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "BEFORE_START";
            case 1L: return "RUNNING";
            case 2L: return "FINISHED_SUCCESS";
            case 3L: return "FINISHED_ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Task::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaskState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Task::State(i);
        if (retval.empty()) {
            retval = "(Task::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Task::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaskState() {
        return stringify::Task::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp line 91
namespace stringify { namespace QtGradientWidgetPrivate {
    const char* Handle(int64_t i) {
        switch (i) {
            case 0L: return "NoHandle";
            case 1L: return "StartLinearHandle";
            case 2L: return "EndLinearHandle";
            case 3L: return "CentralRadialHandle";
            case 4L: return "FocalRadialHandle";
            case 5L: return "RadiusRadialHandle";
            case 6L: return "CentralConicalHandle";
            case 7L: return "AngleConicalHandle";
            default: return "";
        }
    }

    std::string Handle(int64_t i, const std::string &strip) {
        std::string s = Handle(i);
        if (s.empty())
            s = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Handle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtGradientWidgetPrivateHandle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtGradientWidgetPrivate::Handle(i);
        if (retval.empty()) {
            retval = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtGradientWidgetPrivate::Handle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtGradientWidgetPrivateHandle() {
        return stringify::QtGradientWidgetPrivate::Handle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h line 62
namespace stringify { namespace QtColorLine {
    const char* ColorComponent(int64_t i) {
        switch (i) {
            case 0L: return "Red";
            case 1L: return "Green";
            case 2L: return "Blue";
            case 3L: return "Hue";
            case 4L: return "Saturation";
            case 5L: return "Value";
            case 6L: return "Alpha";
            default: return "";
        }
    }

    std::string ColorComponent(int64_t i, const std::string &strip) {
        std::string s = ColorComponent(i);
        if (s.empty())
            s = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ColorComponent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtColorLineColorComponent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtColorLine::ColorComponent(i);
        if (retval.empty()) {
            retval = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtColorLine::ColorComponent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtColorLineColorComponent() {
        return stringify::QtColorLine::ColorComponent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/util/AstDisplayInfo.h line 14
namespace stringify { namespace AstDisplayInfo {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "ROOT";
            case 1L: return "INCLUDE_ROOT";
            case 2L: return "SRC_FILE";
            case 3L: return "INCLUDE_FILE";
            case 4L: return "NAMESPACE";
            case 5L: return "CLASS";
            case 6L: return "FUNCTION";
            case 7L: return "LOOP";
            case 8L: return "UNKNOWN";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstDisplayInfoNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstDisplayInfo::NodeType(i);
        if (retval.empty()) {
            retval = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstDisplayInfo::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstDisplayInfoNodeType() {
        return stringify::AstDisplayInfo::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 64
namespace stringify { namespace QEditor {
    const char* CodecUpdatePolicy(int64_t i) {
        switch (i) {
            case 0L: return "NoUpdate";
            case 1L: return "UpdateOld";
            case 2L: return "UpdateDefault";
            case 4L: return "UpdateCustom";
            case 7L: return "UpdateAll";
            default: return "";
        }
    }

    std::string CodecUpdatePolicy(int64_t i, const std::string &strip) {
        std::string s = CodecUpdatePolicy(i);
        if (s.empty())
            s = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CodecUpdatePolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorCodecUpdatePolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::CodecUpdatePolicy(i);
        if (retval.empty()) {
            retval = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::CodecUpdatePolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorCodecUpdatePolicy() {
        return stringify::QEditor::CodecUpdatePolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 74
namespace stringify { namespace QEditor {
    const char* EditFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Overwrite";
            case 2L: return "CursorOn";
            case 4L: return "ReadOnly";
            case 8L: return "MousePressed";
            case 16L: return "MaybeDrag";
            case 32L: return "Selection";
            case 64L: return "Persistent";
            case 128L: return "Multiline";
            case 256L: return "FoldedCursor";
            case 4095L: return "Internal";
            case 4096L: return "LineWrap";
            case 65536L: return "CtrlNavigation";
            case 131072L: return "CursorJumpPastWrap";
            case 1048576L: return "ReplaceTabs";
            case 2097152L: return "RemoveTrailing";
            case 4194304L: return "PreserveTrailingIndent";
            case 16777216L: return "AutoCloseChars";
            case 33554432L: return "AutoIndent";
            case 4294963200L: return "Accessible";
            default: return "";
        }
    }

    std::string EditFlag(int64_t i, const std::string &strip) {
        std::string s = EditFlag(i);
        if (s.empty())
            s = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            4095L,
            4096L,
            65536L,
            131072L,
            1048576L,
            2097152L,
            4194304L,
            16777216L,
            33554432L,
            4294963200L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorEditFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::EditFlag(i);
        if (retval.empty()) {
            retval = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::EditFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorEditFlag() {
        return stringify::QEditor::EditFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 493
namespace stringify { namespace QEditor {
    const char* SaveState(int64_t i) {
        switch (i) {
            case 0L: return "Undefined";
            case 1L: return "Saving";
            case 2L: return "Saved";
            case 3L: return "Conflict";
            default: return "";
        }
    }

    std::string SaveState(int64_t i, const std::string &strip) {
        std::string s = SaveState(i);
        if (s.empty())
            s = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SaveState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorSaveState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::SaveState(i);
        if (retval.empty()) {
            retval = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::SaveState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorSaveState() {
        return stringify::QEditor::SaveState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h line 52
namespace stringify { namespace QReliableFileWatch {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "Clean";
            case 1L: return "Recent";
            case 2L: return "Duplicate";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQReliableFileWatchState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QReliableFileWatch::State(i);
        if (retval.empty()) {
            retval = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QReliableFileWatch::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQReliableFileWatchState() {
        return stringify::QReliableFileWatch::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 38
namespace stringify { namespace QPanelLayout {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::Position(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutPosition() {
        return stringify::QPanelLayout::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 87
namespace stringify { namespace QPanelLayout {
    const char* SizeType(int64_t i) {
        switch (i) {
            case 0L: return "MinimumSize";
            case 1L: return "SizeHint";
            default: return "";
        }
    }

    std::string SizeType(int64_t i, const std::string &strip) {
        std::string s = SizeType(i);
        if (s.empty())
            s = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SizeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutSizeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::SizeType(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::SizeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutSizeType() {
        return stringify::QPanelLayout::SizeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 38
namespace stringify { namespace QParenthesis {
    const char* Role(int64_t i) {
        switch (i) {
            case 1L: return "Open";
            case 2L: return "Close";
            case 4L: return "Indent";
            case 8L: return "Fold";
            case 16L: return "Match";
            default: return "";
        }
    }

    std::string Role(int64_t i, const std::string &strip) {
        std::string s = Role(i);
        if (s.empty())
            s = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Role() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQParenthesisRole(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QParenthesis::Role(i);
        if (retval.empty()) {
            retval = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QParenthesis::Role::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQParenthesisRole() {
        return stringify::QParenthesis::Role();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 69
namespace stringify { namespace QDocumentLine {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Hidden";
            case 2L: return "CollapsedBlockStart";
            case 4L: return "CollapsedBlockEnd";
            case 16L: return "LayoutDirty";
            case 32L: return "FormatsApplied";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentLine::State(i);
        if (retval.empty()) {
            retval = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentLine::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineState() {
        return stringify::QDocumentLine::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h line 37
namespace stringify { namespace QDocumentCommand {
    const char* Command(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Insert";
            case 2L: return "Erase";
            case 3L: return "Replace";
            case 4L: return "Custom";
            default: return "";
        }
    }

    std::string Command(int64_t i, const std::string &strip) {
        std::string s = Command(i);
        if (s.empty())
            s = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Command() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCommandCommand(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCommand::Command(i);
        if (retval.empty()) {
            retval = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCommand::Command::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCommandCommand() {
        return stringify::QDocumentCommand::Command();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 39
namespace stringify { namespace QDocumentCursor {
    const char* MoveFlag(int64_t i) {
        switch (i) {
            case 0L: return "MoveAnchor";
            case 1L: return "KeepAnchor";
            case 2L: return "ThroughWrap";
            default: return "";
        }
    }

    std::string MoveFlag(int64_t i, const std::string &strip) {
        std::string s = MoveFlag(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveFlag(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveFlag() {
        return stringify::QDocumentCursor::MoveFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 48
namespace stringify { namespace QDocumentCursor {
    const char* MoveOperation(int64_t i) {
        switch (i) {
            case 0L: return "NoMove";
            case 1L: return "Up";
            case 2L: return "Down";
            case 3L: return "Left";
            case 4L: return "Right";
            case 5L: return "Start";
            case 6L: return "StartOfLine";
            case 7L: return "StartOfWord";
            case 8L: return "PreviousBlock";
            case 9L: return "PreviousWord";
            case 10L: return "WordLeft";
            case 11L: return "WordRight";
            case 12L: return "End";
            case 13L: return "EndOfLine";
            case 14L: return "EndOfWord";
            case 15L: return "NextWord";
            case 16L: return "NextBlock";
            default: return "";
        }
    }

    std::string MoveOperation(int64_t i, const std::string &strip) {
        std::string s = MoveOperation(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveOperation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveOperation(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveOperation() {
        return stringify::QDocumentCursor::MoveOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 75
namespace stringify { namespace QDocumentCursor {
    const char* SelectionType(int64_t i) {
        switch (i) {
            case 0L: return "WordUnderCursor";
            case 1L: return "LineUnderCursor";
            default: return "";
        }
    }

    std::string SelectionType(int64_t i, const std::string &strip) {
        std::string s = SelectionType(i);
        if (s.empty())
            s = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorSelectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::SelectionType(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::SelectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorSelectionType() {
        return stringify::QDocumentCursor::SelectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h line 40
namespace stringify { namespace QDocumentSearch {
    const char* Option(int64_t i) {
        switch (i) {
            case 1L: return "WholeWords";
            case 2L: return "CaseSensitive";
            case 4L: return "RegExp";
            case 8L: return "Replace";
            case 16L: return "Prompt";
            case 32L: return "Silent";
            case 64L: return "HighlightAll";
            default: return "";
        }
    }

    std::string Option(int64_t i, const std::string &strip) {
        std::string s = Option(i);
        if (s.empty())
            s = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Option() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentSearchOption(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentSearch::Option(i);
        if (retval.empty()) {
            retval = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentSearch::Option::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentSearchOption() {
        return stringify::QDocumentSearch::Option();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 84
namespace stringify { namespace QDocument {
    const char* LineEnding(int64_t i) {
        switch (i) {
            case 0L: return "Conservative";
            case 1L: return "Local";
            case 2L: return "Unix";
            case 3L: return "Windows";
            case 4L: return "Mac";
            default: return "";
        }
    }

    std::string LineEnding(int64_t i, const std::string &strip) {
        std::string s = LineEnding(i);
        if (s.empty())
            s = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LineEnding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineEnding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::LineEnding(i);
        if (retval.empty()) {
            retval = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::LineEnding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineEnding() {
        return stringify::QDocument::LineEnding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 93
namespace stringify { namespace QDocument {
    const char* TextProcessing(int64_t i) {
        switch (i) {
            case 1L: return "RemoveTrailingWS";
            case 2L: return "PreserveIndent";
            case 4L: return "RestoreTrailingIndent";
            default: return "";
        }
    }

    std::string TextProcessing(int64_t i, const std::string &strip) {
        std::string s = TextProcessing(i);
        if (s.empty())
            s = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TextProcessing() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentTextProcessing(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::TextProcessing(i);
        if (retval.empty()) {
            retval = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::TextProcessing::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentTextProcessing() {
        return stringify::QDocument::TextProcessing();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 100
namespace stringify { namespace QDocument {
    const char* WhiteSpaceFlag(int64_t i) {
        switch (i) {
            case 0L: return "ShowNone";
            case 1L: return "ShowTrailing";
            case 2L: return "ShowLeading";
            case 4L: return "ShowTabs";
            default: return "";
        }
    }

    std::string WhiteSpaceFlag(int64_t i, const std::string &strip) {
        std::string s = WhiteSpaceFlag(i);
        if (s.empty())
            s = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhiteSpaceFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentWhiteSpaceFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::WhiteSpaceFlag(i);
        if (retval.empty()) {
            retval = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::WhiteSpaceFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentWhiteSpaceFlag() {
        return stringify::QDocument::WhiteSpaceFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h line 52
namespace stringify { namespace QDocumentCursorHandle {
    const char* Flags(int64_t i) {
        switch (i) {
            case 1L: return "Silent";
            case 2L: return "ColumnMemory";
            case 4L: return "MoveWithinWrapped";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorHandleFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursorHandle::Flags(i);
        if (retval.empty()) {
            retval = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursorHandle::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorHandleFlags() {
        return stringify::QDocumentCursorHandle::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h line 44
namespace stringify { namespace QLanguageDefinition {
    const char* CollapseFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 4095L: return "OpenMask";
            case 16773120L: return "CloseMask";
            case 268435456L: return "Collapsible";
            case 536870912L: return "Collapsed";
            case 1073741824L: return "Closure";
            default: return "";
        }
    }

    std::string CollapseFlag(int64_t i, const std::string &strip) {
        std::string s = CollapseFlag(i);
        if (s.empty())
            s = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CollapseFlag() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            268435456L,
            536870912L,
            1073741824L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQLanguageDefinitionCollapseFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QLanguageDefinition::CollapseFlag(i);
        if (retval.empty()) {
            retval = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QLanguageDefinition::CollapseFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQLanguageDefinitionCollapseFlag() {
        return stringify::QLanguageDefinition::CollapseFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 42
namespace stringify {
    const char* NFAType(int64_t i) {
        switch (i) {
            case 0L: return "Char";
            case 1L: return "Match";
            case 2L: return "CxtBeg";
            case 3L: return "ContextBegin";
            case 4L: return "CxtEnd";
            case 5L: return "ContextEnd";
            case 8L: return "CxtEsc";
            case 9L: return "EscapeSeq";
            case 16L: return "Escaped";
            case 32L: return "Exclusive";
            case 64L: return "StayOnLine";
            case 128L: return "Reserved";
            default: return "";
        }
    }

    std::string NFAType(int64_t i, const std::string &strip) {
        std::string s = NFAType(i);
        if (s.empty())
            s = "(NFAType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            8L,
            9L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAType(i);
        if (retval.empty()) {
            retval = "(NFAType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAType() {
        return stringify::NFAType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 63
namespace stringify {
    const char* NFAAssertion(int64_t i) {
        switch (i) {
            case 0L: return "NoAssertion";
            case 1L: return "ZeroOrOne";
            case 2L: return "ZeroOrMore";
            case 4L: return "OneOrMore";
            case 8L: return "WordStart";
            case 16L: return "WordEnd";
            case 32L: return "Word";
            case 64L: return "NonWord";
            case 128L: return "Digit";
            case 256L: return "NonDigit";
            case 512L: return "Space";
            case 1024L: return "NonSpace";
            case 2048L: return "CaseSensitive";
            default: return "";
        }
    }

    std::string NFAAssertion(int64_t i, const std::string &strip) {
        std::string s = NFAAssertion(i);
        if (s.empty())
            s = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAAssertion() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            2048L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAAssertion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAAssertion(i);
        if (retval.empty()) {
            retval = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAAssertion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAAssertion() {
        return stringify::NFAAssertion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 41
namespace stringify { namespace QNFAAction {
    const char* QNFAAction_(int64_t i) {
        switch (i) {
            case 0L: return "NoAction";
            case 4095L: return "FormatMask";
            case 16773120L: return "ParenMask";
            case 16777216L: return "Highlight";
            case 33554432L: return "Indent";
            case 67108864L: return "ParenOpen";
            case 134217728L: return "ParenClose";
            case 268435456L: return "MatchParen";
            case 536870912L: return "Fold";
            case 1073741824L: return "Ambiguous";
            case 2147483648L: return "Content";
            default: return "";
        }
    }

    std::string QNFAAction_(int64_t i, const std::string &strip) {
        std::string s = QNFAAction_(i);
        if (s.empty())
            s = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QNFAAction_() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQNFAActionQNFAAction_(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFAAction::QNFAAction_(i);
        if (retval.empty()) {
            retval = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFAAction::QNFAAction_::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFAActionQNFAAction_() {
        return stringify::QNFAAction::QNFAAction_();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 129
namespace stringify { namespace QNFADefinition { namespace PMatch {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyQNFADefinitionPMatchType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFADefinition::PMatch::Type(i);
        if (retval.empty()) {
            retval = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFADefinition::PMatch::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFADefinitionPMatchType() {
        return stringify::QNFADefinition::PMatch::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h line 46
namespace stringify { namespace QCodeEdit {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQCodeEditPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QCodeEdit::Position(i);
        if (retval.empty()) {
            retval = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QCodeEdit::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQCodeEditPosition() {
        return stringify::QCodeEdit::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h line 40
namespace stringify { namespace DisplayEdge {
    const char* PaintMode(int64_t i) {
        switch (i) {
            case 0L: return "STRAIGHT";
            case 1L: return "RECTANGULAR";
            case 2L: return "BEZIER_QUAD";
            case 3L: return "BEZIER_CUBIC";
            default: return "";
        }
    }

    std::string PaintMode(int64_t i, const std::string &strip) {
        std::string s = PaintMode(i);
        if (s.empty())
            s = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PaintMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDisplayEdgePaintMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DisplayEdge::PaintMode(i);
        if (retval.empty()) {
            retval = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DisplayEdge::PaintMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDisplayEdgePaintMode() {
        return stringify::DisplayEdge::PaintMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h line 20
namespace stringify { namespace DependencyInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "VALID";
            case 1L: return "INVALID";
            case 2L: return "ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDependencyInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DependencyInfo::State(i);
        if (retval.empty()) {
            retval = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DependencyInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDependencyInfoState() {
        return stringify::DependencyInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 19
namespace stringify {
    const char* AssociativitySpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_assoc_none";
            case 1L: return "e_assoc_right";
            case 2L: return "e_assoc_left";
            case 3L: return "e_assoc_last";
            default: return "";
        }
    }

    std::string AssociativitySpecifier(int64_t i, const std::string &strip) {
        std::string s = AssociativitySpecifier(i);
        if (s.empty())
            s = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AssociativitySpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociativitySpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AssociativitySpecifier(i);
        if (retval.empty()) {
            retval = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AssociativitySpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociativitySpecifier() {
        return stringify::AssociativitySpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 40
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            case 6L: return "e_else_whitespace_start";
            case 7L: return "e_else_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 66
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* unparsed_as_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_unparsed_as_error";
            case 1L: return "e_unparsed_as_AST";
            case 2L: return "e_unparsed_as_partial_token_sequence";
            case 3L: return "e_unparsed_as_token_stream";
            case 4L: return "e_unparsed_as_last";
            default: return "";
        }
    }

    std::string unparsed_as_enum_type(int64_t i, const std::string &strip) {
        std::string s = unparsed_as_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparsed_as_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/formatSupport/unparse_format.h line 51
namespace stringify {
    const char* Format_Opt(int64_t i) {
        switch (i) {
            case 0L: return "FORMAT_BEFORE_DIRECTIVE";
            case 1L: return "FORMAT_AFTER_DIRECTIVE";
            case 2L: return "FORMAT_BEFORE_STMT";
            case 3L: return "FORMAT_AFTER_STMT";
            case 4L: return "FORMAT_BEFORE_BASIC_BLOCK1";
            case 5L: return "FORMAT_AFTER_BASIC_BLOCK1";
            case 6L: return "FORMAT_BEFORE_BASIC_BLOCK2";
            case 7L: return "FORMAT_AFTER_BASIC_BLOCK2";
            case 8L: return "FORMAT_BEFORE_NESTED_STATEMENT";
            case 9L: return "FORMAT_AFTER_NESTED_STATEMENT";
            default: return "";
        }
    }

    std::string Format_Opt(int64_t i, const std::string &strip) {
        std::string s = Format_Opt(i);
        if (s.empty())
            s = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format_Opt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFormat_Opt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Format_Opt(i);
        if (retval.empty()) {
            retval = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Format_Opt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormat_Opt() {
        return stringify::Format_Opt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 3
namespace stringify {
    const char* E_SgSourceFile(int64_t i) {
        switch (i) {
            case 0L: return "SgSourceFile_globalScope";
            case 1L: return "SgSourceFile_package";
            case 2L: return "SgSourceFile_import_list";
            case 3L: return "SgSourceFile_class_list";
            default: return "";
        }
    }

    std::string E_SgSourceFile(int64_t i, const std::string &strip) {
        std::string s = E_SgSourceFile(i);
        if (s.empty())
            s = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSourceFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSourceFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSourceFile(i);
        if (retval.empty()) {
            retval = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSourceFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSourceFile() {
        return stringify::E_SgSourceFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 6
namespace stringify {
    const char* E_SgUnknownFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownFile_globalScope";
            default: return "";
        }
    }

    std::string E_SgUnknownFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownFile(i);
        if (s.empty())
            s = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownFile(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownFile() {
        return stringify::E_SgUnknownFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 9
namespace stringify {
    const char* E_SgJvmComposite(int64_t i) {
        switch (i) {
            case 0L: return "SgJvmComposite_genericFileList";
            case 1L: return "SgJvmComposite_interpretations";
            default: return "";
        }
    }

    std::string E_SgJvmComposite(int64_t i, const std::string &strip) {
        std::string s = E_SgJvmComposite(i);
        if (s.empty())
            s = "(E_SgJvmComposite)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJvmComposite() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJvmComposite(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJvmComposite(i);
        if (retval.empty()) {
            retval = "(E_SgJvmComposite)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJvmComposite::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJvmComposite() {
        return stringify::E_SgJvmComposite();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 12
namespace stringify {
    const char* E_SgBinaryComposite(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryComposite_genericFileList";
            case 1L: return "SgBinaryComposite_interpretations";
            default: return "";
        }
    }

    std::string E_SgBinaryComposite(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryComposite(i);
        if (s.empty())
            s = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryComposite() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryComposite(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryComposite(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryComposite::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryComposite() {
        return stringify::E_SgBinaryComposite();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 15
namespace stringify {
    const char* E_SgProject(int64_t i) {
        switch (i) {
            case 0L: return "SgProject_fileList_ptr";
            default: return "";
        }
    }

    std::string E_SgProject(int64_t i, const std::string &strip) {
        std::string s = E_SgProject(i);
        if (s.empty())
            s = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProject(i);
        if (retval.empty()) {
            retval = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProject() {
        return stringify::E_SgProject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 18
namespace stringify {
    const char* E_SgExpBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgExpBaseClass_base_class";
            case 1L: return "SgExpBaseClass_base_class_exp";
            default: return "";
        }
    }

    std::string E_SgExpBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgExpBaseClass(i);
        if (s.empty())
            s = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpBaseClass() {
        return stringify::E_SgExpBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 21
namespace stringify {
    const char* E_SgNonrealBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealBaseClass_base_class";
            case 1L: return "SgNonrealBaseClass_base_class_nonreal";
            default: return "";
        }
    }

    std::string E_SgNonrealBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealBaseClass(i);
        if (s.empty())
            s = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealBaseClass() {
        return stringify::E_SgNonrealBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 24
namespace stringify {
    const char* E_SgBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgBaseClass_base_class";
            default: return "";
        }
    }

    std::string E_SgBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgBaseClass(i);
        if (s.empty())
            s = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBaseClass() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBaseClass() {
        return stringify::E_SgBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 27
namespace stringify {
    const char* E_SgTemplateParameter(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameter_expression";
            case 1L: return "SgTemplateParameter_defaultExpressionParameter";
            case 2L: return "SgTemplateParameter_templateDeclaration";
            case 3L: return "SgTemplateParameter_defaultTemplateDeclarationParameter";
            case 4L: return "SgTemplateParameter_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateParameter(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameter(i);
        if (s.empty())
            s = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameter(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameter() {
        return stringify::E_SgTemplateParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 30
namespace stringify {
    const char* E_SgTemplateArgument(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgument_expression";
            case 1L: return "SgTemplateArgument_templateDeclaration";
            case 2L: return "SgTemplateArgument_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateArgument(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgument(i);
        if (s.empty())
            s = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgument() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgument(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgument(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgument::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgument() {
        return stringify::E_SgTemplateArgument();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 33
namespace stringify {
    const char* E_SgDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectory_fileList";
            case 1L: return "SgDirectory_directoryList";
            default: return "";
        }
    }

    std::string E_SgDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectory(i);
        if (s.empty())
            s = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectory() {
        return stringify::E_SgDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 36
namespace stringify {
    const char* E_SgFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgFileList_listOfFiles";
            default: return "";
        }
    }

    std::string E_SgFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgFileList(i);
        if (s.empty())
            s = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFileList(i);
        if (retval.empty()) {
            retval = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFileList() {
        return stringify::E_SgFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 39
namespace stringify {
    const char* E_SgDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectoryList_listOfDirectories";
            default: return "";
        }
    }

    std::string E_SgDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectoryList(i);
        if (s.empty())
            s = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectoryList() {
        return stringify::E_SgDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 42
namespace stringify {
    const char* E_SgTemplateArgumentList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgumentList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateArgumentList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgumentList(i);
        if (s.empty())
            s = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgumentList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgumentList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgumentList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgumentList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgumentList() {
        return stringify::E_SgTemplateArgumentList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 45
namespace stringify {
    const char* E_SgTemplateParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameterList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameterList(i);
        if (s.empty())
            s = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameterList() {
        return stringify::E_SgTemplateParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 48
namespace stringify {
    const char* E_SgIncludeFile(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeFile_include_file_list";
            default: return "";
        }
    }

    std::string E_SgIncludeFile(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeFile(i);
        if (s.empty())
            s = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeFile(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeFile() {
        return stringify::E_SgIncludeFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 51
namespace stringify {
    const char* E_SgJavaImportStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaImportStatementList_java_import_list";
            default: return "";
        }
    }

    std::string E_SgJavaImportStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaImportStatementList(i);
        if (s.empty())
            s = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaImportStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaImportStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaImportStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaImportStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaImportStatementList() {
        return stringify::E_SgJavaImportStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 54
namespace stringify {
    const char* E_SgJavaClassDeclarationList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaClassDeclarationList_java_class_list";
            default: return "";
        }
    }

    std::string E_SgJavaClassDeclarationList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaClassDeclarationList(i);
        if (s.empty())
            s = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaClassDeclarationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaClassDeclarationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaClassDeclarationList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaClassDeclarationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaClassDeclarationList() {
        return stringify::E_SgJavaClassDeclarationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 57
namespace stringify {
    const char* E_SgTypeUnknown(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnknown_type_kind";
            case 1L: return "SgTypeUnknown_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnknown(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnknown(i);
        if (s.empty())
            s = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnknown() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnknown(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnknown(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnknown::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnknown() {
        return stringify::E_SgTypeUnknown();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 60
namespace stringify {
    const char* E_SgTypeChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar_type_kind";
            case 1L: return "SgTypeChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar(i);
        if (s.empty())
            s = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar() {
        return stringify::E_SgTypeChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 63
namespace stringify {
    const char* E_SgTypeSignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedChar_type_kind";
            case 1L: return "SgTypeSignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedChar(i);
        if (s.empty())
            s = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedChar() {
        return stringify::E_SgTypeSignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 66
namespace stringify {
    const char* E_SgTypeUnsignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedChar_type_kind";
            case 1L: return "SgTypeUnsignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedChar(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedChar() {
        return stringify::E_SgTypeUnsignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 69
namespace stringify {
    const char* E_SgTypeShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeShort_type_kind";
            case 1L: return "SgTypeShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeShort(i);
        if (s.empty())
            s = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeShort() {
        return stringify::E_SgTypeShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 72
namespace stringify {
    const char* E_SgTypeSignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedShort_type_kind";
            case 1L: return "SgTypeSignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedShort(i);
        if (s.empty())
            s = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedShort() {
        return stringify::E_SgTypeSignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 75
namespace stringify {
    const char* E_SgTypeUnsignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedShort_type_kind";
            case 1L: return "SgTypeUnsignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedShort(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedShort() {
        return stringify::E_SgTypeUnsignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 78
namespace stringify {
    const char* E_SgTypeInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeInt_type_kind";
            case 1L: return "SgTypeInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeInt(i);
        if (s.empty())
            s = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeInt() {
        return stringify::E_SgTypeInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 81
namespace stringify {
    const char* E_SgTypeSignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedInt_type_kind";
            case 1L: return "SgTypeSignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedInt(i);
        if (s.empty())
            s = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedInt() {
        return stringify::E_SgTypeSignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 84
namespace stringify {
    const char* E_SgTypeUnsignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedInt_type_kind";
            case 1L: return "SgTypeUnsignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedInt(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedInt() {
        return stringify::E_SgTypeUnsignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 87
namespace stringify {
    const char* E_SgTypeLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLong_type_kind";
            case 1L: return "SgTypeLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLong(i);
        if (s.empty())
            s = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLong() {
        return stringify::E_SgTypeLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 90
namespace stringify {
    const char* E_SgTypeSignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLong_type_kind";
            case 1L: return "SgTypeSignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLong() {
        return stringify::E_SgTypeSignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 93
namespace stringify {
    const char* E_SgTypeUnsignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLong_type_kind";
            case 1L: return "SgTypeUnsignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLong() {
        return stringify::E_SgTypeUnsignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 96
namespace stringify {
    const char* E_SgTypeVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeVoid_type_kind";
            case 1L: return "SgTypeVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeVoid(i);
        if (s.empty())
            s = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeVoid() {
        return stringify::E_SgTypeVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 99
namespace stringify {
    const char* E_SgTypeGlobalVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeGlobalVoid_type_kind";
            case 1L: return "SgTypeGlobalVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeGlobalVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeGlobalVoid(i);
        if (s.empty())
            s = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeGlobalVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeGlobalVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeGlobalVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeGlobalVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeGlobalVoid() {
        return stringify::E_SgTypeGlobalVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 102
namespace stringify {
    const char* E_SgTypeWchar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeWchar_type_kind";
            case 1L: return "SgTypeWchar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeWchar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeWchar(i);
        if (s.empty())
            s = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeWchar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeWchar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeWchar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeWchar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeWchar() {
        return stringify::E_SgTypeWchar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 105
namespace stringify {
    const char* E_SgTypeFloat(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat_type_kind";
            case 1L: return "SgTypeFloat_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat(i);
        if (s.empty())
            s = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat() {
        return stringify::E_SgTypeFloat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 108
namespace stringify {
    const char* E_SgTypeDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDouble_type_kind";
            case 1L: return "SgTypeDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDouble(i);
        if (s.empty())
            s = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDouble() {
        return stringify::E_SgTypeDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 111
namespace stringify {
    const char* E_SgTypeLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongLong_type_kind";
            case 1L: return "SgTypeLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongLong(i);
        if (s.empty())
            s = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongLong() {
        return stringify::E_SgTypeLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 114
namespace stringify {
    const char* E_SgTypeSignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLongLong_type_kind";
            case 1L: return "SgTypeSignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLongLong() {
        return stringify::E_SgTypeSignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 117
namespace stringify {
    const char* E_SgTypeUnsignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLongLong_type_kind";
            case 1L: return "SgTypeUnsignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLongLong() {
        return stringify::E_SgTypeUnsignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 120
namespace stringify {
    const char* E_SgTypeSigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSigned128bitInteger_type_kind";
            case 1L: return "SgTypeSigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSigned128bitInteger() {
        return stringify::E_SgTypeSigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 123
namespace stringify {
    const char* E_SgTypeUnsigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsigned128bitInteger_type_kind";
            case 1L: return "SgTypeUnsigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsigned128bitInteger() {
        return stringify::E_SgTypeUnsigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 126
namespace stringify {
    const char* E_SgTypeFloat80(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat80_type_kind";
            case 1L: return "SgTypeFloat80_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat80(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat80(i);
        if (s.empty())
            s = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat80() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat80(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat80(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat80::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat80() {
        return stringify::E_SgTypeFloat80();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 129
namespace stringify {
    const char* E_SgTypeLongDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongDouble_type_kind";
            case 1L: return "SgTypeLongDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongDouble(i);
        if (s.empty())
            s = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongDouble() {
        return stringify::E_SgTypeLongDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 132
namespace stringify {
    const char* E_SgTypeString(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeString_type_kind";
            case 1L: return "SgTypeString_lengthExpression";
            default: return "";
        }
    }

    std::string E_SgTypeString(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeString(i);
        if (s.empty())
            s = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeString() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeString(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeString(i);
        if (retval.empty()) {
            retval = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeString::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeString() {
        return stringify::E_SgTypeString();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 135
namespace stringify {
    const char* E_SgTypeBool(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeBool_type_kind";
            case 1L: return "SgTypeBool_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeBool(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeBool(i);
        if (s.empty())
            s = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeBool() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeBool(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeBool(i);
        if (retval.empty()) {
            retval = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeBool::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeBool() {
        return stringify::E_SgTypeBool();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 138
namespace stringify {
    const char* E_SgPointerMemberType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerMemberType_type_kind";
            case 1L: return "SgPointerMemberType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerMemberType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerMemberType(i);
        if (s.empty())
            s = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerMemberType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerMemberType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerMemberType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerMemberType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerMemberType() {
        return stringify::E_SgPointerMemberType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 141
namespace stringify {
    const char* E_SgPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerType_type_kind";
            case 1L: return "SgPointerType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerType(i);
        if (s.empty())
            s = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerType() {
        return stringify::E_SgPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 144
namespace stringify {
    const char* E_SgReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgReferenceType(i);
        if (s.empty())
            s = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReferenceType() {
        return stringify::E_SgReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 147
namespace stringify {
    const char* E_SgJavaParameterType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterType_type_kind";
            case 1L: return "SgJavaParameterType_builtin_type";
            case 2L: return "SgJavaParameterType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterType(i);
        if (s.empty())
            s = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterType() {
        return stringify::E_SgJavaParameterType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 150
namespace stringify {
    const char* E_SgJovialTableType(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableType_type_kind";
            case 1L: return "SgJovialTableType_builtin_type";
            case 2L: return "SgJovialTableType_declaration";
            case 3L: return "SgJovialTableType_dim_info";
            default: return "";
        }
    }

    std::string E_SgJovialTableType(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableType(i);
        if (s.empty())
            s = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableType(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableType() {
        return stringify::E_SgJovialTableType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 153
namespace stringify {
    const char* E_SgClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgClassType_type_kind";
            case 1L: return "SgClassType_builtin_type";
            case 2L: return "SgClassType_declaration";
            default: return "";
        }
    }

    std::string E_SgClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgClassType(i);
        if (s.empty())
            s = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassType(i);
        if (retval.empty()) {
            retval = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassType() {
        return stringify::E_SgClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 156
namespace stringify {
    const char* E_SgEnumType(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumType_type_kind";
            case 1L: return "SgEnumType_builtin_type";
            case 2L: return "SgEnumType_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumType(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumType(i);
        if (s.empty())
            s = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumType(i);
        if (retval.empty()) {
            retval = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumType() {
        return stringify::E_SgEnumType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 159
namespace stringify {
    const char* E_SgTypedefType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefType_type_kind";
            case 1L: return "SgTypedefType_builtin_type";
            case 2L: return "SgTypedefType_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefType(i);
        if (s.empty())
            s = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefType(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefType() {
        return stringify::E_SgTypedefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 162
namespace stringify {
    const char* E_SgNonrealType(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealType_type_kind";
            case 1L: return "SgNonrealType_builtin_type";
            case 2L: return "SgNonrealType_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealType(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealType(i);
        if (s.empty())
            s = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealType(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealType() {
        return stringify::E_SgNonrealType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 165
namespace stringify {
    const char* E_SgJavaParameterizedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterizedType_type_kind";
            case 1L: return "SgJavaParameterizedType_builtin_type";
            case 2L: return "SgJavaParameterizedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterizedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterizedType(i);
        if (s.empty())
            s = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterizedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterizedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterizedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterizedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterizedType() {
        return stringify::E_SgJavaParameterizedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 168
namespace stringify {
    const char* E_SgJavaQualifiedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaQualifiedType_type_kind";
            case 1L: return "SgJavaQualifiedType_builtin_type";
            case 2L: return "SgJavaQualifiedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaQualifiedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaQualifiedType(i);
        if (s.empty())
            s = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaQualifiedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaQualifiedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaQualifiedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaQualifiedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaQualifiedType() {
        return stringify::E_SgJavaQualifiedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 171
namespace stringify {
    const char* E_SgJavaWildcardType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaWildcardType_type_kind";
            case 1L: return "SgJavaWildcardType_builtin_type";
            case 2L: return "SgJavaWildcardType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaWildcardType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaWildcardType(i);
        if (s.empty())
            s = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaWildcardType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaWildcardType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaWildcardType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaWildcardType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaWildcardType() {
        return stringify::E_SgJavaWildcardType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 174
namespace stringify {
    const char* E_SgAdaTaskType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskType_type_kind";
            case 1L: return "SgAdaTaskType_builtin_type";
            case 2L: return "SgAdaTaskType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaTaskType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskType(i);
        if (s.empty())
            s = "(E_SgAdaTaskType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskType() {
        return stringify::E_SgAdaTaskType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 177
namespace stringify {
    const char* E_SgAdaProtectedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedType_type_kind";
            case 1L: return "SgAdaProtectedType_builtin_type";
            case 2L: return "SgAdaProtectedType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedType(i);
        if (s.empty())
            s = "(E_SgAdaProtectedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedType() {
        return stringify::E_SgAdaProtectedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 180
namespace stringify {
    const char* E_SgAdaFormalType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalType_type_kind";
            case 1L: return "SgAdaFormalType_builtin_type";
            case 2L: return "SgAdaFormalType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaFormalType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalType(i);
        if (s.empty())
            s = "(E_SgAdaFormalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalType() {
        return stringify::E_SgAdaFormalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 183
namespace stringify {
    const char* E_SgAdaDiscriminatedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminatedType_type_kind";
            case 1L: return "SgAdaDiscriminatedType_builtin_type";
            case 2L: return "SgAdaDiscriminatedType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminatedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminatedType(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminatedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminatedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminatedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminatedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminatedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminatedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminatedType() {
        return stringify::E_SgAdaDiscriminatedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 186
namespace stringify {
    const char* E_SgScopedType(int64_t i) {
        switch (i) {
            case 0L: return "SgScopedType_type_kind";
            case 1L: return "SgScopedType_builtin_type";
            case 2L: return "SgScopedType_declaration";
            default: return "";
        }
    }

    std::string E_SgScopedType(int64_t i, const std::string &strip) {
        std::string s = E_SgScopedType(i);
        if (s.empty())
            s = "(E_SgScopedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopedType(i);
        if (retval.empty()) {
            retval = "(E_SgScopedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopedType() {
        return stringify::E_SgScopedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 189
namespace stringify {
    const char* E_SgNamedType(int64_t i) {
        switch (i) {
            case 0L: return "SgNamedType_type_kind";
            case 1L: return "SgNamedType_builtin_type";
            case 2L: return "SgNamedType_declaration";
            default: return "";
        }
    }

    std::string E_SgNamedType(int64_t i, const std::string &strip) {
        std::string s = E_SgNamedType(i);
        if (s.empty())
            s = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamedType(i);
        if (retval.empty()) {
            retval = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamedType() {
        return stringify::E_SgNamedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 192
namespace stringify {
    const char* E_SgModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgModifierType_type_kind";
            case 1L: return "SgModifierType_base_type";
            default: return "";
        }
    }

    std::string E_SgModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgModifierType(i);
        if (s.empty())
            s = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModifierType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModifierType() {
        return stringify::E_SgModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 195
namespace stringify {
    const char* E_SgPartialFunctionModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionModifierType_type_kind";
            case 1L: return "SgPartialFunctionModifierType_return_type";
            case 2L: return "SgPartialFunctionModifierType_orig_return_type";
            case 3L: return "SgPartialFunctionModifierType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionModifierType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionModifierType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionModifierType() {
        return stringify::E_SgPartialFunctionModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 198
namespace stringify {
    const char* E_SgPartialFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionType_type_kind";
            case 1L: return "SgPartialFunctionType_return_type";
            case 2L: return "SgPartialFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionType() {
        return stringify::E_SgPartialFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 201
namespace stringify {
    const char* E_SgMemberFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionType_type_kind";
            case 1L: return "SgMemberFunctionType_return_type";
            case 2L: return "SgMemberFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionType(i);
        if (s.empty())
            s = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionType() {
        return stringify::E_SgMemberFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 204
namespace stringify {
    const char* E_SgFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionType_type_kind";
            case 1L: return "SgFunctionType_return_type";
            case 2L: return "SgFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionType(i);
        if (s.empty())
            s = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionType() {
        return stringify::E_SgFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 207
namespace stringify {
    const char* E_SgArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgArrayType_type_kind";
            case 1L: return "SgArrayType_index";
            case 2L: return "SgArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgArrayType(i);
        if (s.empty())
            s = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrayType() {
        return stringify::E_SgArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 210
namespace stringify {
    const char* E_SgTypeEllipse(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeEllipse_type_kind";
            case 1L: return "SgTypeEllipse_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeEllipse(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeEllipse(i);
        if (s.empty())
            s = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeEllipse() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeEllipse(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeEllipse(i);
        if (retval.empty()) {
            retval = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeEllipse::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeEllipse() {
        return stringify::E_SgTypeEllipse();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 213
namespace stringify {
    const char* E_SgTemplateType(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateType_type_kind";
            case 1L: return "SgTemplateType_class_type";
            case 2L: return "SgTemplateType_parent_class_type";
            case 3L: return "SgTemplateType_template_parameter";
            default: return "";
        }
    }

    std::string E_SgTemplateType(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateType(i);
        if (s.empty())
            s = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateType(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateType() {
        return stringify::E_SgTemplateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 216
namespace stringify {
    const char* E_SgQualifiedNameType(int64_t i) {
        switch (i) {
            case 0L: return "SgQualifiedNameType_type_kind";
            default: return "";
        }
    }

    std::string E_SgQualifiedNameType(int64_t i, const std::string &strip) {
        std::string s = E_SgQualifiedNameType(i);
        if (s.empty())
            s = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgQualifiedNameType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgQualifiedNameType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgQualifiedNameType(i);
        if (retval.empty()) {
            retval = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgQualifiedNameType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgQualifiedNameType() {
        return stringify::E_SgQualifiedNameType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 219
namespace stringify {
    const char* E_SgTypeComplex(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeComplex_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeComplex(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeComplex(i);
        if (s.empty())
            s = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeComplex() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeComplex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeComplex(i);
        if (retval.empty()) {
            retval = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeComplex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeComplex() {
        return stringify::E_SgTypeComplex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 222
namespace stringify {
    const char* E_SgTypeImaginary(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeImaginary_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeImaginary(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeImaginary(i);
        if (s.empty())
            s = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeImaginary() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeImaginary(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeImaginary(i);
        if (retval.empty()) {
            retval = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeImaginary::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeImaginary() {
        return stringify::E_SgTypeImaginary();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 225
namespace stringify {
    const char* E_SgTypeDefault(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDefault_type_kind";
            case 1L: return "SgTypeDefault_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDefault(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDefault(i);
        if (s.empty())
            s = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDefault() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDefault(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDefault(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDefault::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDefault() {
        return stringify::E_SgTypeDefault();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 228
namespace stringify {
    const char* E_SgTypeCAFTeam(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCAFTeam_type_kind";
            case 1L: return "SgTypeCAFTeam_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCAFTeam(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCAFTeam(i);
        if (s.empty())
            s = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCAFTeam() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCAFTeam(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCAFTeam(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCAFTeam::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCAFTeam() {
        return stringify::E_SgTypeCAFTeam();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 231
namespace stringify {
    const char* E_SgTypeCrayPointer(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCrayPointer_type_kind";
            case 1L: return "SgTypeCrayPointer_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCrayPointer(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCrayPointer(i);
        if (s.empty())
            s = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCrayPointer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCrayPointer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCrayPointer(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCrayPointer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCrayPointer() {
        return stringify::E_SgTypeCrayPointer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 234
namespace stringify {
    const char* E_SgTypeLabel(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLabel_type_kind";
            case 1L: return "SgTypeLabel_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLabel(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLabel(i);
        if (s.empty())
            s = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLabel() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLabel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLabel(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLabel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLabel() {
        return stringify::E_SgTypeLabel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 237
namespace stringify {
    const char* E_SgJavaUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnionType_type_kind";
            default: return "";
        }
    }

    std::string E_SgJavaUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnionType(i);
        if (s.empty())
            s = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnionType() {
        return stringify::E_SgJavaUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 240
namespace stringify {
    const char* E_SgRvalueReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgRvalueReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRvalueReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgRvalueReferenceType(i);
        if (s.empty())
            s = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRvalueReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRvalueReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRvalueReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRvalueReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRvalueReferenceType() {
        return stringify::E_SgRvalueReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 243
namespace stringify {
    const char* E_SgTypeNullptr(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeNullptr_type_kind";
            case 1L: return "SgTypeNullptr_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeNullptr(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeNullptr(i);
        if (s.empty())
            s = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeNullptr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeNullptr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeNullptr(i);
        if (retval.empty()) {
            retval = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeNullptr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeNullptr() {
        return stringify::E_SgTypeNullptr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 246
namespace stringify {
    const char* E_SgDeclType(int64_t i) {
        switch (i) {
            case 0L: return "SgDeclType_type_kind";
            default: return "";
        }
    }

    std::string E_SgDeclType(int64_t i, const std::string &strip) {
        std::string s = E_SgDeclType(i);
        if (s.empty())
            s = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeclType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeclType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeclType(i);
        if (retval.empty()) {
            retval = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeclType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeclType() {
        return stringify::E_SgDeclType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 249
namespace stringify {
    const char* E_SgTypeOfType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeOfType_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeOfType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeOfType(i);
        if (s.empty())
            s = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeOfType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeOfType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeOfType(i);
        if (retval.empty()) {
            retval = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeOfType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeOfType() {
        return stringify::E_SgTypeOfType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 252
namespace stringify {
    const char* E_SgTypeMatrix(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeMatrix_type_kind";
            case 1L: return "SgTypeMatrix_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeMatrix(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeMatrix(i);
        if (s.empty())
            s = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeMatrix() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeMatrix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeMatrix(i);
        if (retval.empty()) {
            retval = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeMatrix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeMatrix() {
        return stringify::E_SgTypeMatrix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 255
namespace stringify {
    const char* E_SgTypeTuple(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeTuple_type_kind";
            case 1L: return "SgTypeTuple_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeTuple(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeTuple(i);
        if (s.empty())
            s = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeTuple() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeTuple(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeTuple(i);
        if (retval.empty()) {
            retval = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeTuple::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeTuple() {
        return stringify::E_SgTypeTuple();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 258
namespace stringify {
    const char* E_SgTypeChar16(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar16_type_kind";
            case 1L: return "SgTypeChar16_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar16(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar16(i);
        if (s.empty())
            s = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar16() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar16(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar16(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar16::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar16() {
        return stringify::E_SgTypeChar16();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 261
namespace stringify {
    const char* E_SgTypeChar32(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar32_type_kind";
            case 1L: return "SgTypeChar32_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar32(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar32(i);
        if (s.empty())
            s = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar32() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar32(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar32(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar32::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar32() {
        return stringify::E_SgTypeChar32();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 264
namespace stringify {
    const char* E_SgTypeFloat128(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat128_type_kind";
            case 1L: return "SgTypeFloat128_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat128(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat128(i);
        if (s.empty())
            s = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat128() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat128(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat128(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat128::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat128() {
        return stringify::E_SgTypeFloat128();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 267
namespace stringify {
    const char* E_SgTypeFixed(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFixed_type_kind";
            case 1L: return "SgTypeFixed_scale";
            case 2L: return "SgTypeFixed_fraction";
            default: return "";
        }
    }

    std::string E_SgTypeFixed(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFixed(i);
        if (s.empty())
            s = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFixed() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFixed(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFixed(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFixed::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFixed() {
        return stringify::E_SgTypeFixed();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 270
namespace stringify {
    const char* E_SgAutoType(int64_t i) {
        switch (i) {
            case 0L: return "SgAutoType_type_kind";
            default: return "";
        }
    }

    std::string E_SgAutoType(int64_t i, const std::string &strip) {
        std::string s = E_SgAutoType(i);
        if (s.empty())
            s = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAutoType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAutoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAutoType(i);
        if (retval.empty()) {
            retval = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAutoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAutoType() {
        return stringify::E_SgAutoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 273
namespace stringify {
    const char* E_SgAdaAccessType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAccessType_type_kind";
            case 1L: return "SgAdaAccessType_base_type";
            default: return "";
        }
    }

    std::string E_SgAdaAccessType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAccessType(i);
        if (s.empty())
            s = "(E_SgAdaAccessType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAccessType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAccessType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAccessType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAccessType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAccessType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAccessType() {
        return stringify::E_SgAdaAccessType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 276
namespace stringify {
    const char* E_SgAdaSubtype(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSubtype_type_kind";
            case 1L: return "SgAdaSubtype_base_type";
            case 2L: return "SgAdaSubtype_constraint";
            default: return "";
        }
    }

    std::string E_SgAdaSubtype(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSubtype(i);
        if (s.empty())
            s = "(E_SgAdaSubtype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSubtype() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSubtype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSubtype(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSubtype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSubtype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSubtype() {
        return stringify::E_SgAdaSubtype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 279
namespace stringify {
    const char* E_SgAdaDiscreteType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscreteType_type_kind";
            case 1L: return "SgAdaDiscreteType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgAdaDiscreteType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscreteType(i);
        if (s.empty())
            s = "(E_SgAdaDiscreteType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscreteType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscreteType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscreteType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscreteType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscreteType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscreteType() {
        return stringify::E_SgAdaDiscreteType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 282
namespace stringify {
    const char* E_SgAdaModularType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaModularType_type_kind";
            case 1L: return "SgAdaModularType_modexpr";
            default: return "";
        }
    }

    std::string E_SgAdaModularType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaModularType(i);
        if (s.empty())
            s = "(E_SgAdaModularType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaModularType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaModularType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaModularType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaModularType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaModularType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaModularType() {
        return stringify::E_SgAdaModularType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 285
namespace stringify {
    const char* E_SgAdaDerivedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDerivedType_type_kind";
            case 1L: return "SgAdaDerivedType_base_type";
            default: return "";
        }
    }

    std::string E_SgAdaDerivedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDerivedType(i);
        if (s.empty())
            s = "(E_SgAdaDerivedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDerivedType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDerivedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDerivedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDerivedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDerivedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDerivedType() {
        return stringify::E_SgAdaDerivedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 288
namespace stringify {
    const char* E_SgAdaSubroutineType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSubroutineType_type_kind";
            case 1L: return "SgAdaSubroutineType_parameterList";
            case 2L: return "SgAdaSubroutineType_return_type";
            default: return "";
        }
    }

    std::string E_SgAdaSubroutineType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSubroutineType(i);
        if (s.empty())
            s = "(E_SgAdaSubroutineType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSubroutineType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSubroutineType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSubroutineType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSubroutineType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSubroutineType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSubroutineType() {
        return stringify::E_SgAdaSubroutineType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 291
namespace stringify {
    const char* E_SgJovialBitType(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialBitType_type_kind";
            default: return "";
        }
    }

    std::string E_SgJovialBitType(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialBitType(i);
        if (s.empty())
            s = "(E_SgJovialBitType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialBitType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialBitType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialBitType(i);
        if (retval.empty()) {
            retval = "(E_SgJovialBitType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialBitType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialBitType() {
        return stringify::E_SgJovialBitType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 294
namespace stringify {
    const char* E_SgRangeType(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRangeType(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeType(i);
        if (s.empty())
            s = "(E_SgRangeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeType(i);
        if (retval.empty()) {
            retval = "(E_SgRangeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeType() {
        return stringify::E_SgRangeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 297
namespace stringify {
    const char* E_SgType(int64_t i) {
        switch (i) {
            case 0L: return "SgType_type_kind";
            default: return "";
        }
    }

    std::string E_SgType(int64_t i, const std::string &strip) {
        std::string s = E_SgType(i);
        if (s.empty())
            s = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgType(i);
        if (retval.empty()) {
            retval = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgType() {
        return stringify::E_SgType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 300
namespace stringify {
    const char* E_SgCommonBlockObject(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlockObject_variable_reference_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlockObject(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlockObject(i);
        if (s.empty())
            s = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlockObject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlockObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlockObject(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlockObject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlockObject() {
        return stringify::E_SgCommonBlockObject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 303
namespace stringify {
    const char* E_SgInitializedName(int64_t i) {
        switch (i) {
            case 0L: return "SgInitializedName_initptr";
            default: return "";
        }
    }

    std::string E_SgInitializedName(int64_t i, const std::string &strip) {
        std::string s = E_SgInitializedName(i);
        if (s.empty())
            s = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInitializedName() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInitializedName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInitializedName(i);
        if (retval.empty()) {
            retval = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInitializedName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInitializedName() {
        return stringify::E_SgInitializedName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 306
namespace stringify {
    const char* E_SgJavaMemberValuePair(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaMemberValuePair_value";
            default: return "";
        }
    }

    std::string E_SgJavaMemberValuePair(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaMemberValuePair(i);
        if (s.empty())
            s = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaMemberValuePair() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaMemberValuePair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaMemberValuePair(i);
        if (retval.empty()) {
            retval = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaMemberValuePair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaMemberValuePair() {
        return stringify::E_SgJavaMemberValuePair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 309
namespace stringify {
    const char* E_SgOmpOrderedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedClause(i);
        if (s.empty())
            s = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedClause() {
        return stringify::E_SgOmpOrderedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 312
namespace stringify {
    const char* E_SgOmpCollapseClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCollapseClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpCollapseClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCollapseClause(i);
        if (s.empty())
            s = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCollapseClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCollapseClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCollapseClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCollapseClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCollapseClause() {
        return stringify::E_SgOmpCollapseClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 315
namespace stringify {
    const char* E_SgOmpIfClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpIfClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpIfClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpIfClause(i);
        if (s.empty())
            s = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpIfClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpIfClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpIfClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpIfClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpIfClause() {
        return stringify::E_SgOmpIfClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 318
namespace stringify {
    const char* E_SgOmpNumThreadsClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumThreadsClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumThreadsClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumThreadsClause(i);
        if (s.empty())
            s = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumThreadsClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumThreadsClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumThreadsClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumThreadsClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumThreadsClause() {
        return stringify::E_SgOmpNumThreadsClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 321
namespace stringify {
    const char* E_SgOmpDeviceClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeviceClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpDeviceClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeviceClause(i);
        if (s.empty())
            s = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeviceClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeviceClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeviceClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeviceClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeviceClause() {
        return stringify::E_SgOmpDeviceClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 324
namespace stringify {
    const char* E_SgOmpSafelenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSafelenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSafelenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSafelenClause(i);
        if (s.empty())
            s = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSafelenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSafelenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSafelenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSafelenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSafelenClause() {
        return stringify::E_SgOmpSafelenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 327
namespace stringify {
    const char* E_SgOmpSimdlenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdlenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSimdlenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdlenClause(i);
        if (s.empty())
            s = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdlenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdlenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdlenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdlenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdlenClause() {
        return stringify::E_SgOmpSimdlenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 330
namespace stringify {
    const char* E_SgOmpFinalClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFinalClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpFinalClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFinalClause(i);
        if (s.empty())
            s = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFinalClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFinalClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFinalClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFinalClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFinalClause() {
        return stringify::E_SgOmpFinalClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 333
namespace stringify {
    const char* E_SgOmpPriorityClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPriorityClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpPriorityClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPriorityClause(i);
        if (s.empty())
            s = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPriorityClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPriorityClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPriorityClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPriorityClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPriorityClause() {
        return stringify::E_SgOmpPriorityClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 336
namespace stringify {
    const char* E_SgOmpExpressionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpExpressionClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpExpressionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpExpressionClause(i);
        if (s.empty())
            s = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpExpressionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpExpressionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpExpressionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpExpressionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpExpressionClause() {
        return stringify::E_SgOmpExpressionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 339
namespace stringify {
    const char* E_SgOmpCopyprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyprivateClause() {
        return stringify::E_SgOmpCopyprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 342
namespace stringify {
    const char* E_SgOmpPrivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPrivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpPrivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPrivateClause(i);
        if (s.empty())
            s = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPrivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPrivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPrivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPrivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPrivateClause() {
        return stringify::E_SgOmpPrivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 345
namespace stringify {
    const char* E_SgOmpFirstprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFirstprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFirstprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFirstprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFirstprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFirstprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFirstprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFirstprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFirstprivateClause() {
        return stringify::E_SgOmpFirstprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 348
namespace stringify {
    const char* E_SgOmpSharedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSharedClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpSharedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSharedClause(i);
        if (s.empty())
            s = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSharedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSharedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSharedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSharedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSharedClause() {
        return stringify::E_SgOmpSharedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 351
namespace stringify {
    const char* E_SgOmpCopyinClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyinClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyinClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyinClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyinClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyinClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyinClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyinClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyinClause() {
        return stringify::E_SgOmpCopyinClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 354
namespace stringify {
    const char* E_SgOmpLastprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLastprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpLastprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLastprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLastprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLastprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLastprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLastprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLastprivateClause() {
        return stringify::E_SgOmpLastprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 357
namespace stringify {
    const char* E_SgOmpReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpReductionClause() {
        return stringify::E_SgOmpReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 360
namespace stringify {
    const char* E_SgOmpMapClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMapClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpMapClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMapClause(i);
        if (s.empty())
            s = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMapClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMapClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMapClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMapClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMapClause() {
        return stringify::E_SgOmpMapClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 363
namespace stringify {
    const char* E_SgOmpUniformClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUniformClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUniformClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUniformClause(i);
        if (s.empty())
            s = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUniformClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUniformClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUniformClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUniformClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUniformClause() {
        return stringify::E_SgOmpUniformClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 366
namespace stringify {
    const char* E_SgOmpAlignedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAlignedClause_variables";
            case 1L: return "SgOmpAlignedClause_alignment";
            default: return "";
        }
    }

    std::string E_SgOmpAlignedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAlignedClause(i);
        if (s.empty())
            s = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAlignedClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAlignedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAlignedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAlignedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAlignedClause() {
        return stringify::E_SgOmpAlignedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 369
namespace stringify {
    const char* E_SgOmpLinearClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLinearClause_variables";
            case 1L: return "SgOmpLinearClause_step";
            default: return "";
        }
    }

    std::string E_SgOmpLinearClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLinearClause(i);
        if (s.empty())
            s = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLinearClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLinearClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLinearClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLinearClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLinearClause() {
        return stringify::E_SgOmpLinearClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 372
namespace stringify {
    const char* E_SgOmpDependClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDependClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpDependClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDependClause(i);
        if (s.empty())
            s = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDependClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDependClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDependClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDependClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDependClause() {
        return stringify::E_SgOmpDependClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 375
namespace stringify {
    const char* E_SgOmpVariablesClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpVariablesClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpVariablesClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpVariablesClause(i);
        if (s.empty())
            s = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpVariablesClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpVariablesClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpVariablesClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpVariablesClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpVariablesClause() {
        return stringify::E_SgOmpVariablesClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 378
namespace stringify {
    const char* E_SgOmpScheduleClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpScheduleClause_chunk_size";
            default: return "";
        }
    }

    std::string E_SgOmpScheduleClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpScheduleClause(i);
        if (s.empty())
            s = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpScheduleClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpScheduleClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpScheduleClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpScheduleClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpScheduleClause() {
        return stringify::E_SgOmpScheduleClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 381
namespace stringify {
    const char* E_SgLambdaCapture(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCapture_capture_variable";
            case 1L: return "SgLambdaCapture_source_closure_variable";
            case 2L: return "SgLambdaCapture_closure_variable";
            default: return "";
        }
    }

    std::string E_SgLambdaCapture(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCapture(i);
        if (s.empty())
            s = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCapture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCapture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCapture(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCapture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCapture() {
        return stringify::E_SgLambdaCapture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 384
namespace stringify {
    const char* E_SgLambdaCaptureList(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCaptureList_capture_list";
            default: return "";
        }
    }

    std::string E_SgLambdaCaptureList(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCaptureList(i);
        if (s.empty())
            s = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCaptureList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCaptureList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCaptureList(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCaptureList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCaptureList() {
        return stringify::E_SgLambdaCaptureList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 387
namespace stringify {
    const char* E_SgAdaRangeConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRangeConstraint_range";
            default: return "";
        }
    }

    std::string E_SgAdaRangeConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRangeConstraint(i);
        if (s.empty())
            s = "(E_SgAdaRangeConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRangeConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRangeConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRangeConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRangeConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRangeConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRangeConstraint() {
        return stringify::E_SgAdaRangeConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 390
namespace stringify {
    const char* E_SgAdaIndexConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaIndexConstraint_indexRanges";
            default: return "";
        }
    }

    std::string E_SgAdaIndexConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaIndexConstraint(i);
        if (s.empty())
            s = "(E_SgAdaIndexConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaIndexConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaIndexConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaIndexConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaIndexConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaIndexConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaIndexConstraint() {
        return stringify::E_SgAdaIndexConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 393
namespace stringify {
    const char* E_SgAdaDigitsConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDigitsConstraint_digits";
            case 1L: return "SgAdaDigitsConstraint_subConstraint";
            default: return "";
        }
    }

    std::string E_SgAdaDigitsConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDigitsConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDigitsConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDigitsConstraint() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDigitsConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDigitsConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDigitsConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDigitsConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDigitsConstraint() {
        return stringify::E_SgAdaDigitsConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 396
namespace stringify {
    const char* E_SgAdaDeltaConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDeltaConstraint_delta";
            case 1L: return "SgAdaDeltaConstraint_subConstraint";
            default: return "";
        }
    }

    std::string E_SgAdaDeltaConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDeltaConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDeltaConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDeltaConstraint() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDeltaConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDeltaConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDeltaConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDeltaConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDeltaConstraint() {
        return stringify::E_SgAdaDeltaConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 399
namespace stringify {
    const char* E_SgAdaDiscriminantConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminantConstraint_discriminants";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminantConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminantConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminantConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminantConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminantConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminantConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminantConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminantConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminantConstraint() {
        return stringify::E_SgAdaDiscriminantConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 402
namespace stringify {
    const char* E_SgGlobal(int64_t i) {
        switch (i) {
            case 0L: return "SgGlobal_declarations";
            default: return "";
        }
    }

    std::string E_SgGlobal(int64_t i, const std::string &strip) {
        std::string s = E_SgGlobal(i);
        if (s.empty())
            s = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGlobal() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGlobal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGlobal(i);
        if (retval.empty()) {
            retval = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGlobal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGlobal() {
        return stringify::E_SgGlobal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 405
namespace stringify {
    const char* E_SgBasicBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgBasicBlock_statements";
            default: return "";
        }
    }

    std::string E_SgBasicBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgBasicBlock(i);
        if (s.empty())
            s = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBasicBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBasicBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBasicBlock(i);
        if (retval.empty()) {
            retval = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBasicBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBasicBlock() {
        return stringify::E_SgBasicBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 408
namespace stringify {
    const char* E_SgIfStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgIfStmt_conditional";
            case 1L: return "SgIfStmt_true_body";
            case 2L: return "SgIfStmt_false_body";
            default: return "";
        }
    }

    std::string E_SgIfStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgIfStmt(i);
        if (s.empty())
            s = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIfStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIfStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIfStmt(i);
        if (retval.empty()) {
            retval = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIfStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIfStmt() {
        return stringify::E_SgIfStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 411
namespace stringify {
    const char* E_SgForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForStatement_for_init_stmt";
            case 1L: return "SgForStatement_test";
            case 2L: return "SgForStatement_increment";
            case 3L: return "SgForStatement_loop_body";
            case 4L: return "SgForStatement_else_body";
            default: return "";
        }
    }

    std::string E_SgForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForStatement(i);
        if (s.empty())
            s = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForStatement() {
        return stringify::E_SgForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 414
namespace stringify {
    const char* E_SgTemplateFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDefinition() {
        return stringify::E_SgTemplateFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 417
namespace stringify {
    const char* E_SgFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDefinition() {
        return stringify::E_SgFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 420
namespace stringify {
    const char* E_SgTemplateInstantiationDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDefn_members";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDefn(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDefn(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDefn() {
        return stringify::E_SgTemplateInstantiationDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 423
namespace stringify {
    const char* E_SgTemplateClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDefinition() {
        return stringify::E_SgTemplateClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 426
namespace stringify {
    const char* E_SgClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDefinition(i);
        if (s.empty())
            s = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDefinition() {
        return stringify::E_SgClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 429
namespace stringify {
    const char* E_SgWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhileStmt_condition";
            case 1L: return "SgWhileStmt_body";
            case 2L: return "SgWhileStmt_else_body";
            default: return "";
        }
    }

    std::string E_SgWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhileStmt(i);
        if (s.empty())
            s = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhileStmt() {
        return stringify::E_SgWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 432
namespace stringify {
    const char* E_SgDoWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDoWhileStmt_body";
            case 1L: return "SgDoWhileStmt_condition";
            default: return "";
        }
    }

    std::string E_SgDoWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDoWhileStmt(i);
        if (s.empty())
            s = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDoWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDoWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDoWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDoWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDoWhileStmt() {
        return stringify::E_SgDoWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 435
namespace stringify {
    const char* E_SgSwitchStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSwitchStatement_item_selector";
            case 1L: return "SgSwitchStatement_body";
            default: return "";
        }
    }

    std::string E_SgSwitchStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSwitchStatement(i);
        if (s.empty())
            s = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSwitchStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSwitchStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSwitchStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSwitchStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSwitchStatement() {
        return stringify::E_SgSwitchStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 438
namespace stringify {
    const char* E_SgCatchOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchOptionStmt_condition";
            case 1L: return "SgCatchOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgCatchOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchOptionStmt(i);
        if (s.empty())
            s = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchOptionStmt() {
        return stringify::E_SgCatchOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 441
namespace stringify {
    const char* E_SgNamespaceDefinitionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDefinitionStatement_declarations";
            default: return "";
        }
    }

    std::string E_SgNamespaceDefinitionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDefinitionStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDefinitionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDefinitionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDefinitionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDefinitionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDefinitionStatement() {
        return stringify::E_SgNamespaceDefinitionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 444
namespace stringify {
    const char* E_SgAssociateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssociateStatement_body";
            default: return "";
        }
    }

    std::string E_SgAssociateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssociateStatement(i);
        if (s.empty())
            s = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssociateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssociateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssociateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssociateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssociateStatement() {
        return stringify::E_SgAssociateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 447
namespace stringify {
    const char* E_SgFortranNonblockedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranNonblockedDo_initialization";
            case 1L: return "SgFortranNonblockedDo_bound";
            case 2L: return "SgFortranNonblockedDo_increment";
            case 3L: return "SgFortranNonblockedDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranNonblockedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranNonblockedDo(i);
        if (s.empty())
            s = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranNonblockedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranNonblockedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranNonblockedDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranNonblockedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranNonblockedDo() {
        return stringify::E_SgFortranNonblockedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 450
namespace stringify {
    const char* E_SgFortranDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranDo_initialization";
            case 1L: return "SgFortranDo_bound";
            case 2L: return "SgFortranDo_increment";
            case 3L: return "SgFortranDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranDo(i);
        if (s.empty())
            s = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranDo() {
        return stringify::E_SgFortranDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 453
namespace stringify {
    const char* E_SgForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForAllStatement_forall_header";
            case 1L: return "SgForAllStatement_body";
            default: return "";
        }
    }

    std::string E_SgForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForAllStatement(i);
        if (s.empty())
            s = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForAllStatement() {
        return stringify::E_SgForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 456
namespace stringify {
    const char* E_SgUpcForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcForAllStatement_for_init_stmt";
            case 1L: return "SgUpcForAllStatement_test";
            case 2L: return "SgUpcForAllStatement_increment";
            case 3L: return "SgUpcForAllStatement_affinity";
            case 4L: return "SgUpcForAllStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgUpcForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcForAllStatement(i);
        if (s.empty())
            s = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcForAllStatement() {
        return stringify::E_SgUpcForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 459
namespace stringify {
    const char* E_SgCAFWithTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFWithTeamStatement_body";
            default: return "";
        }
    }

    std::string E_SgCAFWithTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFWithTeamStatement(i);
        if (s.empty())
            s = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFWithTeamStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFWithTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFWithTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFWithTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFWithTeamStatement() {
        return stringify::E_SgCAFWithTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 462
namespace stringify {
    const char* E_SgJavaForEachStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaForEachStatement_element";
            case 1L: return "SgJavaForEachStatement_collection";
            case 2L: return "SgJavaForEachStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJavaForEachStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaForEachStatement(i);
        if (s.empty())
            s = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaForEachStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaForEachStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaForEachStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaForEachStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaForEachStatement() {
        return stringify::E_SgJavaForEachStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 465
namespace stringify {
    const char* E_SgJavaLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgJavaLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelStatement(i);
        if (s.empty())
            s = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelStatement() {
        return stringify::E_SgJavaLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 468
namespace stringify {
    const char* E_SgMatlabForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgMatlabForStatement_index";
            case 1L: return "SgMatlabForStatement_range";
            case 2L: return "SgMatlabForStatement_body";
            default: return "";
        }
    }

    std::string E_SgMatlabForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgMatlabForStatement(i);
        if (s.empty())
            s = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatlabForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatlabForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatlabForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatlabForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatlabForStatement() {
        return stringify::E_SgMatlabForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 471
namespace stringify {
    const char* E_SgFunctionParameterScope(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterScope_declarations";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterScope(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterScope(i);
        if (s.empty())
            s = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterScope() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterScope(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterScope() {
        return stringify::E_SgFunctionParameterScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 474
namespace stringify {
    const char* E_SgRangeBasedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeBasedForStatement_iterator_declaration";
            case 1L: return "SgRangeBasedForStatement_range_declaration";
            case 2L: return "SgRangeBasedForStatement_begin_declaration";
            case 3L: return "SgRangeBasedForStatement_end_declaration";
            case 4L: return "SgRangeBasedForStatement_not_equal_expression";
            case 5L: return "SgRangeBasedForStatement_increment_expression";
            case 6L: return "SgRangeBasedForStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgRangeBasedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeBasedForStatement(i);
        if (s.empty())
            s = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeBasedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeBasedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeBasedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeBasedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeBasedForStatement() {
        return stringify::E_SgRangeBasedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 477
namespace stringify {
    const char* E_SgJovialForThenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialForThenStatement_initialization";
            case 1L: return "SgJovialForThenStatement_while_expression";
            case 2L: return "SgJovialForThenStatement_by_or_then_expression";
            case 3L: return "SgJovialForThenStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJovialForThenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialForThenStatement(i);
        if (s.empty())
            s = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialForThenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialForThenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialForThenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialForThenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialForThenStatement() {
        return stringify::E_SgJovialForThenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 480
namespace stringify {
    const char* E_SgAdaAcceptStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAcceptStmt_parameterList";
            case 1L: return "SgAdaAcceptStmt_entry";
            case 2L: return "SgAdaAcceptStmt_index";
            case 3L: return "SgAdaAcceptStmt_body";
            default: return "";
        }
    }

    std::string E_SgAdaAcceptStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAcceptStmt(i);
        if (s.empty())
            s = "(E_SgAdaAcceptStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAcceptStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAcceptStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAcceptStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAcceptStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAcceptStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAcceptStmt() {
        return stringify::E_SgAdaAcceptStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 483
namespace stringify {
    const char* E_SgAdaPackageSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSpec(i);
        if (s.empty())
            s = "(E_SgAdaPackageSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSpec() {
        return stringify::E_SgAdaPackageSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 486
namespace stringify {
    const char* E_SgAdaPackageBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaPackageBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageBody(i);
        if (s.empty())
            s = "(E_SgAdaPackageBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageBody() {
        return stringify::E_SgAdaPackageBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 489
namespace stringify {
    const char* E_SgAdaTaskSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSpec(i);
        if (s.empty())
            s = "(E_SgAdaTaskSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSpec() {
        return stringify::E_SgAdaTaskSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 492
namespace stringify {
    const char* E_SgAdaTaskBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaTaskBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskBody(i);
        if (s.empty())
            s = "(E_SgAdaTaskBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskBody() {
        return stringify::E_SgAdaTaskBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 495
namespace stringify {
    const char* E_SgAdaProtectedBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedBody(i);
        if (s.empty())
            s = "(E_SgAdaProtectedBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedBody() {
        return stringify::E_SgAdaProtectedBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 498
namespace stringify {
    const char* E_SgAdaProtectedSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSpec(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSpec() {
        return stringify::E_SgAdaProtectedSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 501
namespace stringify {
    const char* E_SgAdaGenericDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericDefn_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaGenericDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericDefn(i);
        if (s.empty())
            s = "(E_SgAdaGenericDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericDefn(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericDefn() {
        return stringify::E_SgAdaGenericDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 504
namespace stringify {
    const char* E_SgFunctionParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterList_args";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterList(i);
        if (s.empty())
            s = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterList() {
        return stringify::E_SgFunctionParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 507
namespace stringify {
    const char* E_SgTemplateVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgTemplateVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgTemplateVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateVariableDeclaration() {
        return stringify::E_SgTemplateVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 510
namespace stringify {
    const char* E_SgTemplateVariableInstantiation(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateVariableInstantiation_baseTypeDefiningDeclaration";
            case 1L: return "SgTemplateVariableInstantiation_variables";
            default: return "";
        }
    }

    std::string E_SgTemplateVariableInstantiation(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateVariableInstantiation(i);
        if (s.empty())
            s = "(E_SgTemplateVariableInstantiation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateVariableInstantiation() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateVariableInstantiation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateVariableInstantiation(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateVariableInstantiation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateVariableInstantiation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateVariableInstantiation() {
        return stringify::E_SgTemplateVariableInstantiation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 513
namespace stringify {
    const char* E_SgVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDeclaration() {
        return stringify::E_SgVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 516
namespace stringify {
    const char* E_SgVariableDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDefinition_vardefn";
            case 1L: return "SgVariableDefinition_bitfield";
            default: return "";
        }
    }

    std::string E_SgVariableDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDefinition(i);
        if (s.empty())
            s = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDefinition() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDefinition() {
        return stringify::E_SgVariableDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 519
namespace stringify {
    const char* E_SgEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumDeclaration() {
        return stringify::E_SgEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 522
namespace stringify {
    const char* E_SgAsmStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmStmt_operands";
            default: return "";
        }
    }

    std::string E_SgAsmStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmStmt(i);
        if (s.empty())
            s = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmStmt() {
        return stringify::E_SgAsmStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 525
namespace stringify {
    const char* E_SgTemplateInstantiationDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDirectiveStatement_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDirectiveStatement() {
        return stringify::E_SgTemplateInstantiationDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 528
namespace stringify {
    const char* E_SgUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUseStatement(i);
        if (s.empty())
            s = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUseStatement() {
        return stringify::E_SgUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 531
namespace stringify {
    const char* E_SgNamespaceDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDeclarationStatement_definition";
            default: return "";
        }
    }

    std::string E_SgNamespaceDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDeclarationStatement() {
        return stringify::E_SgNamespaceDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 534
namespace stringify {
    const char* E_SgInterfaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInterfaceStatement_interface_body_list";
            default: return "";
        }
    }

    std::string E_SgInterfaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInterfaceStatement(i);
        if (s.empty())
            s = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInterfaceStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInterfaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInterfaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInterfaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInterfaceStatement() {
        return stringify::E_SgInterfaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 537
namespace stringify {
    const char* E_SgCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlock_block_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlock(i);
        if (s.empty())
            s = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlock() {
        return stringify::E_SgCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 540
namespace stringify {
    const char* E_SgTemplateTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefDeclaration() {
        return stringify::E_SgTemplateTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 543
namespace stringify {
    const char* E_SgTemplateInstantiationTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationTypedefDeclaration() {
        return stringify::E_SgTemplateInstantiationTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 546
namespace stringify {
    const char* E_SgTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefDeclaration() {
        return stringify::E_SgTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 549
namespace stringify {
    const char* E_SgStatementFunctionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementFunctionStatement_function";
            case 1L: return "SgStatementFunctionStatement_expression";
            default: return "";
        }
    }

    std::string E_SgStatementFunctionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementFunctionStatement(i);
        if (s.empty())
            s = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementFunctionStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementFunctionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementFunctionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementFunctionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementFunctionStatement() {
        return stringify::E_SgStatementFunctionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 552
namespace stringify {
    const char* E_SgCtorInitializerList(int64_t i) {
        switch (i) {
            case 0L: return "SgCtorInitializerList_ctors";
            default: return "";
        }
    }

    std::string E_SgCtorInitializerList(int64_t i, const std::string &strip) {
        std::string s = E_SgCtorInitializerList(i);
        if (s.empty())
            s = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCtorInitializerList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCtorInitializerList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCtorInitializerList(i);
        if (retval.empty()) {
            retval = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCtorInitializerList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCtorInitializerList() {
        return stringify::E_SgCtorInitializerList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 555
namespace stringify {
    const char* E_SgPragmaDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgPragmaDeclaration_pragma";
            default: return "";
        }
    }

    std::string E_SgPragmaDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgPragmaDeclaration(i);
        if (s.empty())
            s = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPragmaDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPragmaDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPragmaDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPragmaDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPragmaDeclaration() {
        return stringify::E_SgPragmaDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 558
namespace stringify {
    const char* E_SgTemplateClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDeclaration_definition";
            case 1L: return "SgTemplateClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDeclaration() {
        return stringify::E_SgTemplateClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 561
namespace stringify {
    const char* E_SgTemplateInstantiationDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDecl_definition";
            case 1L: return "SgTemplateInstantiationDecl_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDecl() {
        return stringify::E_SgTemplateInstantiationDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 564
namespace stringify {
    const char* E_SgDerivedTypeStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDerivedTypeStatement_definition";
            case 1L: return "SgDerivedTypeStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgDerivedTypeStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDerivedTypeStatement(i);
        if (s.empty())
            s = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDerivedTypeStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDerivedTypeStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDerivedTypeStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDerivedTypeStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDerivedTypeStatement() {
        return stringify::E_SgDerivedTypeStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 567
namespace stringify {
    const char* E_SgModuleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleStatement_definition";
            case 1L: return "SgModuleStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgModuleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleStatement(i);
        if (s.empty())
            s = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleStatement() {
        return stringify::E_SgModuleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 570
namespace stringify {
    const char* E_SgJavaPackageDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaPackageDeclaration_definition";
            case 1L: return "SgJavaPackageDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJavaPackageDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaPackageDeclaration(i);
        if (s.empty())
            s = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaPackageDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaPackageDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaPackageDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaPackageDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaPackageDeclaration() {
        return stringify::E_SgJavaPackageDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 573
namespace stringify {
    const char* E_SgJovialTableStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableStatement_definition";
            case 1L: return "SgJovialTableStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJovialTableStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableStatement(i);
        if (s.empty())
            s = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableStatement() {
        return stringify::E_SgJovialTableStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 576
namespace stringify {
    const char* E_SgClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDeclaration_definition";
            case 1L: return "SgClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDeclaration(i);
        if (s.empty())
            s = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDeclaration() {
        return stringify::E_SgClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 579
namespace stringify {
    const char* E_SgImplicitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImplicitStatement_variables";
            default: return "";
        }
    }

    std::string E_SgImplicitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImplicitStatement(i);
        if (s.empty())
            s = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImplicitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImplicitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImplicitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImplicitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImplicitStatement() {
        return stringify::E_SgImplicitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 582
namespace stringify {
    const char* E_SgTemplateFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDeclaration() {
        return stringify::E_SgTemplateFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 585
namespace stringify {
    const char* E_SgTemplateMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateMemberFunctionDeclaration_definition";
            case 3L: return "SgTemplateMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionDeclaration() {
        return stringify::E_SgTemplateMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 588
namespace stringify {
    const char* E_SgTemplateInstantiationMemberFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationMemberFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationMemberFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationMemberFunctionDecl_definition";
            case 3L: return "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationMemberFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationMemberFunctionDecl() {
        return stringify::E_SgTemplateInstantiationMemberFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 591
namespace stringify {
    const char* E_SgMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionDeclaration_parameterList";
            case 1L: return "SgMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgMemberFunctionDeclaration_definition";
            case 3L: return "SgMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionDeclaration() {
        return stringify::E_SgMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 594
namespace stringify {
    const char* E_SgTemplateInstantiationFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationFunctionDecl_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationFunctionDecl() {
        return stringify::E_SgTemplateInstantiationFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 597
namespace stringify {
    const char* E_SgProgramHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProgramHeaderStatement_parameterList";
            case 1L: return "SgProgramHeaderStatement_decoratorList";
            case 2L: return "SgProgramHeaderStatement_definition";
            default: return "";
        }
    }

    std::string E_SgProgramHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProgramHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProgramHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProgramHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProgramHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProgramHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProgramHeaderStatement() {
        return stringify::E_SgProgramHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 600
namespace stringify {
    const char* E_SgProcedureHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcedureHeaderStatement_parameterList";
            case 1L: return "SgProcedureHeaderStatement_decoratorList";
            case 2L: return "SgProcedureHeaderStatement_definition";
            case 3L: return "SgProcedureHeaderStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgProcedureHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcedureHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcedureHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcedureHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcedureHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcedureHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcedureHeaderStatement() {
        return stringify::E_SgProcedureHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 603
namespace stringify {
    const char* E_SgEntryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEntryStatement_parameterList";
            case 1L: return "SgEntryStatement_decoratorList";
            case 2L: return "SgEntryStatement_definition";
            case 3L: return "SgEntryStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgEntryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEntryStatement(i);
        if (s.empty())
            s = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEntryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEntryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEntryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEntryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEntryStatement() {
        return stringify::E_SgEntryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 606
namespace stringify {
    const char* E_SgAdaEntryDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaEntryDecl_parameterList";
            case 1L: return "SgAdaEntryDecl_decoratorList";
            case 2L: return "SgAdaEntryDecl_definition";
            case 3L: return "SgAdaEntryDecl_entryIndex";
            case 4L: return "SgAdaEntryDecl_entryBarrier";
            default: return "";
        }
    }

    std::string E_SgAdaEntryDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaEntryDecl(i);
        if (s.empty())
            s = "(E_SgAdaEntryDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaEntryDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaEntryDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaEntryDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaEntryDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaEntryDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaEntryDecl() {
        return stringify::E_SgAdaEntryDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 609
namespace stringify {
    const char* E_SgAdaFunctionRenamingDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFunctionRenamingDecl_parameterList";
            case 1L: return "SgAdaFunctionRenamingDecl_decoratorList";
            case 2L: return "SgAdaFunctionRenamingDecl_definition";
            case 3L: return "SgAdaFunctionRenamingDecl_renamed_function";
            default: return "";
        }
    }

    std::string E_SgAdaFunctionRenamingDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFunctionRenamingDecl(i);
        if (s.empty())
            s = "(E_SgAdaFunctionRenamingDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFunctionRenamingDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFunctionRenamingDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFunctionRenamingDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFunctionRenamingDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFunctionRenamingDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFunctionRenamingDecl() {
        return stringify::E_SgAdaFunctionRenamingDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 612
namespace stringify {
    const char* E_SgFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDeclaration_parameterList";
            case 1L: return "SgFunctionDeclaration_decoratorList";
            case 2L: return "SgFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDeclaration() {
        return stringify::E_SgFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 615
namespace stringify {
    const char* E_SgIncludeDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeDirectiveStatement_headerFileBody";
            default: return "";
        }
    }

    std::string E_SgIncludeDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeDirectiveStatement() {
        return stringify::E_SgIncludeDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 618
namespace stringify {
    const char* E_SgOmpThreadprivateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpThreadprivateStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpThreadprivateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpThreadprivateStatement(i);
        if (s.empty())
            s = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpThreadprivateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpThreadprivateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpThreadprivateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpThreadprivateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpThreadprivateStatement() {
        return stringify::E_SgOmpThreadprivateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 621
namespace stringify {
    const char* E_SgStmtDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStmtDeclarationStatement_statement";
            default: return "";
        }
    }

    std::string E_SgStmtDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStmtDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStmtDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStmtDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStmtDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStmtDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStmtDeclarationStatement() {
        return stringify::E_SgStmtDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 624
namespace stringify {
    const char* E_SgStaticAssertionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgStaticAssertionDeclaration_condition";
            default: return "";
        }
    }

    std::string E_SgStaticAssertionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgStaticAssertionDeclaration(i);
        if (s.empty())
            s = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStaticAssertionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStaticAssertionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStaticAssertionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStaticAssertionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStaticAssertionDeclaration() {
        return stringify::E_SgStaticAssertionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 627
namespace stringify {
    const char* E_SgOmpDeclareSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeclareSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDeclareSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeclareSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeclareSimdStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeclareSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeclareSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeclareSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeclareSimdStatement() {
        return stringify::E_SgOmpDeclareSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 630
namespace stringify {
    const char* E_SgJovialOverlayDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialOverlayDeclaration_address";
            case 1L: return "SgJovialOverlayDeclaration_overlay";
            default: return "";
        }
    }

    std::string E_SgJovialOverlayDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialOverlayDeclaration(i);
        if (s.empty())
            s = "(E_SgJovialOverlayDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialOverlayDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialOverlayDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialOverlayDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgJovialOverlayDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialOverlayDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialOverlayDeclaration() {
        return stringify::E_SgJovialOverlayDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 633
namespace stringify {
    const char* E_SgAdaPackageBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaPackageBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaPackageBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageBodyDecl() {
        return stringify::E_SgAdaPackageBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 636
namespace stringify {
    const char* E_SgAdaPackageSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaPackageSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSpecDecl() {
        return stringify::E_SgAdaPackageSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 639
namespace stringify {
    const char* E_SgAdaRenamingDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRenamingDecl_renamed";
            default: return "";
        }
    }

    std::string E_SgAdaRenamingDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRenamingDecl(i);
        if (s.empty())
            s = "(E_SgAdaRenamingDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRenamingDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRenamingDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRenamingDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRenamingDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRenamingDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRenamingDecl() {
        return stringify::E_SgAdaRenamingDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 642
namespace stringify {
    const char* E_SgAdaTaskSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSpecDecl() {
        return stringify::E_SgAdaTaskSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 645
namespace stringify {
    const char* E_SgAdaTaskBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskBodyDecl() {
        return stringify::E_SgAdaTaskBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 648
namespace stringify {
    const char* E_SgAdaTaskTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskTypeDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskTypeDecl() {
        return stringify::E_SgAdaTaskTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 651
namespace stringify {
    const char* E_SgAdaProtectedSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSpecDecl() {
        return stringify::E_SgAdaProtectedSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 654
namespace stringify {
    const char* E_SgAdaProtectedBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedBodyDecl() {
        return stringify::E_SgAdaProtectedBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 657
namespace stringify {
    const char* E_SgAdaProtectedTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedTypeDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedTypeDecl() {
        return stringify::E_SgAdaProtectedTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 660
namespace stringify {
    const char* E_SgAdaRepresentationClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRepresentationClause_alignment";
            case 1L: return "SgAdaRepresentationClause_components";
            default: return "";
        }
    }

    std::string E_SgAdaRepresentationClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRepresentationClause(i);
        if (s.empty())
            s = "(E_SgAdaRepresentationClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRepresentationClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRepresentationClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRepresentationClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRepresentationClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRepresentationClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRepresentationClause() {
        return stringify::E_SgAdaRepresentationClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 663
namespace stringify {
    const char* E_SgAdaComponentClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaComponentClause_component";
            case 1L: return "SgAdaComponentClause_offset";
            case 2L: return "SgAdaComponentClause_range";
            default: return "";
        }
    }

    std::string E_SgAdaComponentClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaComponentClause(i);
        if (s.empty())
            s = "(E_SgAdaComponentClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaComponentClause() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaComponentClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaComponentClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaComponentClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaComponentClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaComponentClause() {
        return stringify::E_SgAdaComponentClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 666
namespace stringify {
    const char* E_SgAdaAttributeClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAttributeClause_attribute";
            case 1L: return "SgAdaAttributeClause_size";
            default: return "";
        }
    }

    std::string E_SgAdaAttributeClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAttributeClause(i);
        if (s.empty())
            s = "(E_SgAdaAttributeClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAttributeClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAttributeClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAttributeClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAttributeClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAttributeClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAttributeClause() {
        return stringify::E_SgAdaAttributeClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 669
namespace stringify {
    const char* E_SgAdaEnumRepresentationClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaEnumRepresentationClause_components";
            default: return "";
        }
    }

    std::string E_SgAdaEnumRepresentationClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaEnumRepresentationClause(i);
        if (s.empty())
            s = "(E_SgAdaEnumRepresentationClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaEnumRepresentationClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaEnumRepresentationClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaEnumRepresentationClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaEnumRepresentationClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaEnumRepresentationClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaEnumRepresentationClause() {
        return stringify::E_SgAdaEnumRepresentationClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 672
namespace stringify {
    const char* E_SgAdaGenericDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericDecl_definition";
            case 1L: return "SgAdaGenericDecl_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericDecl(i);
        if (s.empty())
            s = "(E_SgAdaGenericDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericDecl() {
        return stringify::E_SgAdaGenericDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 675
namespace stringify {
    const char* E_SgAdaFormalTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalTypeDecl_discriminants";
            default: return "";
        }
    }

    std::string E_SgAdaFormalTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaFormalTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalTypeDecl() {
        return stringify::E_SgAdaFormalTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 678
namespace stringify {
    const char* E_SgAdaDiscriminatedTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminatedTypeDecl_discriminants";
            case 1L: return "SgAdaDiscriminatedTypeDecl_discriminatedDecl";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminatedTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminatedTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminatedTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminatedTypeDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminatedTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminatedTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminatedTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminatedTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminatedTypeDecl() {
        return stringify::E_SgAdaDiscriminatedTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 681
namespace stringify {
    const char* E_SgAdaGenericInstanceDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericInstanceDecl_instantiatedScope";
            case 1L: return "SgAdaGenericInstanceDecl_actual_parameters";
            default: return "";
        }
    }

    std::string E_SgAdaGenericInstanceDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericInstanceDecl(i);
        if (s.empty())
            s = "(E_SgAdaGenericInstanceDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericInstanceDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericInstanceDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericInstanceDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericInstanceDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericInstanceDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericInstanceDecl() {
        return stringify::E_SgAdaGenericInstanceDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 684
namespace stringify {
    const char* E_SgAdaParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaParameterList_parameters";
            default: return "";
        }
    }

    std::string E_SgAdaParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaParameterList(i);
        if (s.empty())
            s = "(E_SgAdaParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgAdaParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaParameterList() {
        return stringify::E_SgAdaParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 687
namespace stringify {
    const char* E_SgAdaVariantDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaVariantDecl_discriminant";
            case 1L: return "SgAdaVariantDecl_variants";
            default: return "";
        }
    }

    std::string E_SgAdaVariantDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaVariantDecl(i);
        if (s.empty())
            s = "(E_SgAdaVariantDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaVariantDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaVariantDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaVariantDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaVariantDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaVariantDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaVariantDecl() {
        return stringify::E_SgAdaVariantDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 690
namespace stringify {
    const char* E_SgExprStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExprStatement_expression";
            default: return "";
        }
    }

    std::string E_SgExprStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExprStatement(i);
        if (s.empty())
            s = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprStatement() {
        return stringify::E_SgExprStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 693
namespace stringify {
    const char* E_SgLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelStatement(i);
        if (s.empty())
            s = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelStatement() {
        return stringify::E_SgLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 696
namespace stringify {
    const char* E_SgCaseOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCaseOptionStmt_key";
            case 1L: return "SgCaseOptionStmt_body";
            case 2L: return "SgCaseOptionStmt_key_range_end";
            default: return "";
        }
    }

    std::string E_SgCaseOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCaseOptionStmt(i);
        if (s.empty())
            s = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCaseOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCaseOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCaseOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCaseOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCaseOptionStmt() {
        return stringify::E_SgCaseOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 699
namespace stringify {
    const char* E_SgTryStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgTryStmt_body";
            case 1L: return "SgTryStmt_catch_statement_seq_root";
            case 2L: return "SgTryStmt_else_body";
            case 3L: return "SgTryStmt_finally_body";
            default: return "";
        }
    }

    std::string E_SgTryStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgTryStmt(i);
        if (s.empty())
            s = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTryStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTryStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTryStmt(i);
        if (retval.empty()) {
            retval = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTryStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTryStmt() {
        return stringify::E_SgTryStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 702
namespace stringify {
    const char* E_SgDefaultOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDefaultOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgDefaultOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDefaultOptionStmt(i);
        if (s.empty())
            s = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDefaultOptionStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDefaultOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDefaultOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDefaultOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDefaultOptionStmt() {
        return stringify::E_SgDefaultOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 705
namespace stringify {
    const char* E_SgReturnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgReturnStmt_expression";
            default: return "";
        }
    }

    std::string E_SgReturnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgReturnStmt(i);
        if (s.empty())
            s = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReturnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReturnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReturnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReturnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReturnStmt() {
        return stringify::E_SgReturnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 708
namespace stringify {
    const char* E_SgSpawnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgSpawnStmt_the_func";
            default: return "";
        }
    }

    std::string E_SgSpawnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgSpawnStmt(i);
        if (s.empty())
            s = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpawnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpawnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpawnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpawnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpawnStmt() {
        return stringify::E_SgSpawnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 711
namespace stringify {
    const char* E_SgForInitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForInitStatement_init_stmt";
            default: return "";
        }
    }

    std::string E_SgForInitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForInitStatement(i);
        if (s.empty())
            s = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForInitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForInitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForInitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForInitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForInitStatement() {
        return stringify::E_SgForInitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 714
namespace stringify {
    const char* E_SgCatchStatementSeq(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchStatementSeq_catch_statement_seq";
            default: return "";
        }
    }

    std::string E_SgCatchStatementSeq(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchStatementSeq(i);
        if (s.empty())
            s = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchStatementSeq() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchStatementSeq(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchStatementSeq(i);
        if (retval.empty()) {
            retval = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchStatementSeq::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchStatementSeq() {
        return stringify::E_SgCatchStatementSeq();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 717
namespace stringify {
    const char* E_SgProcessControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcessControlStatement_code";
            case 1L: return "SgProcessControlStatement_quiet";
            default: return "";
        }
    }

    std::string E_SgProcessControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcessControlStatement(i);
        if (s.empty())
            s = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcessControlStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcessControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcessControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcessControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcessControlStatement() {
        return stringify::E_SgProcessControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 720
namespace stringify {
    const char* E_SgPrintStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgPrintStatement_io_stmt_list";
            case 1L: return "SgPrintStatement_unit";
            case 2L: return "SgPrintStatement_iostat";
            case 3L: return "SgPrintStatement_err";
            case 4L: return "SgPrintStatement_iomsg";
            case 5L: return "SgPrintStatement_format";
            default: return "";
        }
    }

    std::string E_SgPrintStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgPrintStatement(i);
        if (s.empty())
            s = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPrintStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPrintStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPrintStatement(i);
        if (retval.empty()) {
            retval = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPrintStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPrintStatement() {
        return stringify::E_SgPrintStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 723
namespace stringify {
    const char* E_SgReadStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgReadStatement_io_stmt_list";
            case 1L: return "SgReadStatement_unit";
            case 2L: return "SgReadStatement_iostat";
            case 3L: return "SgReadStatement_err";
            case 4L: return "SgReadStatement_iomsg";
            case 5L: return "SgReadStatement_format";
            case 6L: return "SgReadStatement_namelist";
            case 7L: return "SgReadStatement_advance";
            case 8L: return "SgReadStatement_asynchronous";
            case 9L: return "SgReadStatement_blank";
            case 10L: return "SgReadStatement_decimal";
            case 11L: return "SgReadStatement_delim";
            case 12L: return "SgReadStatement_end";
            case 13L: return "SgReadStatement_eor";
            case 14L: return "SgReadStatement_id";
            case 15L: return "SgReadStatement_pad";
            case 16L: return "SgReadStatement_pos";
            case 17L: return "SgReadStatement_rec";
            case 18L: return "SgReadStatement_round";
            case 19L: return "SgReadStatement_sign";
            case 20L: return "SgReadStatement_size";
            default: return "";
        }
    }

    std::string E_SgReadStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgReadStatement(i);
        if (s.empty())
            s = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReadStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReadStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReadStatement(i);
        if (retval.empty()) {
            retval = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReadStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReadStatement() {
        return stringify::E_SgReadStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 726
namespace stringify {
    const char* E_SgWriteStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWriteStatement_io_stmt_list";
            case 1L: return "SgWriteStatement_unit";
            case 2L: return "SgWriteStatement_iostat";
            case 3L: return "SgWriteStatement_err";
            case 4L: return "SgWriteStatement_iomsg";
            case 5L: return "SgWriteStatement_format";
            case 6L: return "SgWriteStatement_namelist";
            case 7L: return "SgWriteStatement_advance";
            case 8L: return "SgWriteStatement_asynchronous";
            case 9L: return "SgWriteStatement_blank";
            case 10L: return "SgWriteStatement_decimal";
            case 11L: return "SgWriteStatement_delim";
            case 12L: return "SgWriteStatement_end";
            case 13L: return "SgWriteStatement_eor";
            case 14L: return "SgWriteStatement_id";
            case 15L: return "SgWriteStatement_pad";
            case 16L: return "SgWriteStatement_pos";
            case 17L: return "SgWriteStatement_rec";
            case 18L: return "SgWriteStatement_round";
            case 19L: return "SgWriteStatement_sign";
            case 20L: return "SgWriteStatement_size";
            default: return "";
        }
    }

    std::string E_SgWriteStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWriteStatement(i);
        if (s.empty())
            s = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWriteStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWriteStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWriteStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWriteStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWriteStatement() {
        return stringify::E_SgWriteStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 729
namespace stringify {
    const char* E_SgOpenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOpenStatement_io_stmt_list";
            case 1L: return "SgOpenStatement_unit";
            case 2L: return "SgOpenStatement_iostat";
            case 3L: return "SgOpenStatement_err";
            case 4L: return "SgOpenStatement_iomsg";
            case 5L: return "SgOpenStatement_file";
            case 6L: return "SgOpenStatement_status";
            case 7L: return "SgOpenStatement_access";
            case 8L: return "SgOpenStatement_form";
            case 9L: return "SgOpenStatement_recl";
            case 10L: return "SgOpenStatement_blank";
            case 11L: return "SgOpenStatement_position";
            case 12L: return "SgOpenStatement_action";
            case 13L: return "SgOpenStatement_delim";
            case 14L: return "SgOpenStatement_pad";
            case 15L: return "SgOpenStatement_round";
            case 16L: return "SgOpenStatement_sign";
            case 17L: return "SgOpenStatement_asynchronous";
            default: return "";
        }
    }

    std::string E_SgOpenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOpenStatement(i);
        if (s.empty())
            s = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOpenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOpenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOpenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOpenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOpenStatement() {
        return stringify::E_SgOpenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 732
namespace stringify {
    const char* E_SgCloseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCloseStatement_io_stmt_list";
            case 1L: return "SgCloseStatement_unit";
            case 2L: return "SgCloseStatement_iostat";
            case 3L: return "SgCloseStatement_err";
            case 4L: return "SgCloseStatement_iomsg";
            case 5L: return "SgCloseStatement_status";
            default: return "";
        }
    }

    std::string E_SgCloseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCloseStatement(i);
        if (s.empty())
            s = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCloseStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCloseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCloseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCloseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCloseStatement() {
        return stringify::E_SgCloseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 735
namespace stringify {
    const char* E_SgInquireStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInquireStatement_io_stmt_list";
            case 1L: return "SgInquireStatement_unit";
            case 2L: return "SgInquireStatement_iostat";
            case 3L: return "SgInquireStatement_err";
            case 4L: return "SgInquireStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgInquireStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInquireStatement(i);
        if (s.empty())
            s = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInquireStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInquireStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInquireStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInquireStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInquireStatement() {
        return stringify::E_SgInquireStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 738
namespace stringify {
    const char* E_SgFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgFlushStatement_io_stmt_list";
            case 1L: return "SgFlushStatement_unit";
            case 2L: return "SgFlushStatement_iostat";
            case 3L: return "SgFlushStatement_err";
            case 4L: return "SgFlushStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgFlushStatement(i);
        if (s.empty())
            s = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFlushStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFlushStatement() {
        return stringify::E_SgFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 741
namespace stringify {
    const char* E_SgBackspaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgBackspaceStatement_io_stmt_list";
            case 1L: return "SgBackspaceStatement_unit";
            case 2L: return "SgBackspaceStatement_iostat";
            case 3L: return "SgBackspaceStatement_err";
            case 4L: return "SgBackspaceStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgBackspaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgBackspaceStatement(i);
        if (s.empty())
            s = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBackspaceStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBackspaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBackspaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBackspaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBackspaceStatement() {
        return stringify::E_SgBackspaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 744
namespace stringify {
    const char* E_SgRewindStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRewindStatement_io_stmt_list";
            case 1L: return "SgRewindStatement_unit";
            case 2L: return "SgRewindStatement_iostat";
            case 3L: return "SgRewindStatement_err";
            case 4L: return "SgRewindStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgRewindStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRewindStatement(i);
        if (s.empty())
            s = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRewindStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRewindStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRewindStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRewindStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRewindStatement() {
        return stringify::E_SgRewindStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 747
namespace stringify {
    const char* E_SgEndfileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEndfileStatement_io_stmt_list";
            case 1L: return "SgEndfileStatement_unit";
            case 2L: return "SgEndfileStatement_iostat";
            case 3L: return "SgEndfileStatement_err";
            case 4L: return "SgEndfileStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgEndfileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEndfileStatement(i);
        if (s.empty())
            s = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEndfileStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEndfileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEndfileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEndfileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEndfileStatement() {
        return stringify::E_SgEndfileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 750
namespace stringify {
    const char* E_SgWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWaitStatement_io_stmt_list";
            case 1L: return "SgWaitStatement_unit";
            case 2L: return "SgWaitStatement_iostat";
            case 3L: return "SgWaitStatement_err";
            case 4L: return "SgWaitStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWaitStatement(i);
        if (s.empty())
            s = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWaitStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWaitStatement() {
        return stringify::E_SgWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 753
namespace stringify {
    const char* E_SgIOStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIOStatement_io_stmt_list";
            case 1L: return "SgIOStatement_unit";
            case 2L: return "SgIOStatement_iostat";
            case 3L: return "SgIOStatement_err";
            case 4L: return "SgIOStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgIOStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIOStatement(i);
        if (s.empty())
            s = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOStatement() {
        return stringify::E_SgIOStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 756
namespace stringify {
    const char* E_SgWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWhereStatement_condition";
            case 1L: return "SgWhereStatement_body";
            case 2L: return "SgWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWhereStatement(i);
        if (s.empty())
            s = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhereStatement() {
        return stringify::E_SgWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 759
namespace stringify {
    const char* E_SgElseWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgElseWhereStatement_condition";
            case 1L: return "SgElseWhereStatement_body";
            case 2L: return "SgElseWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgElseWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgElseWhereStatement(i);
        if (s.empty())
            s = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElseWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElseWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElseWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElseWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElseWhereStatement() {
        return stringify::E_SgElseWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 762
namespace stringify {
    const char* E_SgNullifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNullifyStatement_pointer_list";
            default: return "";
        }
    }

    std::string E_SgNullifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNullifyStatement(i);
        if (s.empty())
            s = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNullifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNullifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNullifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNullifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNullifyStatement() {
        return stringify::E_SgNullifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 765
namespace stringify {
    const char* E_SgArithmeticIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgArithmeticIfStatement_conditional";
            default: return "";
        }
    }

    std::string E_SgArithmeticIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgArithmeticIfStatement(i);
        if (s.empty())
            s = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArithmeticIfStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArithmeticIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArithmeticIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArithmeticIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArithmeticIfStatement() {
        return stringify::E_SgArithmeticIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 768
namespace stringify {
    const char* E_SgAssignStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignStatement_value";
            default: return "";
        }
    }

    std::string E_SgAssignStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignStatement(i);
        if (s.empty())
            s = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignStatement() {
        return stringify::E_SgAssignStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 771
namespace stringify {
    const char* E_SgComputedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgComputedGotoStatement_labelList";
            case 1L: return "SgComputedGotoStatement_label_index";
            default: return "";
        }
    }

    std::string E_SgComputedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgComputedGotoStatement(i);
        if (s.empty())
            s = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComputedGotoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComputedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComputedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComputedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComputedGotoStatement() {
        return stringify::E_SgComputedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 774
namespace stringify {
    const char* E_SgAssignedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignedGotoStatement_targets";
            default: return "";
        }
    }

    std::string E_SgAssignedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignedGotoStatement(i);
        if (s.empty())
            s = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignedGotoStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignedGotoStatement() {
        return stringify::E_SgAssignedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 777
namespace stringify {
    const char* E_SgAllocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAllocateStatement_expr_list";
            case 1L: return "SgAllocateStatement_stat_expression";
            case 2L: return "SgAllocateStatement_errmsg_expression";
            case 3L: return "SgAllocateStatement_source_expression";
            default: return "";
        }
    }

    std::string E_SgAllocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAllocateStatement(i);
        if (s.empty())
            s = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAllocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAllocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAllocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAllocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAllocateStatement() {
        return stringify::E_SgAllocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 780
namespace stringify {
    const char* E_SgDeallocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDeallocateStatement_expr_list";
            case 1L: return "SgDeallocateStatement_stat_expression";
            case 2L: return "SgDeallocateStatement_errmsg_expression";
            default: return "";
        }
    }

    std::string E_SgDeallocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDeallocateStatement(i);
        if (s.empty())
            s = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeallocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeallocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeallocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeallocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeallocateStatement() {
        return stringify::E_SgDeallocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 783
namespace stringify {
    const char* E_SgUpcNotifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcNotifyStatement_notify_expression";
            default: return "";
        }
    }

    std::string E_SgUpcNotifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcNotifyStatement(i);
        if (s.empty())
            s = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcNotifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcNotifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcNotifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcNotifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcNotifyStatement() {
        return stringify::E_SgUpcNotifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 786
namespace stringify {
    const char* E_SgUpcWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcWaitStatement_wait_expression";
            default: return "";
        }
    }

    std::string E_SgUpcWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcWaitStatement(i);
        if (s.empty())
            s = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcWaitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcWaitStatement() {
        return stringify::E_SgUpcWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 789
namespace stringify {
    const char* E_SgUpcBarrierStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBarrierStatement_barrier_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBarrierStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBarrierStatement(i);
        if (s.empty())
            s = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBarrierStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBarrierStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBarrierStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBarrierStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBarrierStatement() {
        return stringify::E_SgUpcBarrierStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 792
namespace stringify {
    const char* E_SgOmpFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFlushStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFlushStatement(i);
        if (s.empty())
            s = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFlushStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFlushStatement() {
        return stringify::E_SgOmpFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 795
namespace stringify {
    const char* E_SgOmpMasterStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMasterStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpMasterStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMasterStatement(i);
        if (s.empty())
            s = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMasterStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMasterStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMasterStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMasterStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMasterStatement() {
        return stringify::E_SgOmpMasterStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 798
namespace stringify {
    const char* E_SgOmpOrderedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedStatement(i);
        if (s.empty())
            s = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedStatement() {
        return stringify::E_SgOmpOrderedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 801
namespace stringify {
    const char* E_SgOmpCriticalStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCriticalStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpCriticalStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCriticalStatement(i);
        if (s.empty())
            s = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCriticalStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCriticalStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCriticalStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCriticalStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCriticalStatement() {
        return stringify::E_SgOmpCriticalStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 804
namespace stringify {
    const char* E_SgOmpSectionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpSectionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionStatement() {
        return stringify::E_SgOmpSectionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 807
namespace stringify {
    const char* E_SgOmpWorkshareStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpWorkshareStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpWorkshareStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpWorkshareStatement(i);
        if (s.empty())
            s = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpWorkshareStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpWorkshareStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpWorkshareStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpWorkshareStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpWorkshareStatement() {
        return stringify::E_SgOmpWorkshareStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 810
namespace stringify {
    const char* E_SgOmpParallelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpParallelStatement_body";
            case 1L: return "SgOmpParallelStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpParallelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpParallelStatement(i);
        if (s.empty())
            s = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpParallelStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpParallelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpParallelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpParallelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpParallelStatement() {
        return stringify::E_SgOmpParallelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 813
namespace stringify {
    const char* E_SgOmpSingleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSingleStatement_body";
            case 1L: return "SgOmpSingleStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSingleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSingleStatement(i);
        if (s.empty())
            s = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSingleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSingleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSingleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSingleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSingleStatement() {
        return stringify::E_SgOmpSingleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 816
namespace stringify {
    const char* E_SgOmpAtomicStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAtomicStatement_body";
            case 1L: return "SgOmpAtomicStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpAtomicStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAtomicStatement(i);
        if (s.empty())
            s = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAtomicStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAtomicStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAtomicStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAtomicStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAtomicStatement() {
        return stringify::E_SgOmpAtomicStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 819
namespace stringify {
    const char* E_SgOmpTaskStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskStatement_body";
            case 1L: return "SgOmpTaskStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskStatement() {
        return stringify::E_SgOmpTaskStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 822
namespace stringify {
    const char* E_SgOmpForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForStatement_body";
            case 1L: return "SgOmpForStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForStatement(i);
        if (s.empty())
            s = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForStatement() {
        return stringify::E_SgOmpForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 825
namespace stringify {
    const char* E_SgOmpDoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDoStatement_body";
            case 1L: return "SgOmpDoStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDoStatement(i);
        if (s.empty())
            s = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDoStatement() {
        return stringify::E_SgOmpDoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 828
namespace stringify {
    const char* E_SgOmpSectionsStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionsStatement_body";
            case 1L: return "SgOmpSectionsStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSectionsStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionsStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionsStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionsStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionsStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionsStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionsStatement() {
        return stringify::E_SgOmpSectionsStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 831
namespace stringify {
    const char* E_SgOmpTargetStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetStatement_body";
            case 1L: return "SgOmpTargetStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetStatement() {
        return stringify::E_SgOmpTargetStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 834
namespace stringify {
    const char* E_SgOmpTargetDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetDataStatement_body";
            case 1L: return "SgOmpTargetDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetDataStatement() {
        return stringify::E_SgOmpTargetDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 837
namespace stringify {
    const char* E_SgOmpSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdStatement_body";
            case 1L: return "SgOmpSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdStatement() {
        return stringify::E_SgOmpSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 840
namespace stringify {
    const char* E_SgOmpForSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForSimdStatement_body";
            case 1L: return "SgOmpForSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForSimdStatement() {
        return stringify::E_SgOmpForSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 843
namespace stringify {
    const char* E_SgOmpClauseBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpClauseBodyStatement_body";
            case 1L: return "SgOmpClauseBodyStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpClauseBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpClauseBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpClauseBodyStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpClauseBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpClauseBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpClauseBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpClauseBodyStatement() {
        return stringify::E_SgOmpClauseBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 846
namespace stringify {
    const char* E_SgOmpBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpBodyStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpBodyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpBodyStatement() {
        return stringify::E_SgOmpBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 849
namespace stringify {
    const char* E_SgWithStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWithStatement_expression";
            case 1L: return "SgWithStatement_body";
            default: return "";
        }
    }

    std::string E_SgWithStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWithStatement(i);
        if (s.empty())
            s = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWithStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWithStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWithStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWithStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWithStatement() {
        return stringify::E_SgWithStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 852
namespace stringify {
    const char* E_SgPythonPrintStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonPrintStmt_destination";
            case 1L: return "SgPythonPrintStmt_values";
            default: return "";
        }
    }

    std::string E_SgPythonPrintStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonPrintStmt(i);
        if (s.empty())
            s = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonPrintStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonPrintStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonPrintStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonPrintStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonPrintStmt() {
        return stringify::E_SgPythonPrintStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 855
namespace stringify {
    const char* E_SgAssertStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAssertStmt_test";
            case 1L: return "SgAssertStmt_exception_argument";
            default: return "";
        }
    }

    std::string E_SgAssertStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAssertStmt(i);
        if (s.empty())
            s = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssertStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssertStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssertStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssertStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssertStmt() {
        return stringify::E_SgAssertStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 858
namespace stringify {
    const char* E_SgExecStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExecStatement_executable";
            case 1L: return "SgExecStatement_globals";
            case 2L: return "SgExecStatement_locals";
            default: return "";
        }
    }

    std::string E_SgExecStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExecStatement(i);
        if (s.empty())
            s = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExecStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExecStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExecStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExecStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExecStatement() {
        return stringify::E_SgExecStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 861
namespace stringify {
    const char* E_SgPythonGlobalStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonGlobalStmt_names";
            default: return "";
        }
    }

    std::string E_SgPythonGlobalStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonGlobalStmt(i);
        if (s.empty())
            s = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonGlobalStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonGlobalStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonGlobalStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonGlobalStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonGlobalStmt() {
        return stringify::E_SgPythonGlobalStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 864
namespace stringify {
    const char* E_SgJavaSynchronizedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSynchronizedStatement_expression";
            case 1L: return "SgJavaSynchronizedStatement_body";
            default: return "";
        }
    }

    std::string E_SgJavaSynchronizedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSynchronizedStatement(i);
        if (s.empty())
            s = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSynchronizedStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSynchronizedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSynchronizedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSynchronizedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSynchronizedStatement() {
        return stringify::E_SgJavaSynchronizedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 867
namespace stringify {
    const char* E_SgAsyncStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsyncStmt_body";
            default: return "";
        }
    }

    std::string E_SgAsyncStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsyncStmt(i);
        if (s.empty())
            s = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsyncStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsyncStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsyncStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsyncStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsyncStmt() {
        return stringify::E_SgAsyncStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 870
namespace stringify {
    const char* E_SgFinishStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishStmt_body";
            default: return "";
        }
    }

    std::string E_SgFinishStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishStmt(i);
        if (s.empty())
            s = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishStmt(i);
        if (retval.empty()) {
            retval = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishStmt() {
        return stringify::E_SgFinishStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 873
namespace stringify {
    const char* E_SgAtStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtStmt_expression";
            case 1L: return "SgAtStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtStmt(i);
        if (s.empty())
            s = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtStmt() {
        return stringify::E_SgAtStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 876
namespace stringify {
    const char* E_SgAtomicStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtomicStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtomicStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtomicStmt(i);
        if (s.empty())
            s = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtomicStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtomicStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtomicStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtomicStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtomicStmt() {
        return stringify::E_SgAtomicStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 879
namespace stringify {
    const char* E_SgWhenStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhenStmt_expression";
            case 1L: return "SgWhenStmt_body";
            default: return "";
        }
    }

    std::string E_SgWhenStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhenStmt(i);
        if (s.empty())
            s = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhenStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhenStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhenStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhenStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhenStmt() {
        return stringify::E_SgWhenStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 882
namespace stringify {
    const char* E_SgSyncAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncAllStatement_stat";
            case 1L: return "SgSyncAllStatement_err_msg";
            case 2L: return "SgSyncAllStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncAllStatement(i);
        if (s.empty())
            s = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncAllStatement() {
        return stringify::E_SgSyncAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 885
namespace stringify {
    const char* E_SgSyncImagesStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncImagesStatement_stat";
            case 1L: return "SgSyncImagesStatement_err_msg";
            case 2L: return "SgSyncImagesStatement_acquired_lock";
            case 3L: return "SgSyncImagesStatement_image_set";
            default: return "";
        }
    }

    std::string E_SgSyncImagesStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncImagesStatement(i);
        if (s.empty())
            s = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncImagesStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncImagesStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncImagesStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncImagesStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncImagesStatement() {
        return stringify::E_SgSyncImagesStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 888
namespace stringify {
    const char* E_SgSyncMemoryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncMemoryStatement_stat";
            case 1L: return "SgSyncMemoryStatement_err_msg";
            case 2L: return "SgSyncMemoryStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncMemoryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncMemoryStatement(i);
        if (s.empty())
            s = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncMemoryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncMemoryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncMemoryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncMemoryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncMemoryStatement() {
        return stringify::E_SgSyncMemoryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 891
namespace stringify {
    const char* E_SgSyncTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncTeamStatement_stat";
            case 1L: return "SgSyncTeamStatement_err_msg";
            case 2L: return "SgSyncTeamStatement_acquired_lock";
            case 3L: return "SgSyncTeamStatement_team_value";
            default: return "";
        }
    }

    std::string E_SgSyncTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncTeamStatement(i);
        if (s.empty())
            s = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncTeamStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncTeamStatement() {
        return stringify::E_SgSyncTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 894
namespace stringify {
    const char* E_SgLockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLockStatement_stat";
            case 1L: return "SgLockStatement_err_msg";
            case 2L: return "SgLockStatement_acquired_lock";
            case 3L: return "SgLockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgLockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLockStatement(i);
        if (s.empty())
            s = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLockStatement() {
        return stringify::E_SgLockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 897
namespace stringify {
    const char* E_SgUnlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUnlockStatement_stat";
            case 1L: return "SgUnlockStatement_err_msg";
            case 2L: return "SgUnlockStatement_acquired_lock";
            case 3L: return "SgUnlockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgUnlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUnlockStatement(i);
        if (s.empty())
            s = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnlockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnlockStatement() {
        return stringify::E_SgUnlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 900
namespace stringify {
    const char* E_SgImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImageControlStatement_stat";
            case 1L: return "SgImageControlStatement_err_msg";
            case 2L: return "SgImageControlStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImageControlStatement(i);
        if (s.empty())
            s = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImageControlStatement() {
        return stringify::E_SgImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 903
namespace stringify {
    const char* E_SgAdaExitStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaExitStmt_condition";
            default: return "";
        }
    }

    std::string E_SgAdaExitStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaExitStmt(i);
        if (s.empty())
            s = "(E_SgAdaExitStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaExitStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaExitStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaExitStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaExitStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaExitStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaExitStmt() {
        return stringify::E_SgAdaExitStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 906
namespace stringify {
    const char* E_SgAdaDelayStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDelayStmt_time";
            default: return "";
        }
    }

    std::string E_SgAdaDelayStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDelayStmt(i);
        if (s.empty())
            s = "(E_SgAdaDelayStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDelayStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDelayStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDelayStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDelayStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDelayStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDelayStmt() {
        return stringify::E_SgAdaDelayStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 909
namespace stringify {
    const char* E_SgAdaLoopStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaLoopStmt_body";
            default: return "";
        }
    }

    std::string E_SgAdaLoopStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaLoopStmt(i);
        if (s.empty())
            s = "(E_SgAdaLoopStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaLoopStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaLoopStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaLoopStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaLoopStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaLoopStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaLoopStmt() {
        return stringify::E_SgAdaLoopStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 912
namespace stringify {
    const char* E_SgAdaSelectStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSelectStmt_select_path";
            case 1L: return "SgAdaSelectStmt_or_path";
            case 2L: return "SgAdaSelectStmt_else_path";
            case 3L: return "SgAdaSelectStmt_abort_path";
            default: return "";
        }
    }

    std::string E_SgAdaSelectStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSelectStmt(i);
        if (s.empty())
            s = "(E_SgAdaSelectStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSelectStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSelectStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSelectStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSelectStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSelectStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSelectStmt() {
        return stringify::E_SgAdaSelectStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 915
namespace stringify {
    const char* E_SgAdaSelectAlternativeStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSelectAlternativeStmt_body";
            case 1L: return "SgAdaSelectAlternativeStmt_guard";
            case 2L: return "SgAdaSelectAlternativeStmt_next";
            default: return "";
        }
    }

    std::string E_SgAdaSelectAlternativeStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSelectAlternativeStmt(i);
        if (s.empty())
            s = "(E_SgAdaSelectAlternativeStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSelectAlternativeStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSelectAlternativeStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSelectAlternativeStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSelectAlternativeStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSelectAlternativeStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSelectAlternativeStmt() {
        return stringify::E_SgAdaSelectAlternativeStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 918
namespace stringify {
    const char* E_SgAdaUnscopedBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaUnscopedBlock_statements";
            default: return "";
        }
    }

    std::string E_SgAdaUnscopedBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaUnscopedBlock(i);
        if (s.empty())
            s = "(E_SgAdaUnscopedBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaUnscopedBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaUnscopedBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaUnscopedBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAdaUnscopedBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaUnscopedBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaUnscopedBlock() {
        return stringify::E_SgAdaUnscopedBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 921
namespace stringify {
    const char* E_SgAdaVariantWhenStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaVariantWhenStmt_choices";
            case 1L: return "SgAdaVariantWhenStmt_components";
            default: return "";
        }
    }

    std::string E_SgAdaVariantWhenStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaVariantWhenStmt(i);
        if (s.empty())
            s = "(E_SgAdaVariantWhenStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaVariantWhenStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaVariantWhenStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaVariantWhenStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaVariantWhenStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaVariantWhenStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaVariantWhenStmt() {
        return stringify::E_SgAdaVariantWhenStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 924
namespace stringify {
    const char* E_SgExpressionRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgExpressionRoot_operand_i";
            default: return "";
        }
    }

    std::string E_SgExpressionRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgExpressionRoot(i);
        if (s.empty())
            s = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpressionRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpressionRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpressionRoot(i);
        if (retval.empty()) {
            retval = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpressionRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpressionRoot() {
        return stringify::E_SgExpressionRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 927
namespace stringify {
    const char* E_SgMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusOp() {
        return stringify::E_SgMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 930
namespace stringify {
    const char* E_SgUnaryAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryAddOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryAddOp(i);
        if (s.empty())
            s = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryAddOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryAddOp() {
        return stringify::E_SgUnaryAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 933
namespace stringify {
    const char* E_SgNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotOp(i);
        if (s.empty())
            s = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotOp() {
        return stringify::E_SgNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 936
namespace stringify {
    const char* E_SgPointerDerefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerDerefExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerDerefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerDerefExp(i);
        if (s.empty())
            s = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerDerefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerDerefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerDerefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerDerefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerDerefExp() {
        return stringify::E_SgPointerDerefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 939
namespace stringify {
    const char* E_SgAddressOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddressOfOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddressOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddressOfOp(i);
        if (s.empty())
            s = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddressOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddressOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddressOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddressOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddressOfOp() {
        return stringify::E_SgAddressOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 942
namespace stringify {
    const char* E_SgMinusMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusMinusOp() {
        return stringify::E_SgMinusMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 945
namespace stringify {
    const char* E_SgPlusPlusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusPlusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusPlusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusPlusOp(i);
        if (s.empty())
            s = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusPlusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusPlusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusPlusOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusPlusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusPlusOp() {
        return stringify::E_SgPlusPlusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 948
namespace stringify {
    const char* E_SgBitComplementOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitComplementOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitComplementOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitComplementOp(i);
        if (s.empty())
            s = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitComplementOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitComplementOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitComplementOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitComplementOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitComplementOp() {
        return stringify::E_SgBitComplementOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 951
namespace stringify {
    const char* E_SgCastExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCastExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgCastExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCastExp(i);
        if (s.empty())
            s = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCastExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCastExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCastExp(i);
        if (retval.empty()) {
            retval = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCastExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCastExp() {
        return stringify::E_SgCastExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 954
namespace stringify {
    const char* E_SgThrowOp(int64_t i) {
        switch (i) {
            case 0L: return "SgThrowOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgThrowOp(int64_t i, const std::string &strip) {
        std::string s = E_SgThrowOp(i);
        if (s.empty())
            s = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgThrowOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgThrowOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgThrowOp(i);
        if (retval.empty()) {
            retval = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgThrowOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgThrowOp() {
        return stringify::E_SgThrowOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 957
namespace stringify {
    const char* E_SgRealPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRealPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgRealPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRealPartOp(i);
        if (s.empty())
            s = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRealPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRealPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRealPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRealPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRealPartOp() {
        return stringify::E_SgRealPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 960
namespace stringify {
    const char* E_SgImagPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgImagPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgImagPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgImagPartOp(i);
        if (s.empty())
            s = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImagPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImagPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImagPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImagPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImagPartOp() {
        return stringify::E_SgImagPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 963
namespace stringify {
    const char* E_SgConjugateOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConjugateOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgConjugateOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConjugateOp(i);
        if (s.empty())
            s = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConjugateOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConjugateOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConjugateOp(i);
        if (retval.empty()) {
            retval = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConjugateOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConjugateOp() {
        return stringify::E_SgConjugateOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 966
namespace stringify {
    const char* E_SgUserDefinedUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedUnaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedUnaryOp() {
        return stringify::E_SgUserDefinedUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 969
namespace stringify {
    const char* E_SgMatrixTransposeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixTransposeOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMatrixTransposeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixTransposeOp(i);
        if (s.empty())
            s = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixTransposeOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixTransposeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixTransposeOp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixTransposeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixTransposeOp() {
        return stringify::E_SgMatrixTransposeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 972
namespace stringify {
    const char* E_SgAbsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAbsOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAbsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAbsOp(i);
        if (s.empty())
            s = "(E_SgAbsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAbsOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAbsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAbsOp(i);
        if (retval.empty()) {
            retval = "(E_SgAbsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAbsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAbsOp() {
        return stringify::E_SgAbsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 975
namespace stringify {
    const char* E_SgUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryOp(i);
        if (s.empty())
            s = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryOp() {
        return stringify::E_SgUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 978
namespace stringify {
    const char* E_SgArrowExp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowExp_lhs_operand_i";
            case 1L: return "SgArrowExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowExp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowExp(i);
        if (s.empty())
            s = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowExp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowExp() {
        return stringify::E_SgArrowExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 981
namespace stringify {
    const char* E_SgDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotExp_lhs_operand_i";
            case 1L: return "SgDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotExp(i);
        if (s.empty())
            s = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotExp() {
        return stringify::E_SgDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 984
namespace stringify {
    const char* E_SgDotStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotStarOp_lhs_operand_i";
            case 1L: return "SgDotStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotStarOp(i);
        if (s.empty())
            s = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotStarOp() {
        return stringify::E_SgDotStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 987
namespace stringify {
    const char* E_SgArrowStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowStarOp_lhs_operand_i";
            case 1L: return "SgArrowStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowStarOp(i);
        if (s.empty())
            s = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowStarOp() {
        return stringify::E_SgArrowStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 990
namespace stringify {
    const char* E_SgEqualityOp(int64_t i) {
        switch (i) {
            case 0L: return "SgEqualityOp_lhs_operand_i";
            case 1L: return "SgEqualityOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgEqualityOp(int64_t i, const std::string &strip) {
        std::string s = E_SgEqualityOp(i);
        if (s.empty())
            s = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEqualityOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEqualityOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEqualityOp(i);
        if (retval.empty()) {
            retval = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEqualityOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEqualityOp() {
        return stringify::E_SgEqualityOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 993
namespace stringify {
    const char* E_SgLessThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessThanOp_lhs_operand_i";
            case 1L: return "SgLessThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessThanOp(i);
        if (s.empty())
            s = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessThanOp() {
        return stringify::E_SgLessThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 996
namespace stringify {
    const char* E_SgGreaterThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterThanOp_lhs_operand_i";
            case 1L: return "SgGreaterThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterThanOp(i);
        if (s.empty())
            s = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterThanOp() {
        return stringify::E_SgGreaterThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 999
namespace stringify {
    const char* E_SgNotEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotEqualOp_lhs_operand_i";
            case 1L: return "SgNotEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotEqualOp(i);
        if (s.empty())
            s = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotEqualOp() {
        return stringify::E_SgNotEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1002
namespace stringify {
    const char* E_SgLessOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessOrEqualOp_lhs_operand_i";
            case 1L: return "SgLessOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessOrEqualOp(i);
        if (s.empty())
            s = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessOrEqualOp() {
        return stringify::E_SgLessOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1005
namespace stringify {
    const char* E_SgGreaterOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterOrEqualOp_lhs_operand_i";
            case 1L: return "SgGreaterOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterOrEqualOp(i);
        if (s.empty())
            s = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterOrEqualOp() {
        return stringify::E_SgGreaterOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1008
namespace stringify {
    const char* E_SgAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddOp_lhs_operand_i";
            case 1L: return "SgAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddOp(i);
        if (s.empty())
            s = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddOp() {
        return stringify::E_SgAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1011
namespace stringify {
    const char* E_SgSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSubtractOp_lhs_operand_i";
            case 1L: return "SgSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSubtractOp(i);
        if (s.empty())
            s = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubtractOp() {
        return stringify::E_SgSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1014
namespace stringify {
    const char* E_SgMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultiplyOp_lhs_operand_i";
            case 1L: return "SgMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultiplyOp(i);
        if (s.empty())
            s = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultiplyOp() {
        return stringify::E_SgMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1017
namespace stringify {
    const char* E_SgDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivideOp_lhs_operand_i";
            case 1L: return "SgDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivideOp(i);
        if (s.empty())
            s = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivideOp() {
        return stringify::E_SgDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1020
namespace stringify {
    const char* E_SgIntegerDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideOp() {
        return stringify::E_SgIntegerDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1023
namespace stringify {
    const char* E_SgModOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModOp_lhs_operand_i";
            case 1L: return "SgModOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModOp(i);
        if (s.empty())
            s = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModOp(i);
        if (retval.empty()) {
            retval = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModOp() {
        return stringify::E_SgModOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1026
namespace stringify {
    const char* E_SgAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndOp_lhs_operand_i";
            case 1L: return "SgAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndOp(i);
        if (s.empty())
            s = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndOp() {
        return stringify::E_SgAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1029
namespace stringify {
    const char* E_SgOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgOrOp_lhs_operand_i";
            case 1L: return "SgOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgOrOp(i);
        if (s.empty())
            s = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOrOp() {
        return stringify::E_SgOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1032
namespace stringify {
    const char* E_SgBitXorOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitXorOp_lhs_operand_i";
            case 1L: return "SgBitXorOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitXorOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitXorOp(i);
        if (s.empty())
            s = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitXorOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitXorOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitXorOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitXorOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitXorOp() {
        return stringify::E_SgBitXorOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1035
namespace stringify {
    const char* E_SgBitAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitAndOp_lhs_operand_i";
            case 1L: return "SgBitAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitAndOp(i);
        if (s.empty())
            s = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitAndOp() {
        return stringify::E_SgBitAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1038
namespace stringify {
    const char* E_SgBitOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitOrOp_lhs_operand_i";
            case 1L: return "SgBitOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitOrOp(i);
        if (s.empty())
            s = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitOrOp() {
        return stringify::E_SgBitOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1041
namespace stringify {
    const char* E_SgBitEqvOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitEqvOp_lhs_operand_i";
            case 1L: return "SgBitEqvOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitEqvOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitEqvOp(i);
        if (s.empty())
            s = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitEqvOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitEqvOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitEqvOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitEqvOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitEqvOp() {
        return stringify::E_SgBitEqvOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1044
namespace stringify {
    const char* E_SgCommaOpExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCommaOpExp_lhs_operand_i";
            case 1L: return "SgCommaOpExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCommaOpExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCommaOpExp(i);
        if (s.empty())
            s = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommaOpExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommaOpExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommaOpExp(i);
        if (retval.empty()) {
            retval = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommaOpExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommaOpExp() {
        return stringify::E_SgCommaOpExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1047
namespace stringify {
    const char* E_SgLshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftOp_lhs_operand_i";
            case 1L: return "SgLshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftOp(i);
        if (s.empty())
            s = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftOp() {
        return stringify::E_SgLshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1050
namespace stringify {
    const char* E_SgRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftOp_lhs_operand_i";
            case 1L: return "SgRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftOp(i);
        if (s.empty())
            s = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftOp() {
        return stringify::E_SgRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1053
namespace stringify {
    const char* E_SgPntrArrRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPntrArrRefExp_lhs_operand_i";
            case 1L: return "SgPntrArrRefExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPntrArrRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPntrArrRefExp(i);
        if (s.empty())
            s = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPntrArrRefExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPntrArrRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPntrArrRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPntrArrRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPntrArrRefExp() {
        return stringify::E_SgPntrArrRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1056
namespace stringify {
    const char* E_SgScopeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgScopeOp_lhs_operand_i";
            case 1L: return "SgScopeOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgScopeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgScopeOp(i);
        if (s.empty())
            s = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopeOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopeOp(i);
        if (retval.empty()) {
            retval = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopeOp() {
        return stringify::E_SgScopeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1059
namespace stringify {
    const char* E_SgAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignOp_lhs_operand_i";
            case 1L: return "SgAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignOp(i);
        if (s.empty())
            s = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignOp() {
        return stringify::E_SgAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1062
namespace stringify {
    const char* E_SgExponentiationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationOp_lhs_operand_i";
            case 1L: return "SgExponentiationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationOp(i);
        if (s.empty())
            s = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationOp() {
        return stringify::E_SgExponentiationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1065
namespace stringify {
    const char* E_SgJavaUnsignedRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftOp() {
        return stringify::E_SgJavaUnsignedRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1068
namespace stringify {
    const char* E_SgConcatenationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConcatenationOp_lhs_operand_i";
            case 1L: return "SgConcatenationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgConcatenationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConcatenationOp(i);
        if (s.empty())
            s = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConcatenationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConcatenationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConcatenationOp(i);
        if (retval.empty()) {
            retval = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConcatenationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConcatenationOp() {
        return stringify::E_SgConcatenationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1071
namespace stringify {
    const char* E_SgPointerAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerAssignOp_lhs_operand_i";
            case 1L: return "SgPointerAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerAssignOp(i);
        if (s.empty())
            s = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerAssignOp() {
        return stringify::E_SgPointerAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1074
namespace stringify {
    const char* E_SgUserDefinedBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedBinaryOp_lhs_operand_i";
            case 1L: return "SgUserDefinedBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedBinaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedBinaryOp() {
        return stringify::E_SgUserDefinedBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1077
namespace stringify {
    const char* E_SgPlusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusAssignOp_lhs_operand_i";
            case 1L: return "SgPlusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusAssignOp(i);
        if (s.empty())
            s = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusAssignOp() {
        return stringify::E_SgPlusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1080
namespace stringify {
    const char* E_SgMinusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusAssignOp_lhs_operand_i";
            case 1L: return "SgMinusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusAssignOp(i);
        if (s.empty())
            s = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusAssignOp() {
        return stringify::E_SgMinusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1083
namespace stringify {
    const char* E_SgAndAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndAssignOp_lhs_operand_i";
            case 1L: return "SgAndAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndAssignOp(i);
        if (s.empty())
            s = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndAssignOp() {
        return stringify::E_SgAndAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1086
namespace stringify {
    const char* E_SgIorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIorAssignOp_lhs_operand_i";
            case 1L: return "SgIorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIorAssignOp(i);
        if (s.empty())
            s = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIorAssignOp() {
        return stringify::E_SgIorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1089
namespace stringify {
    const char* E_SgMultAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultAssignOp_lhs_operand_i";
            case 1L: return "SgMultAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultAssignOp(i);
        if (s.empty())
            s = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultAssignOp() {
        return stringify::E_SgMultAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1092
namespace stringify {
    const char* E_SgDivAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivAssignOp_lhs_operand_i";
            case 1L: return "SgDivAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivAssignOp(i);
        if (s.empty())
            s = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivAssignOp() {
        return stringify::E_SgDivAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1095
namespace stringify {
    const char* E_SgModAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModAssignOp_lhs_operand_i";
            case 1L: return "SgModAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModAssignOp(i);
        if (s.empty())
            s = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModAssignOp() {
        return stringify::E_SgModAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1098
namespace stringify {
    const char* E_SgXorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgXorAssignOp_lhs_operand_i";
            case 1L: return "SgXorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgXorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgXorAssignOp(i);
        if (s.empty())
            s = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgXorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgXorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgXorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgXorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgXorAssignOp() {
        return stringify::E_SgXorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1101
namespace stringify {
    const char* E_SgLshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftAssignOp_lhs_operand_i";
            case 1L: return "SgLshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftAssignOp() {
        return stringify::E_SgLshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1104
namespace stringify {
    const char* E_SgRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftAssignOp() {
        return stringify::E_SgRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1107
namespace stringify {
    const char* E_SgJavaUnsignedRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftAssignOp() {
        return stringify::E_SgJavaUnsignedRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1110
namespace stringify {
    const char* E_SgIntegerDivideAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideAssignOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideAssignOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideAssignOp() {
        return stringify::E_SgIntegerDivideAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1113
namespace stringify {
    const char* E_SgExponentiationAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationAssignOp_lhs_operand_i";
            case 1L: return "SgExponentiationAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationAssignOp(i);
        if (s.empty())
            s = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationAssignOp() {
        return stringify::E_SgExponentiationAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1116
namespace stringify {
    const char* E_SgCompoundAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundAssignOp_lhs_operand_i";
            case 1L: return "SgCompoundAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCompoundAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundAssignOp(i);
        if (s.empty())
            s = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundAssignOp() {
        return stringify::E_SgCompoundAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1119
namespace stringify {
    const char* E_SgMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMembershipOp_lhs_operand_i";
            case 1L: return "SgMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMembershipOp(i);
        if (s.empty())
            s = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMembershipOp() {
        return stringify::E_SgMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1122
namespace stringify {
    const char* E_SgSpaceshipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSpaceshipOp_lhs_operand_i";
            case 1L: return "SgSpaceshipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSpaceshipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSpaceshipOp(i);
        if (s.empty())
            s = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpaceshipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpaceshipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpaceshipOp(i);
        if (retval.empty()) {
            retval = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpaceshipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpaceshipOp() {
        return stringify::E_SgSpaceshipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1125
namespace stringify {
    const char* E_SgNonMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNonMembershipOp_lhs_operand_i";
            case 1L: return "SgNonMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNonMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNonMembershipOp(i);
        if (s.empty())
            s = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonMembershipOp() {
        return stringify::E_SgNonMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1128
namespace stringify {
    const char* E_SgIsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsOp_lhs_operand_i";
            case 1L: return "SgIsOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsOp(i);
        if (s.empty())
            s = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsOp() {
        return stringify::E_SgIsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1131
namespace stringify {
    const char* E_SgIsNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsNotOp_lhs_operand_i";
            case 1L: return "SgIsNotOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsNotOp(i);
        if (s.empty())
            s = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsNotOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsNotOp() {
        return stringify::E_SgIsNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1134
namespace stringify {
    const char* E_SgDotDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotDotExp_lhs_operand_i";
            case 1L: return "SgDotDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotDotExp(i);
        if (s.empty())
            s = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotDotExp() {
        return stringify::E_SgDotDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1137
namespace stringify {
    const char* E_SgElementwiseMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseMultiplyOp_lhs_operand_i";
            case 1L: return "SgElementwiseMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseMultiplyOp(i);
        if (s.empty())
            s = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseMultiplyOp() {
        return stringify::E_SgElementwiseMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1140
namespace stringify {
    const char* E_SgElementwisePowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwisePowerOp_lhs_operand_i";
            case 1L: return "SgElementwisePowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwisePowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwisePowerOp(i);
        if (s.empty())
            s = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwisePowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwisePowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwisePowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwisePowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwisePowerOp() {
        return stringify::E_SgElementwisePowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1143
namespace stringify {
    const char* E_SgElementwiseLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseLeftDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseLeftDivideOp() {
        return stringify::E_SgElementwiseLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1146
namespace stringify {
    const char* E_SgElementwiseDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseDivideOp() {
        return stringify::E_SgElementwiseDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1149
namespace stringify {
    const char* E_SgElementwiseAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseAddOp_lhs_operand_i";
            case 1L: return "SgElementwiseAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseAddOp(i);
        if (s.empty())
            s = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseAddOp() {
        return stringify::E_SgElementwiseAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1152
namespace stringify {
    const char* E_SgElementwiseSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseSubtractOp_lhs_operand_i";
            case 1L: return "SgElementwiseSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseSubtractOp(i);
        if (s.empty())
            s = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseSubtractOp() {
        return stringify::E_SgElementwiseSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1155
namespace stringify {
    const char* E_SgElementwiseOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseOp_lhs_operand_i";
            case 1L: return "SgElementwiseOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseOp(i);
        if (s.empty())
            s = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseOp() {
        return stringify::E_SgElementwiseOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1158
namespace stringify {
    const char* E_SgPowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPowerOp_lhs_operand_i";
            case 1L: return "SgPowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPowerOp(i);
        if (s.empty())
            s = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPowerOp() {
        return stringify::E_SgPowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1161
namespace stringify {
    const char* E_SgLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLeftDivideOp_lhs_operand_i";
            case 1L: return "SgLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLeftDivideOp() {
        return stringify::E_SgLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1164
namespace stringify {
    const char* E_SgRemOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRemOp_lhs_operand_i";
            case 1L: return "SgRemOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRemOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRemOp(i);
        if (s.empty())
            s = "(E_SgRemOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRemOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRemOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRemOp(i);
        if (retval.empty()) {
            retval = "(E_SgRemOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRemOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRemOp() {
        return stringify::E_SgRemOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1167
namespace stringify {
    const char* E_SgReplicationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgReplicationOp_lhs_operand_i";
            case 1L: return "SgReplicationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgReplicationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgReplicationOp(i);
        if (s.empty())
            s = "(E_SgReplicationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReplicationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReplicationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReplicationOp(i);
        if (retval.empty()) {
            retval = "(E_SgReplicationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReplicationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReplicationOp() {
        return stringify::E_SgReplicationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1170
namespace stringify {
    const char* E_SgAtOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAtOp_lhs_operand_i";
            case 1L: return "SgAtOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAtOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAtOp(i);
        if (s.empty())
            s = "(E_SgAtOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtOp(i);
        if (retval.empty()) {
            retval = "(E_SgAtOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtOp() {
        return stringify::E_SgAtOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1173
namespace stringify {
    const char* E_SgBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryOp_lhs_operand_i";
            case 1L: return "SgBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryOp(i);
        if (s.empty())
            s = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryOp() {
        return stringify::E_SgBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1176
namespace stringify {
    const char* E_SgListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgListExp(i);
        if (s.empty())
            s = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListExp(i);
        if (retval.empty()) {
            retval = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListExp() {
        return stringify::E_SgListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1179
namespace stringify {
    const char* E_SgTupleExp(int64_t i) {
        switch (i) {
            case 0L: return "SgTupleExp_expressions";
            default: return "";
        }
    }

    std::string E_SgTupleExp(int64_t i, const std::string &strip) {
        std::string s = E_SgTupleExp(i);
        if (s.empty())
            s = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTupleExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTupleExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTupleExp(i);
        if (retval.empty()) {
            retval = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTupleExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTupleExp() {
        return stringify::E_SgTupleExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1182
namespace stringify {
    const char* E_SgMatrixExp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixExp_expressions";
            default: return "";
        }
    }

    std::string E_SgMatrixExp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixExp(i);
        if (s.empty())
            s = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixExp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixExp() {
        return stringify::E_SgMatrixExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1185
namespace stringify {
    const char* E_SgExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgExprListExp(i);
        if (s.empty())
            s = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprListExp() {
        return stringify::E_SgExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1188
namespace stringify {
    const char* E_SgComplexVal(int64_t i) {
        switch (i) {
            case 0L: return "SgComplexVal_real_value";
            case 1L: return "SgComplexVal_imaginary_value";
            default: return "";
        }
    }

    std::string E_SgComplexVal(int64_t i, const std::string &strip) {
        std::string s = E_SgComplexVal(i);
        if (s.empty())
            s = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComplexVal() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComplexVal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComplexVal(i);
        if (retval.empty()) {
            retval = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComplexVal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComplexVal() {
        return stringify::E_SgComplexVal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1191
namespace stringify {
    const char* E_SgCudaKernelCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelCallExp_function";
            case 1L: return "SgCudaKernelCallExp_args";
            case 2L: return "SgCudaKernelCallExp_exec_config";
            default: return "";
        }
    }

    std::string E_SgCudaKernelCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelCallExp(i);
        if (s.empty())
            s = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelCallExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelCallExp() {
        return stringify::E_SgCudaKernelCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1194
namespace stringify {
    const char* E_SgFunctionCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionCallExp_function";
            case 1L: return "SgFunctionCallExp_args";
            default: return "";
        }
    }

    std::string E_SgFunctionCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionCallExp(i);
        if (s.empty())
            s = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionCallExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionCallExp() {
        return stringify::E_SgFunctionCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1197
namespace stringify {
    const char* E_SgCallExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCallExpression_function";
            case 1L: return "SgCallExpression_args";
            default: return "";
        }
    }

    std::string E_SgCallExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCallExpression(i);
        if (s.empty())
            s = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCallExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCallExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCallExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCallExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCallExpression() {
        return stringify::E_SgCallExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1200
namespace stringify {
    const char* E_SgUpcLocalsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcLocalsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcLocalsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcLocalsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcLocalsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcLocalsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcLocalsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcLocalsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcLocalsizeofExpression() {
        return stringify::E_SgUpcLocalsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1203
namespace stringify {
    const char* E_SgUpcBlocksizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBlocksizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBlocksizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBlocksizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBlocksizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBlocksizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBlocksizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBlocksizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBlocksizeofExpression() {
        return stringify::E_SgUpcBlocksizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1206
namespace stringify {
    const char* E_SgUpcElemsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcElemsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcElemsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcElemsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcElemsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcElemsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcElemsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcElemsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcElemsizeofExpression() {
        return stringify::E_SgUpcElemsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1209
namespace stringify {
    const char* E_SgJavaInstanceOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaInstanceOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgJavaInstanceOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaInstanceOfOp(i);
        if (s.empty())
            s = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaInstanceOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaInstanceOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaInstanceOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaInstanceOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaInstanceOfOp() {
        return stringify::E_SgJavaInstanceOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1212
namespace stringify {
    const char* E_SgTypeIdOp(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeIdOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgTypeIdOp(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeIdOp(i);
        if (s.empty())
            s = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeIdOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeIdOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeIdOp(i);
        if (retval.empty()) {
            retval = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeIdOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeIdOp() {
        return stringify::E_SgTypeIdOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1215
namespace stringify {
    const char* E_SgConditionalExp(int64_t i) {
        switch (i) {
            case 0L: return "SgConditionalExp_conditional_exp";
            case 1L: return "SgConditionalExp_true_exp";
            case 2L: return "SgConditionalExp_false_exp";
            default: return "";
        }
    }

    std::string E_SgConditionalExp(int64_t i, const std::string &strip) {
        std::string s = E_SgConditionalExp(i);
        if (s.empty())
            s = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConditionalExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConditionalExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConditionalExp(i);
        if (retval.empty()) {
            retval = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConditionalExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConditionalExp() {
        return stringify::E_SgConditionalExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1218
namespace stringify {
    const char* E_SgNewExp(int64_t i) {
        switch (i) {
            case 0L: return "SgNewExp_placement_args";
            case 1L: return "SgNewExp_constructor_args";
            case 2L: return "SgNewExp_builtin_args";
            default: return "";
        }
    }

    std::string E_SgNewExp(int64_t i, const std::string &strip) {
        std::string s = E_SgNewExp(i);
        if (s.empty())
            s = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNewExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNewExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNewExp(i);
        if (retval.empty()) {
            retval = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNewExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNewExp() {
        return stringify::E_SgNewExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1221
namespace stringify {
    const char* E_SgDeleteExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDeleteExp_variable";
            default: return "";
        }
    }

    std::string E_SgDeleteExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDeleteExp(i);
        if (s.empty())
            s = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeleteExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeleteExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeleteExp(i);
        if (retval.empty()) {
            retval = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeleteExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeleteExp() {
        return stringify::E_SgDeleteExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1224
namespace stringify {
    const char* E_SgAggregateInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAggregateInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgAggregateInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAggregateInitializer(i);
        if (s.empty())
            s = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAggregateInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAggregateInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAggregateInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAggregateInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAggregateInitializer() {
        return stringify::E_SgAggregateInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1227
namespace stringify {
    const char* E_SgCompoundInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgCompoundInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundInitializer(i);
        if (s.empty())
            s = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundInitializer() {
        return stringify::E_SgCompoundInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1230
namespace stringify {
    const char* E_SgConstructorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgConstructorInitializer_args";
            default: return "";
        }
    }

    std::string E_SgConstructorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgConstructorInitializer(i);
        if (s.empty())
            s = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConstructorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConstructorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConstructorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConstructorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConstructorInitializer() {
        return stringify::E_SgConstructorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1233
namespace stringify {
    const char* E_SgAssignInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignInitializer_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignInitializer(i);
        if (s.empty())
            s = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignInitializer() {
        return stringify::E_SgAssignInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1236
namespace stringify {
    const char* E_SgDesignatedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgDesignatedInitializer_designatorList";
            case 1L: return "SgDesignatedInitializer_memberInit";
            default: return "";
        }
    }

    std::string E_SgDesignatedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgDesignatedInitializer(i);
        if (s.empty())
            s = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDesignatedInitializer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDesignatedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDesignatedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDesignatedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDesignatedInitializer() {
        return stringify::E_SgDesignatedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1239
namespace stringify {
    const char* E_SgBracedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgBracedInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgBracedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgBracedInitializer(i);
        if (s.empty())
            s = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBracedInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBracedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBracedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBracedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBracedInitializer() {
        return stringify::E_SgBracedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1242
namespace stringify {
    const char* E_SgAdaAncestorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAncestorInitializer_ancestor";
            default: return "";
        }
    }

    std::string E_SgAdaAncestorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAncestorInitializer(i);
        if (s.empty())
            s = "(E_SgAdaAncestorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAncestorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAncestorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAncestorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAncestorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAncestorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAncestorInitializer() {
        return stringify::E_SgAdaAncestorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1245
namespace stringify {
    const char* E_SgVarArgStartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOp_lhs_operand";
            case 1L: return "SgVarArgStartOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOp() {
        return stringify::E_SgVarArgStartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1248
namespace stringify {
    const char* E_SgVarArgOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgOp(i);
        if (s.empty())
            s = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgOp() {
        return stringify::E_SgVarArgOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1251
namespace stringify {
    const char* E_SgVarArgEndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgEndOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgEndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgEndOp(i);
        if (s.empty())
            s = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgEndOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgEndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgEndOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgEndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgEndOp() {
        return stringify::E_SgVarArgEndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1254
namespace stringify {
    const char* E_SgVarArgCopyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgCopyOp_lhs_operand";
            case 1L: return "SgVarArgCopyOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgCopyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgCopyOp(i);
        if (s.empty())
            s = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgCopyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgCopyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgCopyOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgCopyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgCopyOp() {
        return stringify::E_SgVarArgCopyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1257
namespace stringify {
    const char* E_SgVarArgStartOneOperandOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOneOperandOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOneOperandOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOneOperandOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOneOperandOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOneOperandOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOneOperandOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOneOperandOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOneOperandOp() {
        return stringify::E_SgVarArgStartOneOperandOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1260
namespace stringify {
    const char* E_SgSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgSubscriptExpression_lowerBound";
            case 1L: return "SgSubscriptExpression_upperBound";
            case 2L: return "SgSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubscriptExpression() {
        return stringify::E_SgSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1263
namespace stringify {
    const char* E_SgImpliedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgImpliedDo_do_var_initialization";
            case 1L: return "SgImpliedDo_last_val";
            case 2L: return "SgImpliedDo_increment";
            case 3L: return "SgImpliedDo_object_list";
            default: return "";
        }
    }

    std::string E_SgImpliedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgImpliedDo(i);
        if (s.empty())
            s = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImpliedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImpliedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImpliedDo(i);
        if (retval.empty()) {
            retval = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImpliedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImpliedDo() {
        return stringify::E_SgImpliedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1266
namespace stringify {
    const char* E_SgIOItemExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgIOItemExpression_io_item";
            default: return "";
        }
    }

    std::string E_SgIOItemExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgIOItemExpression(i);
        if (s.empty())
            s = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOItemExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOItemExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOItemExpression(i);
        if (retval.empty()) {
            retval = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOItemExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOItemExpression() {
        return stringify::E_SgIOItemExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1269
namespace stringify {
    const char* E_SgActualArgumentExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgActualArgumentExpression_expression";
            default: return "";
        }
    }

    std::string E_SgActualArgumentExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgActualArgumentExpression(i);
        if (s.empty())
            s = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgActualArgumentExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgActualArgumentExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgActualArgumentExpression(i);
        if (retval.empty()) {
            retval = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgActualArgumentExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgActualArgumentExpression() {
        return stringify::E_SgActualArgumentExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1272
namespace stringify {
    const char* E_SgStatementExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementExpression_statement";
            default: return "";
        }
    }

    std::string E_SgStatementExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementExpression(i);
        if (s.empty())
            s = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementExpression(i);
        if (retval.empty()) {
            retval = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementExpression() {
        return stringify::E_SgStatementExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1275
namespace stringify {
    const char* E_SgAsmOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOp_expression";
            default: return "";
        }
    }

    std::string E_SgAsmOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOp(i);
        if (s.empty())
            s = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOp() {
        return stringify::E_SgAsmOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1278
namespace stringify {
    const char* E_SgCudaKernelExecConfig(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelExecConfig_grid";
            case 1L: return "SgCudaKernelExecConfig_blocks";
            case 2L: return "SgCudaKernelExecConfig_shared";
            case 3L: return "SgCudaKernelExecConfig_stream";
            default: return "";
        }
    }

    std::string E_SgCudaKernelExecConfig(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelExecConfig(i);
        if (s.empty())
            s = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelExecConfig() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelExecConfig(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelExecConfig(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelExecConfig::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelExecConfig() {
        return stringify::E_SgCudaKernelExecConfig();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1281
namespace stringify {
    const char* E_SgUnknownArrayOrFunctionReference(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownArrayOrFunctionReference_named_reference";
            case 1L: return "SgUnknownArrayOrFunctionReference_expression_list";
            default: return "";
        }
    }

    std::string E_SgUnknownArrayOrFunctionReference(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownArrayOrFunctionReference(i);
        if (s.empty())
            s = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownArrayOrFunctionReference() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownArrayOrFunctionReference(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownArrayOrFunctionReference(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownArrayOrFunctionReference() {
        return stringify::E_SgUnknownArrayOrFunctionReference();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1284
namespace stringify {
    const char* E_SgCAFCoExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFCoExpression_referData";
            default: return "";
        }
    }

    std::string E_SgCAFCoExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFCoExpression(i);
        if (s.empty())
            s = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFCoExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFCoExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFCoExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFCoExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFCoExpression() {
        return stringify::E_SgCAFCoExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1287
namespace stringify {
    const char* E_SgSizeOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSizeOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgSizeOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSizeOfOp(i);
        if (s.empty())
            s = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSizeOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSizeOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSizeOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSizeOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSizeOfOp() {
        return stringify::E_SgSizeOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1290
namespace stringify {
    const char* E_SgLambdaRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaRefExp_functionDeclaration";
            default: return "";
        }
    }

    std::string E_SgLambdaRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaRefExp(i);
        if (s.empty())
            s = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaRefExp() {
        return stringify::E_SgLambdaRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1293
namespace stringify {
    const char* E_SgDictionaryExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryExp_key_datum_pairs";
            default: return "";
        }
    }

    std::string E_SgDictionaryExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryExp(i);
        if (s.empty())
            s = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryExp(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryExp() {
        return stringify::E_SgDictionaryExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1296
namespace stringify {
    const char* E_SgKeyDatumPair(int64_t i) {
        switch (i) {
            case 0L: return "SgKeyDatumPair_key";
            case 1L: return "SgKeyDatumPair_datum";
            default: return "";
        }
    }

    std::string E_SgKeyDatumPair(int64_t i, const std::string &strip) {
        std::string s = E_SgKeyDatumPair(i);
        if (s.empty())
            s = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgKeyDatumPair() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgKeyDatumPair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgKeyDatumPair(i);
        if (retval.empty()) {
            retval = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgKeyDatumPair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgKeyDatumPair() {
        return stringify::E_SgKeyDatumPair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1299
namespace stringify {
    const char* E_SgScopedRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgScopedRefExp_lhs";
            case 1L: return "SgScopedRefExp_rhs";
            default: return "";
        }
    }

    std::string E_SgScopedRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgScopedRefExp(i);
        if (s.empty())
            s = "(E_SgScopedRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopedRefExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopedRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopedRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgScopedRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopedRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopedRefExp() {
        return stringify::E_SgScopedRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1302
namespace stringify {
    const char* E_SgComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgComprehension_target";
            case 1L: return "SgComprehension_iter";
            case 2L: return "SgComprehension_filters";
            default: return "";
        }
    }

    std::string E_SgComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgComprehension(i);
        if (s.empty())
            s = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComprehension() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComprehension() {
        return stringify::E_SgComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1305
namespace stringify {
    const char* E_SgListComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgListComprehension_element";
            case 1L: return "SgListComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgListComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgListComprehension(i);
        if (s.empty())
            s = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListComprehension() {
        return stringify::E_SgListComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1308
namespace stringify {
    const char* E_SgSetComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgSetComprehension_element";
            case 1L: return "SgSetComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgSetComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgSetComprehension(i);
        if (s.empty())
            s = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSetComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSetComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSetComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSetComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSetComprehension() {
        return stringify::E_SgSetComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1311
namespace stringify {
    const char* E_SgDictionaryComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryComprehension_element";
            case 1L: return "SgDictionaryComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgDictionaryComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryComprehension(i);
        if (s.empty())
            s = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryComprehension() {
        return stringify::E_SgDictionaryComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1314
namespace stringify {
    const char* E_SgNaryBooleanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryBooleanOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryBooleanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryBooleanOp(i);
        if (s.empty())
            s = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryBooleanOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryBooleanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryBooleanOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryBooleanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryBooleanOp() {
        return stringify::E_SgNaryBooleanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1317
namespace stringify {
    const char* E_SgNaryComparisonOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryComparisonOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryComparisonOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryComparisonOp(i);
        if (s.empty())
            s = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryComparisonOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryComparisonOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryComparisonOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryComparisonOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryComparisonOp() {
        return stringify::E_SgNaryComparisonOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1320
namespace stringify {
    const char* E_SgNaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryOp(i);
        if (s.empty())
            s = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryOp() {
        return stringify::E_SgNaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1323
namespace stringify {
    const char* E_SgStringConversion(int64_t i) {
        switch (i) {
            case 0L: return "SgStringConversion_expression";
            default: return "";
        }
    }

    std::string E_SgStringConversion(int64_t i, const std::string &strip) {
        std::string s = E_SgStringConversion(i);
        if (s.empty())
            s = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStringConversion() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStringConversion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStringConversion(i);
        if (retval.empty()) {
            retval = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStringConversion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStringConversion() {
        return stringify::E_SgStringConversion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1326
namespace stringify {
    const char* E_SgYieldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgYieldExpression_value";
            default: return "";
        }
    }

    std::string E_SgYieldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgYieldExpression(i);
        if (s.empty())
            s = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgYieldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgYieldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgYieldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgYieldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgYieldExpression() {
        return stringify::E_SgYieldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1329
namespace stringify {
    const char* E_SgAlignOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAlignOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgAlignOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAlignOfOp(i);
        if (s.empty())
            s = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAlignOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAlignOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAlignOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAlignOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAlignOfOp() {
        return stringify::E_SgAlignOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1332
namespace stringify {
    const char* E_SgRangeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeExp_start";
            case 1L: return "SgRangeExp_end";
            case 2L: return "SgRangeExp_stride";
            default: return "";
        }
    }

    std::string E_SgRangeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeExp(i);
        if (s.empty())
            s = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeExp(i);
        if (retval.empty()) {
            retval = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeExp() {
        return stringify::E_SgRangeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1335
namespace stringify {
    const char* E_SgJavaSingleMemberAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSingleMemberAnnotation_value";
            default: return "";
        }
    }

    std::string E_SgJavaSingleMemberAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSingleMemberAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSingleMemberAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSingleMemberAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSingleMemberAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSingleMemberAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSingleMemberAnnotation() {
        return stringify::E_SgJavaSingleMemberAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1338
namespace stringify {
    const char* E_SgJavaNormalAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaNormalAnnotation_value_pair_list";
            default: return "";
        }
    }

    std::string E_SgJavaNormalAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaNormalAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaNormalAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaNormalAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaNormalAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaNormalAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaNormalAnnotation() {
        return stringify::E_SgJavaNormalAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1341
namespace stringify {
    const char* E_SgFunctionParameterRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterRefExp_parameter_expression";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterRefExp(i);
        if (s.empty())
            s = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterRefExp() {
        return stringify::E_SgFunctionParameterRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1344
namespace stringify {
    const char* E_SgLambdaExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaExp_lambda_capture_list";
            case 1L: return "SgLambdaExp_lambda_closure_class";
            case 2L: return "SgLambdaExp_lambda_function";
            default: return "";
        }
    }

    std::string E_SgLambdaExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaExp(i);
        if (s.empty())
            s = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaExp() {
        return stringify::E_SgLambdaExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1347
namespace stringify {
    const char* E_SgHereExp(int64_t i) {
        switch (i) {
            case 0L: return "SgHereExp_expression";
            default: return "";
        }
    }

    std::string E_SgHereExp(int64_t i, const std::string &strip) {
        std::string s = E_SgHereExp(i);
        if (s.empty())
            s = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgHereExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgHereExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgHereExp(i);
        if (retval.empty()) {
            retval = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgHereExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgHereExp() {
        return stringify::E_SgHereExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1350
namespace stringify {
    const char* E_SgAtExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAtExp_expression";
            case 1L: return "SgAtExp_body";
            default: return "";
        }
    }

    std::string E_SgAtExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAtExp(i);
        if (s.empty())
            s = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtExp(i);
        if (retval.empty()) {
            retval = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtExp() {
        return stringify::E_SgAtExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1353
namespace stringify {
    const char* E_SgFinishExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishExp_expression";
            case 1L: return "SgFinishExp_body";
            default: return "";
        }
    }

    std::string E_SgFinishExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishExp(i);
        if (s.empty())
            s = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishExp(i);
        if (retval.empty()) {
            retval = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishExp() {
        return stringify::E_SgFinishExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1356
namespace stringify {
    const char* E_SgNoexceptOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNoexceptOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgNoexceptOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNoexceptOp(i);
        if (s.empty())
            s = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNoexceptOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNoexceptOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNoexceptOp(i);
        if (retval.empty()) {
            retval = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNoexceptOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNoexceptOp() {
        return stringify::E_SgNoexceptOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1359
namespace stringify {
    const char* E_SgFoldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgFoldExpression_operands";
            default: return "";
        }
    }

    std::string E_SgFoldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgFoldExpression(i);
        if (s.empty())
            s = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFoldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFoldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFoldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFoldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFoldExpression() {
        return stringify::E_SgFoldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1362
namespace stringify {
    const char* E_SgAwaitExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAwaitExpression_value";
            default: return "";
        }
    }

    std::string E_SgAwaitExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAwaitExpression(i);
        if (s.empty())
            s = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAwaitExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAwaitExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAwaitExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAwaitExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAwaitExpression() {
        return stringify::E_SgAwaitExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1365
namespace stringify {
    const char* E_SgChooseExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgChooseExpression_value";
            default: return "";
        }
    }

    std::string E_SgChooseExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgChooseExpression(i);
        if (s.empty())
            s = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgChooseExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgChooseExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgChooseExpression(i);
        if (retval.empty()) {
            retval = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgChooseExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgChooseExpression() {
        return stringify::E_SgChooseExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1368
namespace stringify {
    const char* E_SgAdaAttributeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAttributeExp_object";
            case 1L: return "SgAdaAttributeExp_args";
            default: return "";
        }
    }

    std::string E_SgAdaAttributeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAttributeExp(i);
        if (s.empty())
            s = "(E_SgAdaAttributeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAttributeExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAttributeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAttributeExp(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAttributeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAttributeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAttributeExp() {
        return stringify::E_SgAdaAttributeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1371
namespace stringify {
    const char* E_SgJovialTablePresetExp(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTablePresetExp_preset_list";
            default: return "";
        }
    }

    std::string E_SgJovialTablePresetExp(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTablePresetExp(i);
        if (s.empty())
            s = "(E_SgJovialTablePresetExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTablePresetExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTablePresetExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTablePresetExp(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTablePresetExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTablePresetExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTablePresetExp() {
        return stringify::E_SgJovialTablePresetExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1374
namespace stringify {
    const char* E_SgJovialPresetPositionExp(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialPresetPositionExp_indices";
            case 1L: return "SgJovialPresetPositionExp_value";
            default: return "";
        }
    }

    std::string E_SgJovialPresetPositionExp(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialPresetPositionExp(i);
        if (s.empty())
            s = "(E_SgJovialPresetPositionExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialPresetPositionExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialPresetPositionExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialPresetPositionExp(i);
        if (retval.empty()) {
            retval = "(E_SgJovialPresetPositionExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialPresetPositionExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialPresetPositionExp() {
        return stringify::E_SgJovialPresetPositionExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1377
namespace stringify {
    const char* E_SgNonrealSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealSymbol(i);
        if (s.empty())
            s = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealSymbol() {
        return stringify::E_SgNonrealSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1380
namespace stringify {
    const char* E_SgTemplateMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionSymbol() {
        return stringify::E_SgTemplateMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1383
namespace stringify {
    const char* E_SgMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionSymbol() {
        return stringify::E_SgMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1386
namespace stringify {
    const char* E_SgTemplateFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionSymbol() {
        return stringify::E_SgTemplateFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1389
namespace stringify {
    const char* E_SgRenameSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgRenameSymbol_declaration";
            case 1L: return "SgRenameSymbol_original_symbol";
            default: return "";
        }
    }

    std::string E_SgRenameSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgRenameSymbol(i);
        if (s.empty())
            s = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRenameSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRenameSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRenameSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRenameSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRenameSymbol() {
        return stringify::E_SgRenameSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1392
namespace stringify {
    const char* E_SgAdaInheritedFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaInheritedFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaInheritedFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaInheritedFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgAdaInheritedFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaInheritedFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaInheritedFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaInheritedFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaInheritedFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaInheritedFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaInheritedFunctionSymbol() {
        return stringify::E_SgAdaInheritedFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1395
namespace stringify {
    const char* E_SgFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionSymbol() {
        return stringify::E_SgFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1398
namespace stringify {
    const char* E_SgTemplateSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateSymbol() {
        return stringify::E_SgTemplateSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1401
namespace stringify {
    const char* E_SgTemplateClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassSymbol() {
        return stringify::E_SgTemplateClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1404
namespace stringify {
    const char* E_SgClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgClassSymbol(i);
        if (s.empty())
            s = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassSymbol() {
        return stringify::E_SgClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1407
namespace stringify {
    const char* E_SgTemplateTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefSymbol() {
        return stringify::E_SgTemplateTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1410
namespace stringify {
    const char* E_SgTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefSymbol() {
        return stringify::E_SgTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1413
namespace stringify {
    const char* E_SgEnumSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumSymbol(i);
        if (s.empty())
            s = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumSymbol() {
        return stringify::E_SgEnumSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1416
namespace stringify {
    const char* E_SgLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelSymbol(i);
        if (s.empty())
            s = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelSymbol() {
        return stringify::E_SgLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1419
namespace stringify {
    const char* E_SgNamespaceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceSymbol_declaration";
            case 1L: return "SgNamespaceSymbol_aliasDeclaration";
            default: return "";
        }
    }

    std::string E_SgNamespaceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceSymbol(i);
        if (s.empty())
            s = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceSymbol() {
        return stringify::E_SgNamespaceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1422
namespace stringify {
    const char* E_SgModuleSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgModuleSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleSymbol(i);
        if (s.empty())
            s = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleSymbol() {
        return stringify::E_SgModuleSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1425
namespace stringify {
    const char* E_SgAliasSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAliasSymbol_alias";
            default: return "";
        }
    }

    std::string E_SgAliasSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAliasSymbol(i);
        if (s.empty())
            s = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAliasSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAliasSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAliasSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAliasSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAliasSymbol() {
        return stringify::E_SgAliasSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1428
namespace stringify {
    const char* E_SgJavaLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelSymbol(i);
        if (s.empty())
            s = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelSymbol() {
        return stringify::E_SgJavaLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1431
namespace stringify {
    const char* E_SgAdaPackageSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSymbol(i);
        if (s.empty())
            s = "(E_SgAdaPackageSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSymbol() {
        return stringify::E_SgAdaPackageSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1434
namespace stringify {
    const char* E_SgAdaTaskSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSymbol(i);
        if (s.empty())
            s = "(E_SgAdaTaskSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSymbol() {
        return stringify::E_SgAdaTaskSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1437
namespace stringify {
    const char* E_SgAdaProtectedSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSymbol(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSymbol() {
        return stringify::E_SgAdaProtectedSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1440
namespace stringify {
    const char* E_SgAdaRenamingSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRenamingSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaRenamingSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRenamingSymbol(i);
        if (s.empty())
            s = "(E_SgAdaRenamingSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRenamingSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRenamingSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRenamingSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRenamingSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRenamingSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRenamingSymbol() {
        return stringify::E_SgAdaRenamingSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1443
namespace stringify {
    const char* E_SgAdaGenericSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericSymbol(i);
        if (s.empty())
            s = "(E_SgAdaGenericSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericSymbol() {
        return stringify::E_SgAdaGenericSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1446
namespace stringify {
    const char* E_SgAdaGenericInstanceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericInstanceSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericInstanceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericInstanceSymbol(i);
        if (s.empty())
            s = "(E_SgAdaGenericInstanceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericInstanceSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericInstanceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericInstanceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericInstanceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericInstanceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericInstanceSymbol() {
        return stringify::E_SgAdaGenericInstanceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1449
namespace stringify {
    const char* E_SgAdaFormalPackageSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalPackageSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaFormalPackageSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalPackageSymbol(i);
        if (s.empty())
            s = "(E_SgAdaFormalPackageSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalPackageSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalPackageSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalPackageSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalPackageSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalPackageSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalPackageSymbol() {
        return stringify::E_SgAdaFormalPackageSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1452
namespace stringify {
    const char* E_SgAsmCilMetadataHeap(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMetadataHeap_AssemblyTable";
            case 1L: return "SgAsmCilMetadataHeap_AssemblyOSTable";
            case 2L: return "SgAsmCilMetadataHeap_AssemblyProcessorTable";
            case 3L: return "SgAsmCilMetadataHeap_AssemblyRefTable";
            case 4L: return "SgAsmCilMetadataHeap_AssemblyRefOSTable";
            case 5L: return "SgAsmCilMetadataHeap_AssemblyRefProcessorTable";
            case 6L: return "SgAsmCilMetadataHeap_ClassLayoutTable";
            case 7L: return "SgAsmCilMetadataHeap_ConstantTable";
            case 8L: return "SgAsmCilMetadataHeap_CustomAttributeTable";
            case 9L: return "SgAsmCilMetadataHeap_DeclSecurityTable";
            case 10L: return "SgAsmCilMetadataHeap_EventTable";
            case 11L: return "SgAsmCilMetadataHeap_EventMapTable";
            case 12L: return "SgAsmCilMetadataHeap_ExportedTypeTable";
            case 13L: return "SgAsmCilMetadataHeap_FieldTable";
            case 14L: return "SgAsmCilMetadataHeap_FieldLayoutTable";
            case 15L: return "SgAsmCilMetadataHeap_FieldMarshalTable";
            case 16L: return "SgAsmCilMetadataHeap_FieldRVATable";
            case 17L: return "SgAsmCilMetadataHeap_FileTable";
            case 18L: return "SgAsmCilMetadataHeap_GenericParamTable";
            case 19L: return "SgAsmCilMetadataHeap_GenericParamConstraintTable";
            case 20L: return "SgAsmCilMetadataHeap_ImplMapTable";
            case 21L: return "SgAsmCilMetadataHeap_InterfaceImplTable";
            case 22L: return "SgAsmCilMetadataHeap_ManifestResourceTable";
            case 23L: return "SgAsmCilMetadataHeap_MemberRefTable";
            case 24L: return "SgAsmCilMetadataHeap_MethodDefTable";
            case 25L: return "SgAsmCilMetadataHeap_MethodImplTable";
            case 26L: return "SgAsmCilMetadataHeap_MethodSemanticsTable";
            case 27L: return "SgAsmCilMetadataHeap_MethodSpecTable";
            case 28L: return "SgAsmCilMetadataHeap_ModuleTable";
            case 29L: return "SgAsmCilMetadataHeap_ModuleRefTable";
            case 30L: return "SgAsmCilMetadataHeap_NestedClassTable";
            case 31L: return "SgAsmCilMetadataHeap_ParamTable";
            case 32L: return "SgAsmCilMetadataHeap_PropertyTable";
            case 33L: return "SgAsmCilMetadataHeap_PropertyMapTable";
            case 34L: return "SgAsmCilMetadataHeap_StandAloneSigTable";
            case 35L: return "SgAsmCilMetadataHeap_TypeDefTable";
            case 36L: return "SgAsmCilMetadataHeap_TypeRefTable";
            case 37L: return "SgAsmCilMetadataHeap_TypeSpecTable";
            default: return "";
        }
    }

    std::string E_SgAsmCilMetadataHeap(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMetadataHeap(i);
        if (s.empty())
            s = "(E_SgAsmCilMetadataHeap)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMetadataHeap() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L
        };
        static const std::vector<int64_t> retval(values, values + 38);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMetadataHeap(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMetadataHeap(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMetadataHeap)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMetadataHeap::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMetadataHeap() {
        return stringify::E_SgAsmCilMetadataHeap();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1455
namespace stringify {
    const char* E_SgAsmCilAssemblyOSTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyOSTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyOSTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyOSTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyOSTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyOSTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyOSTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyOSTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyOSTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyOSTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyOSTable() {
        return stringify::E_SgAsmCilAssemblyOSTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1458
namespace stringify {
    const char* E_SgAsmCilAssemblyProcessorTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyProcessorTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyProcessorTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyProcessorTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyProcessorTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyProcessorTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyProcessorTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyProcessorTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyProcessorTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyProcessorTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyProcessorTable() {
        return stringify::E_SgAsmCilAssemblyProcessorTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1461
namespace stringify {
    const char* E_SgAsmCilAssemblyRefOSTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefOSTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefOSTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefOSTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefOSTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefOSTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefOSTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefOSTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefOSTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefOSTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefOSTable() {
        return stringify::E_SgAsmCilAssemblyRefOSTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1464
namespace stringify {
    const char* E_SgAsmCilAssemblyRefProcessorTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefProcessorTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefProcessorTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefProcessorTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefProcessorTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefProcessorTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefProcessorTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefProcessorTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefProcessorTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefProcessorTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefProcessorTable() {
        return stringify::E_SgAsmCilAssemblyRefProcessorTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1467
namespace stringify {
    const char* E_SgAsmCilAssemblyRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefTable() {
        return stringify::E_SgAsmCilAssemblyRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1470
namespace stringify {
    const char* E_SgAsmCilAssemblyTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyTable() {
        return stringify::E_SgAsmCilAssemblyTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1473
namespace stringify {
    const char* E_SgAsmCilClassLayoutTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilClassLayoutTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilClassLayoutTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilClassLayoutTable(i);
        if (s.empty())
            s = "(E_SgAsmCilClassLayoutTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilClassLayoutTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilClassLayoutTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilClassLayoutTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilClassLayoutTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilClassLayoutTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilClassLayoutTable() {
        return stringify::E_SgAsmCilClassLayoutTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1476
namespace stringify {
    const char* E_SgAsmCilConstantTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilConstantTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilConstantTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilConstantTable(i);
        if (s.empty())
            s = "(E_SgAsmCilConstantTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilConstantTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilConstantTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilConstantTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilConstantTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilConstantTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilConstantTable() {
        return stringify::E_SgAsmCilConstantTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1479
namespace stringify {
    const char* E_SgAsmCilCustomAttributeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilCustomAttributeTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilCustomAttributeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilCustomAttributeTable(i);
        if (s.empty())
            s = "(E_SgAsmCilCustomAttributeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilCustomAttributeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilCustomAttributeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilCustomAttributeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilCustomAttributeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilCustomAttributeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilCustomAttributeTable() {
        return stringify::E_SgAsmCilCustomAttributeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1482
namespace stringify {
    const char* E_SgAsmCilDeclSecurityTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilDeclSecurityTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilDeclSecurityTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilDeclSecurityTable(i);
        if (s.empty())
            s = "(E_SgAsmCilDeclSecurityTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilDeclSecurityTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilDeclSecurityTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilDeclSecurityTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilDeclSecurityTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilDeclSecurityTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilDeclSecurityTable() {
        return stringify::E_SgAsmCilDeclSecurityTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1485
namespace stringify {
    const char* E_SgAsmCilEventMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilEventMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilEventMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilEventMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilEventMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilEventMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilEventMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilEventMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilEventMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilEventMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilEventMapTable() {
        return stringify::E_SgAsmCilEventMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1488
namespace stringify {
    const char* E_SgAsmCilEventTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilEventTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilEventTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilEventTable(i);
        if (s.empty())
            s = "(E_SgAsmCilEventTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilEventTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilEventTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilEventTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilEventTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilEventTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilEventTable() {
        return stringify::E_SgAsmCilEventTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1491
namespace stringify {
    const char* E_SgAsmCilExportedTypeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilExportedTypeTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilExportedTypeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilExportedTypeTable(i);
        if (s.empty())
            s = "(E_SgAsmCilExportedTypeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilExportedTypeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilExportedTypeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilExportedTypeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilExportedTypeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilExportedTypeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilExportedTypeTable() {
        return stringify::E_SgAsmCilExportedTypeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1494
namespace stringify {
    const char* E_SgAsmCilFieldLayoutTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldLayoutTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldLayoutTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldLayoutTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldLayoutTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldLayoutTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldLayoutTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldLayoutTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldLayoutTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldLayoutTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldLayoutTable() {
        return stringify::E_SgAsmCilFieldLayoutTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1497
namespace stringify {
    const char* E_SgAsmCilFieldMarshalTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldMarshalTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldMarshalTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldMarshalTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldMarshalTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldMarshalTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldMarshalTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldMarshalTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldMarshalTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldMarshalTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldMarshalTable() {
        return stringify::E_SgAsmCilFieldMarshalTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1500
namespace stringify {
    const char* E_SgAsmCilFieldRVATable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldRVATable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldRVATable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldRVATable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldRVATable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldRVATable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldRVATable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldRVATable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldRVATable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldRVATable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldRVATable() {
        return stringify::E_SgAsmCilFieldRVATable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1503
namespace stringify {
    const char* E_SgAsmCilFieldTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldTable() {
        return stringify::E_SgAsmCilFieldTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1506
namespace stringify {
    const char* E_SgAsmCilFileTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFileTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFileTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFileTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFileTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFileTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFileTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFileTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFileTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFileTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFileTable() {
        return stringify::E_SgAsmCilFileTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1509
namespace stringify {
    const char* E_SgAsmCilGenericParamConstraintTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilGenericParamConstraintTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilGenericParamConstraintTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilGenericParamConstraintTable(i);
        if (s.empty())
            s = "(E_SgAsmCilGenericParamConstraintTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilGenericParamConstraintTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilGenericParamConstraintTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilGenericParamConstraintTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilGenericParamConstraintTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilGenericParamConstraintTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilGenericParamConstraintTable() {
        return stringify::E_SgAsmCilGenericParamConstraintTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1512
namespace stringify {
    const char* E_SgAsmCilGenericParamTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilGenericParamTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilGenericParamTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilGenericParamTable(i);
        if (s.empty())
            s = "(E_SgAsmCilGenericParamTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilGenericParamTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilGenericParamTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilGenericParamTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilGenericParamTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilGenericParamTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilGenericParamTable() {
        return stringify::E_SgAsmCilGenericParamTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1515
namespace stringify {
    const char* E_SgAsmCilImplMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilImplMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilImplMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilImplMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilImplMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilImplMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilImplMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilImplMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilImplMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilImplMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilImplMapTable() {
        return stringify::E_SgAsmCilImplMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1518
namespace stringify {
    const char* E_SgAsmCilInterfaceImplTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilInterfaceImplTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilInterfaceImplTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilInterfaceImplTable(i);
        if (s.empty())
            s = "(E_SgAsmCilInterfaceImplTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilInterfaceImplTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilInterfaceImplTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilInterfaceImplTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilInterfaceImplTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilInterfaceImplTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilInterfaceImplTable() {
        return stringify::E_SgAsmCilInterfaceImplTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1521
namespace stringify {
    const char* E_SgAsmCilManifestResourceTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilManifestResourceTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilManifestResourceTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilManifestResourceTable(i);
        if (s.empty())
            s = "(E_SgAsmCilManifestResourceTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilManifestResourceTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilManifestResourceTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilManifestResourceTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilManifestResourceTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilManifestResourceTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilManifestResourceTable() {
        return stringify::E_SgAsmCilManifestResourceTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1524
namespace stringify {
    const char* E_SgAsmCilMemberRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMemberRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMemberRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMemberRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMemberRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMemberRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMemberRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMemberRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMemberRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMemberRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMemberRefTable() {
        return stringify::E_SgAsmCilMemberRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1527
namespace stringify {
    const char* E_SgAsmCilMethodDefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodDefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodDefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodDefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodDefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodDefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodDefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodDefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodDefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodDefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodDefTable() {
        return stringify::E_SgAsmCilMethodDefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1530
namespace stringify {
    const char* E_SgAsmCilMethodImplTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodImplTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodImplTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodImplTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodImplTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodImplTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodImplTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodImplTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodImplTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodImplTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodImplTable() {
        return stringify::E_SgAsmCilMethodImplTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1533
namespace stringify {
    const char* E_SgAsmCilMethodSemanticsTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodSemanticsTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodSemanticsTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodSemanticsTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodSemanticsTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodSemanticsTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodSemanticsTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodSemanticsTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodSemanticsTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodSemanticsTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodSemanticsTable() {
        return stringify::E_SgAsmCilMethodSemanticsTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1536
namespace stringify {
    const char* E_SgAsmCilMethodSpecTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodSpecTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodSpecTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodSpecTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodSpecTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodSpecTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodSpecTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodSpecTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodSpecTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodSpecTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodSpecTable() {
        return stringify::E_SgAsmCilMethodSpecTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1539
namespace stringify {
    const char* E_SgAsmCilModuleRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilModuleRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilModuleRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilModuleRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilModuleRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilModuleRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilModuleRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilModuleRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilModuleRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilModuleRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilModuleRefTable() {
        return stringify::E_SgAsmCilModuleRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1542
namespace stringify {
    const char* E_SgAsmCilModuleTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilModuleTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilModuleTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilModuleTable(i);
        if (s.empty())
            s = "(E_SgAsmCilModuleTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilModuleTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilModuleTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilModuleTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilModuleTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilModuleTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilModuleTable() {
        return stringify::E_SgAsmCilModuleTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1545
namespace stringify {
    const char* E_SgAsmCilNestedClassTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilNestedClassTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilNestedClassTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilNestedClassTable(i);
        if (s.empty())
            s = "(E_SgAsmCilNestedClassTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilNestedClassTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilNestedClassTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilNestedClassTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilNestedClassTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilNestedClassTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilNestedClassTable() {
        return stringify::E_SgAsmCilNestedClassTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1548
namespace stringify {
    const char* E_SgAsmCilParamTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilParamTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilParamTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilParamTable(i);
        if (s.empty())
            s = "(E_SgAsmCilParamTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilParamTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilParamTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilParamTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilParamTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilParamTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilParamTable() {
        return stringify::E_SgAsmCilParamTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1551
namespace stringify {
    const char* E_SgAsmCilPropertyMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilPropertyMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilPropertyMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilPropertyMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilPropertyMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilPropertyMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilPropertyMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilPropertyMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilPropertyMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilPropertyMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilPropertyMapTable() {
        return stringify::E_SgAsmCilPropertyMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1554
namespace stringify {
    const char* E_SgAsmCilPropertyTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilPropertyTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilPropertyTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilPropertyTable(i);
        if (s.empty())
            s = "(E_SgAsmCilPropertyTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilPropertyTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilPropertyTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilPropertyTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilPropertyTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilPropertyTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilPropertyTable() {
        return stringify::E_SgAsmCilPropertyTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1557
namespace stringify {
    const char* E_SgAsmCilStandAloneSigTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilStandAloneSigTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilStandAloneSigTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilStandAloneSigTable(i);
        if (s.empty())
            s = "(E_SgAsmCilStandAloneSigTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilStandAloneSigTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilStandAloneSigTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilStandAloneSigTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilStandAloneSigTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilStandAloneSigTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilStandAloneSigTable() {
        return stringify::E_SgAsmCilStandAloneSigTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1560
namespace stringify {
    const char* E_SgAsmCilTypeDefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeDefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeDefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeDefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeDefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeDefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeDefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeDefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeDefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeDefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeDefTable() {
        return stringify::E_SgAsmCilTypeDefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1563
namespace stringify {
    const char* E_SgAsmCilTypeRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeRefTable() {
        return stringify::E_SgAsmCilTypeRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1566
namespace stringify {
    const char* E_SgAsmCilTypeSpecTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeSpecTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeSpecTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeSpecTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeSpecTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeSpecTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeSpecTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeSpecTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeSpecTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeSpecTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeSpecTable() {
        return stringify::E_SgAsmCilTypeSpecTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1569
namespace stringify {
    const char* E_SgAsmCilMetadataRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMetadataRoot_Streams";
            default: return "";
        }
    }

    std::string E_SgAsmCilMetadataRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMetadataRoot(i);
        if (s.empty())
            s = "(E_SgAsmCilMetadataRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMetadataRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMetadataRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMetadataRoot(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMetadataRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMetadataRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMetadataRoot() {
        return stringify::E_SgAsmCilMetadataRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1572
namespace stringify {
    const char* E_SgAsmCoffSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolList() {
        return stringify::E_SgAsmCoffSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1575
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnitList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnitList_cu_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnitList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnitList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnitList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnitList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnitList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnitList() {
        return stringify::E_SgAsmDwarfCompilationUnitList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1578
namespace stringify {
    const char* E_SgAsmDwarfArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfArrayType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfArrayType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfArrayType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfArrayType() {
        return stringify::E_SgAsmDwarfArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1581
namespace stringify {
    const char* E_SgAsmDwarfClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfClassType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfClassType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfClassType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfClassType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfClassType() {
        return stringify::E_SgAsmDwarfClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1584
namespace stringify {
    const char* E_SgAsmDwarfCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCommonBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCommonBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCommonBlock() {
        return stringify::E_SgAsmDwarfCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1587
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnit(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnit_line_info";
            case 1L: return "SgAsmDwarfCompilationUnit_language_constructs";
            case 2L: return "SgAsmDwarfCompilationUnit_macro_info";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnit(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnit(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnit() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnit(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnit(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnit::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnit() {
        return stringify::E_SgAsmDwarfCompilationUnit();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1590
namespace stringify {
    const char* E_SgAsmDwarfEnumerationType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfEnumerationType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfEnumerationType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfEnumerationType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfEnumerationType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfEnumerationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfEnumerationType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfEnumerationType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfEnumerationType() {
        return stringify::E_SgAsmDwarfEnumerationType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1593
namespace stringify {
    const char* E_SgAsmDwarfInlinedSubroutine(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfInlinedSubroutine_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfInlinedSubroutine(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfInlinedSubroutine(i);
        if (s.empty())
            s = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfInlinedSubroutine() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfInlinedSubroutine(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfInlinedSubroutine(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfInlinedSubroutine() {
        return stringify::E_SgAsmDwarfInlinedSubroutine();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1596
namespace stringify {
    const char* E_SgAsmDwarfLexicalBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLexicalBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLexicalBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLexicalBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLexicalBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLexicalBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLexicalBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLexicalBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLexicalBlock() {
        return stringify::E_SgAsmDwarfLexicalBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1599
namespace stringify {
    const char* E_SgAsmDwarfNamespace(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfNamespace_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfNamespace(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfNamespace(i);
        if (s.empty())
            s = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfNamespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfNamespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfNamespace(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfNamespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfNamespace() {
        return stringify::E_SgAsmDwarfNamespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1602
namespace stringify {
    const char* E_SgAsmDwarfStructureType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfStructureType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfStructureType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfStructureType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfStructureType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfStructureType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfStructureType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfStructureType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfStructureType() {
        return stringify::E_SgAsmDwarfStructureType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1605
namespace stringify {
    const char* E_SgAsmDwarfSubprogram(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubprogram_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubprogram(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubprogram(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubprogram() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubprogram(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubprogram(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubprogram::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubprogram() {
        return stringify::E_SgAsmDwarfSubprogram();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1608
namespace stringify {
    const char* E_SgAsmDwarfSubroutineType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubroutineType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubroutineType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubroutineType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubroutineType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubroutineType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubroutineType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubroutineType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubroutineType() {
        return stringify::E_SgAsmDwarfSubroutineType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1611
namespace stringify {
    const char* E_SgAsmDwarfUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfUnionType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfUnionType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfUnionType() {
        return stringify::E_SgAsmDwarfUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1614
namespace stringify {
    const char* E_SgAsmDwarfConstructList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfConstructList_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfConstructList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfConstructList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfConstructList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfConstructList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfConstructList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfConstructList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfConstructList() {
        return stringify::E_SgAsmDwarfConstructList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1617
namespace stringify {
    const char* E_SgAsmDwarfLineList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLineList_line_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLineList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLineList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLineList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLineList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLineList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLineList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLineList() {
        return stringify::E_SgAsmDwarfLineList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1620
namespace stringify {
    const char* E_SgAsmDwarfMacroList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfMacroList_macro_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfMacroList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfMacroList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfMacroList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfMacroList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfMacroList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfMacroList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfMacroList() {
        return stringify::E_SgAsmDwarfMacroList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1623
namespace stringify {
    const char* E_SgAsmElfDynamicEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicEntry() {
        return stringify::E_SgAsmElfDynamicEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1626
namespace stringify {
    const char* E_SgAsmElfEHFrameEntryCI(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameEntryCI_fd_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameEntryCI(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameEntryCI(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameEntryCI() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameEntryCI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameEntryCI(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameEntryCI() {
        return stringify::E_SgAsmElfEHFrameEntryCI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1629
namespace stringify {
    const char* E_SgAsmElfNoteEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteEntry() {
        return stringify::E_SgAsmElfNoteEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1632
namespace stringify {
    const char* E_SgAsmElfRelocEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocEntryList() {
        return stringify::E_SgAsmElfRelocEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1635
namespace stringify {
    const char* E_SgAsmElfSegmentTableEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSegmentTableEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSegmentTableEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSegmentTableEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSegmentTableEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSegmentTableEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSegmentTableEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSegmentTableEntryList() {
        return stringify::E_SgAsmElfSegmentTableEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1638
namespace stringify {
    const char* E_SgAsmElfSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolList() {
        return stringify::E_SgAsmElfSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1641
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAux() {
        return stringify::E_SgAsmElfSymverDefinedAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1644
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAuxList() {
        return stringify::E_SgAsmElfSymverDefinedAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1647
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntry() {
        return stringify::E_SgAsmElfSymverDefinedEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1650
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntryList() {
        return stringify::E_SgAsmElfSymverDefinedEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1653
namespace stringify {
    const char* E_SgAsmElfSymverEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverEntryList() {
        return stringify::E_SgAsmElfSymverEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1656
namespace stringify {
    const char* E_SgAsmElfSymverNeededAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAux() {
        return stringify::E_SgAsmElfSymverNeededAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1659
namespace stringify {
    const char* E_SgAsmElfSymverNeededAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAuxList() {
        return stringify::E_SgAsmElfSymverNeededAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1662
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntry_fileName";
            case 1L: return "SgAsmElfSymverNeededEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntry() {
        return stringify::E_SgAsmElfSymverNeededEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1665
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntryList() {
        return stringify::E_SgAsmElfSymverNeededEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1668
namespace stringify {
    const char* E_SgAsmGenericDLL(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericDLL_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericDLL(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericDLL(i);
        if (s.empty())
            s = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericDLL() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericDLL(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericDLL(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericDLL::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericDLL() {
        return stringify::E_SgAsmGenericDLL();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1671
namespace stringify {
    const char* E_SgAsmGenericFile(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFile_dwarfInfo";
            case 1L: return "SgAsmGenericFile_headers";
            case 2L: return "SgAsmGenericFile_holes";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFile(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFile(i);
        if (s.empty())
            s = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFile(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFile() {
        return stringify::E_SgAsmGenericFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1674
namespace stringify {
    const char* E_SgAsmGenericHeaderList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeaderList_headers";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeaderList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeaderList(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeaderList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeaderList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeaderList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeaderList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeaderList() {
        return stringify::E_SgAsmGenericHeaderList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1677
namespace stringify {
    const char* E_SgAsmCliHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCliHeader_metadataRoot";
            default: return "";
        }
    }

    std::string E_SgAsmCliHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCliHeader(i);
        if (s.empty())
            s = "(E_SgAsmCliHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCliHeader() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCliHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCliHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCliHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCliHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCliHeader() {
        return stringify::E_SgAsmCliHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1680
namespace stringify {
    const char* E_SgAsmCoffSymbolTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolTable_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolTable(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolTable() {
        return stringify::E_SgAsmCoffSymbolTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1683
namespace stringify {
    const char* E_SgAsmElfDynamicSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicSection_sectionEntry";
            case 1L: return "SgAsmElfDynamicSection_segmentEntry";
            case 2L: return "SgAsmElfDynamicSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicSection(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicSection() {
        return stringify::E_SgAsmElfDynamicSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1686
namespace stringify {
    const char* E_SgAsmElfEHFrameSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameSection_sectionEntry";
            case 1L: return "SgAsmElfEHFrameSection_segmentEntry";
            case 2L: return "SgAsmElfEHFrameSection_ci_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameSection(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameSection() {
        return stringify::E_SgAsmElfEHFrameSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1689
namespace stringify {
    const char* E_SgAsmElfNoteSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteSection_sectionEntry";
            case 1L: return "SgAsmElfNoteSection_segmentEntry";
            case 2L: return "SgAsmElfNoteSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteSection(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteSection() {
        return stringify::E_SgAsmElfNoteSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1692
namespace stringify {
    const char* E_SgAsmElfRelocSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocSection_sectionEntry";
            case 1L: return "SgAsmElfRelocSection_segmentEntry";
            case 2L: return "SgAsmElfRelocSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocSection(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocSection() {
        return stringify::E_SgAsmElfRelocSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1695
namespace stringify {
    const char* E_SgAsmElfStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfStringSection_sectionEntry";
            case 1L: return "SgAsmElfStringSection_segmentEntry";
            default: return "";
        }
    }

    std::string E_SgAsmElfStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfStringSection(i);
        if (s.empty())
            s = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfStringSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfStringSection() {
        return stringify::E_SgAsmElfStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1698
namespace stringify {
    const char* E_SgAsmElfSymbolSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolSection_sectionEntry";
            case 1L: return "SgAsmElfSymbolSection_segmentEntry";
            case 2L: return "SgAsmElfSymbolSection_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolSection() {
        return stringify::E_SgAsmElfSymbolSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1701
namespace stringify {
    const char* E_SgAsmElfSymverDefinedSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedSection_sectionEntry";
            case 1L: return "SgAsmElfSymverDefinedSection_segmentEntry";
            case 2L: return "SgAsmElfSymverDefinedSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedSection() {
        return stringify::E_SgAsmElfSymverDefinedSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1704
namespace stringify {
    const char* E_SgAsmElfSymverNeededSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededSection_sectionEntry";
            case 1L: return "SgAsmElfSymverNeededSection_segmentEntry";
            case 2L: return "SgAsmElfSymverNeededSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededSection() {
        return stringify::E_SgAsmElfSymverNeededSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1707
namespace stringify {
    const char* E_SgAsmElfSymverSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverSection_sectionEntry";
            case 1L: return "SgAsmElfSymverSection_segmentEntry";
            case 2L: return "SgAsmElfSymverSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverSection() {
        return stringify::E_SgAsmElfSymverSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1710
namespace stringify {
    const char* E_SgAsmElfSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSection_sectionEntry";
            case 1L: return "SgAsmElfSection_segmentEntry";
            default: return "";
        }
    }

    std::string E_SgAsmElfSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSection() {
        return stringify::E_SgAsmElfSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1713
namespace stringify {
    const char* E_SgAsmDOSFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDOSFileHeader_executableFormat";
            case 1L: return "SgAsmDOSFileHeader_dlls";
            case 2L: return "SgAsmDOSFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmDOSFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDOSFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDOSFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDOSFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDOSFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDOSFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDOSFileHeader() {
        return stringify::E_SgAsmDOSFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1716
namespace stringify {
    const char* E_SgAsmElfFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfFileHeader_executableFormat";
            case 1L: return "SgAsmElfFileHeader_dlls";
            case 2L: return "SgAsmElfFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmElfFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfFileHeader() {
        return stringify::E_SgAsmElfFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1719
namespace stringify {
    const char* E_SgAsmJvmFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmFileHeader_executableFormat";
            case 1L: return "SgAsmJvmFileHeader_dlls";
            case 2L: return "SgAsmJvmFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmJvmFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmJvmFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmFileHeader() {
        return stringify::E_SgAsmJvmFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1722
namespace stringify {
    const char* E_SgAsmLEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEFileHeader_executableFormat";
            case 1L: return "SgAsmLEFileHeader_dlls";
            case 2L: return "SgAsmLEFileHeader_sections";
            case 3L: return "SgAsmLEFileHeader_dos2Header";
            case 4L: return "SgAsmLEFileHeader_pageTable";
            case 5L: return "SgAsmLEFileHeader_residentNameTable";
            case 6L: return "SgAsmLEFileHeader_nonresidentNameTable";
            case 7L: return "SgAsmLEFileHeader_entryTable";
            case 8L: return "SgAsmLEFileHeader_relocationTable";
            default: return "";
        }
    }

    std::string E_SgAsmLEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEFileHeader() {
        return stringify::E_SgAsmLEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1725
namespace stringify {
    const char* E_SgAsmNEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEFileHeader_executableFormat";
            case 1L: return "SgAsmNEFileHeader_dlls";
            case 2L: return "SgAsmNEFileHeader_sections";
            case 3L: return "SgAsmNEFileHeader_dos2Header";
            case 4L: return "SgAsmNEFileHeader_residentNameTable";
            case 5L: return "SgAsmNEFileHeader_nonresidentNameTable";
            case 6L: return "SgAsmNEFileHeader_moduleTable";
            case 7L: return "SgAsmNEFileHeader_entryTable";
            default: return "";
        }
    }

    std::string E_SgAsmNEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEFileHeader() {
        return stringify::E_SgAsmNEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1728
namespace stringify {
    const char* E_SgAsmPEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEFileHeader_executableFormat";
            case 1L: return "SgAsmPEFileHeader_dlls";
            case 2L: return "SgAsmPEFileHeader_sections";
            case 3L: return "SgAsmPEFileHeader_rvaSizePairs";
            default: return "";
        }
    }

    std::string E_SgAsmPEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEFileHeader() {
        return stringify::E_SgAsmPEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1731
namespace stringify {
    const char* E_SgAsmGenericHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeader_executableFormat";
            case 1L: return "SgAsmGenericHeader_dlls";
            case 2L: return "SgAsmGenericHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeader(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeader() {
        return stringify::E_SgAsmGenericHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1734
namespace stringify {
    const char* E_SgAsmJvmAttributeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmAttributeTable_attributes";
            default: return "";
        }
    }

    std::string E_SgAsmJvmAttributeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmAttributeTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmAttributeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmAttributeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmAttributeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmAttributeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmAttributeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmAttributeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmAttributeTable() {
        return stringify::E_SgAsmJvmAttributeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1737
namespace stringify {
    const char* E_SgAsmJvmFieldTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmFieldTable_fields";
            default: return "";
        }
    }

    std::string E_SgAsmJvmFieldTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmFieldTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmFieldTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmFieldTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmFieldTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmFieldTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmFieldTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmFieldTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmFieldTable() {
        return stringify::E_SgAsmJvmFieldTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1740
namespace stringify {
    const char* E_SgAsmJvmMethodTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmMethodTable_methods";
            default: return "";
        }
    }

    std::string E_SgAsmJvmMethodTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmMethodTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmMethodTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmMethodTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmMethodTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmMethodTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmMethodTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmMethodTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmMethodTable() {
        return stringify::E_SgAsmJvmMethodTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1743
namespace stringify {
    const char* E_SgAsmLEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryTable() {
        return stringify::E_SgAsmLEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1746
namespace stringify {
    const char* E_SgAsmLEPageTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEPageTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEPageTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEPageTable(i);
        if (s.empty())
            s = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEPageTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEPageTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEPageTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEPageTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEPageTable() {
        return stringify::E_SgAsmLEPageTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1749
namespace stringify {
    const char* E_SgAsmLERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLERelocTable() {
        return stringify::E_SgAsmLERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1752
namespace stringify {
    const char* E_SgAsmLESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLESection_sectionTableEntry";
            default: return "";
        }
    }

    std::string E_SgAsmLESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLESection(i);
        if (s.empty())
            s = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLESection() {
        return stringify::E_SgAsmLESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1755
namespace stringify {
    const char* E_SgAsmNEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEEntryTable() {
        return stringify::E_SgAsmNEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1758
namespace stringify {
    const char* E_SgAsmNEModuleTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEModuleTable_strtab";
            default: return "";
        }
    }

    std::string E_SgAsmNEModuleTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEModuleTable(i);
        if (s.empty())
            s = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEModuleTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEModuleTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEModuleTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEModuleTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEModuleTable() {
        return stringify::E_SgAsmNEModuleTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1761
namespace stringify {
    const char* E_SgAsmNERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNERelocTable() {
        return stringify::E_SgAsmNERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1764
namespace stringify {
    const char* E_SgAsmNESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNESection_sectionTableEntry";
            case 1L: return "SgAsmNESection_relocationTable";
            default: return "";
        }
    }

    std::string E_SgAsmNESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNESection(i);
        if (s.empty())
            s = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNESection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNESection() {
        return stringify::E_SgAsmNESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1767
namespace stringify {
    const char* E_SgAsmPEExportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportSection_section_entry";
            case 1L: return "SgAsmPEExportSection_exportDirectory";
            case 2L: return "SgAsmPEExportSection_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportSection() {
        return stringify::E_SgAsmPEExportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1770
namespace stringify {
    const char* E_SgAsmPEImportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportSection_section_entry";
            case 1L: return "SgAsmPEImportSection_importDirectories";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportSection() {
        return stringify::E_SgAsmPEImportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1773
namespace stringify {
    const char* E_SgAsmPEStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEStringSection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPEStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEStringSection(i);
        if (s.empty())
            s = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEStringSection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEStringSection() {
        return stringify::E_SgAsmPEStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1776
namespace stringify {
    const char* E_SgAsmPESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPESection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPESection(i);
        if (s.empty())
            s = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPESection() {
        return stringify::E_SgAsmPESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1779
namespace stringify {
    const char* E_SgAsmGenericSectionList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSectionList_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSectionList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSectionList(i);
        if (s.empty())
            s = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSectionList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSectionList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSectionList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSectionList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSectionList() {
        return stringify::E_SgAsmGenericSectionList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1782
namespace stringify {
    const char* E_SgAsmCoffSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbol(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbol() {
        return stringify::E_SgAsmCoffSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1785
namespace stringify {
    const char* E_SgAsmElfSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbol(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbol() {
        return stringify::E_SgAsmElfSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1788
namespace stringify {
    const char* E_SgAsmGenericSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSymbol(i);
        if (s.empty())
            s = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSymbol() {
        return stringify::E_SgAsmGenericSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1791
namespace stringify {
    const char* E_SgAsmLEEntryPoint(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryPoint_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryPoint(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryPoint(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryPoint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryPoint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryPoint(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryPoint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryPoint() {
        return stringify::E_SgAsmLEEntryPoint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1794
namespace stringify {
    const char* E_SgAsmPEExportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportDirectory_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportDirectory() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportDirectory() {
        return stringify::E_SgAsmPEExportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1797
namespace stringify {
    const char* E_SgAsmPEExportEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntry_name";
            case 1L: return "SgAsmPEExportEntry_forwarder";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntry(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntry() {
        return stringify::E_SgAsmPEExportEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1800
namespace stringify {
    const char* E_SgAsmPEExportEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntryList_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntryList(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntryList() {
        return stringify::E_SgAsmPEExportEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1803
namespace stringify {
    const char* E_SgAsmPEImportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectory_dllName";
            case 1L: return "SgAsmPEImportDirectory_imports";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectory() {
        return stringify::E_SgAsmPEImportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1806
namespace stringify {
    const char* E_SgAsmPEImportDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectoryList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectoryList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectoryList() {
        return stringify::E_SgAsmPEImportDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1809
namespace stringify {
    const char* E_SgAsmPEImportItem(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItem_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItem(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItem(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItem() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItem(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItem() {
        return stringify::E_SgAsmPEImportItem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1812
namespace stringify {
    const char* E_SgAsmPEImportItemList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItemList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItemList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItemList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItemList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItemList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItemList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItemList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItemList() {
        return stringify::E_SgAsmPEImportItemList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1815
namespace stringify {
    const char* E_SgAsmPERVASizePairList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPERVASizePairList_pairs";
            default: return "";
        }
    }

    std::string E_SgAsmPERVASizePairList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPERVASizePairList(i);
        if (s.empty())
            s = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPERVASizePairList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPERVASizePairList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPERVASizePairList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPERVASizePairList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPERVASizePairList() {
        return stringify::E_SgAsmPERVASizePairList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1818
namespace stringify {
    const char* E_SgAsmBinaryAdd(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAdd_lhs";
            case 1L: return "SgAsmBinaryAdd_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAdd(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAdd(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAdd() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAdd(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAdd(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAdd::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAdd() {
        return stringify::E_SgAsmBinaryAdd();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1821
namespace stringify {
    const char* E_SgAsmBinaryAsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAsr_lhs";
            case 1L: return "SgAsmBinaryAsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAsr() {
        return stringify::E_SgAsmBinaryAsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1824
namespace stringify {
    const char* E_SgAsmBinaryConcat(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryConcat_lhs";
            case 1L: return "SgAsmBinaryConcat_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryConcat(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryConcat(i);
        if (s.empty())
            s = "(E_SgAsmBinaryConcat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryConcat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryConcat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryConcat(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryConcat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryConcat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryConcat() {
        return stringify::E_SgAsmBinaryConcat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1827
namespace stringify {
    const char* E_SgAsmBinaryDivide(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryDivide_lhs";
            case 1L: return "SgAsmBinaryDivide_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryDivide(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryDivide(i);
        if (s.empty())
            s = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryDivide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryDivide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryDivide(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryDivide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryDivide() {
        return stringify::E_SgAsmBinaryDivide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1830
namespace stringify {
    const char* E_SgAsmBinaryLsl(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsl_lhs";
            case 1L: return "SgAsmBinaryLsl_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsl(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsl(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsl(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsl() {
        return stringify::E_SgAsmBinaryLsl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1833
namespace stringify {
    const char* E_SgAsmBinaryLsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsr_lhs";
            case 1L: return "SgAsmBinaryLsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsr() {
        return stringify::E_SgAsmBinaryLsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1836
namespace stringify {
    const char* E_SgAsmBinaryMod(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMod_lhs";
            case 1L: return "SgAsmBinaryMod_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMod(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMod(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMod() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMod(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMod(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMod::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMod() {
        return stringify::E_SgAsmBinaryMod();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1839
namespace stringify {
    const char* E_SgAsmBinaryMsl(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMsl_lhs";
            case 1L: return "SgAsmBinaryMsl_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMsl(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMsl(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMsl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMsl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMsl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMsl(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMsl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMsl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMsl() {
        return stringify::E_SgAsmBinaryMsl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1842
namespace stringify {
    const char* E_SgAsmBinaryMultiply(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMultiply_lhs";
            case 1L: return "SgAsmBinaryMultiply_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMultiply(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMultiply(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMultiply() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMultiply(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMultiply(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMultiply::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMultiply() {
        return stringify::E_SgAsmBinaryMultiply();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1845
namespace stringify {
    const char* E_SgAsmBinaryPostupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryPostupdate_lhs";
            case 1L: return "SgAsmBinaryPostupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryPostupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryPostupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryPostupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryPostupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryPostupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryPostupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryPostupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryPostupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryPostupdate() {
        return stringify::E_SgAsmBinaryPostupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1848
namespace stringify {
    const char* E_SgAsmBinaryPreupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryPreupdate_lhs";
            case 1L: return "SgAsmBinaryPreupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryPreupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryPreupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryPreupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryPreupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryPreupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryPreupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryPreupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryPreupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryPreupdate() {
        return stringify::E_SgAsmBinaryPreupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1851
namespace stringify {
    const char* E_SgAsmBinaryRor(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryRor_lhs";
            case 1L: return "SgAsmBinaryRor_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryRor(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryRor(i);
        if (s.empty())
            s = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryRor() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryRor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryRor(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryRor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryRor() {
        return stringify::E_SgAsmBinaryRor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1854
namespace stringify {
    const char* E_SgAsmBinarySubtract(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinarySubtract_lhs";
            case 1L: return "SgAsmBinarySubtract_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinarySubtract(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinarySubtract(i);
        if (s.empty())
            s = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinarySubtract() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinarySubtract(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinarySubtract(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinarySubtract::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinarySubtract() {
        return stringify::E_SgAsmBinarySubtract();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1857
namespace stringify {
    const char* E_SgAsmBinaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryExpression_lhs";
            case 1L: return "SgAsmBinaryExpression_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryExpression() {
        return stringify::E_SgAsmBinaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1860
namespace stringify {
    const char* E_SgAsmCommonSubExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCommonSubExpression_subexpression";
            default: return "";
        }
    }

    std::string E_SgAsmCommonSubExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCommonSubExpression(i);
        if (s.empty())
            s = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCommonSubExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCommonSubExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCommonSubExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCommonSubExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCommonSubExpression() {
        return stringify::E_SgAsmCommonSubExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1863
namespace stringify {
    const char* E_SgAsmExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgAsmExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmExprListExp(i);
        if (s.empty())
            s = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmExprListExp() {
        return stringify::E_SgAsmExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1866
namespace stringify {
    const char* E_SgAsmMemoryReferenceExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMemoryReferenceExpression_address";
            case 1L: return "SgAsmMemoryReferenceExpression_segment";
            default: return "";
        }
    }

    std::string E_SgAsmMemoryReferenceExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMemoryReferenceExpression(i);
        if (s.empty())
            s = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMemoryReferenceExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMemoryReferenceExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMemoryReferenceExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMemoryReferenceExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMemoryReferenceExpression() {
        return stringify::E_SgAsmMemoryReferenceExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1869
namespace stringify {
    const char* E_SgAsmRegisterNames(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRegisterNames_registers";
            default: return "";
        }
    }

    std::string E_SgAsmRegisterNames(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRegisterNames(i);
        if (s.empty())
            s = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRegisterNames() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRegisterNames(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRegisterNames(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRegisterNames::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRegisterNames() {
        return stringify::E_SgAsmRegisterNames();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1872
namespace stringify {
    const char* E_SgAsmRiscOperation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRiscOperation_operands";
            default: return "";
        }
    }

    std::string E_SgAsmRiscOperation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRiscOperation(i);
        if (s.empty())
            s = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRiscOperation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRiscOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRiscOperation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRiscOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRiscOperation() {
        return stringify::E_SgAsmRiscOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1875
namespace stringify {
    const char* E_SgAsmUnaryMinus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryMinus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryMinus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryMinus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryMinus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryMinus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryMinus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryMinus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryMinus() {
        return stringify::E_SgAsmUnaryMinus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1878
namespace stringify {
    const char* E_SgAsmUnaryPlus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryPlus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryPlus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryPlus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryPlus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryPlus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryPlus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryPlus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryPlus() {
        return stringify::E_SgAsmUnaryPlus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1881
namespace stringify {
    const char* E_SgAsmUnaryRrx(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryRrx_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryRrx(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryRrx(i);
        if (s.empty())
            s = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryRrx() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryRrx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryRrx(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryRrx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryRrx() {
        return stringify::E_SgAsmUnaryRrx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1884
namespace stringify {
    const char* E_SgAsmUnarySignedExtend(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnarySignedExtend_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnarySignedExtend(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnarySignedExtend(i);
        if (s.empty())
            s = "(E_SgAsmUnarySignedExtend)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnarySignedExtend() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnarySignedExtend(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnarySignedExtend(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnarySignedExtend)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnarySignedExtend::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnarySignedExtend() {
        return stringify::E_SgAsmUnarySignedExtend();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1887
namespace stringify {
    const char* E_SgAsmUnaryTruncate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryTruncate_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryTruncate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryTruncate(i);
        if (s.empty())
            s = "(E_SgAsmUnaryTruncate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryTruncate() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryTruncate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryTruncate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryTruncate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryTruncate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryTruncate() {
        return stringify::E_SgAsmUnaryTruncate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1890
namespace stringify {
    const char* E_SgAsmUnaryUnsignedExtend(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryUnsignedExtend_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryUnsignedExtend(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryUnsignedExtend(i);
        if (s.empty())
            s = "(E_SgAsmUnaryUnsignedExtend)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryUnsignedExtend() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryUnsignedExtend(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryUnsignedExtend(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryUnsignedExtend)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryUnsignedExtend::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryUnsignedExtend() {
        return stringify::E_SgAsmUnaryUnsignedExtend();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1893
namespace stringify {
    const char* E_SgAsmUnaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryExpression_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryExpression() {
        return stringify::E_SgAsmUnaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1896
namespace stringify {
    const char* E_SgAsmFloatValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFloatValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmFloatValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFloatValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFloatValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFloatValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFloatValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFloatValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFloatValueExpression() {
        return stringify::E_SgAsmFloatValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1899
namespace stringify {
    const char* E_SgAsmIntegerValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmIntegerValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmIntegerValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmIntegerValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmIntegerValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmIntegerValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmIntegerValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmIntegerValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmIntegerValueExpression() {
        return stringify::E_SgAsmIntegerValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1902
namespace stringify {
    const char* E_SgAsmConstantExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmConstantExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmConstantExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmConstantExpression(i);
        if (s.empty())
            s = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmConstantExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmConstantExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmConstantExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmConstantExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmConstantExpression() {
        return stringify::E_SgAsmConstantExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1905
namespace stringify {
    const char* E_SgAsmValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmValueExpression() {
        return stringify::E_SgAsmValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1908
namespace stringify {
    const char* E_SgAsmGenericFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFileList_files";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFileList(i);
        if (s.empty())
            s = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFileList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFileList() {
        return stringify::E_SgAsmGenericFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1911
namespace stringify {
    const char* E_SgAsmInterpretation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretation_globalBlock";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretation(i);
        if (s.empty())
            s = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretation() {
        return stringify::E_SgAsmInterpretation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1914
namespace stringify {
    const char* E_SgAsmInterpretationList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretationList_interpretations";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretationList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretationList(i);
        if (s.empty())
            s = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretationList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretationList() {
        return stringify::E_SgAsmInterpretationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1917
namespace stringify {
    const char* E_SgAsmJvmField(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmField_attribute_table";
            default: return "";
        }
    }

    std::string E_SgAsmJvmField(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmField(i);
        if (s.empty())
            s = "(E_SgAsmJvmField)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmField() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmField(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmField(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmField)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmField::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmField() {
        return stringify::E_SgAsmJvmField();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1920
namespace stringify {
    const char* E_SgAsmJvmMethod(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmMethod_attribute_table";
            default: return "";
        }
    }

    std::string E_SgAsmJvmMethod(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmMethod(i);
        if (s.empty())
            s = "(E_SgAsmJvmMethod)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmMethod() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmMethod(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmMethod(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmMethod)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmMethod::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmMethod() {
        return stringify::E_SgAsmJvmMethod();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1923
namespace stringify {
    const char* E_SgAsmOperandList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOperandList_operands";
            default: return "";
        }
    }

    std::string E_SgAsmOperandList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOperandList(i);
        if (s.empty())
            s = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOperandList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOperandList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOperandList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOperandList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOperandList() {
        return stringify::E_SgAsmOperandList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1926
namespace stringify {
    const char* E_SgAsmBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBlock_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBlock(i);
        if (s.empty())
            s = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBlock() {
        return stringify::E_SgAsmBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1929
namespace stringify {
    const char* E_SgAsmAarch32Instruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmAarch32Instruction_operandList";
            case 1L: return "SgAsmAarch32Instruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmAarch32Instruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmAarch32Instruction(i);
        if (s.empty())
            s = "(E_SgAsmAarch32Instruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmAarch32Instruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmAarch32Instruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmAarch32Instruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmAarch32Instruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmAarch32Instruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmAarch32Instruction() {
        return stringify::E_SgAsmAarch32Instruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1932
namespace stringify {
    const char* E_SgAsmAarch64Instruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmAarch64Instruction_operandList";
            case 1L: return "SgAsmAarch64Instruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmAarch64Instruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmAarch64Instruction(i);
        if (s.empty())
            s = "(E_SgAsmAarch64Instruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmAarch64Instruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmAarch64Instruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmAarch64Instruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmAarch64Instruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmAarch64Instruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmAarch64Instruction() {
        return stringify::E_SgAsmAarch64Instruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1935
namespace stringify {
    const char* E_SgAsmCilInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilInstruction_operandList";
            case 1L: return "SgAsmCilInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmCilInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilInstruction(i);
        if (s.empty())
            s = "(E_SgAsmCilInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilInstruction() {
        return stringify::E_SgAsmCilInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1938
namespace stringify {
    const char* E_SgAsmJvmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmInstruction_operandList";
            case 1L: return "SgAsmJvmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmJvmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmJvmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmInstruction() {
        return stringify::E_SgAsmJvmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1941
namespace stringify {
    const char* E_SgAsmM68kInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmM68kInstruction_operandList";
            case 1L: return "SgAsmM68kInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmM68kInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmM68kInstruction(i);
        if (s.empty())
            s = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmM68kInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmM68kInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmM68kInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmM68kInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmM68kInstruction() {
        return stringify::E_SgAsmM68kInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1944
namespace stringify {
    const char* E_SgAsmMipsInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMipsInstruction_operandList";
            case 1L: return "SgAsmMipsInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmMipsInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMipsInstruction(i);
        if (s.empty())
            s = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMipsInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMipsInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMipsInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMipsInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMipsInstruction() {
        return stringify::E_SgAsmMipsInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1947
namespace stringify {
    const char* E_SgAsmNullInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNullInstruction_operandList";
            case 1L: return "SgAsmNullInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmNullInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNullInstruction(i);
        if (s.empty())
            s = "(E_SgAsmNullInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNullInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNullInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNullInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNullInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNullInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNullInstruction() {
        return stringify::E_SgAsmNullInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1950
namespace stringify {
    const char* E_SgAsmPowerpcInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPowerpcInstruction_operandList";
            case 1L: return "SgAsmPowerpcInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmPowerpcInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPowerpcInstruction(i);
        if (s.empty())
            s = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPowerpcInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPowerpcInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPowerpcInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPowerpcInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPowerpcInstruction() {
        return stringify::E_SgAsmPowerpcInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1953
namespace stringify {
    const char* E_SgAsmUserInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUserInstruction_operandList";
            case 1L: return "SgAsmUserInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmUserInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUserInstruction(i);
        if (s.empty())
            s = "(E_SgAsmUserInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUserInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUserInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUserInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUserInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUserInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUserInstruction() {
        return stringify::E_SgAsmUserInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1956
namespace stringify {
    const char* E_SgAsmX86Instruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmX86Instruction_operandList";
            case 1L: return "SgAsmX86Instruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmX86Instruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmX86Instruction(i);
        if (s.empty())
            s = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmX86Instruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmX86Instruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmX86Instruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmX86Instruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmX86Instruction() {
        return stringify::E_SgAsmX86Instruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1959
namespace stringify {
    const char* E_SgAsmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInstruction_operandList";
            case 1L: return "SgAsmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInstruction() {
        return stringify::E_SgAsmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1962
namespace stringify {
    const char* E_SgAsmFunction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFunction_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmFunction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFunction(i);
        if (s.empty())
            s = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFunction() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFunction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFunction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFunction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFunction() {
        return stringify::E_SgAsmFunction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarTreeTraversalAccessEnums.h line 1965
namespace stringify {
    const char* E_SgAsmPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPointerType_subtype";
            default: return "";
        }
    }

    std::string E_SgAsmPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPointerType(i);
        if (s.empty())
            s = "(E_SgAsmPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPointerType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPointerType() {
        return stringify::E_SgAsmPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 4334
namespace stringify { namespace SgConstVolatileModifier {
    const char* cv_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_const";
            case 3L: return "e_volatile";
            case 4L: return "e_const_volatile";
            case 5L: return "e_java_transient";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string cv_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = cv_modifier_enum(i);
        if (s.empty())
            s = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cv_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgConstVolatileModifier_cv_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgConstVolatileModifier::cv_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgConstVolatileModifier_cv_modifier_enum() {
        return stringify::SgConstVolatileModifier::cv_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 5455
namespace stringify { namespace SgStorageModifier {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_extern";
            case 3L: return "e_static";
            case 4L: return "e_auto";
            case 5L: return "e_unspecified";
            case 6L: return "e_register";
            case 7L: return "e_mutable";
            case 8L: return "e_typedef";
            case 9L: return "e_asm";
            case 10L: return "e_local";
            case 11L: return "e_common";
            case 12L: return "e_associated";
            case 13L: return "e_intrinsic";
            case 14L: return "e_pointer_based";
            case 15L: return "e_contiguous";
            case 16L: return "e_cuda_global";
            case 17L: return "e_cuda_constant";
            case 18L: return "e_cuda_shared";
            case 19L: return "e_cuda_dynamic_shared";
            case 20L: return "e_cuda_device_memory";
            case 21L: return "e_cuda_managed";
            case 22L: return "e_cuda_pinned";
            case 23L: return "e_cuda_texture";
            case 24L: return "e_packing_none";
            case 25L: return "e_packing_mixed";
            case 26L: return "e_packing_dense";
            case 27L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStorageModifier_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStorageModifier::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStorageModifier::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStorageModifier_storage_modifier_enum() {
        return stringify::SgStorageModifier::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 6753
namespace stringify { namespace SgAccessModifier {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 5L: return "e_undefined";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAccessModifier_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAccessModifier::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAccessModifier::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAccessModifier_access_modifier_enum() {
        return stringify::SgAccessModifier::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 7851
namespace stringify { namespace SgFunctionModifier {
    const char* function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_inline";
            case 3L: return "e_virtual";
            case 4L: return "e_pure_virtual";
            case 5L: return "e_explicit";
            case 7L: return "e_pure";
            case 8L: return "e_elemental";
            case 9L: return "e_recursive";
            case 10L: return "e_gnu_attribute__constructor__";
            case 11L: return "e_gnu_attribute__destructor__";
            case 12L: return "e_gnu_attribute__pure__";
            case 13L: return "e_gnu_attribute__weak__";
            case 14L: return "e_gnu_attribute__unused__";
            case 15L: return "e_gnu_attribute__used__";
            case 16L: return "e_gnu_attribute__deprecated__";
            case 17L: return "e_gnu_attribute__malloc__";
            case 18L: return "e_gnu_attribute__naked__";
            case 19L: return "e_gnu_attribute__no_instrument_function__";
            case 20L: return "e_gnu_attribute__no_check_memory_usage__";
            case 21L: return "e_gnu_attribute__noinline__";
            case 22L: return "e_gnu_attribute__always_inline__";
            case 23L: return "e_gnu_attribute__nothrow__";
            case 24L: return "e_gnu_attribute__weakref__";
            case 25L: return "e_cuda_device";
            case 26L: return "e_cuda_kernel";
            case 27L: return "e_cuda_host";
            case 28L: return "e_cuda_global_function";
            case 29L: return "e_cuda_grid_global";
            case 30L: return "e_opencl_kernel";
            case 31L: return "e_opencl_vec_type_hint";
            case 32L: return "e_opencl_work_group_size_hint";
            case 33L: return "e_opencl_work_group_size_req";
            case 34L: return "e_java_native";
            case 35L: return "e_java_synchronized";
            case 36L: return "e_java_strictfp";
            case 37L: return "e_java_initializer";
            case 38L: return "e_marked_default";
            case 39L: return "e_marked_delete";
            case 40L: return "e_reentrant";
            case 41L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = function_modifier_enum(i);
        if (s.empty())
            s = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFunctionModifier_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFunctionModifier::function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFunctionModifier::function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFunctionModifier_function_modifier_enum() {
        return stringify::SgFunctionModifier::function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 9468
namespace stringify { namespace SgUPC_AccessModifier {
    const char* upc_access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_upc_strict";
            case 3L: return "e_upc_relaxed";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string upc_access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = upc_access_modifier_enum(i);
        if (s.empty())
            s = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& upc_access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUPC_AccessModifier_upc_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUPC_AccessModifier::upc_access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUPC_AccessModifier_upc_access_modifier_enum() {
        return stringify::SgUPC_AccessModifier::upc_access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 10595
namespace stringify { namespace SgSpecialFunctionModifier {
    const char* special_function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_constructor";
            case 3L: return "e_destructor";
            case 4L: return "e_conversion";
            case 5L: return "e_operator";
            case 6L: return "e_uld_operator";
            case 7L: return "e_lambda_entry_point";
            case 8L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string special_function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = special_function_modifier_enum(i);
        if (s.empty())
            s = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& special_function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgSpecialFunctionModifier_special_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgSpecialFunctionModifier::special_function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgSpecialFunctionModifier_special_function_modifier_enum() {
        return stringify::SgSpecialFunctionModifier::special_function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 11732
namespace stringify { namespace SgElaboratedTypeModifier {
    const char* elaborated_type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_class";
            case 3L: return "e_struct";
            case 4L: return "e_union";
            case 5L: return "e_enum";
            case 6L: return "e_typename";
            case 7L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string elaborated_type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = elaborated_type_modifier_enum(i);
        if (s.empty())
            s = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& elaborated_type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum() {
        return stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 12838
namespace stringify { namespace SgLinkageModifier {
    const char* linkage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_linkage";
            case 3L: return "e_Cpp_linkage";
            case 4L: return "e_fortran_linkage";
            case 5L: return "e_fortran90_linkage";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string linkage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = linkage_modifier_enum(i);
        if (s.empty())
            s = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& linkage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLinkageModifier_linkage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLinkageModifier::linkage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLinkageModifier_linkage_modifier_enum() {
        return stringify::SgLinkageModifier::linkage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 13928
namespace stringify { namespace SgBaseClassModifier {
    const char* baseclass_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_virtual";
            case 3L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string baseclass_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = baseclass_modifier_enum(i);
        if (s.empty())
            s = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& baseclass_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgBaseClassModifier_baseclass_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgBaseClassModifier::baseclass_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgBaseClassModifier_baseclass_modifier_enum() {
        return stringify::SgBaseClassModifier::baseclass_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 15019
namespace stringify { namespace SgStructureModifier {
    const char* jovial_structure_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_table_structure_parallel";
            case 3L: return "e_table_structure_tight";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string jovial_structure_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = jovial_structure_modifier_enum(i);
        if (s.empty())
            s = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& jovial_structure_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStructureModifier_jovial_structure_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStructureModifier::jovial_structure_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStructureModifier::jovial_structure_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStructureModifier_jovial_structure_modifier_enum() {
        return stringify::SgStructureModifier::jovial_structure_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 16120
namespace stringify { namespace SgTypeModifier {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_restrict";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent_in";
            case 9L: return "e_intent_out";
            case 10L: return "e_intent_inout";
            case 11L: return "e_intrinsic";
            case 12L: return "e_optional";
            case 13L: return "e_extends";
            case 14L: return "e_abstract";
            case 15L: return "e_save";
            case 16L: return "e_target";
            case 17L: return "e_value";
            case 18L: return "e_gnu_attribute__unused__";
            case 19L: return "e_gnu_attribute__packed__";
            case 20L: return "e_gnu_attribute__deprecated__";
            case 21L: return "e_gnu_attribute__transparent_union__";
            case 22L: return "e_gnu_attribute__noreturn__";
            case 23L: return "e_gnu_attribute__const__";
            case 24L: return "e_gnu_attribute__cdecl__";
            case 25L: return "e_gnu_attribute__stdcall__";
            case 26L: return "e_gnu_attribute__warn_unused_result__";
            case 27L: return "e_gnu_attribute__nonnull__";
            case 28L: return "e_gnu_attribute__sentinel__";
            case 29L: return "e_address_space__";
            case 30L: return "e_ocl_global__";
            case 31L: return "e_ocl_local__";
            case 32L: return "e_ocl_constant__";
            case 33L: return "e_vector_type__";
            case 34L: return "e_gnu_attribute__device__";
            case 35L: return "e_round";
            case 36L: return "e_truncate";
            case 37L: return "e_truncate_towards_zero";
            case 38L: return "e_aliased";
            case 39L: return "e_notnull";
            case 40L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_type_modifier_enum() {
        return stringify::SgTypeModifier::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 16214
namespace stringify { namespace SgTypeModifier {
    const char* gnu_extension_machine_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_extension_machine_mode_unknown";
            case 1L: return "e_gnu_extension_machine_mode_unspecified";
            case 2L: return "e_gnu_extension_machine_mode_BImode";
            case 3L: return "e_gnu_extension_machine_mode_QImode";
            case 4L: return "e_gnu_extension_machine_mode_HImode";
            case 5L: return "e_gnu_extension_machine_mode_PSImode";
            case 6L: return "e_gnu_extension_machine_mode_SImode";
            case 7L: return "e_gnu_extension_machine_mode_PDImode";
            case 8L: return "e_gnu_extension_machine_mode_DImode";
            case 9L: return "e_gnu_extension_machine_mode_TImode";
            case 10L: return "e_gnu_extension_machine_mode_OImode";
            case 11L: return "e_gnu_extension_machine_mode_QFmode";
            case 12L: return "e_gnu_extension_machine_mode_HFmode";
            case 13L: return "e_gnu_extension_machine_mode_TQFmode";
            case 14L: return "e_gnu_extension_machine_mode_SFmode";
            case 15L: return "e_gnu_extension_machine_mode_DFmode";
            case 16L: return "e_gnu_extension_machine_mode_XFmode";
            case 17L: return "e_gnu_extension_machine_mode_SDmode";
            case 18L: return "e_gnu_extension_machine_mode_DDmode";
            case 19L: return "e_gnu_extension_machine_mode_TDmode";
            case 20L: return "e_gnu_extension_machine_mode_TFmode";
            case 21L: return "e_gnu_extension_machine_mode_QQmode";
            case 22L: return "e_gnu_extension_machine_mode_HQmode";
            case 23L: return "e_gnu_extension_machine_mode_SQmode";
            case 24L: return "e_gnu_extension_machine_mode_DQmode";
            case 25L: return "e_gnu_extension_machine_mode_TQmode";
            case 26L: return "e_gnu_extension_machine_mode_UQQmode";
            case 27L: return "e_gnu_extension_machine_mode_UHQmode";
            case 28L: return "e_gnu_extension_machine_mode_USQmode";
            case 29L: return "e_gnu_extension_machine_mode_UDQmode";
            case 30L: return "e_gnu_extension_machine_mode_UTQmode";
            case 31L: return "e_gnu_extension_machine_mode_HAmode";
            case 32L: return "e_gnu_extension_machine_mode_SAmode";
            case 33L: return "e_gnu_extension_machine_mode_DAmode";
            case 34L: return "e_gnu_extension_machine_mode_TAmode";
            case 35L: return "e_gnu_extension_machine_mode_UHAmode";
            case 36L: return "e_gnu_extension_machine_mode_USAmode";
            case 37L: return "e_gnu_extension_machine_mode_UDAmode";
            case 38L: return "e_gnu_extension_machine_mode_UTAmode";
            case 39L: return "e_gnu_extension_machine_mode_CCmode";
            case 40L: return "e_gnu_extension_machine_mode_BLKmode";
            case 41L: return "e_gnu_extension_machine_mode_VOIDmode";
            case 42L: return "e_gnu_extension_machine_mode_QCmode";
            case 43L: return "e_gnu_extension_machine_mode_HCmode";
            case 44L: return "e_gnu_extension_machine_mode_SCmode";
            case 45L: return "e_gnu_extension_machine_mode_DCmode";
            case 46L: return "e_gnu_extension_machine_mode_XCmode";
            case 47L: return "e_gnu_extension_machine_mode_TCmode";
            case 48L: return "e_gnu_extension_machine_mode_CQImode";
            case 49L: return "e_gnu_extension_machine_mode_CHImode";
            case 50L: return "e_gnu_extension_machine_mode_CSImode";
            case 51L: return "e_gnu_extension_machine_mode_CDImode";
            case 52L: return "e_gnu_extension_machine_mode_CTImode";
            case 53L: return "e_gnu_extension_machine_mode_COImode";
            case 54L: return "e_last_machine_mode";
            default: return "";
        }
    }

    std::string gnu_extension_machine_mode_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_machine_mode_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_machine_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_gnu_extension_machine_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::gnu_extension_machine_mode_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_gnu_extension_machine_mode_enum() {
        return stringify::SgTypeModifier::gnu_extension_machine_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 17997
namespace stringify { namespace SgDeclarationModifier {
    const char* declaration_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_friend";
            case 3L: return "e_typedef";
            case 4L: return "e_export";
            case 5L: return "e_throw";
            case 6L: return "e_bind";
            case 7L: return "e_final";
            case 8L: return "e_override";
            case 9L: return "e_java_abstract";
            case 10L: return "e_jovial_def";
            case 11L: return "e_jovial_ref";
            case 12L: return "e_jovial_static";
            case 13L: return "e_ms_declspec_align";
            case 14L: return "e_ms_declspec_allocate";
            case 15L: return "e_ms_declspec_appdomain";
            case 16L: return "e_ms_declspec_code_seg";
            case 17L: return "e_ms_declspec_deprecated";
            case 18L: return "e_ms_declspec_dllimport";
            case 19L: return "e_ms_declspec_dllexport";
            case 20L: return "e_ms_declspec_jitintrinsic";
            case 21L: return "e_ms_declspec_naked";
            case 22L: return "e_ms_declspec_noalias";
            case 23L: return "e_ms_declspec_noinline";
            case 24L: return "e_ms_declspec_noreturn";
            case 25L: return "e_ms_declspec_nothrow";
            case 26L: return "e_ms_declspec_novtable";
            case 27L: return "e_ms_declspec_process";
            case 28L: return "e_ms_declspec_property";
            case 29L: return "e_ms_declspec_restrict";
            case 30L: return "e_ms_declspec_safebuffers";
            case 31L: return "e_ms_declspec_selectany";
            case 32L: return "e_ms_declspec_thread";
            case 33L: return "e_ms_declspec_uuid";
            case 34L: return "e_ada_abstract";
            case 35L: return "e_ada_limited";
            case 36L: return "e_ada_tagged";
            case 37L: return "e_ada_separate";
            case 38L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string declaration_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = declaration_modifier_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& declaration_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L
        };
        static const std::vector<int64_t> retval(values, values + 39);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_declaration_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::declaration_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_declaration_modifier_enum() {
        return stringify::SgDeclarationModifier::declaration_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 18055
namespace stringify { namespace SgDeclarationModifier {
    const char* gnu_declaration_visability_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_visibility";
            case 1L: return "e_error_visibility";
            case 2L: return "e_unspecified_visibility";
            case 3L: return "e_hidden_visibility";
            case 4L: return "e_protected_visibility";
            case 5L: return "e_internal_visibility";
            case 6L: return "e_default_visibility";
            case 7L: return "e_last_visibility_attribute";
            default: return "";
        }
    }

    std::string gnu_declaration_visability_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_declaration_visability_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_declaration_visability_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_gnu_declaration_visability_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::gnu_declaration_visability_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_gnu_declaration_visability_enum() {
        return stringify::SgDeclarationModifier::gnu_declaration_visability_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 19670
namespace stringify { namespace SgOpenclAccessModeModifier {
    const char* access_mode_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_read_only";
            case 3L: return "e_write_only";
            case 4L: return "e_read_write";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_mode_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_mode_modifier_enum(i);
        if (s.empty())
            s = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_mode_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOpenclAccessModeModifier_access_mode_modifier_enum() {
        return stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 28967
namespace stringify { namespace Sg_File_Info {
    const char* classifier(int64_t i) {
        switch (i) {
            case 1L: return "e_transformation";
            case 2L: return "e_compiler_generated";
            case 4L: return "e_output_in_code_generation";
            case 8L: return "e_shared";
            case 16L: return "e_frontend_specific";
            case 32L: return "e_source_position_unavailable_in_frontend";
            case 64L: return "e_comment_or_directive";
            case 128L: return "e_token";
            case 256L: return "e_default_argument";
            case 512L: return "e_implicit_cast";
            default: return "";
        }
    }

    std::string classifier(int64_t i, const std::string &strip) {
        std::string s = classifier(i);
        if (s.empty())
            s = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& classifier() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_classifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::classifier(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::classifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_classifier() {
        return stringify::Sg_File_Info::classifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 29211
namespace stringify { namespace Sg_File_Info {
    const char* p_fileflags(int64_t i) {
        switch (i) {
            case -6L: return "BAD_FILE_ID";
            case -5L: return "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID";
            case -4L: return "COMPILER_GENERATED_FILE_ID";
            case -3L: return "TRANSFORMATION_FILE_ID";
            case -2L: return "NULL_FILE_ID";
            case -1L: return "COPY_FILE_ID";
            default: return "";
        }
    }

    std::string p_fileflags(int64_t i, const std::string &strip) {
        std::string s = p_fileflags(i);
        if (s.empty())
            s = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& p_fileflags() {
        static const int64_t values[] = {
            -6L,
            -5L,
            -4L,
            -3L,
            -2L,
            -1L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_p_fileflags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::p_fileflags(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::p_fileflags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_p_fileflags() {
        return stringify::Sg_File_Info::p_fileflags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 30645
namespace stringify { namespace SgFile {
    const char* outputFormatOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_output_format";
            case 1L: return "e_fixed_form_output_format";
            case 2L: return "e_free_form_output_format";
            default: return "";
        }
    }

    std::string outputFormatOption_enum(int64_t i, const std::string &strip) {
        std::string s = outputFormatOption_enum(i);
        if (s.empty())
            s = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& outputFormatOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_outputFormatOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::outputFormatOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::outputFormatOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_outputFormatOption_enum() {
        return stringify::SgFile::outputFormatOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 30659
namespace stringify { namespace SgFile {
    const char* languageOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_language";
            case 1L: return "e_default_language";
            case 2L: return "e_C_language";
            case 3L: return "e_Cxx_language";
            case 4L: return "e_Binary_language";
            case 5L: return "e_Fortran_language";
            case 6L: return "e_Java_language";
            case 7L: return "e_Jvm_language";
            case 8L: return "e_Promela_language";
            case 9L: return "e_PHP_language";
            case 10L: return "e_Python_language";
            case 11L: return "e_Csharp_language";
            case 12L: return "e_Ada_language";
            case 13L: return "e_Jovial_language";
            case 14L: return "e_last_language";
            default: return "";
        }
    }

    std::string languageOption_enum(int64_t i, const std::string &strip) {
        std::string s = languageOption_enum(i);
        if (s.empty())
            s = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_languageOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::languageOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::languageOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_languageOption_enum() {
        return stringify::SgFile::languageOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 30679
namespace stringify { namespace SgFile {
    const char* standard_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default_standard";
            case 1L: return "e_c89_standard";
            case 2L: return "e_c90_standard";
            case 3L: return "e_c99_standard";
            case 4L: return "e_c11_standard";
            case 5L: return "e_c14_standard";
            case 6L: return "e_c18_standard";
            case 7L: return "e_upc_standard";
            case 8L: return "e_cxx98_standard";
            case 9L: return "e_cxx03_standard";
            case 10L: return "e_cxx11_standard";
            case 11L: return "e_cxx14_standard";
            case 12L: return "e_cxx17_standard";
            case 13L: return "e_cxx20_standard";
            case 14L: return "e_upcxx_standard";
            case 15L: return "e_f77_standard";
            case 16L: return "e_f90_standard";
            case 17L: return "e_f95_standard";
            case 18L: return "e_f03_standard";
            case 19L: return "e_f08_standard";
            case 20L: return "e_f18_standard";
            default: return "";
        }
    }

    std::string standard_enum(int64_t i, const std::string &strip) {
        std::string s = standard_enum(i);
        if (s.empty())
            s = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& standard_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_standard_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::standard_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::standard_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_standard_enum() {
        return stringify::SgFile::standard_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 39203
namespace stringify { namespace SgProject {
    const char* template_instantiation_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_none";
            case 3L: return "e_used";
            case 4L: return "e_all";
            case 5L: return "e_local";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string template_instantiation_enum(int64_t i, const std::string &strip) {
        std::string s = template_instantiation_enum(i);
        if (s.empty())
            s = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_instantiation_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProject_template_instantiation_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProject::template_instantiation_enum(i);
        if (retval.empty()) {
            retval = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProject::template_instantiation_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProject_template_instantiation_enum() {
        return stringify::SgProject::template_instantiation_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 43367
namespace stringify { namespace SgUnparse_Info {
    const char* unparse_type_num(int64_t i) {
        switch (i) {
            case 0L: return "b_enum_defaultValue";
            case 1L: return "b_isPointerToSomething";
            case 2L: return "b_isReferenceToSomething";
            case 3L: return "b_inVarDecl";
            case 4L: return "b_inArgList";
            case 5L: return "b_SkipSemiColon";
            case 6L: return "b_inEnumDecl";
            case 7L: return "b_inTemplateList";
            case 8L: return "b_SkipBaseType";
            case 9L: return "b_inAggregateInitializer";
            case 10L: return "b_isWithType";
            case 11L: return "b_inConditional";
            case 12L: return "b_SkipDefinition";
            case 13L: return "b_SkipClassSpecifier";
            case 14L: return "b_inEmbeddedDecl";
            case 15L: return "b_SkipGlobal";
            case 16L: return "b_SkipAtomic";
            case 17L: return "b_PrintName";
            case 18L: return "b_CheckAccess";
            case 19L: return "b_SkipFunctionQualifier";
            case 20L: return "b_isArrayType";
            case 21L: return "b_inRhsExpr";
            case 22L: return "b_SkipParen";
            case 23L: return "b_isTypeSecondPart";
            case 24L: return "b_isTypeFirstPart";
            case 25L: return "b_SkipInitializer";
            case 26L: return "b_SkipComments";
            case 27L: return "b_SkipCPPDirectives";
            case 28L: return "b_SkipEnumDefinition";
            case 29L: return "b_SkipFunctionDefinition";
            case 30L: return "b_SkipClassDefinition";
            case 31L: return "b_AddSemiColonAfterDeclaration";
            case 32L: return "b_SkipWhitespaces";
            case 33L: return "b_SkipBasicBlock";
            case 34L: return "b_outputClassTemplateName";
            case 35L: return "b_outputCompilerGeneratedStatements";
            case 36L: return "b_SkipConstantFoldedExpressions";
            case 37L: return "b_forceQualifiedNames";
            case 38L: return "b_SkipQualifiedNames";
            case 39L: return "b_skipCheckAccess";
            case 40L: return "b_requiresGlobalNameQualification";
            case 41L: return "b_useTypeAttributes";
            case 42L: return "b_SkipFormatting";
            case 43L: return "b_outputFortranModFile";
            case 44L: return "b_supressStrippedTypeName";
            case 45L: return "b_prefixOperator";
            case 46L: return "b_supressArrayBound";
            case 47L: return "b_supressImplicitThisOperator";
            case 48L: return "b_unparsedPartiallyUsingTokenStream";
            case 49L: return "b_skipCompilerGeneratedSubExpressions";
            case 50L: return "b_parentStatementListBeingUnparsedUsingPartialTokenSequence";
            case 51L: return "b_cxx11_initialization_list";
            case 52L: return "b_inTypedefDecl";
            case 53L: return "b_SkipNameQualification";
            case 54L: return "b_useAlternativeDefiningDeclaration";
            case 55L: return "b_usedInUparseToStringFunction";
            case 56L: return "UNPARSE_TYPE_LAST";
            default: return "";
        }
    }

    std::string unparse_type_num(int64_t i, const std::string &strip) {
        std::string s = unparse_type_num(i);
        if (s.empty())
            s = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparse_type_num() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L
        };
        static const std::vector<int64_t> retval(values, values + 57);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_unparse_type_num(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::unparse_type_num(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::unparse_type_num::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_unparse_type_num() {
        return stringify::SgUnparse_Info::unparse_type_num();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 43544
namespace stringify { namespace SgUnparse_Info {
    const char* access_attr_enum(int64_t i) {
        switch (i) {
            case 1L: return "a_unset_access";
            case 2L: return "a_private_access";
            case 3L: return "a_protected_access";
            case 4L: return "a_public_access";
            case 5L: return "a_default_access";
            default: return "";
        }
    }

    std::string access_attr_enum(int64_t i, const std::string &strip) {
        std::string s = access_attr_enum(i);
        if (s.empty())
            s = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_attr_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_access_attr_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::access_attr_enum(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::access_attr_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_access_attr_enum() {
        return stringify::SgUnparse_Info::access_attr_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 50125
namespace stringify { namespace SgTemplateParameter {
    const char* template_parameter_enum(int64_t i) {
        switch (i) {
            case 0L: return "parameter_undefined";
            case 1L: return "type_parameter";
            case 2L: return "nontype_parameter";
            case 3L: return "template_parameter";
            default: return "";
        }
    }

    std::string template_parameter_enum(int64_t i, const std::string &strip) {
        std::string s = template_parameter_enum(i);
        if (s.empty())
            s = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_parameter_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateParameter_template_parameter_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateParameter::template_parameter_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateParameter::template_parameter_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateParameter_template_parameter_enum() {
        return stringify::SgTemplateParameter::template_parameter_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 51302
namespace stringify { namespace SgTemplateArgument {
    const char* template_argument_enum(int64_t i) {
        switch (i) {
            case 0L: return "argument_undefined";
            case 1L: return "type_argument";
            case 2L: return "nontype_argument";
            case 3L: return "template_template_argument";
            case 4L: return "start_of_pack_expansion_argument";
            default: return "";
        }
    }

    std::string template_argument_enum(int64_t i, const std::string &strip) {
        std::string s = template_argument_enum(i);
        if (s.empty())
            s = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_argument_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateArgument_template_argument_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateArgument::template_argument_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateArgument::template_argument_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateArgument_template_argument_enum() {
        return stringify::SgTemplateArgument::template_argument_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 60042
namespace stringify { namespace SgGraph {
    const char* GraphEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "e_type_error";
            case 1L: return "none";
            case 2L: return "cfg";
            case 3L: return "usage";
            case 4L: return "e_last_type";
            default: return "";
        }
    }

    std::string GraphEdgeType(int64_t i, const std::string &strip) {
        std::string s = GraphEdgeType(i);
        if (s.empty())
            s = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphEdgeType(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphEdgeType() {
        return stringify::SgGraph::GraphEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 60056
namespace stringify { namespace SgGraph {
    const char* GraphProperties(int64_t i) {
        switch (i) {
            case 0L: return "e_property_error";
            case 1L: return "name";
            case 2L: return "type";
            case 3L: return "nodest_jmp";
            case 4L: return "itself_call";
            case 5L: return "nodest_call";
            case 6L: return "interrupt";
            case 7L: return "eval";
            case 8L: return "regs";
            case 9L: return "done";
            case 10L: return "dfa_standard";
            case 11L: return "dfa_resolved_func";
            case 12L: return "dfa_unresolved_func";
            case 13L: return "dfa_variable";
            case 14L: return "dfa_conditional_def";
            case 15L: return "edgeLabel";
            case 16L: return "visitedCounter";
            case 17L: return "variable";
            case 18L: return "dfa_bufferoverflow";
            case 19L: return "e_last_property";
            default: return "";
        }
    }

    std::string GraphProperties(int64_t i, const std::string &strip) {
        std::string s = GraphProperties(i);
        if (s.empty())
            s = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphProperties() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphProperties(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphProperties(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphProperties::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphProperties() {
        return stringify::SgGraph::GraphProperties();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 81305
namespace stringify { namespace SgDataStatementValue {
    const char* data_statement_value_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_explicit_list";
            case 3L: return "e_implicit_list";
            case 4L: return "e_implied_do";
            case 5L: return "e_last_initializer_form";
            default: return "";
        }
    }

    std::string data_statement_value_enum(int64_t i, const std::string &strip) {
        std::string s = data_statement_value_enum(i);
        if (s.empty())
            s = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& data_statement_value_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDataStatementValue_data_statement_value_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDataStatementValue::data_statement_value_enum(i);
        if (retval.empty()) {
            retval = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDataStatementValue_data_statement_value_enum() {
        return stringify::SgDataStatementValue::data_statement_value_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 85501
namespace stringify { namespace SgType {
    const char* fortran_attribute_specifiers_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_specifier";
            case 1L: return "e_public_access";
            case 2L: return "e_private_access";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent";
            case 9L: return "e_optional";
            case 10L: return "e_parameter";
            case 11L: return "e_pointer";
            case 12L: return "e_protected";
            case 13L: return "e_save";
            case 14L: return "e_target";
            case 15L: return "e_value";
            case 16L: return "e_volatile";
            case 17L: return "e_last_attribute_specifier";
            default: return "";
        }
    }

    std::string fortran_attribute_specifiers_enum(int64_t i, const std::string &strip) {
        std::string s = fortran_attribute_specifiers_enum(i);
        if (s.empty())
            s = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fortran_attribute_specifiers_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_fortran_attribute_specifiers_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::fortran_attribute_specifiers_enum(i);
        if (retval.empty()) {
            retval = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_fortran_attribute_specifiers_enum() {
        return stringify::SgType::fortran_attribute_specifiers_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 120888
namespace stringify { namespace SgJovialTableType {
    const char* StructureSpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_parallel";
            case 2L: return "e_tight";
            default: return "";
        }
    }

    std::string StructureSpecifier(int64_t i, const std::string &strip) {
        std::string s = StructureSpecifier(i);
        if (s.empty())
            s = "(SgJovialTableType::StructureSpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StructureSpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialTableTypeStructureSpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialTableType::StructureSpecifier(i);
        if (retval.empty()) {
            retval = "(SgJovialTableType::StructureSpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialTableType::StructureSpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialTableTypeStructureSpecifier() {
        return stringify::SgJovialTableType::StructureSpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 136099
namespace stringify { namespace SgMemberFunctionType {
    const char* mfunc_specifier_enum(int64_t i) {
        switch (i) {
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            case 8L: return "e_ref_qualifier_lvalue";
            case 16L: return "e_ref_qualifier_rvalue";
            default: return "";
        }
    }

    std::string mfunc_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = mfunc_specifier_enum(i);
        if (s.empty())
            s = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& mfunc_specifier_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgMemberFunctionType_mfunc_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgMemberFunctionType::mfunc_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgMemberFunctionType_mfunc_specifier_enum() {
        return stringify::SgMemberFunctionType::mfunc_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 172316
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            case 126L: return "FORTRAN_END_PROGRAM";
            case 127L: return "FORTRAN_END_FUNCTION";
            case 128L: return "FORTRAN_END_SUBROUTINE";
            case 129L: return "FORTRAN_END_MODULE";
            case 130L: return "FORTRAN_END_BLOCK_DATA";
            case 131L: return "FORTRAN_SUBMODULE";
            case 132L: return "FORTRAN_END_SUBMODULE";
            case 133L: return "FORTRAN_DOUBLE_COMPLEX";
            case 134L: return "FORTRAN_TYPE";
            case 135L: return "FORTRAN_ABSTRACT_INTERFACE";
            case 136L: return "FORTRAN_ERROR_STOP";
            case 137L: return "FORTRAN_CONTIGUOUS";
            case 138L: return "FORTRAN_PUBLIC";
            case 139L: return "FORTRAN_ELEMENTAL";
            case 140L: return "FORTRAN_IMPURE";
            case 141L: return "FORTRAN_PURE";
            case 142L: return "FORTRAN_RECURSIVE";
            case 143L: return "FORTRAN_INTENT_IN";
            case 144L: return "FORTRAN_INTENT_OUT";
            case 145L: return "FORTRAN_INTENT_INOUT";
            case 146L: return "FORTRAN_ASSIGNMENT";
            case 147L: return "FORTRAN_OPERATOR";
            case 148L: return "FORTRAN_READ_FORMATTED";
            case 149L: return "FORTRAN_READ_UNFORMATTED";
            case 150L: return "FORTRAN_WRITE_FORMATTED";
            case 151L: return "FORTRAN_WRITE_UNFORMATTED";
            case 152L: return "FORTRAN_UNKNOWN";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L
        };
        static const std::vector<int64_t> retval(values, values + 153);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Keywords() {
        return stringify::SgToken::ROSE_Fortran_Keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 172483
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_keywords() {
        return stringify::SgToken::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 172552
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Operators() {
        return stringify::SgToken::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 172579
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_Operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_Operators() {
        return stringify::SgToken::ROSE_C_CXX_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 172659
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Additional_Info() {
        return stringify::SgToken::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 176045
namespace stringify { namespace SgInitializedName {
    const char* preinitialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_preinitialization";
            case 1L: return "e_virtual_base_class";
            case 2L: return "e_nonvirtual_base_class";
            case 3L: return "e_data_member";
            case 4L: return "e_delegation_constructor";
            case 5L: return "e_last_preinitialization";
            default: return "";
        }
    }

    std::string preinitialization_enum(int64_t i, const std::string &strip) {
        std::string s = preinitialization_enum(i);
        if (s.empty())
            s = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& preinitialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_preinitialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::preinitialization_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::preinitialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_preinitialization_enum() {
        return stringify::SgInitializedName::preinitialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 176060
namespace stringify { namespace SgInitializedName {
    const char* asm_register_name_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid_register";
            case 1L: return "e_memory_register";
            case 2L: return "e_register_a";
            case 3L: return "e_register_b";
            case 4L: return "e_register_c";
            case 5L: return "e_register_d";
            case 6L: return "e_register_si";
            case 7L: return "e_register_di";
            case 8L: return "e_register_bp";
            case 9L: return "e_register_sp";
            case 10L: return "e_register_r8";
            case 11L: return "e_register_r9";
            case 12L: return "e_register_r10";
            case 13L: return "e_register_r11";
            case 14L: return "e_register_r12";
            case 15L: return "e_register_r13";
            case 16L: return "e_register_r14";
            case 17L: return "e_register_r15";
            case 18L: return "e_register_st0";
            case 19L: return "e_register_st1";
            case 20L: return "e_register_st2";
            case 21L: return "e_register_st3";
            case 22L: return "e_register_st4";
            case 23L: return "e_register_st5";
            case 24L: return "e_register_st6";
            case 25L: return "e_register_st7";
            case 26L: return "e_register_mm0";
            case 27L: return "e_register_mm1";
            case 28L: return "e_register_mm2";
            case 29L: return "e_register_mm3";
            case 30L: return "e_register_mm4";
            case 31L: return "e_register_mm5";
            case 32L: return "e_register_mm6";
            case 33L: return "e_register_mm7";
            case 34L: return "e_register_f0";
            case 35L: return "e_register_f1";
            case 36L: return "e_register_f2";
            case 37L: return "e_register_f3";
            case 38L: return "e_register_f4";
            case 39L: return "e_register_f5";
            case 40L: return "e_register_f6";
            case 41L: return "e_register_f7";
            case 42L: return "e_register_f8";
            case 43L: return "e_register_f9";
            case 44L: return "e_register_f10";
            case 45L: return "e_register_f11";
            case 46L: return "e_register_f12";
            case 47L: return "e_register_f13";
            case 48L: return "e_register_f14";
            case 49L: return "e_register_f15";
            case 50L: return "e_register_flags";
            case 51L: return "e_register_fpsr";
            case 52L: return "e_register_dirflag";
            case 53L: return "e_register_f16";
            case 54L: return "e_register_f17";
            case 55L: return "e_register_f18";
            case 56L: return "e_register_f19";
            case 57L: return "e_register_f20";
            case 58L: return "e_unrecognized_register";
            case 59L: return "e_last_register";
            default: return "";
        }
    }

    std::string asm_register_name_enum(int64_t i, const std::string &strip) {
        std::string s = asm_register_name_enum(i);
        if (s.empty())
            s = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_register_name_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_asm_register_name_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::asm_register_name_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::asm_register_name_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_asm_register_name_enum() {
        return stringify::SgInitializedName::asm_register_name_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 176127
namespace stringify { namespace SgInitializedName {
    const char* gnu_variable_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute__weak__";
            case 1L: return "e_gnu_attribute__unused__";
            case 2L: return "e_gnu_attribute__used__";
            case 3L: return "e_gnu_attribute__deprecated__";
            case 4L: return "e_gnu_attribute__nocommon__";
            case 5L: return "e_gnu_attribute__transparent_union__";
            case 6L: return "e_gnu_attribute__weakref__";
            case 7L: return "e_gnu_attribute__packed__";
            case 8L: return "e_gnu_attribute__noreturn__";
            case 9L: return "e_gnu_attribute__noreorder__";
            case 10L: return "e_ms_declspec_parameter_appdomain";
            case 11L: return "e_ms_declspec_parameter_deprecated";
            case 12L: return "e_ms_declspec_parameter_dllimport";
            case 13L: return "e_ms_declspec_parameter_dllexport";
            case 14L: return "e_ms_declspec_parameter_novtable";
            case 15L: return "e_ms_declspec_parameter_process";
            case 16L: return "e_ms_declspec_parameter_property";
            case 17L: return "e_ms_declspec_parameter_restrict";
            case 18L: return "e_ms_declspec_parameter_selectany";
            case 19L: return "e_ms_declspec_parameter_thread";
            case 20L: return "e_ms_declspec_parameter_uuid";
            case 21L: return "e_last_gnu_variable_attribute";
            default: return "";
        }
    }

    std::string gnu_variable_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_variable_attribute_enum(i);
        if (s.empty())
            s = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_variable_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_gnu_variable_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::gnu_variable_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_gnu_variable_attribute_enum() {
        return stringify::SgInitializedName::gnu_variable_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 176162
namespace stringify { namespace SgInitializedName {
    const char* excess_specifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_excess_specifier_none";
            case 1L: return "e_excess_specifier_positionals";
            case 2L: return "e_excess_specifier_keywords";
            case 3L: return "e_excess_specifier_last";
            default: return "";
        }
    }

    std::string excess_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = excess_specifier_enum(i);
        if (s.empty())
            s = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& excess_specifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_excess_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::excess_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::excess_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_excess_specifier_enum() {
        return stringify::SgInitializedName::excess_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182619
namespace stringify { namespace SgOmpClause {
    const char* omp_default_option_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_default_unknown";
            case 1L: return "e_omp_default_none";
            case 2L: return "e_omp_default_shared";
            case 3L: return "e_omp_default_private";
            case 4L: return "e_omp_default_firstprivate";
            case 5L: return "e_omp_default_last";
            default: return "";
        }
    }

    std::string omp_default_option_enum(int64_t i, const std::string &strip) {
        std::string s = omp_default_option_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_default_option_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_default_option_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_default_option_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_default_option_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_default_option_enum() {
        return stringify::SgOmpClause::omp_default_option_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182631
namespace stringify { namespace SgOmpClause {
    const char* omp_schedule_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_schedule_unknown";
            case 1L: return "e_omp_schedule_static";
            case 2L: return "e_omp_schedule_dynamic";
            case 3L: return "e_omp_schedule_guided";
            case 4L: return "e_omp_schedule_auto";
            case 5L: return "e_omp_schedule_runtime";
            case 6L: return "e_omp_schedule_last";
            default: return "";
        }
    }

    std::string omp_schedule_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_schedule_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_schedule_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_schedule_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_schedule_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_schedule_kind_enum() {
        return stringify::SgOmpClause::omp_schedule_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182641
namespace stringify { namespace SgOmpClause {
    const char* omp_reduction_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_reduction_unknown";
            case 1L: return "e_omp_reduction_plus";
            case 2L: return "e_omp_reduction_mul";
            case 3L: return "e_omp_reduction_minus";
            case 4L: return "e_omp_reduction_bitand";
            case 5L: return "e_omp_reduction_bitor";
            case 6L: return "e_omp_reduction_bitxor";
            case 7L: return "e_omp_reduction_logand";
            case 8L: return "e_omp_reduction_logor";
            case 9L: return "e_omp_reduction_and";
            case 10L: return "e_omp_reduction_or";
            case 11L: return "e_omp_reduction_eqv";
            case 12L: return "e_omp_reduction_neqv";
            case 13L: return "e_omp_reduction_max";
            case 14L: return "e_omp_reduction_min";
            case 15L: return "e_omp_reduction_iand";
            case 16L: return "e_omp_reduction_ior";
            case 17L: return "e_omp_reduction_ieor";
            case 18L: return "e_omp_reduction_last";
            default: return "";
        }
    }

    std::string omp_reduction_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_reduction_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_reduction_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_reduction_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_reduction_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_reduction_operator_enum() {
        return stringify::SgOmpClause::omp_reduction_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182669
namespace stringify { namespace SgOmpClause {
    const char* omp_dependence_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depend_unknown";
            case 1L: return "e_omp_depend_in";
            case 2L: return "e_omp_depend_out";
            case 3L: return "e_omp_depend_inout";
            case 4L: return "e_omp_depend_last";
            default: return "";
        }
    }

    std::string omp_dependence_type_enum(int64_t i, const std::string &strip) {
        std::string s = omp_dependence_type_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_dependence_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_dependence_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_dependence_type_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_dependence_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_dependence_type_enum() {
        return stringify::SgOmpClause::omp_dependence_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182679
namespace stringify { namespace SgOmpClause {
    const char* omp_map_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_unknown";
            case 1L: return "e_omp_map_alloc";
            case 2L: return "e_omp_map_to";
            case 3L: return "e_omp_map_from";
            case 4L: return "e_omp_map_tofrom";
            case 5L: return "e_omp_map_last";
            default: return "";
        }
    }

    std::string omp_map_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_operator_enum() {
        return stringify::SgOmpClause::omp_map_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182690
namespace stringify { namespace SgOmpClause {
    const char* omp_map_dist_data_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_dist_data_unknown";
            case 1L: return "e_omp_map_dist_data_duplicate";
            case 2L: return "e_omp_map_dist_data_block";
            case 3L: return "e_omp_map_dist_data_cyclic";
            case 4L: return "e_omp_map_dist_data_last";
            default: return "";
        }
    }

    std::string omp_map_dist_data_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_dist_data_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_dist_data_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_dist_data_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_dist_data_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_dist_data_enum() {
        return stringify::SgOmpClause::omp_map_dist_data_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182700
namespace stringify { namespace SgOmpClause {
    const char* omp_proc_bind_policy_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_proc_bind_policy_unknown";
            case 1L: return "e_omp_proc_bind_policy_master";
            case 2L: return "e_omp_proc_bind_policy_close";
            case 3L: return "e_omp_proc_bind_policy_spread";
            case 4L: return "e_omp_proc_bind_policy_last";
            default: return "";
        }
    }

    std::string omp_proc_bind_policy_enum(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_policy_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_policy_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_proc_bind_policy_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_proc_bind_policy_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_proc_bind_policy_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_proc_bind_policy_enum() {
        return stringify::SgOmpClause::omp_proc_bind_policy_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 182709
namespace stringify { namespace SgOmpClause {
    const char* omp_atomic_clause_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_atomic_clause_unknown";
            case 1L: return "e_omp_atomic_clause_read";
            case 2L: return "e_omp_atomic_clause_write";
            case 3L: return "e_omp_atomic_clause_update";
            case 4L: return "e_omp_atomic_clause_capture";
            default: return "";
        }
    }

    std::string omp_atomic_clause_enum(int64_t i, const std::string &strip) {
        std::string s = omp_atomic_clause_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_atomic_clause_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_atomic_clause_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_atomic_clause_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_atomic_clause_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_atomic_clause_enum() {
        return stringify::SgOmpClause::omp_atomic_clause_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 249027
namespace stringify { namespace SgForAllStatement {
    const char* forall_statement_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_forall_statement";
            case 2L: return "e_do_concurrent_statement";
            case 3L: return "e_last_forall_statement_kind";
            default: return "";
        }
    }

    std::string forall_statement_kind_enum(int64_t i, const std::string &strip) {
        std::string s = forall_statement_kind_enum(i);
        if (s.empty())
            s = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& forall_statement_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgForAllStatement_forall_statement_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgForAllStatement::forall_statement_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgForAllStatement::forall_statement_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgForAllStatement_forall_statement_kind_enum() {
        return stringify::SgForAllStatement::forall_statement_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 258807
namespace stringify { namespace SgJovialForThenStatement {
    const char* loop_statement_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_for_only_stmt";
            case 2L: return "e_for_while_stmt";
            case 3L: return "e_for_while_by_stmt";
            case 4L: return "e_for_while_then_stmt";
            case 5L: return "e_for_then_while_stmt";
            case 6L: return "e_for_by_while_stmt";
            default: return "";
        }
    }

    std::string loop_statement_type_enum(int64_t i, const std::string &strip) {
        std::string s = loop_statement_type_enum(i);
        if (s.empty())
            s = "(SgJovialForThenStatement::loop_statement_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& loop_statement_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialForThenStatement_loop_statement_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialForThenStatement::loop_statement_type_enum(i);
        if (retval.empty()) {
            retval = "(SgJovialForThenStatement::loop_statement_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialForThenStatement::loop_statement_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialForThenStatement_loop_statement_type_enum() {
        return stringify::SgJovialForThenStatement::loop_statement_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 269284
namespace stringify { namespace SgDeclarationStatement {
    const char* template_specialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_no_specialization";
            case 2L: return "e_partial_specialization";
            case 3L: return "e_specialization";
            case 4L: return "e_template_specialization_last";
            default: return "";
        }
    }

    std::string template_specialization_enum(int64_t i, const std::string &strip) {
        std::string s = template_specialization_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_specialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_template_specialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::template_specialization_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_template_specialization_enum() {
        return stringify::SgDeclarationStatement::template_specialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 269299
namespace stringify { namespace SgDeclarationStatement {
    const char* gnu_extension_visability_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_visability_unknown";
            case 1L: return "e_gnu_attribute_visability_unspecified";
            case 2L: return "e_gnu_attribute_visability_hidden";
            case 3L: return "e_gnu_attribute_visability_protected";
            case 4L: return "e_gnu_attribute_visability_internal";
            case 5L: return "e_last_gnu_visability_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_visability_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_visability_attribute_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_visability_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum() {
        return stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 272335
namespace stringify { namespace SgVariableDeclaration {
    const char* gnu_extension_declaration_attributes_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_unknown";
            case 1L: return "e_gnu_attribute_unspecified";
            case 2L: return "e_gnu_attribute__weak__";
            case 3L: return "e_gnu_attribute__unused__";
            case 4L: return "e_gnu_attribute__deprecated__";
            case 5L: return "e_gnu_attribute__nocommon__";
            case 6L: return "e_gnu_attribute__transparent_union__";
            case 7L: return "e_last_gnu_declaration_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_declaration_attributes_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_declaration_attributes_enum(i);
        if (s.empty())
            s = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_declaration_attributes_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum(i);
        if (retval.empty()) {
            retval = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum() {
        return stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 282656
namespace stringify { namespace SgAttributeSpecificationStatement {
    const char* attribute_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_spec";
            case 1L: return "e_accessStatement_private";
            case 2L: return "e_accessStatement_public";
            case 3L: return "e_allocatableStatement";
            case 4L: return "e_asynchronousStatement";
            case 5L: return "e_bindStatement";
            case 6L: return "e_dataStatement";
            case 7L: return "e_dimensionStatement";
            case 8L: return "e_externalStatement";
            case 9L: return "e_intentStatement";
            case 10L: return "e_intrinsicStatement";
            case 11L: return "e_optionalStatement";
            case 12L: return "e_parameterStatement";
            case 13L: return "e_pointerStatement";
            case 14L: return "e_protectedStatement";
            case 15L: return "e_saveStatement";
            case 16L: return "e_targetStatement";
            case 17L: return "e_valueStatement";
            case 18L: return "e_volatileStatement";
            case 19L: return "e_last_attribute_spec";
            default: return "";
        }
    }

    std::string attribute_spec_enum(int64_t i, const std::string &strip) {
        std::string s = attribute_spec_enum(i);
        if (s.empty())
            s = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attribute_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAttributeSpecificationStatement_attribute_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAttributeSpecificationStatement::attribute_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAttributeSpecificationStatement_attribute_spec_enum() {
        return stringify::SgAttributeSpecificationStatement::attribute_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 284868
namespace stringify { namespace SgTemplateDeclaration {
    const char* template_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_template_none";
            case 1L: return "e_template_class";
            case 2L: return "e_template_m_class";
            case 3L: return "e_template_function";
            case 4L: return "e_template_m_function";
            case 5L: return "e_template_m_data";
            default: return "";
        }
    }

    std::string template_type_enum(int64_t i, const std::string &strip) {
        std::string s = template_type_enum(i);
        if (s.empty())
            s = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateDeclaration_template_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateDeclaration::template_type_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateDeclaration::template_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateDeclaration_template_type_enum() {
        return stringify::SgTemplateDeclaration::template_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 291304
namespace stringify { namespace SgInterfaceStatement {
    const char* generic_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_interface_type";
            case 1L: return "e_default_interface_type";
            case 2L: return "e_unnamed_interface_type";
            case 3L: return "e_named_interface_type";
            case 4L: return "e_operator_interface_type";
            case 5L: return "e_assignment_interface_type";
            case 6L: return "e_last_interface_type";
            default: return "";
        }
    }

    std::string generic_spec_enum(int64_t i, const std::string &strip) {
        std::string s = generic_spec_enum(i);
        if (s.empty())
            s = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& generic_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInterfaceStatement_generic_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInterfaceStatement::generic_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInterfaceStatement_generic_spec_enum() {
        return stringify::SgInterfaceStatement::generic_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 302321
namespace stringify { namespace SgClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            case 4L: return "e_fortran_module";
            case 5L: return "e_java_interface";
            case 6L: return "e_java_enum";
            case 7L: return "e_java_parameter";
            case 8L: return "e_jovial_block";
            case 9L: return "e_jovial_table";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgClassDeclaration_class_types() {
        return stringify::SgClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 303806
namespace stringify { namespace SgTemplateClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateClassDeclaration_class_types() {
        return stringify::SgTemplateClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 309090
namespace stringify { namespace SgJovialTableStatement {
    const char* WordsPerEntry(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_fixed_length";
            case 2L: return "e_variable_length";
            default: return "";
        }
    }

    std::string WordsPerEntry(int64_t i, const std::string &strip) {
        std::string s = WordsPerEntry(i);
        if (s.empty())
            s = "(SgJovialTableStatement::WordsPerEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WordsPerEntry() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialTableStatementWordsPerEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialTableStatement::WordsPerEntry(i);
        if (retval.empty()) {
            retval = "(SgJovialTableStatement::WordsPerEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialTableStatement::WordsPerEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialTableStatementWordsPerEntry() {
        return stringify::SgJovialTableStatement::WordsPerEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 310182
namespace stringify { namespace SgImplicitStatement {
    const char* implicit_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_implicit_spec";
            case 1L: return "e_has_implicit_spec_list";
            case 2L: return "e_none";
            case 3L: return "e_none_external";
            case 4L: return "e_none_type";
            case 5L: return "e_none_external_and_type";
            default: return "";
        }
    }

    std::string implicit_spec_enum(int64_t i, const std::string &strip) {
        std::string s = implicit_spec_enum(i);
        if (s.empty())
            s = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& implicit_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImplicitStatement_implicit_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImplicitStatement::implicit_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImplicitStatement::implicit_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImplicitStatement_implicit_spec_enum() {
        return stringify::SgImplicitStatement::implicit_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 322998
namespace stringify { namespace SgProcedureHeaderStatement {
    const char* subprogram_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_kind";
            case 1L: return "e_function_subprogram_kind";
            case 2L: return "e_subroutine_subprogram_kind";
            case 3L: return "e_block_data_subprogram_kind";
            case 4L: return "e_last_subprogram_kind";
            default: return "";
        }
    }

    std::string subprogram_kind_enum(int64_t i, const std::string &strip) {
        std::string s = subprogram_kind_enum(i);
        if (s.empty())
            s = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& subprogram_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcedureHeaderStatement_subprogram_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcedureHeaderStatement::subprogram_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcedureHeaderStatement_subprogram_kind_enum() {
        return stringify::SgProcedureHeaderStatement::subprogram_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 354977
namespace stringify { namespace SgJovialDirectiveStatement {
    const char* directive_types(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_compool";
            case 2L: return "e_copy";
            case 3L: return "e_skip";
            case 4L: return "e_begin";
            case 5L: return "e_end";
            case 6L: return "e_linkage";
            case 7L: return "e_trace";
            case 8L: return "e_interference";
            case 9L: return "e_reducible";
            case 10L: return "e_nolist";
            case 11L: return "e_list";
            case 12L: return "e_eject";
            case 13L: return "e_listinv";
            case 14L: return "e_listexp";
            case 15L: return "e_base";
            case 16L: return "e_isbase";
            case 17L: return "e_drop";
            case 18L: return "e_left_right";
            case 19L: return "e_rearrange";
            case 20L: return "e_initialize";
            case 21L: return "e_order";
            case 22L: return "e_align";
            case 23L: return "e_always";
            default: return "";
        }
    }

    std::string directive_types(int64_t i, const std::string &strip) {
        std::string s = directive_types(i);
        if (s.empty())
            s = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& directive_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialDirectiveStatement_directive_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialDirectiveStatement::directive_types(i);
        if (retval.empty()) {
            retval = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialDirectiveStatement::directive_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialDirectiveStatement_directive_types() {
        return stringify::SgJovialDirectiveStatement::directive_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 357085
namespace stringify { namespace SgJovialLabelDeclaration {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_jovial_label_decl";
            case 2L: return "e_jovial_label_def";
            case 3L: return "e_jovial_label_ref";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgJovialLabelDeclaration::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialLabelDeclaration_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialLabelDeclaration::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgJovialLabelDeclaration::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialLabelDeclaration::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialLabelDeclaration_label_type_enum() {
        return stringify::SgJovialLabelDeclaration::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 383540
namespace stringify { namespace SgLabelStatement {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_jovial_label_decl";
            case 2L: return "e_jovial_label_def";
            case 3L: return "e_jovial_label_ref";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelStatement::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelStatement_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelStatement::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelStatement::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelStatement::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelStatement_label_type_enum() {
        return stringify::SgLabelStatement::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 397372
namespace stringify { namespace SgProcessControlStatement {
    const char* control_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_abort";
            case 2L: return "e_stop";
            case 3L: return "e_error_stop";
            case 4L: return "e_exit";
            case 5L: return "e_fail_image";
            case 6L: return "e_pause";
            case 7L: return "e_requeue";
            case 8L: return "e_requeue_with_abort";
            default: return "";
        }
    }

    std::string control_enum(int64_t i, const std::string &strip) {
        std::string s = control_enum(i);
        if (s.empty())
            s = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& control_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcessControlStatement_control_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcessControlStatement::control_enum(i);
        if (retval.empty()) {
            retval = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcessControlStatement::control_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcessControlStatement_control_enum() {
        return stringify::SgProcessControlStatement::control_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 398457
namespace stringify { namespace SgIOStatement {
    const char* io_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_read";
            case 2L: return "e_print";
            case 3L: return "e_write";
            case 4L: return "e_open";
            case 5L: return "e_close";
            case 6L: return "e_inquire";
            case 7L: return "e_backspace";
            case 8L: return "e_endfile";
            case 9L: return "e_rewind";
            case 10L: return "e_last_io_statment_kind";
            default: return "";
        }
    }

    std::string io_statement_enum(int64_t i, const std::string &strip) {
        std::string s = io_statement_enum(i);
        if (s.empty())
            s = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& io_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgIOStatement_io_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgIOStatement::io_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgIOStatement::io_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgIOStatement_io_statement_enum() {
        return stringify::SgIOStatement::io_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 461040
namespace stringify { namespace SgImageControlStatement {
    const char* image_control_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_sync_all";
            case 2L: return "e_sync_images";
            case 3L: return "e_sync_memory";
            case 4L: return "e_sync_team";
            case 5L: return "e_change_team";
            case 6L: return "e_critical";
            case 7L: return "e_event_post";
            case 8L: return "e_event_wait";
            case 9L: return "e_form_team";
            case 10L: return "e_lock";
            case 11L: return "e_unlock";
            case 12L: return "e_last_image_control_statement";
            default: return "";
        }
    }

    std::string image_control_statement_enum(int64_t i, const std::string &strip) {
        std::string s = image_control_statement_enum(i);
        if (s.empty())
            s = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& image_control_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImageControlStatement_image_control_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImageControlStatement::image_control_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImageControlStatement::image_control_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImageControlStatement_image_control_statement_enum() {
        return stringify::SgImageControlStatement::image_control_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 471410
namespace stringify { namespace SgAdaSelectStmt {
    const char* select_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_selective_accept";
            case 2L: return "e_asynchronous";
            case 3L: return "e_conditional_entry";
            case 4L: return "e_timed_entry";
            default: return "";
        }
    }

    std::string select_type_enum(int64_t i, const std::string &strip) {
        std::string s = select_type_enum(i);
        if (s.empty())
            s = "(SgAdaSelectStmt::select_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& select_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAdaSelectStmt_select_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAdaSelectStmt::select_type_enum(i);
        if (retval.empty()) {
            retval = "(SgAdaSelectStmt::select_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAdaSelectStmt::select_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAdaSelectStmt_select_type_enum() {
        return stringify::SgAdaSelectStmt::select_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 477890
namespace stringify { namespace SgUnaryOp {
    const char* Sgop_mode(int64_t i) {
        switch (i) {
            case 0L: return "prefix";
            case 1L: return "postfix";
            default: return "";
        }
    }

    std::string Sgop_mode(int64_t i, const std::string &strip) {
        std::string s = Sgop_mode(i);
        if (s.empty())
            s = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Sgop_mode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnaryOpSgop_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnaryOp::Sgop_mode(i);
        if (retval.empty()) {
            retval = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnaryOp::Sgop_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnaryOpSgop_mode() {
        return stringify::SgUnaryOp::Sgop_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 487986
namespace stringify { namespace SgCastExp {
    const char* cast_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_style_cast";
            case 3L: return "e_const_cast";
            case 4L: return "e_static_cast";
            case 5L: return "e_dynamic_cast";
            case 6L: return "e_reinterpret_cast";
            case 8L: return "e_safe_cast";
            case 9L: return "e_ada_type_qualification";
            case 10L: return "e_last_cast";
            default: return "";
        }
    }

    std::string cast_type_enum(int64_t i, const std::string &strip) {
        std::string s = cast_type_enum(i);
        if (s.empty())
            s = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cast_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgCastExp_cast_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgCastExp::cast_type_enum(i);
        if (retval.empty()) {
            retval = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgCastExp::cast_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgCastExp_cast_type_enum() {
        return stringify::SgCastExp::cast_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 489251
namespace stringify { namespace SgThrowOp {
    const char* e_throw_kind(int64_t i) {
        switch (i) {
            case 0L: return "unknown_throw";
            case 1L: return "throw_expression";
            case 2L: return "rethrow";
            default: return "";
        }
    }

    std::string e_throw_kind(int64_t i, const std::string &strip) {
        std::string s = e_throw_kind(i);
        if (s.empty())
            s = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& e_throw_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgThrowOp_e_throw_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgThrowOp::e_throw_kind(i);
        if (retval.empty()) {
            retval = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgThrowOp::e_throw_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgThrowOp_e_throw_kind() {
        return stringify::SgThrowOp::e_throw_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 636479
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_input";
            case 2L: return "e_output";
            case 3L: return "e_modify";
            case 4L: return "e_earlyclobber";
            case 8L: return "e_commutative";
            case 16L: return "e_ignore_next";
            case 32L: return "e_ignore_till_comma";
            case 64L: return "e_poor_choice";
            case 128L: return "e_bad_choice";
            default: return "";
        }
    }

    std::string asm_operand_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_modifier_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_modifier_enum() {
        return stringify::SgAsmOp::asm_operand_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 636498
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_constraint_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid";
            case 1L: return "e_end_of_constraint";
            case 2L: return "e_mod_earlyclobber";
            case 3L: return "e_mod_commutative_ops";
            case 4L: return "e_mod_ignore";
            case 5L: return "e_mod_ignore_char";
            case 6L: return "e_mod_disparage_slightly";
            case 7L: return "e_mod_disparage_severely";
            case 8L: return "e_any";
            case 9L: return "e_general";
            case 10L: return "e_match_0";
            case 11L: return "e_match_1";
            case 12L: return "e_match_2";
            case 13L: return "e_match_3";
            case 14L: return "e_match_4";
            case 15L: return "e_match_5";
            case 16L: return "e_match_6";
            case 17L: return "e_match_7";
            case 18L: return "e_match_8";
            case 19L: return "e_match_9";
            case 20L: return "e_reg_integer";
            case 21L: return "e_reg_float";
            case 22L: return "e_mem_any";
            case 23L: return "e_mem_load";
            case 24L: return "e_mem_offset";
            case 25L: return "e_mem_nonoffset";
            case 26L: return "e_mem_autoinc";
            case 27L: return "e_mem_autodec";
            case 28L: return "e_imm_int";
            case 29L: return "e_imm_number";
            case 30L: return "e_imm_symbol";
            case 31L: return "e_imm_float";
            case 32L: return "e_reg_a";
            case 33L: return "e_reg_b";
            case 34L: return "e_reg_c";
            case 35L: return "e_reg_d";
            case 36L: return "e_reg_si";
            case 37L: return "e_reg_di";
            case 38L: return "e_reg_legacy";
            case 39L: return "e_reg_q";
            case 40L: return "e_reg_Q";
            case 41L: return "e_reg_ad";
            case 42L: return "e_reg_float_tos";
            case 43L: return "e_reg_float_second";
            case 44L: return "e_reg_sse";
            case 45L: return "e_reg_sse2";
            case 46L: return "e_reg_mmx";
            case 47L: return "e_imm_short_shift";
            case 48L: return "e_imm_long_shift";
            case 49L: return "e_imm_lea_shift";
            case 50L: return "e_imm_signed8";
            case 51L: return "e_imm_unsigned8";
            case 52L: return "e_imm_and_zext";
            case 53L: return "e_imm_80387";
            case 54L: return "e_imm_sse";
            case 55L: return "e_imm_sext32";
            case 56L: return "e_imm_zext32";
            case 57L: return "e_last";
            default: return "";
        }
    }

    std::string asm_operand_constraint_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_constraint_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_constraint_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L
        };
        static const std::vector<int64_t> retval(values, values + 58);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_constraint_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_constraint_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_constraint_enum() {
        return stringify::SgAsmOp::asm_operand_constraint_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_Grammar.h line 716541
namespace stringify { namespace SgLabelSymbol {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_label_type";
            case 1L: return "e_non_numeric_label_type";
            case 2L: return "e_start_label_type";
            case 3L: return "e_else_label_type";
            case 4L: return "e_end_label_type";
            case 5L: return "e_alternative_return_type";
            case 6L: return "e_last_label_type";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelSymbol_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelSymbol::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelSymbol::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelSymbol_label_type_enum() {
        return stringify::SgLabelSymbol::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarVariants.h line 10
namespace stringify {
    const char* Cxx_GrammarVariants(int64_t i) {
        switch (i) {
            case 1L: return "AccessModifierTag";
            case 2L: return "ACTUAL_ARGUMENT_EXPRESSION";
            case 3L: return "ABS_OP";
            case 4L: return "T_ADA_ACCESS_TYPE";
            case 5L: return "ADA_ACCEPT_STMT";
            case 6L: return "ADA_DELAY_STMT";
            case 7L: return "ADA_ENTRY_DECL_STMT";
            case 8L: return "ADA_EXIT_STMT";
            case 9L: return "T_ADA_DISCRETE_TYPE";
            case 10L: return "ADA_FLOAT_VAL";
            case 11L: return "ADA_LOOP_STMT";
            case 12L: return "ADA_PACKAGE_BODY";
            case 13L: return "ADA_PACKAGE_BODY_DECL_STMT";
            case 14L: return "ADA_PACKAGE_SPEC";
            case 15L: return "ADA_PACKAGE_SPEC_DECL_STMT";
            case 16L: return "ADA_PACKAGE_SYMBOL";
            case 17L: return "AdaRangeConstraintTag";
            case 18L: return "ADA_RENAMING_DECL_STMT";
            case 19L: return "T_ADA_SUBTYPE";
            case 20L: return "ADA_TASK_BODY";
            case 21L: return "ADA_TASK_BODY_DECL_STMT";
            case 22L: return "ADA_TASK_SPEC";
            case 23L: return "ADA_TASK_SPEC_DECL_STMT";
            case 24L: return "ADA_TASK_SYMBOL";
            case 25L: return "ADA_TASK_REF";
            case 26L: return "T_ADA_TASK_TYPE";
            case 27L: return "ADA_TASK_TYPE_DECL_STMT";
            case 28L: return "AdaTypeConstraintTag";
            case 29L: return "ADD_OP";
            case 30L: return "ADDRESS_OP";
            case 31L: return "AGGREGATE_INIT";
            case 32L: return "ALIAS_SYMBOL";
            case 33L: return "TEMP_Allocate_Statement";
            case 34L: return "AND_ASSIGN_OP";
            case 35L: return "AND_OP";
            case 36L: return "TEMP_Arithmetic_If_Statement";
            case 37L: return "T_ARRAY";
            case 38L: return "POINTST_OP";
            case 39L: return "ARROWSTAR_OP";
            case 40L: return "AsmAarch64AtOperandTag";
            case 41L: return "AsmAarch64BarrierOperandTag";
            case 42L: return "AsmAarch64CImmediateOperandTag";
            case 43L: return "AsmAarch64InstructionTag";
            case 44L: return "AsmAarch64PrefetchOperandTag";
            case 45L: return "AsmAarch64SysMoveOperandTag";
            case 46L: return "AsmBasicStringTag";
            case 47L: return "AsmBinaryAddTag";
            case 50L: return "AsmBinaryAsrTag";
            case 51L: return "AsmBinaryDivideTag";
            case 52L: return "AsmBinaryExpressionTag";
            case 53L: return "AsmBinaryLslTag";
            case 54L: return "AsmBinaryLsrTag";
            case 55L: return "AsmBinaryModTag";
            case 56L: return "AsmBinaryMslTag";
            case 57L: return "AsmBinaryMultiplyTag";
            case 58L: return "AsmBinaryRorTag";
            case 59L: return "AsmBinarySubtractTag";
            case 62L: return "AsmBlockTag";
            case 63L: return "AsmCoffStrtabTag";
            case 64L: return "AsmCoffSymbolTag";
            case 65L: return "AsmCoffSymbolListTag";
            case 66L: return "AsmCoffSymbolTableTag";
            case 67L: return "AsmCommonSubExpressionTag";
            case 68L: return "AsmControlFlagsExpressionTag";
            case 69L: return "AsmConstantExpressionTag";
            case 70L: return "AsmDOSExtendedHeaderTag";
            case 71L: return "AsmDOSFileHeaderTag";
            case 72L: return "AsmSynthesizedDataStructureDeclarationTag";
            case 73L: return "AsmSynthesizedDeclarationTag";
            case 74L: return "AsmDirectRegisterExpressionTag";
            case 75L: return "AsmDwarfAccessDeclarationTag";
            case 76L: return "AsmDwarfArrayTypeTag";
            case 77L: return "AsmDwarfBaseTypeTag";
            case 78L: return "AsmDwarfCatchBlockTag";
            case 79L: return "AsmDwarfClassTemplateTag";
            case 80L: return "AsmDwarfClassTypeTag";
            case 81L: return "AsmDwarfCommonBlockTag";
            case 82L: return "AsmDwarfCommonInclusionTag";
            case 83L: return "AsmDwarfCompilationUnitTag";
            case 84L: return "AsmDwarfCompilationUnitListTag";
            case 85L: return "AsmDwarfConditionTag";
            case 86L: return "AsmDwarfConstTypeTag";
            case 87L: return "AsmDwarfConstantTag";
            case 88L: return "AsmDwarfConstructTag";
            case 89L: return "AsmDwarfConstructListTag";
            case 90L: return "AsmDwarfDwarfProcedureTag";
            case 91L: return "AsmDwarfEntryPointTag";
            case 92L: return "AsmDwarfEnumerationTypeTag";
            case 93L: return "AsmDwarfEnumeratorTag";
            case 94L: return "AsmDwarfFileTypeTag";
            case 95L: return "AsmDwarfFormalParameterTag";
            case 96L: return "AsmDwarfFormatLabelTag";
            case 97L: return "AsmDwarfFriendTag";
            case 98L: return "AsmDwarfFunctionTemplateTag";
            case 99L: return "AsmDwarfImportedDeclarationTag";
            case 100L: return "AsmDwarfImportedModuleTag";
            case 101L: return "AsmDwarfImportedUnitTag";
            case 102L: return "AsmDwarfInformationTag";
            case 103L: return "AsmDwarfInheritanceTag";
            case 104L: return "AsmDwarfInlinedSubroutineTag";
            case 105L: return "AsmDwarfInterfaceTypeTag";
            case 106L: return "AsmDwarfLabelTag";
            case 107L: return "AsmDwarfLexicalBlockTag";
            case 108L: return "AsmDwarfLineTag";
            case 109L: return "AsmDwarfLineListTag";
            case 110L: return "AsmDwarfMacroTag";
            case 111L: return "AsmDwarfMacroListTag";
            case 112L: return "AsmDwarfMemberTag";
            case 113L: return "AsmDwarfModuleTag";
            case 114L: return "AsmDwarfMutableTypeTag";
            case 115L: return "AsmDwarfNamelistTag";
            case 116L: return "AsmDwarfNamelistItemTag";
            case 117L: return "AsmDwarfNamespaceTag";
            case 118L: return "AsmDwarfPackedTypeTag";
            case 119L: return "AsmDwarfPartialUnitTag";
            case 120L: return "AsmDwarfPointerTypeTag";
            case 121L: return "AsmDwarfPtrToMemberTypeTag";
            case 122L: return "AsmDwarfReferenceTypeTag";
            case 123L: return "AsmDwarfRestrictTypeTag";
            case 124L: return "AsmDwarfSetTypeTag";
            case 125L: return "AsmDwarfSharedTypeTag";
            case 126L: return "AsmDwarfStringTypeTag";
            case 127L: return "AsmDwarfStructureTypeTag";
            case 128L: return "AsmDwarfSubprogramTag";
            case 129L: return "AsmDwarfSubrangeTypeTag";
            case 130L: return "AsmDwarfSubroutineTypeTag";
            case 131L: return "AsmDwarfTemplateTypeParameterTag";
            case 132L: return "AsmDwarfTemplateValueParameterTag";
            case 133L: return "AsmDwarfThrownTypeTag";
            case 134L: return "AsmDwarfTryBlockTag";
            case 135L: return "AsmDwarfTypedefTag";
            case 136L: return "AsmDwarfUnionTypeTag";
            case 137L: return "AsmDwarfUnknownConstructTag";
            case 138L: return "AsmDwarfUnspecifiedParametersTag";
            case 139L: return "AsmDwarfUnspecifiedTypeTag";
            case 140L: return "AsmDwarfUpcRelaxedTypeTag";
            case 141L: return "AsmDwarfUpcSharedTypeTag";
            case 142L: return "AsmDwarfUpcStrictTypeTag";
            case 143L: return "AsmDwarfVariableTag";
            case 144L: return "AsmDwarfVariantTag";
            case 145L: return "AsmDwarfVariantPartTag";
            case 146L: return "AsmDwarfVolatileTypeTag";
            case 147L: return "AsmDwarfWithStmtTag";
            case 148L: return "AsmElfDynamicEntryTag";
            case 149L: return "AsmElfDynamicEntryListTag";
            case 150L: return "AsmElfDynamicSectionTag";
            case 151L: return "AsmElfEHFrameEntryCITag";
            case 152L: return "AsmElfEHFrameEntryCIListTag";
            case 153L: return "AsmElfEHFrameEntryFDTag";
            case 154L: return "AsmElfEHFrameEntryFDListTag";
            case 155L: return "AsmElfEHFrameSectionTag";
            case 156L: return "AsmElfFileHeaderTag";
            case 157L: return "AsmElfNoteEntryTag";
            case 158L: return "AsmElfNoteEntryListTag";
            case 159L: return "AsmElfNoteSectionTag";
            case 160L: return "AsmElfRelocEntryTag";
            case 161L: return "AsmElfRelocEntryListTag";
            case 162L: return "AsmElfRelocSectionTag";
            case 163L: return "AsmElfSectionTag";
            case 164L: return "AsmElfSectionTableTag";
            case 165L: return "AsmElfSectionTableEntryTag";
            case 166L: return "AsmElfSegmentTableTag";
            case 167L: return "AsmElfSegmentTableEntryTag";
            case 168L: return "AsmElfSegmentTableEntryListTag";
            case 169L: return "AsmElfStringSectionTag";
            case 170L: return "AsmElfStrtabTag";
            case 171L: return "AsmElfSymbolTag";
            case 172L: return "AsmElfSymbolListTag";
            case 173L: return "AsmElfSymbolSectionTag";
            case 174L: return "AsmElfSymverDefinedAuxTag";
            case 175L: return "AsmElfSymverDefinedAuxListTag";
            case 176L: return "AsmElfSymverDefinedEntryTag";
            case 177L: return "AsmElfSymverDefinedEntryListTag";
            case 178L: return "AsmElfSymverDefinedSectionTag";
            case 179L: return "AsmElfSymverEntryTag";
            case 180L: return "AsmElfSymverEntryListTag";
            case 181L: return "AsmElfSymverNeededAuxTag";
            case 182L: return "AsmElfSymverNeededAuxListTag";
            case 183L: return "AsmElfSymverNeededEntryTag";
            case 184L: return "AsmElfSymverNeededEntryListTag";
            case 185L: return "AsmElfSymverNeededSectionTag";
            case 186L: return "AsmElfSymverSectionTag";
            case 187L: return "AsmExecutableFileFormatTag";
            case 188L: return "AsmExprListExpTag";
            case 189L: return "AsmExpressionTag";
            case 190L: return "AsmSynthesizedFieldDeclarationTag";
            case 191L: return "AsmFloatTypeTag";
            case 192L: return "AsmFloatValueExpressionTag";
            case 193L: return "AsmFunctionTag";
            case 194L: return "AsmGenericDLLTag";
            case 195L: return "AsmGenericDLLListTag";
            case 196L: return "AsmGenericFileTag";
            case 197L: return "AsmGenericFileListTag";
            case 198L: return "AsmGenericFormatTag";
            case 199L: return "AsmGenericHeaderTag";
            case 200L: return "AsmGenericHeaderListTag";
            case 201L: return "AsmGenericSectionTag";
            case 202L: return "AsmGenericSectionListTag";
            case 203L: return "AsmGenericStringTag";
            case 204L: return "AsmGenericStrtabTag";
            case 205L: return "AsmGenericSymbolTag";
            case 206L: return "AsmGenericSymbolListTag";
            case 207L: return "AsmIndirectRegisterExpressionTag";
            case 208L: return "AsmInstructionTag";
            case 209L: return "AsmIntegerValueExpressionTag";
            case 210L: return "AsmIntegerTypeTag";
            case 211L: return "AsmInterpretationTag";
            case 212L: return "AsmInterpretationListTag";
            case 213L: return "AsmJvmAttributeTag";
            case 214L: return "AsmJvmCodeAttributeTag";
            case 215L: return "AsmJvmMethodTag";
            case 216L: return "AsmJvmConstantPoolTag";
            case 217L: return "AsmJvmConstantPoolEntryTag";
            case 218L: return "AsmJvmConstantValueTag";
            case 219L: return "AsmJvmInstructionTag";
            case 220L: return "AsmJvmFileHeaderTag";
            case 221L: return "AsmJvmNodeTag";
            case 222L: return "AsmJvmSignatureTag";
            case 223L: return "AsmJvmSourceFileTag";
            case 224L: return "AsmLEEntryPointTag";
            case 225L: return "AsmLEEntryTableTag";
            case 226L: return "AsmLEFileHeaderTag";
            case 227L: return "AsmLENameTableTag";
            case 228L: return "AsmLEPageTableTag";
            case 229L: return "AsmLEPageTableEntryTag";
            case 230L: return "AsmLERelocTableTag";
            case 231L: return "AsmLESectionTag";
            case 232L: return "AsmLESectionTableTag";
            case 233L: return "AsmLESectionTableEntryTag";
            case 234L: return "AsmM68kInstructionTag";
            case 235L: return "AsmMemoryReferenceExpressionTag";
            case 236L: return "AsmMipsInstructionTag";
            case 237L: return "AsmNEEntryPointTag";
            case 238L: return "AsmNEEntryTableTag";
            case 239L: return "AsmNEFileHeaderTag";
            case 240L: return "AsmNEModuleTableTag";
            case 241L: return "AsmNENameTableTag";
            case 242L: return "AsmNERelocEntryTag";
            case 243L: return "AsmNERelocTableTag";
            case 244L: return "AsmNESectionTag";
            case 245L: return "AsmNESectionTableTag";
            case 246L: return "AsmNESectionTableEntryTag";
            case 247L: return "AsmNEStringTableTag";
            case 248L: return "AsmNodeTag";
            case 249L: return "ASM_OP";
            case 250L: return "AsmOperandListTag";
            case 251L: return "AsmPEExportDirectoryTag";
            case 252L: return "AsmPEExportEntryTag";
            case 253L: return "AsmPEExportEntryListTag";
            case 254L: return "AsmPEExportSectionTag";
            case 255L: return "AsmPEFileHeaderTag";
            case 256L: return "AsmPEImportDirectoryTag";
            case 257L: return "AsmPEImportDirectoryListTag";
            case 258L: return "AsmPEImportItemTag";
            case 259L: return "AsmPEImportItemListTag";
            case 260L: return "AsmPEImportSectionTag";
            case 261L: return "AsmPERVASizePairTag";
            case 262L: return "AsmPERVASizePairListTag";
            case 263L: return "AsmPESectionTag";
            case 264L: return "AsmPESectionTableTag";
            case 265L: return "AsmPESectionTableEntryTag";
            case 266L: return "AsmPEStringSectionTag";
            case 267L: return "AsmPowerpcInstructionTag";
            case 268L: return "AsmRegisterNamesTag";
            case 269L: return "AsmRegisterReferenceExpressionTag";
            case 270L: return "AsmRiscOperationTag";
            case 271L: return "AsmScalarTypeTag";
            case 272L: return "AsmStatementTag";
            case 273L: return "AsmStaticDataTag";
            case 274L: return "ASM_STMT";
            case 275L: return "AsmStoredStringTag";
            case 276L: return "AsmStringStorageTag";
            case 277L: return "AsmTypeTag";
            case 278L: return "AsmUnaryExpressionTag";
            case 279L: return "AsmUnaryMinusTag";
            case 280L: return "AsmUnaryPlusTag";
            case 281L: return "AsmUnaryRrxTag";
            case 282L: return "AsmUnarySignedExtendTag";
            case 283L: return "AsmUnaryUnsignedExtendTag";
            case 284L: return "AsmUnaryTruncateTag";
            case 285L: return "AsmValueExpressionTag";
            case 286L: return "AsmVectorTypeTag";
            case 287L: return "AsmX86InstructionTag";
            case 288L: return "BINARY_ADDRESS_SYMBOL";
            case 289L: return "BINARY_DATA_SYMBOL";
            case 290L: return "ASSERT_STMT";
            case 291L: return "ASSIGN_INIT";
            case 292L: return "ASSIGN_OP";
            case 293L: return "TEMP_Assign_Statement";
            case 294L: return "TEMP_Assigned_Goto_Statement";
            case 295L: return "TEMP_Associate_Statement";
            case 296L: return "TEMP_AsteriskShapeExp";
            case 297L: return "AT_OP";
            case 298L: return "AttributeTag";
            case 299L: return "TEMP_Attribute_Specification_Statement";
            case 300L: return "T_AUTO";
            case 301L: return "AWAIT_EXPR";
            case 302L: return "BACKSPACE_STATEMENT";
            case 303L: return "BaseClassTag";
            case 304L: return "ExpBaseClassTag";
            case 305L: return "BaseClassModifierTag";
            case 306L: return "BASIC_BLOCK_STMT";
            case 307L: return "BidirectionalGraphTag";
            case 308L: return "BinaryCompositeTag";
            case 309L: return "BINARY_EXPRESSION";
            case 310L: return "BITAND_OP";
            case 311L: return "BitAttributeTag";
            case 312L: return "BIT_COMPLEMENT_OP";
            case 313L: return "BITEQV_OP";
            case 314L: return "BITOR_OP";
            case 315L: return "BITXOR_OP";
            case 316L: return "TEMP_Block_Data_Statement";
            case 317L: return "BOOL_VAL";
            case 318L: return "BREAK_STMT";
            case 319L: return "BRACED_INIT";
            case 320L: return "CPP_DIRECTIVE_STMT";
            case 321L: return "CASE_STMT";
            case 322L: return "CAST_OP";
            case 323L: return "CATCH_STMT";
            case 324L: return "CATCH_STATEMENT_SEQ";
            case 325L: return "CHAR_VAL";
            case 326L: return "CHAR16_VAL";
            case 327L: return "CHAR32_VAL";
            case 328L: return "CHOOSE_EXPR";
            case 329L: return "ClassDecl_attrTag";
            case 330L: return "CLASS_DECL_STMT";
            case 331L: return "CLASS_DEFN_STMT";
            case 332L: return "CLASSNAME_REF";
            case 333L: return "CLASS_NAME";
            case 334L: return "T_CLASS";
            case 335L: return "C_LINKAGE_DECLARATION_STMT";
            case 336L: return "C_LINKAGE_END_STMT";
            case 337L: return "C_LINKAGE_START_STMT";
            case 338L: return "CLOSE_STATEMENT";
            case 339L: return "TEMP_ColonShapeExp";
            case 340L: return "COMMA_OP";
            case 341L: return "COMMON_BLOCK";
            case 342L: return "TEMP_CommonBlockObject";
            case 343L: return "COMMON_SYMBOL";
            case 344L: return "COMPLEX_VAL";
            case 345L: return "COMPREHENSION";
            case 347L: return "COMPOUND_ASSIGN_OP";
            case 348L: return "COMPOUND_INIT";
            case 349L: return "COMPOUND_LITERAL";
            case 350L: return "TEMP_Computed_Goto_Statement";
            case 351L: return "CONCATENATION_OP";
            case 352L: return "EXPR_CONDITIONAL";
            case 353L: return "CONJUGATE_OP";
            case 354L: return "ConstVolatileModifierTag";
            case 355L: return "CONSTRUCTOR_INIT";
            case 356L: return "TEMP_Contains_Statement";
            case 357L: return "CONTINUE_STMT";
            case 358L: return "CTOR_INITIALIZER_LIST";
            case 359L: return "TEMP_DataStatementGroup";
            case 360L: return "TEMP_DataStatementObject";
            case 361L: return "TEMP_DataStatementValue";
            case 362L: return "DEAD_IF_DIRECTIVE_STMT";
            case 363L: return "TEMP_Deallocate_Statement";
            case 364L: return "DeclarationModifierTag";
            case 365L: return "DECLARATION_SCOPE";
            case 366L: return "DECL_STMT";
            case 367L: return "T_DECLTYPE";
            case 368L: return "DEFAULT_STMT";
            case 369L: return "DEFAULT_NAME";
            case 370L: return "DEFINE_DIRECTIVE_STMT";
            case 371L: return "DELETE_OP";
            case 372L: return "TEMP_Derived_Type_Statement";
            case 373L: return "DESIGNATED_INITIALIZER";
            case 374L: return "DICTIONARY_COMPREHENSION";
            case 375L: return "DICT_EXP";
            case 376L: return "TEMP_DimensionObject";
            case 378L: return "DirectedGraphEdgeTag";
            case 380L: return "DirectoryTag";
            case 381L: return "DirectoryListTag";
            case 382L: return "DIV_ASSIGN_OP";
            case 383L: return "DIV_OP";
            case 384L: return "DO_WHILE_STMT";
            case 385L: return "RECORD_REF";
            case 386L: return "DOTSTAR_OP";
            case 387L: return "DOUBLE_VAL";
            case 388L: return "ElaboratedTypeModifierTag";
            case 389L: return "ELEMENT_WISE_OP";
            case 390L: return "ELEMENT_ADD_OP";
            case 391L: return "ELEMENT_DIVIDE_OP";
            case 392L: return "ELEMENT_LEFT_DIVIDE_OP";
            case 393L: return "ELEMENT_MULT_OP";
            case 394L: return "ELEMENT_POWER_OP";
            case 395L: return "ELEMENT_SUBTRACT_OP";
            case 396L: return "ELSE_DIRECTIVE_STMT";
            case 397L: return "TEMP_Else_Where_Statement";
            case 398L: return "ELSEIF_DIRECTIVE_STMT";
            case 399L: return "EMPTY_DECLARATION_STMT";
            case 400L: return "EMPTY_DIRECTIVE_STMT";
            case 401L: return "ENDFILE_STATEMENT";
            case 402L: return "ENDIF_DIRECTIVE_STMT";
            case 403L: return "ENTRY_STMT";
            case 404L: return "ENUM_DECL_STMT";
            case 405L: return "FIELD_NAME";
            case 406L: return "ENUM_NAME";
            case 407L: return "T_ENUM";
            case 408L: return "ENUM_VAL";
            case 409L: return "EQ_OP";
            case 410L: return "TEMP_Equivalence_Statement";
            case 411L: return "ERROR_DIRECTIVE_STMT";
            case 412L: return "EXEC_STMT";
            case 413L: return "EXPONENTIATION_OP";
            case 414L: return "EXP_ASSIGN_OP";
            case 415L: return "EXPR_LIST";
            case 416L: return "EXPR_STMT";
            case 417L: return "ExpressionTag";
            case 418L: return "EXPRESSION_ROOT";
            case 419L: return "FileTag";
            case 420L: return "FileListTag";
            case 421L: return "FLOAT_VAL";
            case 422L: return "FLOAT_128_VAL";
            case 423L: return "FLOAT_80_VAL";
            case 424L: return "FOLD_EXPR";
            case 425L: return "FLUSH_STATEMENT";
            case 426L: return "FOR_ALL_STMT";
            case 427L: return "FOR_INIT_STMT";
            case 428L: return "FOR_STMT";
            case 429L: return "TEMP_FormatItem";
            case 430L: return "TEMP_FormatItemList";
            case 431L: return "FORMAT_STATEMENT";
            case 432L: return "FORTRAN_DO";
            case 433L: return "TEMP_Fortran_Include_Line";
            case 434L: return "FORTRAN_NONBLOCKED_DO";
            case 435L: return "FuncDecl_attrTag";
            case 436L: return "FUNC_CALL";
            case 437L: return "FUNC_DECL_STMT";
            case 438L: return "FUNC_DEFN_STMT";
            case 439L: return "FUNCTION_PARAMETER_SCOPE";
            case 440L: return "FunctionModifierTag";
            case 441L: return "FUNCTION_PARAMETER_LIST";
            case 442L: return "FUNCTION_PARAMETER_REF_EXP";
            case 443L: return "T_FUNCTION_PARAMETER_TYPE_LIST";
            case 444L: return "FUNCTION_REF";
            case 445L: return "FUNCTION_NAME";
            case 446L: return "T_FUNCTION";
            case 447L: return "FUNCTYPE_NAME";
            case 448L: return "FUNC_TBL_STMT";
            case 449L: return "TYPE_TABLE";
            case 450L: return "GLOBAL_STMT";
            case 451L: return "GOTO_STMT";
            case 452L: return "GraphTag";
            case 453L: return "GraphEdgeTag";
            case 454L: return "GraphEdgeListTag";
            case 455L: return "GraphNodeTag";
            case 456L: return "GraphNodeListTag";
            case 457L: return "GE_OP";
            case 458L: return "GT_OP";
            case 459L: return "IO_ITEM_EXPR";
            case 460L: return "IO_STATEMENT";
            case 461L: return "IDENT_DIRECTIVE_STMT";
            case 462L: return "IF_DIRECTIVE_STMT";
            case 463L: return "IF_STMT";
            case 464L: return "IFDEF_DIRECTIVE_STMT";
            case 465L: return "IFNDEF_DIRECTIVE_STMT";
            case 466L: return "IMAGE_CONTROL_STATEMENT";
            case 467L: return "IMAG_PART_OP";
            case 468L: return "TEMP_Implicit_Statement";
            case 469L: return "IMPLIED_DO";
            case 470L: return "TEMP_Import_Statement";
            case 471L: return "IncidenceDirectedGraphTag";
            case 472L: return "IncidenceUndirectedGraphTag";
            case 473L: return "INCLUDE_DIRECTIVE_STMT";
            case 474L: return "IncludeFileTag";
            case 475L: return "INCLUDE_NEXT_DIRECTIVE_STMT";
            case 476L: return "InitializedNameTag";
            case 477L: return "EXPR_INIT";
            case 478L: return "INQUIRE_STATEMENT";
            case 479L: return "IntKeyedBidirectionalGraphTag";
            case 480L: return "INT_VAL";
            case 481L: return "INTEGER_DIV_OP";
            case 482L: return "IDIV_ASSIGN_OP";
            case 483L: return "TEMP_Interface_Body";
            case 484L: return "TEMP_Header_File_Body";
            case 485L: return "HeaderFileReportTag";
            case 486L: return "INTERFACE_STATEMENT";
            case 487L: return "INTERFACE_SYMBOL";
            case 488L: return "INTRINSIC_SYMBOL";
            case 489L: return "IS_OP";
            case 490L: return "IS_NOT_OP";
            case 491L: return "IOR_ASSIGN_OP";
            case 492L: return "T_JOVIAL_BIT";
            case 493L: return "JovialBitValTag";
            case 494L: return "T_JOVIAL_TABLE";
            case 495L: return "JOVIAL_COMPOOL_STATEMENT";
            case 496L: return "JOVIAL_FOR_THEN_STATEMENT";
            case 497L: return "JOVIAL_DEFINE_DECLARATION";
            case 498L: return "JOVIAL_DIRECTIVE_STATEMENT";
            case 499L: return "JOVIAL_OVERLAY_DECLARATION";
            case 500L: return "JOVIAL_PRESET_POSITION_EXP";
            case 501L: return "JOVIAL_TABLE_PRESET_EXP";
            case 502L: return "TEMP_Jovial_Table_Statement";
            case 503L: return "KEY_DATUM_PAIR";
            case 504L: return "EXEC_CONF";
            case 505L: return "KERN_CALL";
            case 506L: return "LABEL_REF";
            case 507L: return "LABEL_STMT";
            case 508L: return "JAVA_LABEL_STMT";
            case 509L: return "LABEL_NAME";
            case 510L: return "JAVA_LABEL_NAME";
            case 511L: return "LambdaCaptureTag";
            case 512L: return "LambdaCaptureListTag";
            case 513L: return "LAMBDA_EXP";
            case 514L: return "LAMBDA_REF_EXP";
            case 515L: return "LEFT_DIVIDE_OP";
            case 516L: return "LE_OP";
            case 517L: return "LT_OP";
            case 518L: return "LINE_DIRECTIVE_STMT";
            case 519L: return "LINEMARKER_DIRECTIVE_STMT";
            case 520L: return "LinkageModifierTag";
            case 521L: return "LIST_COMPREHENSION";
            case 522L: return "LIST_EXP";
            case 523L: return "LocatedNodeTag";
            case 524L: return "LocatedNodeSupportTag";
            case 525L: return "LONG_DOUBLE_VAL";
            case 526L: return "LONG_INT_VAL";
            case 527L: return "LONG_LONG_INT_VAL";
            case 528L: return "LSHIFT_ASSIGN_OP";
            case 529L: return "LSHIFT_OP";
            case 530L: return "MAGIC_COLON_EXP";
            case 531L: return "MATRIX_EXP";
            case 532L: return "MATRIX_TRANSPOSE_OP";
            case 533L: return "MATLAB_FOR_STATEMENT";
            case 534L: return "MFUNC_DECL_STMT";
            case 535L: return "MEMBER_FUNCTION_REF";
            case 536L: return "MEMBER_FUNC_NAME";
            case 537L: return "T_MEMBERFUNCTION";
            case 538L: return "MEMBERSHIP_OP";
            case 539L: return "MS_ATTRIBUTE_DECL_STMT";
            case 540L: return "MINUS_ASSIGN_OP";
            case 541L: return "MINUSMINUS_OP";
            case 542L: return "UNARY_MINUS_OP";
            case 543L: return "MOD_ASSIGN_OP";
            case 544L: return "MOD_OP";
            case 545L: return "ModifierTag";
            case 546L: return "ModifierNodesTag";
            case 547L: return "T_MODIFIER";
            case 548L: return "MODULE_STATEMENT";
            case 549L: return "MODULE_SYMBOL";
            case 550L: return "MULT_ASSIGN_OP";
            case 551L: return "MULT_OP";
            case 552L: return "NameTag";
            case 553L: return "TEMP_Name_Group";
            case 554L: return "T_NAME";
            case 555L: return "TEMP_Namelist_Statement";
            case 556L: return "NAMESPACE_ALIAS_DECLARATION_STMT";
            case 557L: return "NAMESPACE_DECLARATION_STMT";
            case 558L: return "NAMESPACE_DEFINITION_STMT";
            case 559L: return "NAMESPACE_NAME";
            case 560L: return "NARY_EXPRESSION";
            case 561L: return "NARY_BOOLEAN_OP";
            case 562L: return "NARY_COMPARISON_OP";
            case 563L: return "NEW_OP";
            case 564L: return "NodeTag";
            case 565L: return "NOEXCEPT_OP";
            case 566L: return "NE_OP";
            case 567L: return "NOT_OP";
            case 568L: return "NON_MEMBERSHIP_OP";
            case 569L: return "NONREAL_DECL";
            case 570L: return "NONREAL_REF";
            case 571L: return "NONREAL_SYMBOL";
            case 572L: return "T_NONREAL";
            case 573L: return "NonrealBaseClassTag";
            case 574L: return "NULL_EXPR";
            case 575L: return "NULLPTR_VAL";
            case 576L: return "NULL_STMT";
            case 577L: return "TEMP_Nullify_Statement";
            case 578L: return "OMP_ATOMIC_STMT";
            case 579L: return "OMP_BARRIER_STMT";
            case 580L: return "OMP_CRITICAL_STMT";
            case 581L: return "OMP_CLAUSEBODY_STMT";
            case 582L: return "OMP_BODY_STMT";
            case 583L: return "OMP_DO_STMT";
            case 584L: return "OMP_FLUSH_STMT";
            case 585L: return "OMP_DECLARE_SIMD_STMT";
            case 586L: return "OMP_FOR_STMT";
            case 587L: return "OMP_FOR_SIMD_STMT";
            case 588L: return "OMP_MASTER_STMT";
            case 589L: return "OMP_ORDERED_STMT";
            case 590L: return "OMP_PARALLEL_STMT";
            case 591L: return "OMP_SECTION_STMT";
            case 592L: return "OMP_SECTIONS_STMT";
            case 593L: return "OMP_SINGLE_STMT";
            case 594L: return "OMP_TASK_STMT";
            case 595L: return "OMP_TASKWAIT_STMT";
            case 596L: return "OMP_THREADPRIVATE_STMT";
            case 597L: return "OMP_WORKSHARE_STMT";
            case 598L: return "OMP_TARGET_STMT";
            case 599L: return "OMP_TARGET_DATA_STMT";
            case 600L: return "OMP_SIMD_STMT";
            case 601L: return "OmpClauseTag";
            case 602L: return "OmpBeginClauseTag";
            case 603L: return "OmpCollapseClauseTag";
            case 604L: return "OmpCopyinClauseTag";
            case 605L: return "OmpCopyprivateClauseTag";
            case 606L: return "OmpDefaultClauseTag";
            case 607L: return "OmpEndClauseTag";
            case 608L: return "OmpExpressionClauseTag";
            case 609L: return "OmpFirstprivateClauseTag";
            case 610L: return "OmpIfClauseTag";
            case 611L: return "OmpFinalClauseTag";
            case 612L: return "OmpPriorityClauseTag";
            case 613L: return "OmpIfDeviceTag";
            case 614L: return "OmpLastprivateClauseTag";
            case 615L: return "OmpNowaitClauseTag";
            case 616L: return "OmpNumThreadsClauseTag";
            case 617L: return "OmpOrderedClauseTag";
            case 618L: return "OmpPrivateClauseTag";
            case 619L: return "OmpReductionClauseTag";
            case 620L: return "OmpScheduleClauseTag";
            case 621L: return "OmpSharedClauseTag";
            case 622L: return "OmpUntiedClauseTag";
            case 623L: return "OmpMergeableClauseTag";
            case 624L: return "OmpVariablesClauseTag";
            case 625L: return "OmpMapClauseTag";
            case 626L: return "OmpSafelenTag";
            case 627L: return "OmpSimdlenTag";
            case 628L: return "OmpLinearClauseTag";
            case 629L: return "OmpUniformClauseTag";
            case 630L: return "OmpAlignedClauseTag";
            case 631L: return "OmpProcBindClauseTag";
            case 632L: return "OmpAtomicClauseTag";
            case 633L: return "OmpInbranchClauseTag";
            case 634L: return "OmpNotinbranchClauseTag";
            case 635L: return "OmpDependClauseTag";
            case 636L: return "OPENCL_ACCESS_MODE";
            case 637L: return "OPEN_STATEMENT";
            case 638L: return "OptionsTag";
            case 639L: return "OR_OP";
            case 640L: return "PARAMETER_STATEMENT";
            case 641L: return "T_PARTIAL_FUNCTION_MODIFIER";
            case 642L: return "T_PARTIAL_FUNCTION";
            case 643L: return "PASS_STATEMENT";
            case 644L: return "PLUS_ASSIGN_OP";
            case 645L: return "PLUSPLUS_OP";
            case 646L: return "ARRAY_OP";
            case 647L: return "POINTER_ASSIGN_OP";
            case 648L: return "DEREF_OP";
            case 649L: return "T_MEMBER_POINTER";
            case 650L: return "T_POINTER";
            case 651L: return "POWER_OP";
            case 652L: return "PragmaTag";
            case 653L: return "PRAGMA_DECL";
            case 654L: return "PRINT_STATEMENT";
            case 655L: return "PROCEDURE_HEADER_STMT";
            case 656L: return "PROGRAM_HEADER_STMT";
            case 657L: return "ProjectTag";
            case 658L: return "PSEUDO_DESTRUCTOR_REF";
            case 659L: return "PYTHON_GLOBAL_STMT";
            case 660L: return "PYTHON_PRINT_STMT";
            case 661L: return "QualifiedNameTag";
            case 662L: return "T_QUALIFIED_NAME";
            case 663L: return "RANGE_EXP";
            case 664L: return "RANGE_BASED_FOR_STMT";
            case 665L: return "READ_STATEMENT";
            case 666L: return "REAL_PART_OP";
            case 667L: return "TYPE_REF";
            case 668L: return "T_REFERENCE";
            case 669L: return "REM_OP";
            case 670L: return "TEMP_Rename_Pair";
            case 671L: return "RENAME_SYMBOL";
            case 672L: return "REPLICATION_OP";
            case 673L: return "RETURN_STMT";
            case 674L: return "REWIND_STATEMENT";
            case 675L: return "RSHIFT_ASSIGN_OP";
            case 676L: return "RSHIFT_OP";
            case 677L: return "T_RVALUE_REFERENCE";
            case 678L: return "JAVA_UNSIGNED_RSHIFT_ASSIGN_OP";
            case 679L: return "JAVA_UNSIGNED_RSHIFT_OP";
            case 680L: return "SCOPE_OP";
            case 681L: return "SCOPE_STMT";
            case 682L: return "TEMP_Sequence_Statement";
            case 683L: return "SET_COMPREHENSION";
            case 684L: return "SHORT_VAL";
            case 685L: return "SIZEOF_OP";
            case 686L: return "ALIGNOF_OP";
            case 687L: return "JAVA_INSTANCEOF_OP";
            case 688L: return "SourceFileTag";
            case 689L: return "SPACESHIP_OP";
            case 690L: return "SPAWN_STMT";
            case 691L: return "SYNC_ALL_STATEMENT";
            case 692L: return "SYNC_IMAGES_STATEMENT";
            case 693L: return "SYNC_MEMORY_STATEMENT";
            case 694L: return "SYNC_TEAM_STATEMENT";
            case 695L: return "LOCK_STATEMENT";
            case 696L: return "UNLOCK_STATEMENT";
            case 697L: return "JAVE_THROW_STMT";
            case 698L: return "JAVA_FOREACH_STMT";
            case 699L: return "JAVA_SYNC_STMT";
            case 700L: return "T_JAVA_PARAM";
            case 701L: return "T_JAVA_WILD";
            case 702L: return "PROCESS_CONTROL_STATEMENT";
            case 703L: return "SIGNED_CHAR_VAL";
            case 704L: return "SpecialFunctionModifierTag";
            case 705L: return "StatementTag";
            case 706L: return "STATIC_ASSERTION_DECLARATION";
            case 707L: return "STMT_DECL_STMT";
            case 708L: return "STMT_EXPR";
            case 709L: return "TEMP_Statement_Function_Statement";
            case 710L: return "StorageModifierTag";
            case 711L: return "STR_CONV";
            case 712L: return "StringKeyedBidirectionalGraphTag";
            case 713L: return "STRING_VAL";
            case 714L: return "StructureModifierTag";
            case 715L: return "SUBSCRIPT_EXPR";
            case 716L: return "SUBT_OP";
            case 717L: return "SupportTag";
            case 718L: return "SWITCH_STMT";
            case 719L: return "SymbolTag";
            case 720L: return "SymbolTableTag";
            case 721L: return "TemplateArgumentTag";
            case 722L: return "TemplateArgumentListTag";
            case 723L: return "TEMPLATE_DECL_STMT";
            case 724L: return "TEMPLATE_CLASS_DECL_STMT";
            case 725L: return "TEMPLATE_CLASS_NAME";
            case 726L: return "TEMPLATE_FUNCTION_DECL_STMT";
            case 727L: return "TEMPLATE_FUNCTION_REF";
            case 728L: return "TEMPLATE_FUNC_NAME";
            case 729L: return "TEMPLATE_MEMBER_FUNCTION_DECL_STMT";
            case 730L: return "TEMPLATE_MEMBER_FUNCTION_REF";
            case 731L: return "TEMPLATE_MEMBER_FUNC_NAME";
            case 732L: return "TEMPLATE_TYPEDEF_DECL_STMT";
            case 733L: return "TEMPLATE_TYPEDEF_NAME";
            case 734L: return "TEMPLATE_VARIABLE_DECL_STMT";
            case 735L: return "TEMPLATE_VARIABLE_NAME";
            case 736L: return "TEMPLATE_CLASS_DEF_STMT";
            case 737L: return "TEMPLATE_FUNCTION_DEF_STMT";
            case 738L: return "TEMPLATE_INST_DECL_STMT";
            case 739L: return "TEMPLATE_INST_DEFN_STMT";
            case 740L: return "TEMPLATE_INST_DIRECTIVE_STMT";
            case 741L: return "TEMPLATE_INST_FUNCTION_DECL_STMT";
            case 742L: return "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT";
            case 743L: return "TEMPLATE_INST_TYPEDEF_DECL_STMT";
            case 744L: return "TemplateParameterTag";
            case 745L: return "TEMPLATE_PARAMETER_VAL";
            case 746L: return "TemplateParameterListTag";
            case 747L: return "TEMPLATE_NAME";
            case 748L: return "T_TEMPLATE";
            case 749L: return "THIS_NODE";
            case 750L: return "TYPE_TRAIT_BUILTIN_OPERATOR";
            case 751L: return "SUPER_NODE";
            case 752L: return "THROW_OP";
            case 753L: return "TOKEN";
            case 754L: return "TRY_STMT";
            case 755L: return "TUPLE_EXP";
            case 756L: return "TypeTag";
            case 757L: return "T_BOOL";
            case 758L: return "T_CHAR";
            case 759L: return "T_CHAR16";
            case 760L: return "T_CHAR32";
            case 761L: return "T_COMPLEX";
            case 762L: return "T_DEFAULT";
            case 763L: return "TYPE_EXPRESSION";
            case 764L: return "T_LABEL";
            case 765L: return "T_DOUBLE";
            case 766L: return "T_ELLIPSE";
            case 767L: return "T_FIXED";
            case 768L: return "T_FLOAT";
            case 769L: return "T_FLOAT128";
            case 770L: return "T_FLOAT80";
            case 771L: return "T_GLOBAL_VOID";
            case 772L: return "TYPEID_OP";
            case 773L: return "T_IMAGINARY";
            case 774L: return "T_INT";
            case 775L: return "T_LONG";
            case 776L: return "T_LONG_DOUBLE";
            case 777L: return "T_LONG_LONG";
            case 778L: return "TypeModifierTag";
            case 779L: return "T_MATRIX";
            case 780L: return "T_TUPLE";
            case 781L: return "T_NULLPTR";
            case 782L: return "T_TYPEOF_TYPE";
            case 783L: return "T_SHORT";
            case 784L: return "T_SIGNED_128BIT_INTEGER";
            case 785L: return "T_SIGNED_CHAR";
            case 786L: return "T_SIGNED_INT";
            case 787L: return "T_SIGNED_LONG";
            case 788L: return "T_SIGNED_LONG_LONG";
            case 789L: return "T_SIGNED_SHORT";
            case 790L: return "T_STRING";
            case 791L: return "T_UNKNOWN";
            case 792L: return "T_UNSIGNED_128BIT_INTEGER";
            case 793L: return "T_UNSIGNED_CHAR";
            case 794L: return "T_UNSIGNED_INT";
            case 795L: return "T_UNSIGNED_LONG";
            case 796L: return "T_UNSIGNED_LONG_LONG";
            case 797L: return "T_UNSIGNED_SHORT";
            case 798L: return "T_VOID";
            case 799L: return "T_WCHAR";
            case 800L: return "TYPEDEF_STMT";
            case 801L: return "T_TYPEDEF_SEQ";
            case 802L: return "TYPEDEF_NAME";
            case 803L: return "T_TYPEDEF";
            case 804L: return "UPC_AccessModifierTag";
            case 805L: return "UNARY_ADD_OP";
            case 806L: return "UNARY_EXPRESSION";
            case 807L: return "UNDEF_DIRECTIVE_STMT";
            case 808L: return "UndirectedGraphEdgeTag";
            case 809L: return "TEMP_UnknownArrayOrFunctionReference";
            case 810L: return "UnknownFileTag";
            case 812L: return "Unparse_InfoTag";
            case 813L: return "UNSIGNED_CHAR_VAL";
            case 814L: return "UNSIGNED_INT_VAL";
            case 815L: return "UNSIGNED_LONG_LONG_INT_VAL";
            case 816L: return "UNSIGNED_LONG_INT_VAL";
            case 817L: return "UNSIGNED_SHORT_VAL";
            case 818L: return "UPC_BARRIER_STMT";
            case 819L: return "UPC_BLOCK_SIZEOF_EXPR";
            case 820L: return "UPC_ELEM_SIZEOF_EXPR";
            case 821L: return "UPC_FENCE_STMT";
            case 822L: return "UPC_FORALL_STMT";
            case 823L: return "UPC_LOCAL_SIZEOF_EXPR";
            case 824L: return "UPC_MYTHREAD";
            case 825L: return "UPC_NOTIFY_STMT";
            case 826L: return "UPC_THREADS";
            case 827L: return "UPC_WAIT_STMT";
            case 828L: return "USE_STATEMENT";
            case 829L: return "USER_DEFINED_BINARY_OP";
            case 830L: return "USER_DEFINED_UNARY_OP";
            case 831L: return "USING_DECLARATION_STMT";
            case 832L: return "USING_DIRECTIVE_STMT";
            case 833L: return "ValueExpTag";
            case 834L: return "VA_COPY_OP";
            case 835L: return "VA_END_OP";
            case 836L: return "VA_OP";
            case 837L: return "VA_START_ONE_OPERAND_OP";
            case 838L: return "VA_START_OP";
            case 839L: return "VAR_REF";
            case 840L: return "VAR_DECL_STMT";
            case 841L: return "VAR_DEFN_STMT";
            case 842L: return "VARIABLE_NAME";
            case 843L: return "VARIANT_EXPR";
            case 844L: return "VARIANT_STMT";
            case 845L: return "VOID_VAL";
            case 846L: return "WAIT_STATEMENT";
            case 847L: return "WARNING_DIRECTIVE_STMT";
            case 848L: return "WITH_STATEMENT";
            case 849L: return "WCHAR_VAL";
            case 850L: return "TEMP_Where_Statement";
            case 851L: return "WHILE_STMT";
            case 852L: return "WRITE_STATEMENT";
            case 853L: return "XOR_ASSIGN_OP";
            case 854L: return "YIELD_EXP";
            case 855L: return "_File_InfoTag";
            case 856L: return "T_CAFTEAM";
            case 857L: return "WITHTEAM_STMT";
            case 858L: return "COARRAY_REF_EXPR";
            case 859L: return "CALL_EXPRESSION";
            case 860L: return "T_CRAY_POINTER";
            case 861L: return "TEMP_JavaImportStatement";
            case 862L: return "TEMP_JavaPackageDeclaration";
            case 863L: return "TEMP_JavaPackageStatement";
            case 864L: return "JavaImportStatementListTag";
            case 865L: return "JavaClassDeclarationListTag";
            case 866L: return "JavaMemberValuePairTag";
            case 867L: return "JAVA_ANNOTATION";
            case 868L: return "JAVA_MARKER_ANNOTATION";
            case 869L: return "JAVA_SINGLE_MEMBER_ANNOTATION";
            case 870L: return "JAVA_NORMAL_ANNOTATION";
            case 871L: return "JAVA_TYPE_EXPRESSION";
            case 872L: return "T_JAVA_QUALIFIED";
            case 873L: return "CLASS_NODE";
            case 874L: return "T_JAVA_UNION";
            case 875L: return "T_JAVA_PARAMETER";
            case 876L: return "ASYNC_STMT";
            case 877L: return "FINISH_STMT";
            case 878L: return "AT_STMT";
            case 879L: return "ATOMIC_STMT";
            case 881L: return "WHEN_STMT";
            case 882L: return "ATEXP_NODE";
            case 883L: return "FINISHEXP_NODE";
            case 884L: return "HERE_NODE";
            case 885L: return "DOTDOT_NODE";
            case 886L: return "AsmNullInstructionTag";
            case 887L: return "ADA_COMPONENT_CLAUSE";
            case 888L: return "AdaIndexConstraintTag";
            case 889L: return "T_ADA_MODULAR_TYPE";
            case 890L: return "ADA_REPRESENTATION_CLAUSE";
            case 891L: return "ADA_FUNCTION_RENAMING_DECL_STMT";
            case 892L: return "ADA_SELECT_STMT";
            case 893L: return "ADA_SELECT_ALTERNATIVE_STMT";
            case 894L: return "ADA_TERMINATE_STMT";
            case 895L: return "AsmAarch32InstructionTag";
            case 896L: return "AsmAarch32CoprocessorTag";
            case 897L: return "ADA_ATTRIBUTE_CLAUSE";
            case 898L: return "AsmBinaryConcatTag";
            case 899L: return "AsmByteOrderTag";
            case 900L: return "T_ADA_DERIVED_TYPE";
            case 901L: return "ADA_ATTRIBUTE_EXP";
            case 902L: return "ADA_ENUM_REPRESENTATION_CLAUSE";
            case 903L: return "AsmBinaryPreupdateTag";
            case 904L: return "AsmBinaryPostupdateTag";
            case 905L: return "ADA_OTHERS_EXPR";
            case 906L: return "ADA_RENAMING_SYMBOL";
            case 907L: return "ADA_RENAMING_REF";
            case 908L: return "ADA_GENERIC_DECL";
            case 909L: return "ADA_GENERIC_DEFN";
            case 910L: return "T_ADA_FORMAL_TYPE";
            case 911L: return "ADA_GENERIC_SYMBOL";
            case 912L: return "ADA_FORMAL_TYPE_DECL_STMT";
            case 913L: return "ADA_UNIT_REF";
            case 914L: return "ADA_DISCRIMINATED_TYPE_DECL";
            case 915L: return "T_ADA_DISCRIMINATED_TYPE";
            case 916L: return "AdaDiscriminantConstraintTag";
            case 917L: return "ADA_GENERIC_INSTANCE_DECL";
            case 918L: return "ADA_UNSCOPED_BLOCK";
            case 919L: return "ADA_INHERITED_FUNCTION_SYMBOL";
            case 920L: return "ADA_PROTECTED_BODY";
            case 921L: return "ADA_PROTECTED_BODY_DECL_STMT";
            case 922L: return "ADA_PROTECTED_SPEC";
            case 923L: return "ADA_PROTECTED_SPEC_DECL_STMT";
            case 924L: return "ADA_PROTECTED_SYMBOL";
            case 925L: return "ADA_PROTECTED_REF";
            case 926L: return "T_ADA_PROTECTED_TYPE";
            case 927L: return "ADA_PROTECTED_TYPE_DECL_STMT";
            case 928L: return "AdaDigitsConstraintTag";
            case 929L: return "ADA_ANCESTOR_INIT";
            case 930L: return "AdaDeltaConstraintTag";
            case 931L: return "T_ADA_SUBROUTINE_TYPE";
            case 932L: return "ADA_GENERIC_INSTANCE_SYMBOL";
            case 933L: return "ADA_FORMAL_PACKAGE_DECL_STMT";
            case 934L: return "ADA_FORMAL_PACAKGE_SYMBOL";
            case 935L: return "AsmJvmAttributeTableTag";
            case 936L: return "AsmJvmMethodTableTag";
            case 937L: return "AsmJvmFieldTag";
            case 938L: return "AsmJvmFieldTableTag";
            case 939L: return "AsmJvmExceptionHandlerTag";
            case 940L: return "AsmJvmExceptionTableTag";
            case 941L: return "AsmJvmClassTag";
            case 942L: return "AsmJvmLineNumberEntryTag";
            case 943L: return "AsmJvmLineNumberTableTag";
            case 944L: return "AsmJvmInnerClassesEntryTag";
            case 945L: return "AsmJvmInnerClassesTag";
            case 946L: return "AsmCilInstructionTag";
            case 947L: return "AsmStackExpressionTag";
            case 948L: return "AsmJvmEnclosingMethodTag";
            case 949L: return "AdaNullConstraintTag";
            case 950L: return "AsmJvmModuleMainClassTag";
            case 951L: return "AsmInstructionListTag";
            case 952L: return "AsmCilNodeTag";
            case 953L: return "AsmCilAssemblyTag";
            case 954L: return "AsmCilAssemblyOSTag";
            case 955L: return "AsmCilAssemblyProcessorTag";
            case 956L: return "AsmCilAssemblyRefTag";
            case 957L: return "AsmCilAssemblyRefOSTag";
            case 958L: return "AsmCilAssemblyRefProcessorTag";
            case 959L: return "AsmCilClassLayoutTag";
            case 960L: return "AsmCilConstantTag";
            case 961L: return "AsmCilCustomAttributeTag";
            case 962L: return "AsmCilDeclSecurityTag";
            case 963L: return "AsmCilEventTag";
            case 964L: return "AsmCilEventMapTag";
            case 965L: return "AsmCilExportedTypeTag";
            case 966L: return "AsmCilFieldTag";
            case 967L: return "AsmCilFieldLayoutTag";
            case 968L: return "AsmCilFieldMarshalTag";
            case 969L: return "AsmCilFieldRVATag";
            case 970L: return "AsmCilFileTag";
            case 971L: return "AsmCilGenericParamTag";
            case 972L: return "AsmCilGenericParamConstraintTag";
            case 973L: return "AsmCilImplMapTag";
            case 974L: return "AsmCilInterfaceImplTag";
            case 975L: return "AsmCilManifestResourceTag";
            case 976L: return "AsmCilMemberRefTag";
            case 977L: return "AsmCilMethodDefTag";
            case 978L: return "AsmCilMethodImplTag";
            case 979L: return "AsmCilMethodSemanticsTag";
            case 980L: return "AsmCilMethodSpecTag";
            case 981L: return "AsmCilModuleTag";
            case 982L: return "AsmCilModuleRefTag";
            case 983L: return "AsmCilNestedClassTag";
            case 984L: return "AsmCilParamTag";
            case 985L: return "AsmCilPropertyTag";
            case 986L: return "AsmCilPropertyMapTag";
            case 987L: return "AsmCilStandAloneSigTag";
            case 988L: return "AsmCilTypeDefTag";
            case 989L: return "AsmCilTypeRefTag";
            case 990L: return "AsmCilTypeSpecTag";
            case 991L: return "ADA_PARAMETER_LIST";
            case 992L: return "AsmCilMetadataTag";
            case 993L: return "AsmCilMetadataRootTag";
            case 994L: return "AsmCilDataStreamTag";
            case 995L: return "AsmCilMetadataHeapTag";
            case 996L: return "AsmCilUint8HeapTag";
            case 997L: return "AsmCilUint32HeapTag";
            case 998L: return "AsmCliHeaderTag";
            case 999L: return "ADA_VARIANT_DECL_STATEMENT";
            case 1000L: return "ADA_VARIANT_WHEN_STMT";
            case 1001L: return "AsmCilAssemblyTableTag";
            case 1002L: return "AsmCilAssemblyOSTableTag";
            case 1003L: return "AsmCilAssemblyProcessorTableTag";
            case 1004L: return "AsmCilAssemblyRefTableTag";
            case 1005L: return "AsmCilAssemblyRefOSTableTag";
            case 1006L: return "AsmCilAssemblyRefProcessorTableTag";
            case 1007L: return "AsmCilClassLayoutTableTag";
            case 1008L: return "AsmCilConstantTableTag";
            case 1009L: return "AsmCilCustomAttributeTableTag";
            case 1010L: return "AsmCilDeclSecurityTableTag";
            case 1011L: return "AsmCilEventTableTag";
            case 1012L: return "AsmCilEventMapTableTag";
            case 1013L: return "AsmCilExportedTypeTableTag";
            case 1014L: return "AsmCilFieldTableTag";
            case 1015L: return "AsmCilFieldLayoutTableTag";
            case 1016L: return "AsmCilFieldMarshalTableTag";
            case 1017L: return "AsmCilFieldRVATableTag";
            case 1018L: return "AsmCilFileTableTag";
            case 1019L: return "AsmCilGenericParamTableTag";
            case 1020L: return "AsmCilGenericParamConstraintTableTag";
            case 1021L: return "AsmCilImplMapTableTag";
            case 1022L: return "AsmCilInterfaceImplTableTag";
            case 1023L: return "AsmCilManifestResourceTableTag";
            case 1024L: return "AsmCilMemberRefTableTag";
            case 1025L: return "AsmCilMethodDefTableTag";
            case 1026L: return "AsmCilMethodImplTableTag";
            case 1027L: return "AsmCilMethodSemanticsTableTag";
            case 1028L: return "AsmCilMethodSpecTableTag";
            case 1029L: return "AsmCilModuleTableTag";
            case 1030L: return "AsmCilModuleRefTableTag";
            case 1031L: return "AsmCilNestedClassTableTag";
            case 1032L: return "AsmCilParamTableTag";
            case 1033L: return "AsmCilPropertyTableTag";
            case 1034L: return "AsmCilPropertyMapTableTag";
            case 1035L: return "AsmCilStandAloneSigTableTag";
            case 1036L: return "AsmCilTypeDefTableTag";
            case 1037L: return "AsmCilTypeRefTableTag";
            case 1038L: return "AsmCilTypeSpecTableTag";
            case 1039L: return "JvmCompositeTag";
            case 1040L: return "FORTRAN_CONTINUE_STMT";
            case 1041L: return "AsmJvmStackMapTableTag";
            case 1042L: return "AsmJvmStackMapFrameTag";
            case 1043L: return "AsmJvmStackMapVerificationTypeTag";
            case 1044L: return "AsmJvmBootstrapMethodTag";
            case 1045L: return "AsmJvmBootstrapMethodsTag";
            case 1046L: return "AsmJvmExceptionsTag";
            case 1047L: return "AsmJvmNestMembersTag";
            case 1048L: return "AsmJvmNestHostTag";
            case 1049L: return "JOVIAL_LABEL_DECLARATION";
            case 1050L: return "AsmJvmLocalVariableEntryTag";
            case 1051L: return "AsmJvmLocalVariableTableTag";
            case 1052L: return "AsmJvmLocalVariableTypeEntryTag";
            case 1053L: return "AsmJvmLocalVariableTypeTableTag";
            case 1054L: return "AsmUserInstructionTag";
            case 1055L: return "AsmJvmMethodParametersTag";
            case 1056L: return "AsmJvmMethodParametersEntryTag";
            case 1057L: return "AsmVoidTypeTag";
            case 1058L: return "AsmPointerTypeTag";
            case 1059L: return "AsmAarch64PStateTag";
            case 1060L: return "T_RANGE_TYPE";
            case 1061L: return "AsmCilExceptionDataTag";
            case 1062L: return "AsmCilMethodDataTag";
            case 1063L: return "TEMPLATE_VARIABLE_INST_STMT";
            case 1064L: return "ReferenceExpTag";
            case 1065L: return "NTYPE_REF";
            case 1066L: return "SCOPED_REF";
            case 1067L: return "T_SCOPED_TYPE";
            case 1068L: return "TYPE_NAME";
            case 1069L: return "AsmJvmSyntheticTag";
            case 1070L: return "AsmJvmDeprecatedTag";
            case 1072L: return "Cxx_Grammar_UNKNOWN_GRAMMAR";
            case 1073L: return "Cxx_Grammar_LAST_TAG";
            default: return "";
        }
    }

    std::string Cxx_GrammarVariants(int64_t i, const std::string &strip) {
        std::string s = Cxx_GrammarVariants(i);
        if (s.empty())
            s = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Cxx_GrammarVariants() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            378L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1072L,
            1073L
        };
        static const std::vector<int64_t> retval(values, values + 1063);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCxx_GrammarVariants(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cxx_GrammarVariants(i);
        if (retval.empty()) {
            retval = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cxx_GrammarVariants::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCxx_GrammarVariants() {
        return stringify::Cxx_GrammarVariants();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /_build/src/ROSETTA/src/Cxx_GrammarVariants.h line 1077
namespace stringify {
    const char* VariantT(int64_t i) {
        switch (i) {
            case 1L: return "V_SgAccessModifier";
            case 2L: return "V_SgActualArgumentExpression";
            case 3L: return "V_SgAbsOp";
            case 4L: return "V_SgAdaAccessType";
            case 5L: return "V_SgAdaAcceptStmt";
            case 6L: return "V_SgAdaDelayStmt";
            case 7L: return "V_SgAdaEntryDecl";
            case 8L: return "V_SgAdaExitStmt";
            case 9L: return "V_SgAdaDiscreteType";
            case 10L: return "V_SgAdaFloatVal";
            case 11L: return "V_SgAdaLoopStmt";
            case 12L: return "V_SgAdaPackageBody";
            case 13L: return "V_SgAdaPackageBodyDecl";
            case 14L: return "V_SgAdaPackageSpec";
            case 15L: return "V_SgAdaPackageSpecDecl";
            case 16L: return "V_SgAdaPackageSymbol";
            case 17L: return "V_SgAdaRangeConstraint";
            case 18L: return "V_SgAdaRenamingDecl";
            case 19L: return "V_SgAdaSubtype";
            case 20L: return "V_SgAdaTaskBody";
            case 21L: return "V_SgAdaTaskBodyDecl";
            case 22L: return "V_SgAdaTaskSpec";
            case 23L: return "V_SgAdaTaskSpecDecl";
            case 24L: return "V_SgAdaTaskSymbol";
            case 25L: return "V_SgAdaTaskRefExp";
            case 26L: return "V_SgAdaTaskType";
            case 27L: return "V_SgAdaTaskTypeDecl";
            case 28L: return "V_SgAdaTypeConstraint";
            case 29L: return "V_SgAddOp";
            case 30L: return "V_SgAddressOfOp";
            case 31L: return "V_SgAggregateInitializer";
            case 32L: return "V_SgAliasSymbol";
            case 33L: return "V_SgAllocateStatement";
            case 34L: return "V_SgAndAssignOp";
            case 35L: return "V_SgAndOp";
            case 36L: return "V_SgArithmeticIfStatement";
            case 37L: return "V_SgArrayType";
            case 38L: return "V_SgArrowExp";
            case 39L: return "V_SgArrowStarOp";
            case 40L: return "V_SgAsmAarch64AtOperand";
            case 41L: return "V_SgAsmAarch64BarrierOperand";
            case 42L: return "V_SgAsmAarch64CImmediateOperand";
            case 43L: return "V_SgAsmAarch64Instruction";
            case 44L: return "V_SgAsmAarch64PrefetchOperand";
            case 45L: return "V_SgAsmAarch64SysMoveOperand";
            case 46L: return "V_SgAsmBasicString";
            case 47L: return "V_SgAsmBinaryAdd";
            case 50L: return "V_SgAsmBinaryAsr";
            case 51L: return "V_SgAsmBinaryDivide";
            case 52L: return "V_SgAsmBinaryExpression";
            case 53L: return "V_SgAsmBinaryLsl";
            case 54L: return "V_SgAsmBinaryLsr";
            case 55L: return "V_SgAsmBinaryMod";
            case 56L: return "V_SgAsmBinaryMsl";
            case 57L: return "V_SgAsmBinaryMultiply";
            case 58L: return "V_SgAsmBinaryRor";
            case 59L: return "V_SgAsmBinarySubtract";
            case 62L: return "V_SgAsmBlock";
            case 63L: return "V_SgAsmCoffStrtab";
            case 64L: return "V_SgAsmCoffSymbol";
            case 65L: return "V_SgAsmCoffSymbolList";
            case 66L: return "V_SgAsmCoffSymbolTable";
            case 67L: return "V_SgAsmCommonSubExpression";
            case 68L: return "V_SgAsmControlFlagsExpression";
            case 69L: return "V_SgAsmConstantExpression";
            case 70L: return "V_SgAsmDOSExtendedHeader";
            case 71L: return "V_SgAsmDOSFileHeader";
            case 72L: return "V_SgAsmSynthesizedDataStructureDeclaration";
            case 73L: return "V_SgAsmSynthesizedDeclaration";
            case 74L: return "V_SgAsmDirectRegisterExpression";
            case 75L: return "V_SgAsmDwarfAccessDeclaration";
            case 76L: return "V_SgAsmDwarfArrayType";
            case 77L: return "V_SgAsmDwarfBaseType";
            case 78L: return "V_SgAsmDwarfCatchBlock";
            case 79L: return "V_SgAsmDwarfClassTemplate";
            case 80L: return "V_SgAsmDwarfClassType";
            case 81L: return "V_SgAsmDwarfCommonBlock";
            case 82L: return "V_SgAsmDwarfCommonInclusion";
            case 83L: return "V_SgAsmDwarfCompilationUnit";
            case 84L: return "V_SgAsmDwarfCompilationUnitList";
            case 85L: return "V_SgAsmDwarfCondition";
            case 86L: return "V_SgAsmDwarfConstType";
            case 87L: return "V_SgAsmDwarfConstant";
            case 88L: return "V_SgAsmDwarfConstruct";
            case 89L: return "V_SgAsmDwarfConstructList";
            case 90L: return "V_SgAsmDwarfDwarfProcedure";
            case 91L: return "V_SgAsmDwarfEntryPoint";
            case 92L: return "V_SgAsmDwarfEnumerationType";
            case 93L: return "V_SgAsmDwarfEnumerator";
            case 94L: return "V_SgAsmDwarfFileType";
            case 95L: return "V_SgAsmDwarfFormalParameter";
            case 96L: return "V_SgAsmDwarfFormatLabel";
            case 97L: return "V_SgAsmDwarfFriend";
            case 98L: return "V_SgAsmDwarfFunctionTemplate";
            case 99L: return "V_SgAsmDwarfImportedDeclaration";
            case 100L: return "V_SgAsmDwarfImportedModule";
            case 101L: return "V_SgAsmDwarfImportedUnit";
            case 102L: return "V_SgAsmDwarfInformation";
            case 103L: return "V_SgAsmDwarfInheritance";
            case 104L: return "V_SgAsmDwarfInlinedSubroutine";
            case 105L: return "V_SgAsmDwarfInterfaceType";
            case 106L: return "V_SgAsmDwarfLabel";
            case 107L: return "V_SgAsmDwarfLexicalBlock";
            case 108L: return "V_SgAsmDwarfLine";
            case 109L: return "V_SgAsmDwarfLineList";
            case 110L: return "V_SgAsmDwarfMacro";
            case 111L: return "V_SgAsmDwarfMacroList";
            case 112L: return "V_SgAsmDwarfMember";
            case 113L: return "V_SgAsmDwarfModule";
            case 114L: return "V_SgAsmDwarfMutableType";
            case 115L: return "V_SgAsmDwarfNamelist";
            case 116L: return "V_SgAsmDwarfNamelistItem";
            case 117L: return "V_SgAsmDwarfNamespace";
            case 118L: return "V_SgAsmDwarfPackedType";
            case 119L: return "V_SgAsmDwarfPartialUnit";
            case 120L: return "V_SgAsmDwarfPointerType";
            case 121L: return "V_SgAsmDwarfPtrToMemberType";
            case 122L: return "V_SgAsmDwarfReferenceType";
            case 123L: return "V_SgAsmDwarfRestrictType";
            case 124L: return "V_SgAsmDwarfSetType";
            case 125L: return "V_SgAsmDwarfSharedType";
            case 126L: return "V_SgAsmDwarfStringType";
            case 127L: return "V_SgAsmDwarfStructureType";
            case 128L: return "V_SgAsmDwarfSubprogram";
            case 129L: return "V_SgAsmDwarfSubrangeType";
            case 130L: return "V_SgAsmDwarfSubroutineType";
            case 131L: return "V_SgAsmDwarfTemplateTypeParameter";
            case 132L: return "V_SgAsmDwarfTemplateValueParameter";
            case 133L: return "V_SgAsmDwarfThrownType";
            case 134L: return "V_SgAsmDwarfTryBlock";
            case 135L: return "V_SgAsmDwarfTypedef";
            case 136L: return "V_SgAsmDwarfUnionType";
            case 137L: return "V_SgAsmDwarfUnknownConstruct";
            case 138L: return "V_SgAsmDwarfUnspecifiedParameters";
            case 139L: return "V_SgAsmDwarfUnspecifiedType";
            case 140L: return "V_SgAsmDwarfUpcRelaxedType";
            case 141L: return "V_SgAsmDwarfUpcSharedType";
            case 142L: return "V_SgAsmDwarfUpcStrictType";
            case 143L: return "V_SgAsmDwarfVariable";
            case 144L: return "V_SgAsmDwarfVariant";
            case 145L: return "V_SgAsmDwarfVariantPart";
            case 146L: return "V_SgAsmDwarfVolatileType";
            case 147L: return "V_SgAsmDwarfWithStmt";
            case 148L: return "V_SgAsmElfDynamicEntry";
            case 149L: return "V_SgAsmElfDynamicEntryList";
            case 150L: return "V_SgAsmElfDynamicSection";
            case 151L: return "V_SgAsmElfEHFrameEntryCI";
            case 152L: return "V_SgAsmElfEHFrameEntryCIList";
            case 153L: return "V_SgAsmElfEHFrameEntryFD";
            case 154L: return "V_SgAsmElfEHFrameEntryFDList";
            case 155L: return "V_SgAsmElfEHFrameSection";
            case 156L: return "V_SgAsmElfFileHeader";
            case 157L: return "V_SgAsmElfNoteEntry";
            case 158L: return "V_SgAsmElfNoteEntryList";
            case 159L: return "V_SgAsmElfNoteSection";
            case 160L: return "V_SgAsmElfRelocEntry";
            case 161L: return "V_SgAsmElfRelocEntryList";
            case 162L: return "V_SgAsmElfRelocSection";
            case 163L: return "V_SgAsmElfSection";
            case 164L: return "V_SgAsmElfSectionTable";
            case 165L: return "V_SgAsmElfSectionTableEntry";
            case 166L: return "V_SgAsmElfSegmentTable";
            case 167L: return "V_SgAsmElfSegmentTableEntry";
            case 168L: return "V_SgAsmElfSegmentTableEntryList";
            case 169L: return "V_SgAsmElfStringSection";
            case 170L: return "V_SgAsmElfStrtab";
            case 171L: return "V_SgAsmElfSymbol";
            case 172L: return "V_SgAsmElfSymbolList";
            case 173L: return "V_SgAsmElfSymbolSection";
            case 174L: return "V_SgAsmElfSymverDefinedAux";
            case 175L: return "V_SgAsmElfSymverDefinedAuxList";
            case 176L: return "V_SgAsmElfSymverDefinedEntry";
            case 177L: return "V_SgAsmElfSymverDefinedEntryList";
            case 178L: return "V_SgAsmElfSymverDefinedSection";
            case 179L: return "V_SgAsmElfSymverEntry";
            case 180L: return "V_SgAsmElfSymverEntryList";
            case 181L: return "V_SgAsmElfSymverNeededAux";
            case 182L: return "V_SgAsmElfSymverNeededAuxList";
            case 183L: return "V_SgAsmElfSymverNeededEntry";
            case 184L: return "V_SgAsmElfSymverNeededEntryList";
            case 185L: return "V_SgAsmElfSymverNeededSection";
            case 186L: return "V_SgAsmElfSymverSection";
            case 187L: return "V_SgAsmExecutableFileFormat";
            case 188L: return "V_SgAsmExprListExp";
            case 189L: return "V_SgAsmExpression";
            case 190L: return "V_SgAsmSynthesizedFieldDeclaration";
            case 191L: return "V_SgAsmFloatType";
            case 192L: return "V_SgAsmFloatValueExpression";
            case 193L: return "V_SgAsmFunction";
            case 194L: return "V_SgAsmGenericDLL";
            case 195L: return "V_SgAsmGenericDLLList";
            case 196L: return "V_SgAsmGenericFile";
            case 197L: return "V_SgAsmGenericFileList";
            case 198L: return "V_SgAsmGenericFormat";
            case 199L: return "V_SgAsmGenericHeader";
            case 200L: return "V_SgAsmGenericHeaderList";
            case 201L: return "V_SgAsmGenericSection";
            case 202L: return "V_SgAsmGenericSectionList";
            case 203L: return "V_SgAsmGenericString";
            case 204L: return "V_SgAsmGenericStrtab";
            case 205L: return "V_SgAsmGenericSymbol";
            case 206L: return "V_SgAsmGenericSymbolList";
            case 207L: return "V_SgAsmIndirectRegisterExpression";
            case 208L: return "V_SgAsmInstruction";
            case 209L: return "V_SgAsmIntegerValueExpression";
            case 210L: return "V_SgAsmIntegerType";
            case 211L: return "V_SgAsmInterpretation";
            case 212L: return "V_SgAsmInterpretationList";
            case 213L: return "V_SgAsmJvmAttribute";
            case 214L: return "V_SgAsmJvmCodeAttribute";
            case 215L: return "V_SgAsmJvmMethod";
            case 216L: return "V_SgAsmJvmConstantPool";
            case 217L: return "V_SgAsmJvmConstantPoolEntry";
            case 218L: return "V_SgAsmJvmConstantValue";
            case 219L: return "V_SgAsmJvmInstruction";
            case 220L: return "V_SgAsmJvmFileHeader";
            case 221L: return "V_SgAsmJvmNode";
            case 222L: return "V_SgAsmJvmSignature";
            case 223L: return "V_SgAsmJvmSourceFile";
            case 224L: return "V_SgAsmLEEntryPoint";
            case 225L: return "V_SgAsmLEEntryTable";
            case 226L: return "V_SgAsmLEFileHeader";
            case 227L: return "V_SgAsmLENameTable";
            case 228L: return "V_SgAsmLEPageTable";
            case 229L: return "V_SgAsmLEPageTableEntry";
            case 230L: return "V_SgAsmLERelocTable";
            case 231L: return "V_SgAsmLESection";
            case 232L: return "V_SgAsmLESectionTable";
            case 233L: return "V_SgAsmLESectionTableEntry";
            case 234L: return "V_SgAsmM68kInstruction";
            case 235L: return "V_SgAsmMemoryReferenceExpression";
            case 236L: return "V_SgAsmMipsInstruction";
            case 237L: return "V_SgAsmNEEntryPoint";
            case 238L: return "V_SgAsmNEEntryTable";
            case 239L: return "V_SgAsmNEFileHeader";
            case 240L: return "V_SgAsmNEModuleTable";
            case 241L: return "V_SgAsmNENameTable";
            case 242L: return "V_SgAsmNERelocEntry";
            case 243L: return "V_SgAsmNERelocTable";
            case 244L: return "V_SgAsmNESection";
            case 245L: return "V_SgAsmNESectionTable";
            case 246L: return "V_SgAsmNESectionTableEntry";
            case 247L: return "V_SgAsmNEStringTable";
            case 248L: return "V_SgAsmNode";
            case 249L: return "V_SgAsmOp";
            case 250L: return "V_SgAsmOperandList";
            case 251L: return "V_SgAsmPEExportDirectory";
            case 252L: return "V_SgAsmPEExportEntry";
            case 253L: return "V_SgAsmPEExportEntryList";
            case 254L: return "V_SgAsmPEExportSection";
            case 255L: return "V_SgAsmPEFileHeader";
            case 256L: return "V_SgAsmPEImportDirectory";
            case 257L: return "V_SgAsmPEImportDirectoryList";
            case 258L: return "V_SgAsmPEImportItem";
            case 259L: return "V_SgAsmPEImportItemList";
            case 260L: return "V_SgAsmPEImportSection";
            case 261L: return "V_SgAsmPERVASizePair";
            case 262L: return "V_SgAsmPERVASizePairList";
            case 263L: return "V_SgAsmPESection";
            case 264L: return "V_SgAsmPESectionTable";
            case 265L: return "V_SgAsmPESectionTableEntry";
            case 266L: return "V_SgAsmPEStringSection";
            case 267L: return "V_SgAsmPowerpcInstruction";
            case 268L: return "V_SgAsmRegisterNames";
            case 269L: return "V_SgAsmRegisterReferenceExpression";
            case 270L: return "V_SgAsmRiscOperation";
            case 271L: return "V_SgAsmScalarType";
            case 272L: return "V_SgAsmStatement";
            case 273L: return "V_SgAsmStaticData";
            case 274L: return "V_SgAsmStmt";
            case 275L: return "V_SgAsmStoredString";
            case 276L: return "V_SgAsmStringStorage";
            case 277L: return "V_SgAsmType";
            case 278L: return "V_SgAsmUnaryExpression";
            case 279L: return "V_SgAsmUnaryMinus";
            case 280L: return "V_SgAsmUnaryPlus";
            case 281L: return "V_SgAsmUnaryRrx";
            case 282L: return "V_SgAsmUnarySignedExtend";
            case 283L: return "V_SgAsmUnaryUnsignedExtend";
            case 284L: return "V_SgAsmUnaryTruncate";
            case 285L: return "V_SgAsmValueExpression";
            case 286L: return "V_SgAsmVectorType";
            case 287L: return "V_SgAsmX86Instruction";
            case 288L: return "V_SgAsmBinaryAddressSymbol";
            case 289L: return "V_SgAsmBinaryDataSymbol";
            case 290L: return "V_SgAssertStmt";
            case 291L: return "V_SgAssignInitializer";
            case 292L: return "V_SgAssignOp";
            case 293L: return "V_SgAssignStatement";
            case 294L: return "V_SgAssignedGotoStatement";
            case 295L: return "V_SgAssociateStatement";
            case 296L: return "V_SgAsteriskShapeExp";
            case 297L: return "V_SgAtOp";
            case 298L: return "V_SgAttribute";
            case 299L: return "V_SgAttributeSpecificationStatement";
            case 300L: return "V_SgAutoType";
            case 301L: return "V_SgAwaitExpression";
            case 302L: return "V_SgBackspaceStatement";
            case 303L: return "V_SgBaseClass";
            case 304L: return "V_SgExpBaseClass";
            case 305L: return "V_SgBaseClassModifier";
            case 306L: return "V_SgBasicBlock";
            case 307L: return "V_SgBidirectionalGraph";
            case 308L: return "V_SgBinaryComposite";
            case 309L: return "V_SgBinaryOp";
            case 310L: return "V_SgBitAndOp";
            case 311L: return "V_SgBitAttribute";
            case 312L: return "V_SgBitComplementOp";
            case 313L: return "V_SgBitEqvOp";
            case 314L: return "V_SgBitOrOp";
            case 315L: return "V_SgBitXorOp";
            case 316L: return "V_SgBlockDataStatement";
            case 317L: return "V_SgBoolValExp";
            case 318L: return "V_SgBreakStmt";
            case 319L: return "V_SgBracedInitializer";
            case 320L: return "V_SgC_PreprocessorDirectiveStatement";
            case 321L: return "V_SgCaseOptionStmt";
            case 322L: return "V_SgCastExp";
            case 323L: return "V_SgCatchOptionStmt";
            case 324L: return "V_SgCatchStatementSeq";
            case 325L: return "V_SgCharVal";
            case 326L: return "V_SgChar16Val";
            case 327L: return "V_SgChar32Val";
            case 328L: return "V_SgChooseExpression";
            case 329L: return "V_SgClassDecl_attr";
            case 330L: return "V_SgClassDeclaration";
            case 331L: return "V_SgClassDefinition";
            case 332L: return "V_SgClassNameRefExp";
            case 333L: return "V_SgClassSymbol";
            case 334L: return "V_SgClassType";
            case 335L: return "V_SgClinkageDeclarationStatement";
            case 336L: return "V_SgClinkageEndStatement";
            case 337L: return "V_SgClinkageStartStatement";
            case 338L: return "V_SgCloseStatement";
            case 339L: return "V_SgColonShapeExp";
            case 340L: return "V_SgCommaOpExp";
            case 341L: return "V_SgCommonBlock";
            case 342L: return "V_SgCommonBlockObject";
            case 343L: return "V_SgCommonSymbol";
            case 344L: return "V_SgComplexVal";
            case 345L: return "V_SgComprehension";
            case 347L: return "V_SgCompoundAssignOp";
            case 348L: return "V_SgCompoundInitializer";
            case 349L: return "V_SgCompoundLiteralExp";
            case 350L: return "V_SgComputedGotoStatement";
            case 351L: return "V_SgConcatenationOp";
            case 352L: return "V_SgConditionalExp";
            case 353L: return "V_SgConjugateOp";
            case 354L: return "V_SgConstVolatileModifier";
            case 355L: return "V_SgConstructorInitializer";
            case 356L: return "V_SgContainsStatement";
            case 357L: return "V_SgContinueStmt";
            case 358L: return "V_SgCtorInitializerList";
            case 359L: return "V_SgDataStatementGroup";
            case 360L: return "V_SgDataStatementObject";
            case 361L: return "V_SgDataStatementValue";
            case 362L: return "V_SgDeadIfDirectiveStatement";
            case 363L: return "V_SgDeallocateStatement";
            case 364L: return "V_SgDeclarationModifier";
            case 365L: return "V_SgDeclarationScope";
            case 366L: return "V_SgDeclarationStatement";
            case 367L: return "V_SgDeclType";
            case 368L: return "V_SgDefaultOptionStmt";
            case 369L: return "V_SgDefaultSymbol";
            case 370L: return "V_SgDefineDirectiveStatement";
            case 371L: return "V_SgDeleteExp";
            case 372L: return "V_SgDerivedTypeStatement";
            case 373L: return "V_SgDesignatedInitializer";
            case 374L: return "V_SgDictionaryComprehension";
            case 375L: return "V_SgDictionaryExp";
            case 376L: return "V_SgDimensionObject";
            case 378L: return "V_SgDirectedGraphEdge";
            case 380L: return "V_SgDirectory";
            case 381L: return "V_SgDirectoryList";
            case 382L: return "V_SgDivAssignOp";
            case 383L: return "V_SgDivideOp";
            case 384L: return "V_SgDoWhileStmt";
            case 385L: return "V_SgDotExp";
            case 386L: return "V_SgDotStarOp";
            case 387L: return "V_SgDoubleVal";
            case 388L: return "V_SgElaboratedTypeModifier";
            case 389L: return "V_SgElementwiseOp";
            case 390L: return "V_SgElementwiseAddOp";
            case 391L: return "V_SgElementwiseDivideOp";
            case 392L: return "V_SgElementwiseLeftDivideOp";
            case 393L: return "V_SgElementwiseMultiplyOp";
            case 394L: return "V_SgElementwisePowerOp";
            case 395L: return "V_SgElementwiseSubtractOp";
            case 396L: return "V_SgElseDirectiveStatement";
            case 397L: return "V_SgElseWhereStatement";
            case 398L: return "V_SgElseifDirectiveStatement";
            case 399L: return "V_SgEmptyDeclaration";
            case 400L: return "V_SgEmptyDirectiveStatement";
            case 401L: return "V_SgEndfileStatement";
            case 402L: return "V_SgEndifDirectiveStatement";
            case 403L: return "V_SgEntryStatement";
            case 404L: return "V_SgEnumDeclaration";
            case 405L: return "V_SgEnumFieldSymbol";
            case 406L: return "V_SgEnumSymbol";
            case 407L: return "V_SgEnumType";
            case 408L: return "V_SgEnumVal";
            case 409L: return "V_SgEqualityOp";
            case 410L: return "V_SgEquivalenceStatement";
            case 411L: return "V_SgErrorDirectiveStatement";
            case 412L: return "V_SgExecStatement";
            case 413L: return "V_SgExponentiationOp";
            case 414L: return "V_SgExponentiationAssignOp";
            case 415L: return "V_SgExprListExp";
            case 416L: return "V_SgExprStatement";
            case 417L: return "V_SgExpression";
            case 418L: return "V_SgExpressionRoot";
            case 419L: return "V_SgFile";
            case 420L: return "V_SgFileList";
            case 421L: return "V_SgFloatVal";
            case 422L: return "V_SgFloat128Val";
            case 423L: return "V_SgFloat80Val";
            case 424L: return "V_SgFoldExpression";
            case 425L: return "V_SgFlushStatement";
            case 426L: return "V_SgForAllStatement";
            case 427L: return "V_SgForInitStatement";
            case 428L: return "V_SgForStatement";
            case 429L: return "V_SgFormatItem";
            case 430L: return "V_SgFormatItemList";
            case 431L: return "V_SgFormatStatement";
            case 432L: return "V_SgFortranDo";
            case 433L: return "V_SgFortranIncludeLine";
            case 434L: return "V_SgFortranNonblockedDo";
            case 435L: return "V_SgFuncDecl_attr";
            case 436L: return "V_SgFunctionCallExp";
            case 437L: return "V_SgFunctionDeclaration";
            case 438L: return "V_SgFunctionDefinition";
            case 439L: return "V_SgFunctionParameterScope";
            case 440L: return "V_SgFunctionModifier";
            case 441L: return "V_SgFunctionParameterList";
            case 442L: return "V_SgFunctionParameterRefExp";
            case 443L: return "V_SgFunctionParameterTypeList";
            case 444L: return "V_SgFunctionRefExp";
            case 445L: return "V_SgFunctionSymbol";
            case 446L: return "V_SgFunctionType";
            case 447L: return "V_SgFunctionTypeSymbol";
            case 448L: return "V_SgFunctionTypeTable";
            case 449L: return "V_SgTypeTable";
            case 450L: return "V_SgGlobal";
            case 451L: return "V_SgGotoStatement";
            case 452L: return "V_SgGraph";
            case 453L: return "V_SgGraphEdge";
            case 454L: return "V_SgGraphEdgeList";
            case 455L: return "V_SgGraphNode";
            case 456L: return "V_SgGraphNodeList";
            case 457L: return "V_SgGreaterOrEqualOp";
            case 458L: return "V_SgGreaterThanOp";
            case 459L: return "V_SgIOItemExpression";
            case 460L: return "V_SgIOStatement";
            case 461L: return "V_SgIdentDirectiveStatement";
            case 462L: return "V_SgIfDirectiveStatement";
            case 463L: return "V_SgIfStmt";
            case 464L: return "V_SgIfdefDirectiveStatement";
            case 465L: return "V_SgIfndefDirectiveStatement";
            case 466L: return "V_SgImageControlStatement";
            case 467L: return "V_SgImagPartOp";
            case 468L: return "V_SgImplicitStatement";
            case 469L: return "V_SgImpliedDo";
            case 470L: return "V_SgImportStatement";
            case 471L: return "V_SgIncidenceDirectedGraph";
            case 472L: return "V_SgIncidenceUndirectedGraph";
            case 473L: return "V_SgIncludeDirectiveStatement";
            case 474L: return "V_SgIncludeFile";
            case 475L: return "V_SgIncludeNextDirectiveStatement";
            case 476L: return "V_SgInitializedName";
            case 477L: return "V_SgInitializer";
            case 478L: return "V_SgInquireStatement";
            case 479L: return "V_SgIntKeyedBidirectionalGraph";
            case 480L: return "V_SgIntVal";
            case 481L: return "V_SgIntegerDivideOp";
            case 482L: return "V_SgIntegerDivideAssignOp";
            case 483L: return "V_SgInterfaceBody";
            case 484L: return "V_SgHeaderFileBody";
            case 485L: return "V_SgHeaderFileReport";
            case 486L: return "V_SgInterfaceStatement";
            case 487L: return "V_SgInterfaceSymbol";
            case 488L: return "V_SgIntrinsicSymbol";
            case 489L: return "V_SgIsOp";
            case 490L: return "V_SgIsNotOp";
            case 491L: return "V_SgIorAssignOp";
            case 492L: return "V_SgJovialBitType";
            case 493L: return "V_SgJovialBitVal";
            case 494L: return "V_SgJovialTableType";
            case 495L: return "V_SgJovialCompoolStatement";
            case 496L: return "V_SgJovialForThenStatement";
            case 497L: return "V_SgJovialDefineDeclaration";
            case 498L: return "V_SgJovialDirectiveStatement";
            case 499L: return "V_SgJovialOverlayDeclaration";
            case 500L: return "V_SgJovialPresetPositionExp";
            case 501L: return "V_SgJovialTablePresetExp";
            case 502L: return "V_SgJovialTableStatement";
            case 503L: return "V_SgKeyDatumPair";
            case 504L: return "V_SgCudaKernelExecConfig";
            case 505L: return "V_SgCudaKernelCallExp";
            case 506L: return "V_SgLabelRefExp";
            case 507L: return "V_SgLabelStatement";
            case 508L: return "V_SgJavaLabelStatement";
            case 509L: return "V_SgLabelSymbol";
            case 510L: return "V_SgJavaLabelSymbol";
            case 511L: return "V_SgLambdaCapture";
            case 512L: return "V_SgLambdaCaptureList";
            case 513L: return "V_SgLambdaExp";
            case 514L: return "V_SgLambdaRefExp";
            case 515L: return "V_SgLeftDivideOp";
            case 516L: return "V_SgLessOrEqualOp";
            case 517L: return "V_SgLessThanOp";
            case 518L: return "V_SgLineDirectiveStatement";
            case 519L: return "V_SgLinemarkerDirectiveStatement";
            case 520L: return "V_SgLinkageModifier";
            case 521L: return "V_SgListComprehension";
            case 522L: return "V_SgListExp";
            case 523L: return "V_SgLocatedNode";
            case 524L: return "V_SgLocatedNodeSupport";
            case 525L: return "V_SgLongDoubleVal";
            case 526L: return "V_SgLongIntVal";
            case 527L: return "V_SgLongLongIntVal";
            case 528L: return "V_SgLshiftAssignOp";
            case 529L: return "V_SgLshiftOp";
            case 530L: return "V_SgMagicColonExp";
            case 531L: return "V_SgMatrixExp";
            case 532L: return "V_SgMatrixTransposeOp";
            case 533L: return "V_SgMatlabForStatement";
            case 534L: return "V_SgMemberFunctionDeclaration";
            case 535L: return "V_SgMemberFunctionRefExp";
            case 536L: return "V_SgMemberFunctionSymbol";
            case 537L: return "V_SgMemberFunctionType";
            case 538L: return "V_SgMembershipOp";
            case 539L: return "V_SgMicrosoftAttributeDeclaration";
            case 540L: return "V_SgMinusAssignOp";
            case 541L: return "V_SgMinusMinusOp";
            case 542L: return "V_SgMinusOp";
            case 543L: return "V_SgModAssignOp";
            case 544L: return "V_SgModOp";
            case 545L: return "V_SgModifier";
            case 546L: return "V_SgModifierNodes";
            case 547L: return "V_SgModifierType";
            case 548L: return "V_SgModuleStatement";
            case 549L: return "V_SgModuleSymbol";
            case 550L: return "V_SgMultAssignOp";
            case 551L: return "V_SgMultiplyOp";
            case 552L: return "V_SgName";
            case 553L: return "V_SgNameGroup";
            case 554L: return "V_SgNamedType";
            case 555L: return "V_SgNamelistStatement";
            case 556L: return "V_SgNamespaceAliasDeclarationStatement";
            case 557L: return "V_SgNamespaceDeclarationStatement";
            case 558L: return "V_SgNamespaceDefinitionStatement";
            case 559L: return "V_SgNamespaceSymbol";
            case 560L: return "V_SgNaryOp";
            case 561L: return "V_SgNaryBooleanOp";
            case 562L: return "V_SgNaryComparisonOp";
            case 563L: return "V_SgNewExp";
            case 564L: return "V_SgNode";
            case 565L: return "V_SgNoexceptOp";
            case 566L: return "V_SgNotEqualOp";
            case 567L: return "V_SgNotOp";
            case 568L: return "V_SgNonMembershipOp";
            case 569L: return "V_SgNonrealDecl";
            case 570L: return "V_SgNonrealRefExp";
            case 571L: return "V_SgNonrealSymbol";
            case 572L: return "V_SgNonrealType";
            case 573L: return "V_SgNonrealBaseClass";
            case 574L: return "V_SgNullExpression";
            case 575L: return "V_SgNullptrValExp";
            case 576L: return "V_SgNullStatement";
            case 577L: return "V_SgNullifyStatement";
            case 578L: return "V_SgOmpAtomicStatement";
            case 579L: return "V_SgOmpBarrierStatement";
            case 580L: return "V_SgOmpCriticalStatement";
            case 581L: return "V_SgOmpClauseBodyStatement";
            case 582L: return "V_SgOmpBodyStatement";
            case 583L: return "V_SgOmpDoStatement";
            case 584L: return "V_SgOmpFlushStatement";
            case 585L: return "V_SgOmpDeclareSimdStatement";
            case 586L: return "V_SgOmpForStatement";
            case 587L: return "V_SgOmpForSimdStatement";
            case 588L: return "V_SgOmpMasterStatement";
            case 589L: return "V_SgOmpOrderedStatement";
            case 590L: return "V_SgOmpParallelStatement";
            case 591L: return "V_SgOmpSectionStatement";
            case 592L: return "V_SgOmpSectionsStatement";
            case 593L: return "V_SgOmpSingleStatement";
            case 594L: return "V_SgOmpTaskStatement";
            case 595L: return "V_SgOmpTaskwaitStatement";
            case 596L: return "V_SgOmpThreadprivateStatement";
            case 597L: return "V_SgOmpWorkshareStatement";
            case 598L: return "V_SgOmpTargetStatement";
            case 599L: return "V_SgOmpTargetDataStatement";
            case 600L: return "V_SgOmpSimdStatement";
            case 601L: return "V_SgOmpClause";
            case 602L: return "V_SgOmpBeginClause";
            case 603L: return "V_SgOmpCollapseClause";
            case 604L: return "V_SgOmpCopyinClause";
            case 605L: return "V_SgOmpCopyprivateClause";
            case 606L: return "V_SgOmpDefaultClause";
            case 607L: return "V_SgOmpEndClause";
            case 608L: return "V_SgOmpExpressionClause";
            case 609L: return "V_SgOmpFirstprivateClause";
            case 610L: return "V_SgOmpIfClause";
            case 611L: return "V_SgOmpFinalClause";
            case 612L: return "V_SgOmpPriorityClause";
            case 613L: return "V_SgOmpDeviceClause";
            case 614L: return "V_SgOmpLastprivateClause";
            case 615L: return "V_SgOmpNowaitClause";
            case 616L: return "V_SgOmpNumThreadsClause";
            case 617L: return "V_SgOmpOrderedClause";
            case 618L: return "V_SgOmpPrivateClause";
            case 619L: return "V_SgOmpReductionClause";
            case 620L: return "V_SgOmpScheduleClause";
            case 621L: return "V_SgOmpSharedClause";
            case 622L: return "V_SgOmpUntiedClause";
            case 623L: return "V_SgOmpMergeableClause";
            case 624L: return "V_SgOmpVariablesClause";
            case 625L: return "V_SgOmpMapClause";
            case 626L: return "V_SgOmpSafelenClause";
            case 627L: return "V_SgOmpSimdlenClause";
            case 628L: return "V_SgOmpLinearClause";
            case 629L: return "V_SgOmpUniformClause";
            case 630L: return "V_SgOmpAlignedClause";
            case 631L: return "V_SgOmpProcBindClause";
            case 632L: return "V_SgOmpAtomicClause";
            case 633L: return "V_SgOmpInbranchClause";
            case 634L: return "V_SgOmpNotinbranchClause";
            case 635L: return "V_SgOmpDependClause";
            case 636L: return "V_SgOpenclAccessModeModifier";
            case 637L: return "V_SgOpenStatement";
            case 638L: return "V_SgOptions";
            case 639L: return "V_SgOrOp";
            case 640L: return "V_SgParameterStatement";
            case 641L: return "V_SgPartialFunctionModifierType";
            case 642L: return "V_SgPartialFunctionType";
            case 643L: return "V_SgPassStatement";
            case 644L: return "V_SgPlusAssignOp";
            case 645L: return "V_SgPlusPlusOp";
            case 646L: return "V_SgPntrArrRefExp";
            case 647L: return "V_SgPointerAssignOp";
            case 648L: return "V_SgPointerDerefExp";
            case 649L: return "V_SgPointerMemberType";
            case 650L: return "V_SgPointerType";
            case 651L: return "V_SgPowerOp";
            case 652L: return "V_SgPragma";
            case 653L: return "V_SgPragmaDeclaration";
            case 654L: return "V_SgPrintStatement";
            case 655L: return "V_SgProcedureHeaderStatement";
            case 656L: return "V_SgProgramHeaderStatement";
            case 657L: return "V_SgProject";
            case 658L: return "V_SgPseudoDestructorRefExp";
            case 659L: return "V_SgPythonGlobalStmt";
            case 660L: return "V_SgPythonPrintStmt";
            case 661L: return "V_SgQualifiedName";
            case 662L: return "V_SgQualifiedNameType";
            case 663L: return "V_SgRangeExp";
            case 664L: return "V_SgRangeBasedForStatement";
            case 665L: return "V_SgReadStatement";
            case 666L: return "V_SgRealPartOp";
            case 667L: return "V_SgRefExp";
            case 668L: return "V_SgReferenceType";
            case 669L: return "V_SgRemOp";
            case 670L: return "V_SgRenamePair";
            case 671L: return "V_SgRenameSymbol";
            case 672L: return "V_SgReplicationOp";
            case 673L: return "V_SgReturnStmt";
            case 674L: return "V_SgRewindStatement";
            case 675L: return "V_SgRshiftAssignOp";
            case 676L: return "V_SgRshiftOp";
            case 677L: return "V_SgRvalueReferenceType";
            case 678L: return "V_SgJavaUnsignedRshiftAssignOp";
            case 679L: return "V_SgJavaUnsignedRshiftOp";
            case 680L: return "V_SgScopeOp";
            case 681L: return "V_SgScopeStatement";
            case 682L: return "V_SgSequenceStatement";
            case 683L: return "V_SgSetComprehension";
            case 684L: return "V_SgShortVal";
            case 685L: return "V_SgSizeOfOp";
            case 686L: return "V_SgAlignOfOp";
            case 687L: return "V_SgJavaInstanceOfOp";
            case 688L: return "V_SgSourceFile";
            case 689L: return "V_SgSpaceshipOp";
            case 690L: return "V_SgSpawnStmt";
            case 691L: return "V_SgSyncAllStatement";
            case 692L: return "V_SgSyncImagesStatement";
            case 693L: return "V_SgSyncMemoryStatement";
            case 694L: return "V_SgSyncTeamStatement";
            case 695L: return "V_SgLockStatement";
            case 696L: return "V_SgUnlockStatement";
            case 697L: return "V_SgJavaThrowStatement";
            case 698L: return "V_SgJavaForEachStatement";
            case 699L: return "V_SgJavaSynchronizedStatement";
            case 700L: return "V_SgJavaParameterizedType";
            case 701L: return "V_SgJavaWildcardType";
            case 702L: return "V_SgProcessControlStatement";
            case 703L: return "V_SgSignedCharVal";
            case 704L: return "V_SgSpecialFunctionModifier";
            case 705L: return "V_SgStatement";
            case 706L: return "V_SgStaticAssertionDeclaration";
            case 707L: return "V_SgStmtDeclarationStatement";
            case 708L: return "V_SgStatementExpression";
            case 709L: return "V_SgStatementFunctionStatement";
            case 710L: return "V_SgStorageModifier";
            case 711L: return "V_SgStringConversion";
            case 712L: return "V_SgStringKeyedBidirectionalGraph";
            case 713L: return "V_SgStringVal";
            case 714L: return "V_SgStructureModifier";
            case 715L: return "V_SgSubscriptExpression";
            case 716L: return "V_SgSubtractOp";
            case 717L: return "V_SgSupport";
            case 718L: return "V_SgSwitchStatement";
            case 719L: return "V_SgSymbol";
            case 720L: return "V_SgSymbolTable";
            case 721L: return "V_SgTemplateArgument";
            case 722L: return "V_SgTemplateArgumentList";
            case 723L: return "V_SgTemplateDeclaration";
            case 724L: return "V_SgTemplateClassDeclaration";
            case 725L: return "V_SgTemplateClassSymbol";
            case 726L: return "V_SgTemplateFunctionDeclaration";
            case 727L: return "V_SgTemplateFunctionRefExp";
            case 728L: return "V_SgTemplateFunctionSymbol";
            case 729L: return "V_SgTemplateMemberFunctionDeclaration";
            case 730L: return "V_SgTemplateMemberFunctionRefExp";
            case 731L: return "V_SgTemplateMemberFunctionSymbol";
            case 732L: return "V_SgTemplateTypedefDeclaration";
            case 733L: return "V_SgTemplateTypedefSymbol";
            case 734L: return "V_SgTemplateVariableDeclaration";
            case 735L: return "V_SgTemplateVariableSymbol";
            case 736L: return "V_SgTemplateClassDefinition";
            case 737L: return "V_SgTemplateFunctionDefinition";
            case 738L: return "V_SgTemplateInstantiationDecl";
            case 739L: return "V_SgTemplateInstantiationDefn";
            case 740L: return "V_SgTemplateInstantiationDirectiveStatement";
            case 741L: return "V_SgTemplateInstantiationFunctionDecl";
            case 742L: return "V_SgTemplateInstantiationMemberFunctionDecl";
            case 743L: return "V_SgTemplateInstantiationTypedefDeclaration";
            case 744L: return "V_SgTemplateParameter";
            case 745L: return "V_SgTemplateParameterVal";
            case 746L: return "V_SgTemplateParameterList";
            case 747L: return "V_SgTemplateSymbol";
            case 748L: return "V_SgTemplateType";
            case 749L: return "V_SgThisExp";
            case 750L: return "V_SgTypeTraitBuiltinOperator";
            case 751L: return "V_SgSuperExp";
            case 752L: return "V_SgThrowOp";
            case 753L: return "V_SgToken";
            case 754L: return "V_SgTryStmt";
            case 755L: return "V_SgTupleExp";
            case 756L: return "V_SgType";
            case 757L: return "V_SgTypeBool";
            case 758L: return "V_SgTypeChar";
            case 759L: return "V_SgTypeChar16";
            case 760L: return "V_SgTypeChar32";
            case 761L: return "V_SgTypeComplex";
            case 762L: return "V_SgTypeDefault";
            case 763L: return "V_SgTypeExpression";
            case 764L: return "V_SgTypeLabel";
            case 765L: return "V_SgTypeDouble";
            case 766L: return "V_SgTypeEllipse";
            case 767L: return "V_SgTypeFixed";
            case 768L: return "V_SgTypeFloat";
            case 769L: return "V_SgTypeFloat128";
            case 770L: return "V_SgTypeFloat80";
            case 771L: return "V_SgTypeGlobalVoid";
            case 772L: return "V_SgTypeIdOp";
            case 773L: return "V_SgTypeImaginary";
            case 774L: return "V_SgTypeInt";
            case 775L: return "V_SgTypeLong";
            case 776L: return "V_SgTypeLongDouble";
            case 777L: return "V_SgTypeLongLong";
            case 778L: return "V_SgTypeModifier";
            case 779L: return "V_SgTypeMatrix";
            case 780L: return "V_SgTypeTuple";
            case 781L: return "V_SgTypeNullptr";
            case 782L: return "V_SgTypeOfType";
            case 783L: return "V_SgTypeShort";
            case 784L: return "V_SgTypeSigned128bitInteger";
            case 785L: return "V_SgTypeSignedChar";
            case 786L: return "V_SgTypeSignedInt";
            case 787L: return "V_SgTypeSignedLong";
            case 788L: return "V_SgTypeSignedLongLong";
            case 789L: return "V_SgTypeSignedShort";
            case 790L: return "V_SgTypeString";
            case 791L: return "V_SgTypeUnknown";
            case 792L: return "V_SgTypeUnsigned128bitInteger";
            case 793L: return "V_SgTypeUnsignedChar";
            case 794L: return "V_SgTypeUnsignedInt";
            case 795L: return "V_SgTypeUnsignedLong";
            case 796L: return "V_SgTypeUnsignedLongLong";
            case 797L: return "V_SgTypeUnsignedShort";
            case 798L: return "V_SgTypeVoid";
            case 799L: return "V_SgTypeWchar";
            case 800L: return "V_SgTypedefDeclaration";
            case 801L: return "V_SgTypedefSeq";
            case 802L: return "V_SgTypedefSymbol";
            case 803L: return "V_SgTypedefType";
            case 804L: return "V_SgUPC_AccessModifier";
            case 805L: return "V_SgUnaryAddOp";
            case 806L: return "V_SgUnaryOp";
            case 807L: return "V_SgUndefDirectiveStatement";
            case 808L: return "V_SgUndirectedGraphEdge";
            case 809L: return "V_SgUnknownArrayOrFunctionReference";
            case 810L: return "V_SgUnknownFile";
            case 812L: return "V_SgUnparse_Info";
            case 813L: return "V_SgUnsignedCharVal";
            case 814L: return "V_SgUnsignedIntVal";
            case 815L: return "V_SgUnsignedLongLongIntVal";
            case 816L: return "V_SgUnsignedLongVal";
            case 817L: return "V_SgUnsignedShortVal";
            case 818L: return "V_SgUpcBarrierStatement";
            case 819L: return "V_SgUpcBlocksizeofExpression";
            case 820L: return "V_SgUpcElemsizeofExpression";
            case 821L: return "V_SgUpcFenceStatement";
            case 822L: return "V_SgUpcForAllStatement";
            case 823L: return "V_SgUpcLocalsizeofExpression";
            case 824L: return "V_SgUpcMythread";
            case 825L: return "V_SgUpcNotifyStatement";
            case 826L: return "V_SgUpcThreads";
            case 827L: return "V_SgUpcWaitStatement";
            case 828L: return "V_SgUseStatement";
            case 829L: return "V_SgUserDefinedBinaryOp";
            case 830L: return "V_SgUserDefinedUnaryOp";
            case 831L: return "V_SgUsingDeclarationStatement";
            case 832L: return "V_SgUsingDirectiveStatement";
            case 833L: return "V_SgValueExp";
            case 834L: return "V_SgVarArgCopyOp";
            case 835L: return "V_SgVarArgEndOp";
            case 836L: return "V_SgVarArgOp";
            case 837L: return "V_SgVarArgStartOneOperandOp";
            case 838L: return "V_SgVarArgStartOp";
            case 839L: return "V_SgVarRefExp";
            case 840L: return "V_SgVariableDeclaration";
            case 841L: return "V_SgVariableDefinition";
            case 842L: return "V_SgVariableSymbol";
            case 843L: return "V_SgVariantExpression";
            case 844L: return "V_SgVariantStatement";
            case 845L: return "V_SgVoidVal";
            case 846L: return "V_SgWaitStatement";
            case 847L: return "V_SgWarningDirectiveStatement";
            case 848L: return "V_SgWithStatement";
            case 849L: return "V_SgWcharVal";
            case 850L: return "V_SgWhereStatement";
            case 851L: return "V_SgWhileStmt";
            case 852L: return "V_SgWriteStatement";
            case 853L: return "V_SgXorAssignOp";
            case 854L: return "V_SgYieldExpression";
            case 855L: return "V_Sg_File_Info";
            case 856L: return "V_SgTypeCAFTeam";
            case 857L: return "V_SgCAFWithTeamStatement";
            case 858L: return "V_SgCAFCoExpression";
            case 859L: return "V_SgCallExpression";
            case 860L: return "V_SgTypeCrayPointer";
            case 861L: return "V_SgJavaImportStatement";
            case 862L: return "V_SgJavaPackageDeclaration";
            case 863L: return "V_SgJavaPackageStatement";
            case 864L: return "V_SgJavaImportStatementList";
            case 865L: return "V_SgJavaClassDeclarationList";
            case 866L: return "V_SgJavaMemberValuePair";
            case 867L: return "V_SgJavaAnnotation";
            case 868L: return "V_SgJavaMarkerAnnotation";
            case 869L: return "V_SgJavaSingleMemberAnnotation";
            case 870L: return "V_SgJavaNormalAnnotation";
            case 871L: return "V_SgJavaTypeExpression";
            case 872L: return "V_SgJavaQualifiedType";
            case 873L: return "V_SgClassExp";
            case 874L: return "V_SgJavaUnionType";
            case 875L: return "V_SgJavaParameterType";
            case 876L: return "V_SgAsyncStmt";
            case 877L: return "V_SgFinishStmt";
            case 878L: return "V_SgAtStmt";
            case 879L: return "V_SgAtomicStmt";
            case 881L: return "V_SgWhenStmt";
            case 882L: return "V_SgAtExp";
            case 883L: return "V_SgFinishExp";
            case 884L: return "V_SgHereExp";
            case 885L: return "V_SgDotDotExp";
            case 886L: return "V_SgAsmNullInstruction";
            case 887L: return "V_SgAdaComponentClause";
            case 888L: return "V_SgAdaIndexConstraint";
            case 889L: return "V_SgAdaModularType";
            case 890L: return "V_SgAdaRepresentationClause";
            case 891L: return "V_SgAdaFunctionRenamingDecl";
            case 892L: return "V_SgAdaSelectStmt";
            case 893L: return "V_SgAdaSelectAlternativeStmt";
            case 894L: return "V_SgAdaTerminateStmt";
            case 895L: return "V_SgAsmAarch32Instruction";
            case 896L: return "V_SgAsmAarch32Coprocessor";
            case 897L: return "V_SgAdaAttributeClause";
            case 898L: return "V_SgAsmBinaryConcat";
            case 899L: return "V_SgAsmByteOrder";
            case 900L: return "V_SgAdaDerivedType";
            case 901L: return "V_SgAdaAttributeExp";
            case 902L: return "V_SgAdaEnumRepresentationClause";
            case 903L: return "V_SgAsmBinaryPreupdate";
            case 904L: return "V_SgAsmBinaryPostupdate";
            case 905L: return "V_SgAdaOthersExp";
            case 906L: return "V_SgAdaRenamingSymbol";
            case 907L: return "V_SgAdaRenamingRefExp";
            case 908L: return "V_SgAdaGenericDecl";
            case 909L: return "V_SgAdaGenericDefn";
            case 910L: return "V_SgAdaFormalType";
            case 911L: return "V_SgAdaGenericSymbol";
            case 912L: return "V_SgAdaFormalTypeDecl";
            case 913L: return "V_SgAdaUnitRefExp";
            case 914L: return "V_SgAdaDiscriminatedTypeDecl";
            case 915L: return "V_SgAdaDiscriminatedType";
            case 916L: return "V_SgAdaDiscriminantConstraint";
            case 917L: return "V_SgAdaGenericInstanceDecl";
            case 918L: return "V_SgAdaUnscopedBlock";
            case 919L: return "V_SgAdaInheritedFunctionSymbol";
            case 920L: return "V_SgAdaProtectedBody";
            case 921L: return "V_SgAdaProtectedBodyDecl";
            case 922L: return "V_SgAdaProtectedSpec";
            case 923L: return "V_SgAdaProtectedSpecDecl";
            case 924L: return "V_SgAdaProtectedSymbol";
            case 925L: return "V_SgAdaProtectedRefExp";
            case 926L: return "V_SgAdaProtectedType";
            case 927L: return "V_SgAdaProtectedTypeDecl";
            case 928L: return "V_SgAdaDigitsConstraint";
            case 929L: return "V_SgAdaAncestorInitializer";
            case 930L: return "V_SgAdaDeltaConstraint";
            case 931L: return "V_SgAdaSubroutineType";
            case 932L: return "V_SgAdaGenericInstanceSymbol";
            case 933L: return "V_SgAdaFormalPackageDecl";
            case 934L: return "V_SgAdaFormalPackageSymbol";
            case 935L: return "V_SgAsmJvmAttributeTable";
            case 936L: return "V_SgAsmJvmMethodTable";
            case 937L: return "V_SgAsmJvmField";
            case 938L: return "V_SgAsmJvmFieldTable";
            case 939L: return "V_SgAsmJvmExceptionHandler";
            case 940L: return "V_SgAsmJvmExceptionTable";
            case 941L: return "V_SgAsmJvmClass";
            case 942L: return "V_SgAsmJvmLineNumberEntry";
            case 943L: return "V_SgAsmJvmLineNumberTable";
            case 944L: return "V_SgAsmJvmInnerClassesEntry";
            case 945L: return "V_SgAsmJvmInnerClasses";
            case 946L: return "V_SgAsmCilInstruction";
            case 947L: return "V_SgAsmStackExpression";
            case 948L: return "V_SgAsmJvmEnclosingMethod";
            case 949L: return "V_SgAdaNullConstraint";
            case 950L: return "V_SgAsmJvmModuleMainClass";
            case 951L: return "V_SgAsmInstructionList";
            case 952L: return "V_SgAsmCilNode";
            case 953L: return "V_SgAsmCilAssembly";
            case 954L: return "V_SgAsmCilAssemblyOS";
            case 955L: return "V_SgAsmCilAssemblyProcessor";
            case 956L: return "V_SgAsmCilAssemblyRef";
            case 957L: return "V_SgAsmCilAssemblyRefOS";
            case 958L: return "V_SgAsmCilAssemblyRefProcessor";
            case 959L: return "V_SgAsmCilClassLayout";
            case 960L: return "V_SgAsmCilConstant";
            case 961L: return "V_SgAsmCilCustomAttribute";
            case 962L: return "V_SgAsmCilDeclSecurity";
            case 963L: return "V_SgAsmCilEvent";
            case 964L: return "V_SgAsmCilEventMap";
            case 965L: return "V_SgAsmCilExportedType";
            case 966L: return "V_SgAsmCilField";
            case 967L: return "V_SgAsmCilFieldLayout";
            case 968L: return "V_SgAsmCilFieldMarshal";
            case 969L: return "V_SgAsmCilFieldRVA";
            case 970L: return "V_SgAsmCilFile";
            case 971L: return "V_SgAsmCilGenericParam";
            case 972L: return "V_SgAsmCilGenericParamConstraint";
            case 973L: return "V_SgAsmCilImplMap";
            case 974L: return "V_SgAsmCilInterfaceImpl";
            case 975L: return "V_SgAsmCilManifestResource";
            case 976L: return "V_SgAsmCilMemberRef";
            case 977L: return "V_SgAsmCilMethodDef";
            case 978L: return "V_SgAsmCilMethodImpl";
            case 979L: return "V_SgAsmCilMethodSemantics";
            case 980L: return "V_SgAsmCilMethodSpec";
            case 981L: return "V_SgAsmCilModule";
            case 982L: return "V_SgAsmCilModuleRef";
            case 983L: return "V_SgAsmCilNestedClass";
            case 984L: return "V_SgAsmCilParam";
            case 985L: return "V_SgAsmCilProperty";
            case 986L: return "V_SgAsmCilPropertyMap";
            case 987L: return "V_SgAsmCilStandAloneSig";
            case 988L: return "V_SgAsmCilTypeDef";
            case 989L: return "V_SgAsmCilTypeRef";
            case 990L: return "V_SgAsmCilTypeSpec";
            case 991L: return "V_SgAdaParameterList";
            case 992L: return "V_SgAsmCilMetadata";
            case 993L: return "V_SgAsmCilMetadataRoot";
            case 994L: return "V_SgAsmCilDataStream";
            case 995L: return "V_SgAsmCilMetadataHeap";
            case 996L: return "V_SgAsmCilUint8Heap";
            case 997L: return "V_SgAsmCilUint32Heap";
            case 998L: return "V_SgAsmCliHeader";
            case 999L: return "V_SgAdaVariantDecl";
            case 1000L: return "V_SgAdaVariantWhenStmt";
            case 1001L: return "V_SgAsmCilAssemblyTable";
            case 1002L: return "V_SgAsmCilAssemblyOSTable";
            case 1003L: return "V_SgAsmCilAssemblyProcessorTable";
            case 1004L: return "V_SgAsmCilAssemblyRefTable";
            case 1005L: return "V_SgAsmCilAssemblyRefOSTable";
            case 1006L: return "V_SgAsmCilAssemblyRefProcessorTable";
            case 1007L: return "V_SgAsmCilClassLayoutTable";
            case 1008L: return "V_SgAsmCilConstantTable";
            case 1009L: return "V_SgAsmCilCustomAttributeTable";
            case 1010L: return "V_SgAsmCilDeclSecurityTable";
            case 1011L: return "V_SgAsmCilEventTable";
            case 1012L: return "V_SgAsmCilEventMapTable";
            case 1013L: return "V_SgAsmCilExportedTypeTable";
            case 1014L: return "V_SgAsmCilFieldTable";
            case 1015L: return "V_SgAsmCilFieldLayoutTable";
            case 1016L: return "V_SgAsmCilFieldMarshalTable";
            case 1017L: return "V_SgAsmCilFieldRVATable";
            case 1018L: return "V_SgAsmCilFileTable";
            case 1019L: return "V_SgAsmCilGenericParamTable";
            case 1020L: return "V_SgAsmCilGenericParamConstraintTable";
            case 1021L: return "V_SgAsmCilImplMapTable";
            case 1022L: return "V_SgAsmCilInterfaceImplTable";
            case 1023L: return "V_SgAsmCilManifestResourceTable";
            case 1024L: return "V_SgAsmCilMemberRefTable";
            case 1025L: return "V_SgAsmCilMethodDefTable";
            case 1026L: return "V_SgAsmCilMethodImplTable";
            case 1027L: return "V_SgAsmCilMethodSemanticsTable";
            case 1028L: return "V_SgAsmCilMethodSpecTable";
            case 1029L: return "V_SgAsmCilModuleTable";
            case 1030L: return "V_SgAsmCilModuleRefTable";
            case 1031L: return "V_SgAsmCilNestedClassTable";
            case 1032L: return "V_SgAsmCilParamTable";
            case 1033L: return "V_SgAsmCilPropertyTable";
            case 1034L: return "V_SgAsmCilPropertyMapTable";
            case 1035L: return "V_SgAsmCilStandAloneSigTable";
            case 1036L: return "V_SgAsmCilTypeDefTable";
            case 1037L: return "V_SgAsmCilTypeRefTable";
            case 1038L: return "V_SgAsmCilTypeSpecTable";
            case 1039L: return "V_SgJvmComposite";
            case 1040L: return "V_SgFortranContinueStmt";
            case 1041L: return "V_SgAsmJvmStackMapTable";
            case 1042L: return "V_SgAsmJvmStackMapFrame";
            case 1043L: return "V_SgAsmJvmStackMapVerificationType";
            case 1044L: return "V_SgAsmJvmBootstrapMethod";
            case 1045L: return "V_SgAsmJvmBootstrapMethods";
            case 1046L: return "V_SgAsmJvmExceptions";
            case 1047L: return "V_SgAsmJvmNestMembers";
            case 1048L: return "V_SgAsmJvmNestHost";
            case 1049L: return "V_SgJovialLabelDeclaration";
            case 1050L: return "V_SgAsmJvmLocalVariableEntry";
            case 1051L: return "V_SgAsmJvmLocalVariableTable";
            case 1052L: return "V_SgAsmJvmLocalVariableTypeEntry";
            case 1053L: return "V_SgAsmJvmLocalVariableTypeTable";
            case 1054L: return "V_SgAsmUserInstruction";
            case 1055L: return "V_SgAsmJvmMethodParameters";
            case 1056L: return "V_SgAsmJvmMethodParametersEntry";
            case 1057L: return "V_SgAsmVoidType";
            case 1058L: return "V_SgAsmPointerType";
            case 1059L: return "V_SgAsmAarch64PState";
            case 1060L: return "V_SgRangeType";
            case 1061L: return "V_SgAsmCilExceptionData";
            case 1062L: return "V_SgAsmCilMethodData";
            case 1063L: return "V_SgTemplateVariableInstantiation";
            case 1064L: return "V_SgReferenceExp";
            case 1065L: return "V_SgTypeRefExp";
            case 1066L: return "V_SgScopedRefExp";
            case 1067L: return "V_SgScopedType";
            case 1068L: return "V_SgTypeSymbol";
            case 1069L: return "V_SgAsmJvmSynthetic";
            case 1070L: return "V_SgAsmJvmDeprecated";
            case 1072L: return "V_SgNumVariants";
            default: return "";
        }
    }

    std::string VariantT(int64_t i, const std::string &strip) {
        std::string s = VariantT(i);
        if (s.empty())
            s = "(VariantT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariantT() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            378L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1072L
        };
        static const std::vector<int64_t> retval(values, values + 1062);
        return retval;
    }

}

namespace Rose {
    std::string stringifyVariantT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VariantT(i);
        if (retval.empty()) {
            retval = "(VariantT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VariantT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVariantT() {
        return stringify::VariantT();
    }
}

