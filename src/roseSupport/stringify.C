#include <boost/algorithm/string/predicate.hpp>
#include <boost/lexical_cast.hpp>
#include <string>
#include <vector>

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/GenRepresentation.h line 23
namespace stringify { namespace GenRepresentation {
    const char* TypeOfPrint(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElement";
            case 1L: return "Container";
            case 2L: return "Contained";
            case 3L: return "END_OF_LIST";
            default: return "";
        }
    }

    std::string TypeOfPrint(int64_t i, const std::string &strip) {
        std::string s = TypeOfPrint(i);
        if (s.empty())
            s = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfPrint() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyGenRepresentationTypeOfPrint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::GenRepresentation::TypeOfPrint(i);
        if (retval.empty()) {
            retval = "(GenRepresentation::TypeOfPrint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "GenRepresentation::TypeOfPrint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenRepresentationTypeOfPrint() {
        return stringify::GenRepresentation::TypeOfPrint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/dataStructureTraversal/exampleTest.C line 3
namespace stringify {
    const char* controlEnum(int64_t i) {
        switch (i) {
            case 0L: return "BEGGINING_OF_ENUM";
            case 1L: return "typeInt";
            case 2L: return "typeChar";
            case 3L: return "typeTestStruct";
            case 4L: return "END_OF_ENUM";
            default: return "";
        }
    }

    std::string controlEnum(int64_t i, const std::string &strip) {
        std::string s = controlEnum(i);
        if (s.empty())
            s = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& controlEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_controlEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::controlEnum(i);
        if (retval.empty()) {
            retval = "(controlEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "controlEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_controlEnum() {
        return stringify::controlEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/failSafe/failSafePragma.h line 31
namespace stringify { namespace FailSafe {
    const char* fail_safe_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_region";
            case 2L: return "e_status_predicate";
            case 3L: return "e_data_predicate";
            case 4L: return "e_tolerance";
            case 5L: return "e_double_redundancy";
            case 6L: return "e_triple_redundancy";
            case 7L: return "e_save";
            case 8L: return "e_assert";
            case 9L: return "e_specifier";
            case 10L: return "e_region_reference";
            case 11L: return "e_error";
            case 12L: return "e_violation";
            case 13L: return "e_recover";
            case 14L: return "e_pre";
            case 15L: return "e_post";
            case 16L: return "e_type_ET1";
            case 17L: return "e_type_ET2";
            case 18L: return "e_violation_NaN";
            case 19L: return "e_violation_SECDED";
            case 20L: return "e_violation_SEGFAULT";
            case 21L: return "e_violation_ANY";
            case 22L: return "e_not_failsafe";
            default: return "";
        }
    }

    std::string fail_safe_enum(int64_t i, const std::string &strip) {
        std::string s = fail_safe_enum(i);
        if (s.empty())
            s = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fail_safe_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFailSafe_fail_safe_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FailSafe::fail_safe_enum(i);
        if (retval.empty()) {
            retval = "(FailSafe::fail_safe_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FailSafe::fail_safe_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFailSafe_fail_safe_enum() {
        return stringify::FailSafe::fail_safe_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/util/AstDisplayInfo.h line 14
namespace stringify { namespace AstDisplayInfo {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "ROOT";
            case 1L: return "INCLUDE_ROOT";
            case 2L: return "SRC_FILE";
            case 3L: return "INCLUDE_FILE";
            case 4L: return "NAMESPACE";
            case 5L: return "CLASS";
            case 6L: return "FUNCTION";
            case 7L: return "LOOP";
            case 8L: return "UNKNOWN";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstDisplayInfoNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstDisplayInfo::NodeType(i);
        if (retval.empty()) {
            retval = "(AstDisplayInfo::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstDisplayInfo::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstDisplayInfoNodeType() {
        return stringify::AstDisplayInfo::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h line 25
namespace stringify { namespace CompilerOutputWidget {
    const char* PatternType(int64_t i) {
        switch (i) {
            case 0L: return "Unknown";
            case 1L: return "Warning";
            case 2L: return "Error";
            default: return "";
        }
    }

    std::string PatternType(int64_t i, const std::string &strip) {
        std::string s = PatternType(i);
        if (s.empty())
            s = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCompilerOutputWidgetPatternType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CompilerOutputWidget::PatternType(i);
        if (retval.empty()) {
            retval = "(CompilerOutputWidget::PatternType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CompilerOutputWidget::PatternType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCompilerOutputWidgetPatternType() {
        return stringify::CompilerOutputWidget::PatternType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h line 25
namespace stringify { namespace Task {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "BEFORE_START";
            case 1L: return "RUNNING";
            case 2L: return "FINISHED_SUCCESS";
            case 3L: return "FINISHED_ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Task::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaskState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Task::State(i);
        if (retval.empty()) {
            retval = "(Task::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Task::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaskState() {
        return stringify::Task::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h line 40
namespace stringify { namespace DisplayEdge {
    const char* PaintMode(int64_t i) {
        switch (i) {
            case 0L: return "STRAIGHT";
            case 1L: return "RECTANGULAR";
            case 2L: return "BEZIER_QUAD";
            case 3L: return "BEZIER_CUBIC";
            default: return "";
        }
    }

    std::string PaintMode(int64_t i, const std::string &strip) {
        std::string s = PaintMode(i);
        if (s.empty())
            s = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PaintMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDisplayEdgePaintMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DisplayEdge::PaintMode(i);
        if (retval.empty()) {
            retval = "(DisplayEdge::PaintMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DisplayEdge::PaintMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDisplayEdgePaintMode() {
        return stringify::DisplayEdge::PaintMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h line 20
namespace stringify { namespace DependencyInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "VALID";
            case 1L: return "INVALID";
            case 2L: return "ERROR";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDependencyInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DependencyInfo::State(i);
        if (retval.empty()) {
            retval = "(DependencyInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DependencyInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDependencyInfoState() {
        return stringify::DependencyInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 64
namespace stringify { namespace QEditor {
    const char* CodecUpdatePolicy(int64_t i) {
        switch (i) {
            case 0L: return "NoUpdate";
            case 1L: return "UpdateOld";
            case 2L: return "UpdateDefault";
            case 4L: return "UpdateCustom";
            case 7L: return "UpdateAll";
            default: return "";
        }
    }

    std::string CodecUpdatePolicy(int64_t i, const std::string &strip) {
        std::string s = CodecUpdatePolicy(i);
        if (s.empty())
            s = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CodecUpdatePolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorCodecUpdatePolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::CodecUpdatePolicy(i);
        if (retval.empty()) {
            retval = "(QEditor::CodecUpdatePolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::CodecUpdatePolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorCodecUpdatePolicy() {
        return stringify::QEditor::CodecUpdatePolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 74
namespace stringify { namespace QEditor {
    const char* EditFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Overwrite";
            case 2L: return "CursorOn";
            case 4L: return "ReadOnly";
            case 8L: return "MousePressed";
            case 16L: return "MaybeDrag";
            case 32L: return "Selection";
            case 64L: return "Persistent";
            case 128L: return "Multiline";
            case 256L: return "FoldedCursor";
            case 4095L: return "Internal";
            case 4096L: return "LineWrap";
            case 65536L: return "CtrlNavigation";
            case 131072L: return "CursorJumpPastWrap";
            case 1048576L: return "ReplaceTabs";
            case 2097152L: return "RemoveTrailing";
            case 4194304L: return "PreserveTrailingIndent";
            case 16777216L: return "AutoCloseChars";
            case 33554432L: return "AutoIndent";
            case 4294963200L: return "Accessible";
            default: return "";
        }
    }

    std::string EditFlag(int64_t i, const std::string &strip) {
        std::string s = EditFlag(i);
        if (s.empty())
            s = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            4095L,
            4096L,
            65536L,
            131072L,
            1048576L,
            2097152L,
            4194304L,
            16777216L,
            33554432L,
            4294963200L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorEditFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::EditFlag(i);
        if (retval.empty()) {
            retval = "(QEditor::EditFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::EditFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorEditFlag() {
        return stringify::QEditor::EditFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h line 493
namespace stringify { namespace QEditor {
    const char* SaveState(int64_t i) {
        switch (i) {
            case 0L: return "Undefined";
            case 1L: return "Saving";
            case 2L: return "Saved";
            case 3L: return "Conflict";
            default: return "";
        }
    }

    std::string SaveState(int64_t i, const std::string &strip) {
        std::string s = SaveState(i);
        if (s.empty())
            s = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SaveState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQEditorSaveState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QEditor::SaveState(i);
        if (retval.empty()) {
            retval = "(QEditor::SaveState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QEditor::SaveState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQEditorSaveState() {
        return stringify::QEditor::SaveState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 38
namespace stringify { namespace QPanelLayout {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::Position(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutPosition() {
        return stringify::QPanelLayout::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h line 87
namespace stringify { namespace QPanelLayout {
    const char* SizeType(int64_t i) {
        switch (i) {
            case 0L: return "MinimumSize";
            case 1L: return "SizeHint";
            default: return "";
        }
    }

    std::string SizeType(int64_t i, const std::string &strip) {
        std::string s = SizeType(i);
        if (s.empty())
            s = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SizeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQPanelLayoutSizeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QPanelLayout::SizeType(i);
        if (retval.empty()) {
            retval = "(QPanelLayout::SizeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QPanelLayout::SizeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQPanelLayoutSizeType() {
        return stringify::QPanelLayout::SizeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h line 44
namespace stringify { namespace QLanguageDefinition {
    const char* CollapseFlag(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 4095L: return "OpenMask";
            case 16773120L: return "CloseMask";
            case 268435456L: return "Collapsible";
            case 536870912L: return "Collapsed";
            case 1073741824L: return "Closure";
            default: return "";
        }
    }

    std::string CollapseFlag(int64_t i, const std::string &strip) {
        std::string s = CollapseFlag(i);
        if (s.empty())
            s = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CollapseFlag() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            268435456L,
            536870912L,
            1073741824L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQLanguageDefinitionCollapseFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QLanguageDefinition::CollapseFlag(i);
        if (retval.empty()) {
            retval = "(QLanguageDefinition::CollapseFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QLanguageDefinition::CollapseFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQLanguageDefinitionCollapseFlag() {
        return stringify::QLanguageDefinition::CollapseFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h line 52
namespace stringify { namespace QReliableFileWatch {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "Clean";
            case 1L: return "Recent";
            case 2L: return "Duplicate";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQReliableFileWatchState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QReliableFileWatch::State(i);
        if (retval.empty()) {
            retval = "(QReliableFileWatch::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QReliableFileWatch::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQReliableFileWatchState() {
        return stringify::QReliableFileWatch::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h line 52
namespace stringify { namespace QDocumentCursorHandle {
    const char* Flags(int64_t i) {
        switch (i) {
            case 1L: return "Silent";
            case 2L: return "ColumnMemory";
            case 4L: return "MoveWithinWrapped";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorHandleFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursorHandle::Flags(i);
        if (retval.empty()) {
            retval = "(QDocumentCursorHandle::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursorHandle::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorHandleFlags() {
        return stringify::QDocumentCursorHandle::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 39
namespace stringify { namespace QDocumentCursor {
    const char* MoveFlag(int64_t i) {
        switch (i) {
            case 0L: return "MoveAnchor";
            case 1L: return "KeepAnchor";
            case 2L: return "ThroughWrap";
            default: return "";
        }
    }

    std::string MoveFlag(int64_t i, const std::string &strip) {
        std::string s = MoveFlag(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveFlag(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveFlag() {
        return stringify::QDocumentCursor::MoveFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 48
namespace stringify { namespace QDocumentCursor {
    const char* MoveOperation(int64_t i) {
        switch (i) {
            case 0L: return "NoMove";
            case 1L: return "Up";
            case 2L: return "Down";
            case 3L: return "Left";
            case 4L: return "Right";
            case 5L: return "Start";
            case 6L: return "StartOfLine";
            case 7L: return "StartOfWord";
            case 8L: return "PreviousBlock";
            case 9L: return "PreviousWord";
            case 10L: return "WordLeft";
            case 11L: return "WordRight";
            case 12L: return "End";
            case 13L: return "EndOfLine";
            case 14L: return "EndOfWord";
            case 15L: return "NextWord";
            case 16L: return "NextBlock";
            default: return "";
        }
    }

    std::string MoveOperation(int64_t i, const std::string &strip) {
        std::string s = MoveOperation(i);
        if (s.empty())
            s = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MoveOperation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorMoveOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::MoveOperation(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::MoveOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::MoveOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorMoveOperation() {
        return stringify::QDocumentCursor::MoveOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h line 75
namespace stringify { namespace QDocumentCursor {
    const char* SelectionType(int64_t i) {
        switch (i) {
            case 0L: return "WordUnderCursor";
            case 1L: return "LineUnderCursor";
            default: return "";
        }
    }

    std::string SelectionType(int64_t i, const std::string &strip) {
        std::string s = SelectionType(i);
        if (s.empty())
            s = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCursorSelectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCursor::SelectionType(i);
        if (retval.empty()) {
            retval = "(QDocumentCursor::SelectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCursor::SelectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCursorSelectionType() {
        return stringify::QDocumentCursor::SelectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 38
namespace stringify { namespace QParenthesis {
    const char* Role(int64_t i) {
        switch (i) {
            case 1L: return "Open";
            case 2L: return "Close";
            case 4L: return "Indent";
            case 8L: return "Fold";
            case 16L: return "Match";
            default: return "";
        }
    }

    std::string Role(int64_t i, const std::string &strip) {
        std::string s = Role(i);
        if (s.empty())
            s = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Role() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQParenthesisRole(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QParenthesis::Role(i);
        if (retval.empty()) {
            retval = "(QParenthesis::Role)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QParenthesis::Role::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQParenthesisRole() {
        return stringify::QParenthesis::Role();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h line 69
namespace stringify { namespace QDocumentLine {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Hidden";
            case 2L: return "CollapsedBlockStart";
            case 4L: return "CollapsedBlockEnd";
            case 16L: return "LayoutDirty";
            case 32L: return "FormatsApplied";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentLine::State(i);
        if (retval.empty()) {
            retval = "(QDocumentLine::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentLine::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineState() {
        return stringify::QDocumentLine::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h line 40
namespace stringify { namespace QDocumentSearch {
    const char* Option(int64_t i) {
        switch (i) {
            case 1L: return "WholeWords";
            case 2L: return "CaseSensitive";
            case 4L: return "RegExp";
            case 8L: return "Replace";
            case 16L: return "Prompt";
            case 32L: return "Silent";
            case 64L: return "HighlightAll";
            default: return "";
        }
    }

    std::string Option(int64_t i, const std::string &strip) {
        std::string s = Option(i);
        if (s.empty())
            s = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Option() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentSearchOption(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentSearch::Option(i);
        if (retval.empty()) {
            retval = "(QDocumentSearch::Option)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentSearch::Option::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentSearchOption() {
        return stringify::QDocumentSearch::Option();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 84
namespace stringify { namespace QDocument {
    const char* LineEnding(int64_t i) {
        switch (i) {
            case 0L: return "Conservative";
            case 1L: return "Local";
            case 2L: return "Unix";
            case 3L: return "Windows";
            case 4L: return "Mac";
            default: return "";
        }
    }

    std::string LineEnding(int64_t i, const std::string &strip) {
        std::string s = LineEnding(i);
        if (s.empty())
            s = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LineEnding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentLineEnding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::LineEnding(i);
        if (retval.empty()) {
            retval = "(QDocument::LineEnding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::LineEnding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentLineEnding() {
        return stringify::QDocument::LineEnding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 93
namespace stringify { namespace QDocument {
    const char* TextProcessing(int64_t i) {
        switch (i) {
            case 1L: return "RemoveTrailingWS";
            case 2L: return "PreserveIndent";
            case 4L: return "RestoreTrailingIndent";
            default: return "";
        }
    }

    std::string TextProcessing(int64_t i, const std::string &strip) {
        std::string s = TextProcessing(i);
        if (s.empty())
            s = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TextProcessing() {
        static const int64_t values[] = {
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentTextProcessing(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::TextProcessing(i);
        if (retval.empty()) {
            retval = "(QDocument::TextProcessing)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::TextProcessing::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentTextProcessing() {
        return stringify::QDocument::TextProcessing();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h line 100
namespace stringify { namespace QDocument {
    const char* WhiteSpaceFlag(int64_t i) {
        switch (i) {
            case 0L: return "ShowNone";
            case 1L: return "ShowTrailing";
            case 2L: return "ShowLeading";
            case 4L: return "ShowTabs";
            default: return "";
        }
    }

    std::string WhiteSpaceFlag(int64_t i, const std::string &strip) {
        std::string s = WhiteSpaceFlag(i);
        if (s.empty())
            s = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhiteSpaceFlag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentWhiteSpaceFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocument::WhiteSpaceFlag(i);
        if (retval.empty()) {
            retval = "(QDocument::WhiteSpaceFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocument::WhiteSpaceFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentWhiteSpaceFlag() {
        return stringify::QDocument::WhiteSpaceFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h line 37
namespace stringify { namespace QDocumentCommand {
    const char* Command(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "Insert";
            case 2L: return "Erase";
            case 3L: return "Replace";
            case 4L: return "Custom";
            default: return "";
        }
    }

    std::string Command(int64_t i, const std::string &strip) {
        std::string s = Command(i);
        if (s.empty())
            s = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Command() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQDocumentCommandCommand(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QDocumentCommand::Command(i);
        if (retval.empty()) {
            retval = "(QDocumentCommand::Command)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QDocumentCommand::Command::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQDocumentCommandCommand() {
        return stringify::QDocumentCommand::Command();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 41
namespace stringify { namespace QNFAAction {
    const char* QNFAAction_(int64_t i) {
        switch (i) {
            case 0L: return "NoAction";
            case 4095L: return "FormatMask";
            case 16773120L: return "ParenMask";
            case 16777216L: return "Highlight";
            case 33554432L: return "Indent";
            case 67108864L: return "ParenOpen";
            case 134217728L: return "ParenClose";
            case 268435456L: return "MatchParen";
            case 536870912L: return "Fold";
            case 1073741824L: return "Ambiguous";
            case 2147483648L: return "Content";
            default: return "";
        }
    }

    std::string QNFAAction_(int64_t i, const std::string &strip) {
        std::string s = QNFAAction_(i);
        if (s.empty())
            s = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QNFAAction_() {
        static const int64_t values[] = {
            0L,
            4095L,
            16773120L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQNFAActionQNFAAction_(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFAAction::QNFAAction_(i);
        if (retval.empty()) {
            retval = "(QNFAAction::QNFAAction_)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFAAction::QNFAAction_::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFAActionQNFAAction_() {
        return stringify::QNFAAction::QNFAAction_();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h line 129
namespace stringify { namespace QNFADefinition { namespace PMatch {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyQNFADefinitionPMatchType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QNFADefinition::PMatch::Type(i);
        if (retval.empty()) {
            retval = "(QNFADefinition::PMatch::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QNFADefinition::PMatch::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQNFADefinitionPMatchType() {
        return stringify::QNFADefinition::PMatch::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 42
namespace stringify {
    const char* NFAType(int64_t i) {
        switch (i) {
            case 0L: return "Char";
            case 1L: return "Match";
            case 2L: return "CxtBeg";
            case 3L: return "ContextBegin";
            case 4L: return "CxtEnd";
            case 5L: return "ContextEnd";
            case 8L: return "CxtEsc";
            case 9L: return "EscapeSeq";
            case 16L: return "Escaped";
            case 32L: return "Exclusive";
            case 64L: return "StayOnLine";
            case 128L: return "Reserved";
            default: return "";
        }
    }

    std::string NFAType(int64_t i, const std::string &strip) {
        std::string s = NFAType(i);
        if (s.empty())
            s = "(NFAType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            8L,
            9L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAType(i);
        if (retval.empty()) {
            retval = "(NFAType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAType() {
        return stringify::NFAType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h line 63
namespace stringify {
    const char* NFAAssertion(int64_t i) {
        switch (i) {
            case 0L: return "NoAssertion";
            case 1L: return "ZeroOrOne";
            case 2L: return "ZeroOrMore";
            case 4L: return "OneOrMore";
            case 8L: return "WordStart";
            case 16L: return "WordEnd";
            case 32L: return "Word";
            case 64L: return "NonWord";
            case 128L: return "Digit";
            case 256L: return "NonDigit";
            case 512L: return "Space";
            case 1024L: return "NonSpace";
            case 2048L: return "CaseSensitive";
            default: return "";
        }
    }

    std::string NFAAssertion(int64_t i, const std::string &strip) {
        std::string s = NFAAssertion(i);
        if (s.empty())
            s = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NFAAssertion() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            2048L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringifyNFAAssertion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NFAAssertion(i);
        if (retval.empty()) {
            retval = "(NFAAssertion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NFAAssertion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNFAAssertion() {
        return stringify::NFAAssertion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h line 46
namespace stringify { namespace QCodeEdit {
    const char* Position(int64_t i) {
        switch (i) {
            case 0L: return "West";
            case 1L: return "North";
            case 2L: return "South";
            case 3L: return "East";
            default: return "";
        }
    }

    std::string Position(int64_t i, const std::string &strip) {
        std::string s = Position(i);
        if (s.empty())
            s = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Position() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQCodeEditPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QCodeEdit::Position(i);
        if (retval.empty()) {
            retval = "(QCodeEdit::Position)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QCodeEdit::Position::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQCodeEditPosition() {
        return stringify::QCodeEdit::Position();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp line 91
namespace stringify { namespace QtGradientWidgetPrivate {
    const char* Handle(int64_t i) {
        switch (i) {
            case 0L: return "NoHandle";
            case 1L: return "StartLinearHandle";
            case 2L: return "EndLinearHandle";
            case 3L: return "CentralRadialHandle";
            case 4L: return "FocalRadialHandle";
            case 5L: return "RadiusRadialHandle";
            case 6L: return "CentralConicalHandle";
            case 7L: return "AngleConicalHandle";
            default: return "";
        }
    }

    std::string Handle(int64_t i, const std::string &strip) {
        std::string s = Handle(i);
        if (s.empty())
            s = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Handle() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtGradientWidgetPrivateHandle(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtGradientWidgetPrivate::Handle(i);
        if (retval.empty()) {
            retval = "(QtGradientWidgetPrivate::Handle)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtGradientWidgetPrivate::Handle::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtGradientWidgetPrivateHandle() {
        return stringify::QtGradientWidgetPrivate::Handle();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h line 62
namespace stringify { namespace QtColorLine {
    const char* ColorComponent(int64_t i) {
        switch (i) {
            case 0L: return "Red";
            case 1L: return "Green";
            case 2L: return "Blue";
            case 3L: return "Hue";
            case 4L: return "Saturation";
            case 5L: return "Value";
            case 6L: return "Alpha";
            default: return "";
        }
    }

    std::string ColorComponent(int64_t i, const std::string &strip) {
        std::string s = ColorComponent(i);
        if (s.empty())
            s = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ColorComponent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyQtColorLineColorComponent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::QtColorLine::ColorComponent(i);
        if (retval.empty()) {
            retval = "(QtColorLine::ColorComponent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "QtColorLine::ColorComponent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyQtColorLineColorComponent() {
        return stringify::QtColorLine::ColorComponent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstRestructure.h line 22
namespace stringify { namespace AstUnparseAttribute {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 5L: return "replace";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUnparseAttributeRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUnparseAttribute::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(AstUnparseAttribute::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUnparseAttribute::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUnparseAttributeRelativePositionType() {
        return stringify::AstUnparseAttribute::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.h line 41
namespace stringify { namespace AstAttribute {
    const char* OwnershipPolicy(int64_t i) {
        switch (i) {
            case 0L: return "CONTAINER_OWNERSHIP";
            case 1L: return "NO_OWNERSHIP";
            case 2L: return "CUSTOM_OWNERSHIP";
            case 3L: return "UNKNOWN_OWNERSHIP";
            default: return "";
        }
    }

    std::string OwnershipPolicy(int64_t i, const std::string &strip) {
        std::string s = OwnershipPolicy(i);
        if (s.empty())
            s = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OwnershipPolicy() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeOwnershipPolicy(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttribute::OwnershipPolicy(i);
        if (retval.empty()) {
            retval = "(AstAttribute::OwnershipPolicy)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttribute::OwnershipPolicy::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeOwnershipPolicy() {
        return stringify::AstAttribute::OwnershipPolicy();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astProcessing/AstAttributeMechanism.C line 21
namespace stringify {
    const char* WarningType(int64_t i) {
        switch (i) {
            case 0L: return "HAS_MEMORY_LEAK";
            case 1L: return "HAS_UNKNOWN_OWNERSHIP";
            case 2L: return "HAS_NULL_COPY";
            case 3L: return "HAS_SELF_COPY";
            case 4L: return "HAS_NO_CLASS_NAME";
            default: return "";
        }
    }

    std::string WarningType(int64_t i, const std::string &strip) {
        std::string s = WarningType(i);
        if (s.empty())
            s = "(WarningType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WarningType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyWarningType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::WarningType(i);
        if (retval.empty()) {
            retval = "(WarningType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "WarningType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyWarningType() {
        return stringify::WarningType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractMemoryObject/memory_object_impl.h line 84
namespace stringify { namespace AbstractMemoryObject { namespace IndexSet {
    const char* Index_type(int64_t i) {
        switch (i) {
            case 0L: return "Integer_type";
            case 1L: return "Unknown_type";
            default: return "";
        }
    }

    std::string Index_type(int64_t i, const std::string &strip) {
        std::string s = Index_type(i);
        if (s.empty())
            s = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Index_type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyAbstractMemoryObjectIndexSetIndex_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AbstractMemoryObject::IndexSet::Index_type(i);
        if (retval.empty()) {
            retval = "(AbstractMemoryObject::IndexSet::Index_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAbstractMemoryObjectIndexSetIndex_type() {
        return stringify::AbstractMemoryObject::IndexSet::Index_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/AstUtilInterface.h line 13
namespace stringify { namespace AstUtilInterface {
    const char* OperatorSideEffect(int64_t i) {
        switch (i) {
            case 0L: return "Modify";
            case 1L: return "Read";
            case 2L: return "Kill";
            case 3L: return "Call";
            case 4L: return "Decl";
            case 5L: return "Allocate";
            case 6L: return "Free";
            case 7L: return "CallInput";
            case 8L: return "CallOutput";
            default: return "";
        }
    }

    std::string OperatorSideEffect(int64_t i, const std::string &strip) {
        std::string s = OperatorSideEffect(i);
        if (s.empty())
            s = "(AstUtilInterface::OperatorSideEffect)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OperatorSideEffect() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstUtilInterfaceOperatorSideEffect(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstUtilInterface::OperatorSideEffect(i);
        if (retval.empty()) {
            retval = "(AstUtilInterface::OperatorSideEffect)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstUtilInterface::OperatorSideEffect::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstUtilInterfaceOperatorSideEffect() {
        return stringify::AstUtilInterface::OperatorSideEffect();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/astInterface/AstInterface.h line 19
namespace stringify { namespace AstNodePtr {
    const char* SpecialAstType(int64_t i) {
        switch (i) {
            case 0L: return "SG_AST";
            case 1L: return "UNKNOWN_AST";
            case 2L: return "NULL_AST";
            default: return "";
        }
    }

    std::string SpecialAstType(int64_t i, const std::string &strip) {
        std::string s = SpecialAstType(i);
        if (s.empty())
            s = "(AstNodePtr::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SpecialAstType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodePtrSpecialAstType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodePtr::SpecialAstType(i);
        if (retval.empty()) {
            retval = "(AstNodePtr::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodePtr::SpecialAstType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodePtrSpecialAstType() {
        return stringify::AstNodePtr::SpecialAstType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astUtil/astInterface/AstInterface.h line 64
namespace stringify { namespace AstNodeType {
    const char* SpecialAstType(int64_t i) {
        switch (i) {
            case 0L: return "SG_TYPE";
            case 1L: return "UNKNOWN_TYPE";
            case 2L: return "NULL_TYPE";
            default: return "";
        }
    }

    std::string SpecialAstType(int64_t i, const std::string &strip) {
        std::string s = SpecialAstType(i);
        if (s.empty())
            s = "(AstNodeType::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SpecialAstType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeTypeSpecialAstType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeType::SpecialAstType(i);
        if (retval.empty()) {
            retval = "(AstNodeType::SpecialAstType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeType::SpecialAstType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeTypeSpecialAstType() {
        return stringify::AstNodeType::SpecialAstType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h line 45
namespace stringify { namespace ConstrGraph {
    const char* levels(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "bottom";
            case 2L: return "constrKnown";
            case 3L: return "top";
            default: return "";
        }
    }

    std::string levels(int64_t i, const std::string &strip) {
        std::string s = levels(i);
        if (s.empty())
            s = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& levels() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyConstrGraph_levels(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstrGraph::levels(i);
        if (retval.empty()) {
            retval = "(ConstrGraph::levels)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstrGraph::levels::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstrGraph_levels() {
        return stringify::ConstrGraph::levels();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h line 63
namespace stringify { namespace TaintLattice {
    const char* Vertex(int64_t i) {
        switch (i) {
            case 0L: return "VERTEX_BOTTOM";
            case 1L: return "VERTEX_UNTAINTED";
            case 2L: return "VERTEX_TAINTED";
            default: return "";
        }
    }

    std::string Vertex(int64_t i, const std::string &strip) {
        std::string s = Vertex(i);
        if (s.empty())
            s = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Vertex() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTaintLatticeVertex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TaintLattice::Vertex(i);
        if (retval.empty()) {
            retval = "(TaintLattice::Vertex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TaintLattice::Vertex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTaintLatticeVertex() {
        return stringify::TaintLattice::Vertex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h line 119
namespace stringify { namespace CGFunction { namespace iterator {
    const char* direction(int64_t i) {
        switch (i) {
            case 0L: return "fw";
            case 1L: return "bw";
            default: return "";
        }
    }

    std::string direction(int64_t i, const std::string &strip) {
        std::string s = direction(i);
        if (s.empty())
            s = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCGFunction_iterator_direction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CGFunction::iterator::direction(i);
        if (retval.empty()) {
            retval = "(CGFunction::iterator::direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CGFunction::iterator::direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCGFunction_iterator_direction() {
        return stringify::CGFunction::iterator::direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 21
namespace stringify { namespace SDG { namespace SDGNode {
    const char* NodeType(int64_t i) {
        switch (i) {
            case 0L: return "Entry";
            case 1L: return "ASTNode";
            case 2L: return "FunctionCall";
            case 3L: return "ActualIn";
            case 4L: return "ActualOut";
            case 5L: return "FormalIn";
            case 6L: return "FormalOut";
            default: return "";
        }
    }

    std::string NodeType(int64_t i, const std::string &strip) {
        std::string s = NodeType(i);
        if (s.empty())
            s = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGNodeNodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGNode::NodeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGNode::NodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGNode::NodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGNodeNodeType() {
        return stringify::SDG::SDGNode::NodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 48
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            case 2L: return "ParameterIn";
            case 3L: return "ParameterOut";
            case 4L: return "Call";
            case 5L: return "Summary";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeEdgeType() {
        return stringify::SDG::SDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/SDG.h line 58
namespace stringify { namespace SDG { namespace SDGEdge {
    const char* ControlDependenceType(int64_t i) {
        switch (i) {
            case 0L: return "cdTrue";
            case 1L: return "cdFalse";
            case 2L: return "cdCase";
            case 3L: return "cdDefault";
            default: return "";
        }
    }

    std::string ControlDependenceType(int64_t i, const std::string &strip) {
        std::string s = ControlDependenceType(i);
        if (s.empty())
            s = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ControlDependenceType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_SDGEdgeControlDependenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::SDGEdge::ControlDependenceType(i);
        if (retval.empty()) {
            retval = "(SDG::SDGEdge::ControlDependenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_SDGEdgeControlDependenceType() {
        return stringify::SDG::SDGEdge::ControlDependenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/systemDependenceGraph/PDG.h line 32
namespace stringify { namespace SDG { namespace PDGEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "ControlDependence";
            case 1L: return "DataDependence";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySDG_PDGEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SDG::PDGEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(SDG::PDGEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SDG::PDGEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySDG_PDGEdgeEdgeType() {
        return stringify::SDG::PDGEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h line 13
namespace stringify { namespace DominatorTreesAndDominanceFrontiers {
    const char* Dir_ection(int64_t i) {
        switch (i) {
            case 0L: return "PRE_DOMINATOR";
            case 1L: return "POST_DOMINATOR";
            default: return "";
        }
    }

    std::string Dir_ection(int64_t i, const std::string &strip) {
        std::string s = Dir_ection(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Dir_ection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDir_ection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::Dir_ection(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::Dir_ection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDir_ection() {
        return stringify::DominatorTreesAndDominanceFrontiers::Dir_ection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/EditDistance/TreeEditDistance.h line 60
namespace stringify { namespace Rose { namespace EditDistance { namespace TreeEditDistance {
    const char* EditType(int64_t i) {
        switch (i) {
            case 0L: return "INSERT";
            case 1L: return "DELETE";
            case 2L: return "SUBSTITUTE";
            default: return "";
        }
    }

    std::string EditType(int64_t i, const std::string &strip) {
        std::string s = EditType(i);
        if (s.empty())
            s = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EditType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyEditDistanceTreeEditDistanceEditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::EditDistance::TreeEditDistance::EditType(i);
        if (retval.empty()) {
            retval = "(Rose::EditDistance::TreeEditDistance::EditType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::EditDistance::TreeEditDistance::EditType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEditDistanceTreeEditDistanceEditType() {
        return stringify::Rose::EditDistance::TreeEditDistance::EditType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h line 19
namespace stringify { namespace ssa_unfiltered_cfg { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            case 3L: return "EXTERNAL_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_ssa_unfiltered_cfgReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ssa_unfiltered_cfg::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ssa_unfiltered_cfg::ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ssa_unfiltered_cfgReachingDefType() {
        return stringify::ssa_unfiltered_cfg::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h line 50
namespace stringify { namespace DominatorTreesAndDominanceFrontiers { namespace DominatorTree {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction(i);
        if (retval.empty()) {
            retval = "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection() {
        return stringify::DominatorTreesAndDominanceFrontiers::DominatorTree::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 25
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* running_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_analysis_and_instrument";
            case 1L: return "e_static_counting";
            default: return "";
        }
    }

    std::string running_mode_enum(int64_t i, const std::string &strip) {
        std::string s = running_mode_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& running_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_running_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::running_mode_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::running_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::running_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_running_mode_enum() {
        return stringify::ArithmeticIntensityMeasurement::running_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/arithmeticIntensity/ai_measurement.h line 30
namespace stringify { namespace ArithmeticIntensityMeasurement {
    const char* fp_operation_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_total";
            case 2L: return "e_plus";
            case 3L: return "e_minus";
            case 4L: return "e_multiply";
            case 5L: return "e_divide";
            default: return "";
        }
    }

    std::string fp_operation_kind_enum(int64_t i, const std::string &strip) {
        std::string s = fp_operation_kind_enum(i);
        if (s.empty())
            s = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fp_operation_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum(i);
        if (retval.empty()) {
            retval = "(ArithmeticIntensityMeasurement::fp_operation_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ArithmeticIntensityMeasurement::fp_operation_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyArithmeticIntensityMeasurement_fp_operation_kind_enum() {
        return stringify::ArithmeticIntensityMeasurement::fp_operation_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 26
namespace stringify { namespace ReadWriteSets {
    const char* Globality(int64_t i) {
        switch (i) {
            case 0L: return "LOCALS";
            case 1L: return "PARAMETERS";
            case 2L: return "MEMBERS";
            case 3L: return "OTHER_CLASS_MEMBERS";
            case 4L: return "STATIC_MEMBERS";
            case 5L: return "FILE_SCOPE";
            case 6L: return "GLOBALS";
            case 7L: return "GLOBALITY_UNKNOWN";
            default: return "";
        }
    }

    std::string Globality(int64_t i, const std::string &strip) {
        std::string s = Globality(i);
        if (s.empty())
            s = "(ReadWriteSets::Globality)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Globality() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsGlobality(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::Globality(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::Globality)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::Globality::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsGlobality() {
        return stringify::ReadWriteSets::Globality();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 42
namespace stringify { namespace ReadWriteSets {
    const char* VarType(int64_t i) {
        switch (i) {
            case 0L: return "PRIMITIVES";
            case 1L: return "ARRAYS";
            case 2L: return "ARRAY_INDEX_EXPRESSIONS";
            case 3L: return "STRUCTS";
            case 4L: return "ARRAYS_OF_STRUCTS";
            case 5L: return "FUNCTIONS";
            case 6L: return "MEMBER_FUNCTIONS";
            case 7L: return "POINTERS";
            case 8L: return "VARTYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string VarType(int64_t i, const std::string &strip) {
        std::string s = VarType(i);
        if (s.empty())
            s = "(ReadWriteSets::VarType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VarType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsVarType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::VarType(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::VarType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::VarType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsVarType() {
        return stringify::ReadWriteSets::VarType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/ReadWriteSetAnalysis/ReadWriteSetRecords.h line 58
namespace stringify { namespace ReadWriteSets {
    const char* AccessType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL";
            case 1L: return "FIELD_ACCESS";
            case 2L: return "ARRAY_INDEX";
            case 3L: return "ADDRESS_OF";
            case 4L: return "POINTER_DEREFERENCE";
            case 5L: return "POINTER_ARROW";
            case 6L: return "FUNCTION_POINTER_DEREF";
            case 7L: return "ACCESSTYPE_UNKNOWN";
            default: return "";
        }
    }

    std::string AccessType(int64_t i, const std::string &strip) {
        std::string s = AccessType(i);
        if (s.empty())
            s = "(ReadWriteSets::AccessType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AccessType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReadWriteSetsAccessType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReadWriteSets::AccessType(i);
        if (retval.empty()) {
            retval = "(ReadWriteSets::AccessType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReadWriteSets::AccessType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReadWriteSetsAccessType() {
        return stringify::ReadWriteSets::AccessType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 163
namespace stringify {
    const char* IRProcType(int64_t i) {
        switch (i) {
            case 0L: return "ProcType_PGM";
            case 1L: return "ProcType_SUB";
            case 2L: return "ProcType_FUNC";
            case 3L: return "ProcType_BDATA";
            case 4L: return "ProcType_ILLEGAL";
            default: return "";
        }
    }

    std::string IRProcType(int64_t i, const std::string &strip) {
        std::string s = IRProcType(i);
        if (s.empty())
            s = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRProcType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRProcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRProcType(i);
        if (retval.empty()) {
            retval = "(IRProcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRProcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRProcType() {
        return stringify::IRProcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h line 173
namespace stringify {
    const char* IRStmtType(int64_t i) {
        switch (i) {
            case 0L: return "SIMPLE";
            case 1L: return "COMPOUND";
            case 2L: return "LOOP";
            case 3L: return "END_TESTED_LOOP";
            case 4L: return "STRUCT_TWOWAY_CONDITIONAL";
            case 5L: return "STRUCT_MULTIWAY_CONDITIONAL";
            case 6L: return "USTRUCT_TWOWAY_CONDITIONAL_T";
            case 7L: return "USTRUCT_TWOWAY_CONDITIONAL_F";
            case 8L: return "USTRUCT_MULTIWAY_CONDITIONAL";
            case 9L: return "RETURN";
            case 10L: return "BREAK";
            case 11L: return "LOOP_CONTINUE";
            case 12L: return "ALTERNATE_PROC_ENTRY";
            case 13L: return "UNCONDITIONAL_JUMP";
            case 14L: return "UNCONDITIONAL_JUMP_I";
            case 15L: return "NONE";
            default: return "";
        }
    }

    std::string IRStmtType(int64_t i, const std::string &strip) {
        std::string s = IRStmtType(i);
        if (s.empty())
            s = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IRStmtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringifyIRStmtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::IRStmtType(i);
        if (retval.empty()) {
            retval = "(IRStmtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "IRStmtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyIRStmtType() {
        return stringify::IRStmtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h line 261
namespace stringify { namespace BaseGraph { namespace BiDirNodesIterator {
    const char* dirType(int64_t i) {
        switch (i) {
            case 0L: return "Forward";
            case 1L: return "Reverse";
            default: return "";
        }
    }

    std::string dirType(int64_t i, const std::string &strip) {
        std::string s = dirType(i);
        if (s.empty())
            s = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& dirType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBaseGraphBiDirNodesIterator_dirType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BaseGraph::BiDirNodesIterator::dirType(i);
        if (retval.empty()) {
            retval = "(BaseGraph::BiDirNodesIterator::dirType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBaseGraphBiDirNodesIterator_dirType() {
        return stringify::BaseGraph::BiDirNodesIterator::dirType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 65
namespace stringify {
    const char* RITarjType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NOTHING";
            case 1L: return "RI_TARJ_ACYCLIC";
            case 2L: return "RI_TARJ_INTERVAL";
            case 3L: return "RI_TARJ_IRREDUCIBLE";
            default: return "";
        }
    }

    std::string RITarjType(int64_t i, const std::string &strip) {
        std::string s = RITarjType(i);
        if (s.empty())
            s = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjType(i);
        if (retval.empty()) {
            retval = "(RITarjType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjType() {
        return stringify::RITarjType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h line 67
namespace stringify {
    const char* RITarjEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "RI_TARJ_NORMAL";
            case 1L: return "RI_TARJ_LOOP_ENTRY";
            case 2L: return "RI_TARJ_IRRED_ENTRY";
            case 3L: return "RI_TARJ_ITERATE";
            default: return "";
        }
    }

    std::string RITarjEdgeType(int64_t i, const std::string &strip) {
        std::string s = RITarjEdgeType(i);
        if (s.empty())
            s = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RITarjEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyRITarjEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RITarjEdgeType(i);
        if (retval.empty()) {
            retval = "(RITarjEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RITarjEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRITarjEdgeType() {
        return stringify::RITarjEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 63
namespace stringify { namespace RIFG {
    const char* EdgeDirection(int64_t i) {
        switch (i) {
            case 0L: return "ED_INCOMING";
            case 1L: return "ED_OUTGOING";
            default: return "";
        }
    }

    std::string EdgeDirection(int64_t i, const std::string &strip) {
        std::string s = EdgeDirection(i);
        if (s.empty())
            s = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_EdgeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::EdgeDirection(i);
        if (retval.empty()) {
            retval = "(RIFG::EdgeDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::EdgeDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_EdgeDirection() {
        return stringify::RIFG::EdgeDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h line 64
namespace stringify { namespace RIFG {
    const char* ForwardBackward(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string ForwardBackward(int64_t i, const std::string &strip) {
        std::string s = ForwardBackward(i);
        if (s.empty())
            s = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ForwardBackward() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRIFG_ForwardBackward(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::RIFG::ForwardBackward(i);
        if (retval.empty()) {
            retval = "(RIFG::ForwardBackward)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "RIFG::ForwardBackward::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRIFG_ForwardBackward() {
        return stringify::RIFG::ForwardBackward();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h line 83
namespace stringify { namespace CFG {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "TRUE_EDGE";
            case 1L: return "FALLTHROUGH_EDGE";
            case 2L: return "FALSE_EDGE";
            case 3L: return "BACK_EDGE";
            case 4L: return "MULTIWAY_EDGE";
            case 5L: return "BREAK_EDGE";
            case 6L: return "CONTINUE_EDGE";
            case 7L: return "RETURN_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCFG_EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CFG::EdgeType(i);
        if (retval.empty()) {
            retval = "(CFG::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CFG::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCFG_EdgeType() {
        return stringify::CFG::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h line 73
namespace stringify { namespace CallGraph {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "NORMAL_EDGE";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCallGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CallGraph::EdgeType(i);
        if (retval.empty()) {
            retval = "(CallGraph::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CallGraph::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallGraphEdgeType() {
        return stringify::CallGraph::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/staticSingleAssignment/reachingDef.h line 18
namespace stringify { namespace ReachingDef {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PHI_FUNCTION";
            case 1L: return "ORIGINAL_DEF";
            case 2L: return "EXPANDED_DEF";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyReachingDefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ReachingDef::Type(i);
        if (retval.empty()) {
            retval = "(ReachingDef::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ReachingDef::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyReachingDefType() {
        return stringify::ReachingDef::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 280
namespace stringify { namespace CollectAliasRelations {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::COLOR(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsCOLOR() {
        return stringify::CollectAliasRelations::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h line 281
namespace stringify { namespace CollectAliasRelations {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "NON_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyCollectAliasRelationsTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CollectAliasRelations::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(CollectAliasRelations::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCollectAliasRelationsTRAVERSAL_TYPE() {
        return stringify::CollectAliasRelations::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 31
namespace stringify { namespace PtrAliasAnalysis {
    const char* COLOR(int64_t i) {
        switch (i) {
            case 0L: return "WHITE";
            case 1L: return "GREY";
            case 2L: return "BLACK";
            default: return "";
        }
    }

    std::string COLOR(int64_t i, const std::string &strip) {
        std::string s = COLOR(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& COLOR() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisCOLOR(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::COLOR(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::COLOR)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::COLOR::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisCOLOR() {
        return stringify::PtrAliasAnalysis::COLOR();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h line 33
namespace stringify { namespace PtrAliasAnalysis {
    const char* TRAVERSAL_TYPE(int64_t i) {
        switch (i) {
            case 0L: return "TOPOLOGICAL";
            case 1L: return "REVERSE_TOPOLOGICAL";
            default: return "";
        }
    }

    std::string TRAVERSAL_TYPE(int64_t i, const std::string &strip) {
        std::string s = TRAVERSAL_TYPE(i);
        if (s.empty())
            s = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TRAVERSAL_TYPE() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPtrAliasAnalysisTRAVERSAL_TYPE(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PtrAliasAnalysis::TRAVERSAL_TYPE(i);
        if (retval.empty()) {
            retval = "(PtrAliasAnalysis::TRAVERSAL_TYPE)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPtrAliasAnalysisTRAVERSAL_TYPE() {
        return stringify::PtrAliasAnalysis::TRAVERSAL_TYPE();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 15
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* LabelType(int64_t i) {
        switch (i) {
            case 1L: return "LABEL_UNDEF";
            case 2L: return "LABEL_OTHER";
            case 100L: return "LABEL_FUNCTIONCALL";
            case 101L: return "LABEL_FUNCTIONCALLRETURN";
            case 102L: return "LABEL_FUNCTIONENTRY";
            case 103L: return "LABEL_FUNCTIONEXIT";
            case 104L: return "LABEL_BLOCKBEGIN";
            case 105L: return "LABEL_BLOCKEND";
            case 106L: return "LABEL_EMPTY_STMT";
            case 107L: return "LABEL_FORK";
            case 108L: return "LABEL_JOIN";
            case 109L: return "LABEL_WORKSHARE";
            case 110L: return "LABEL_BARRIER";
            default: return "";
        }
    }

    std::string LabelType(int64_t i, const std::string &strip) {
        std::string s = LabelType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LabelType() {
        static const int64_t values[] = {
            1L,
            2L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyLabelType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::LabelType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::LabelType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::LabelType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyLabelType() {
        return stringify::CodeThorn::LabelProperty::LabelType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/Labeler.h line 50
namespace stringify { namespace CodeThorn { namespace LabelProperty {
    const char* IOType(int64_t i) {
        switch (i) {
            case 0L: return "LABELIO_NONE";
            case 1L: return "LABELIO_STDIN";
            case 2L: return "LABELIO_STDOUTVAR";
            case 3L: return "LABELIO_STDOUTCONST";
            case 4L: return "LABELIO_STDERR";
            default: return "";
        }
    }

    std::string IOType(int64_t i, const std::string &strip) {
        std::string s = IOType(i);
        if (s.empty())
            s = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IOType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornLabelPropertyIOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::LabelProperty::IOType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::LabelProperty::IOType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::LabelProperty::IOType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornLabelPropertyIOType() {
        return stringify::CodeThorn::LabelProperty::IOType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/SgNodeHelper.h line 542
namespace stringify { namespace SgNodeHelper { namespace Pattern { namespace OutputTarget {
    const char* OType(int64_t i) {
        switch (i) {
            case 0L: return "VAR";
            case 1L: return "INT";
            case 2L: return "UNKNOWNPRINTF";
            case 3L: return "UNKNOWNOPERATION";
            default: return "";
        }
    }

    std::string OType(int64_t i, const std::string &strip) {
        std::string s = OType(i);
        if (s.empty())
            s = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySgNodeHelperPatternOutputTargetOType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgNodeHelper::Pattern::OutputTarget::OType(i);
        if (retval.empty()) {
            retval = "(SgNodeHelper::Pattern::OutputTarget::OType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgNodeHelperPatternOutputTargetOType() {
        return stringify::SgNodeHelper::Pattern::OutputTarget::OType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 174
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* AggregateType(int64_t i) {
        switch (i) {
            case 0L: return "AT_UNKNOWN";
            case 1L: return "AT_SINGLE";
            case 2L: return "AT_ARRAY";
            case 3L: return "AT_STRUCT";
            case 4L: return "AT_STRING_LITERAL";
            default: return "";
        }
    }

    std::string AggregateType(int64_t i, const std::string &strip) {
        std::string s = AggregateType(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingAggregateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::AggregateType(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::AggregateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::AggregateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingAggregateType() {
        return stringify::CodeThorn::VariableIdMapping::AggregateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/abstractLayer/VariableIdMapping.h line 175
namespace stringify { namespace CodeThorn { namespace VariableIdMapping {
    const char* VariableScope(int64_t i) {
        switch (i) {
            case 0L: return "VS_UNKNOWN";
            case 1L: return "VS_LOCAL";
            case 2L: return "VS_FUNPARAM";
            case 3L: return "VS_GLOBAL";
            case 4L: return "VS_MEMBER";
            default: return "";
        }
    }

    std::string VariableScope(int64_t i, const std::string &strip) {
        std::string s = VariableScope(i);
        if (s.empty())
            s = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariableScope() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeThornVariableIdMappingVariableScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CodeThorn::VariableIdMapping::VariableScope(i);
        if (retval.empty()) {
            retval = "(CodeThorn::VariableIdMapping::VariableScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CodeThorn::VariableIdMapping::VariableScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeThornVariableIdMappingVariableScope() {
        return stringify::CodeThorn::VariableIdMapping::VariableScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/BinaryAnalysis/libraryIdentification/libraryIdentification.h line 18
namespace stringify { namespace LibraryIdentification {
    const char* DUPLICATE_OPTION(int64_t i) {
        switch (i) {
            case 0L: return "UNKNOWN";
            case 1L: return "COMBINE";
            case 2L: return "REPLACE";
            case 3L: return "NO_ADD";
            default: return "";
        }
    }

    std::string DUPLICATE_OPTION(int64_t i, const std::string &strip) {
        std::string s = DUPLICATE_OPTION(i);
        if (s.empty())
            s = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DUPLICATE_OPTION() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLibraryIdentificationDUPLICATE_OPTION(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LibraryIdentification::DUPLICATE_OPTION(i);
        if (retval.empty()) {
            retval = "(LibraryIdentification::DUPLICATE_OPTION)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LibraryIdentification::DUPLICATE_OPTION::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLibraryIdentificationDUPLICATE_OPTION() {
        return stringify::LibraryIdentification::DUPLICATE_OPTION();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/booleanQuery.h line 43
namespace stringify { namespace BooleanQuery {
    const char* TypeOfQueryType(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclaration";
            case 2L: return "Type";
            case 3L: return "FunctionDeclaration";
            case 4L: return "MemberFunctionDeclaration";
            case 5L: return "ClassDeclaration";
            case 6L: return "Argument";
            case 7L: return "Field";
            case 8L: return "UnionedField";
            case 9L: return "Struct";
            case 10L: return "ContainedInSubtreeOfType";
            case 11L: return "END_OF_BOOLEAN_QUERY_TYPE";
            default: return "";
        }
    }

    std::string TypeOfQueryType(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryType(i);
        if (s.empty())
            s = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyBooleanQueryTypeOfQueryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BooleanQuery::TypeOfQueryType(i);
        if (retval.empty()) {
            retval = "(BooleanQuery::TypeOfQueryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BooleanQuery::TypeOfQueryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBooleanQueryTypeOfQueryType() {
        return stringify::BooleanQuery::TypeOfQueryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 74
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableNames";
            case 2L: return "VariableTypeNames";
            case 3L: return "FunctionDeclarationNames";
            case 4L: return "MemberFunctionDeclarationNames";
            case 5L: return "ClassDeclarationNames";
            case 6L: return "ArgumentNames";
            case 7L: return "ClassFieldNames";
            case 8L: return "UnionFieldNames";
            case 9L: return "StructFieldNames";
            case 10L: return "FunctionReferenceNames";
            case 11L: return "StructNames";
            case 12L: return "UnionNames";
            case 13L: return "TypedefDeclarationNames";
            case 14L: return "TypeNames";
            case 15L: return "END_OF_NAME_TYPE_LIST";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeOneParameter() {
        return stringify::NameQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nameQuery.h line 94
namespace stringify { namespace NameQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "VariableNamesWithTypeName";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNameQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NameQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NameQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNameQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NameQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/astQuery.h line 81
namespace stringify { namespace AstQueryNamespace {
    const char* QueryDepth(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeQueryDepth";
            case 1L: return "ChildrenOnly";
            case 2L: return "AllNodes";
            case 3L: return "ExtractTypes";
            case 4L: return "END_OF_NODE_TYPE_LIST_QUERY_DEPTH";
            default: return "";
        }
    }

    std::string QueryDepth(int64_t i, const std::string &strip) {
        std::string s = QueryDepth(i);
        if (s.empty())
            s = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& QueryDepth() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstQueryNamespaceQueryDepth(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstQueryNamespace::QueryDepth(i);
        if (retval.empty()) {
            retval = "(AstQueryNamespace::QueryDepth)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstQueryNamespace::QueryDepth::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstQueryNamespaceQueryDepth() {
        return stringify::AstQueryNamespace::QueryDepth();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 10
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "NumberOfArgsInConstructor";
            case 2L: return "NumberOfOperands";
            case 3L: return "NumberOfArgsInScalarIndexingOperator";
            case 4L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeOneParameter() {
        return stringify::NumberQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/numberQuery.h line 19
namespace stringify { namespace NumberQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "NumberOfArgsInParanthesisOperator";
            case 2L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNumberQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NumberQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NumberQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNumberQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NumberQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 133
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeOneParameter(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementType";
            case 1L: return "VariableDeclarations";
            case 2L: return "VariableTypes";
            case 3L: return "FunctionDeclarations";
            case 4L: return "MemberFunctionDeclarations";
            case 5L: return "ClassDeclarations";
            case 6L: return "StructDeclarations";
            case 7L: return "UnionDeclarations";
            case 8L: return "Arguments";
            case 9L: return "ClassFields";
            case 10L: return "StructFields";
            case 11L: return "UnionFields";
            case 12L: return "StructDefinitions";
            case 13L: return "TypedefDeclarations";
            case 14L: return "AnonymousTypedefs";
            case 15L: return "AnonymousTypedefClassDeclarations";
            case 16L: return "END_OF_NODE_TYPE_LIST_ONE_PARAMETER";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeOneParameter(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeOneParameter(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeOneParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeOneParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeOneParameter(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeOneParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeOneParameter() {
        return stringify::NodeQuery::TypeOfQueryTypeOneParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astQuery/nodeQuery.h line 154
namespace stringify { namespace NodeQuery {
    const char* TypeOfQueryTypeTwoParameters(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementTypeTwoParameters";
            case 1L: return "FunctionDeclarationFromDefinition";
            case 2L: return "ClassDeclarationFromName";
            case 3L: return "ClassDeclarationsFromTypeName";
            case 4L: return "PragmaDeclarationFromName";
            case 5L: return "VariableDeclarationFromName";
            case 6L: return "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS";
            default: return "";
        }
    }

    std::string TypeOfQueryTypeTwoParameters(int64_t i, const std::string &strip) {
        std::string s = TypeOfQueryTypeTwoParameters(i);
        if (s.empty())
            s = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeOfQueryTypeTwoParameters() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyNodeQueryTypeOfQueryTypeTwoParameters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::NodeQuery::TypeOfQueryTypeTwoParameters(i);
        if (retval.empty()) {
            retval = "(NodeQuery::TypeOfQueryTypeTwoParameters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyNodeQueryTypeOfQueryTypeTwoParameters() {
        return stringify::NodeQuery::TypeOfQueryTypeTwoParameters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 319
namespace stringify { namespace Rose { namespace Snippet {
    const char* InsertMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BODY";
            case 1L: return "INSERT_STMTS";
            default: return "";
        }
    }

    std::string InsertMechanism(int64_t i, const std::string &strip) {
        std::string s = InsertMechanism(i);
        if (s.empty())
            s = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetInsertMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::InsertMechanism(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::InsertMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::InsertMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetInsertMechanism() {
        return stringify::Rose::Snippet::InsertMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astSnippet/Snippet.h line 329
namespace stringify { namespace Rose { namespace Snippet {
    const char* LocalDeclarationPosition(int64_t i) {
        switch (i) {
            case 0L: return "LOCDECLS_AT_BEGINNING";
            case 1L: return "LOCDECLS_AT_END";
            case 2L: return "LOCDECLS_AT_CURSOR";
            default: return "";
        }
    }

    std::string LocalDeclarationPosition(int64_t i, const std::string &strip) {
        std::string s = LocalDeclarationPosition(i);
        if (s.empty())
            s = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LocalDeclarationPosition() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySnippetLocalDeclarationPosition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Snippet::LocalDeclarationPosition(i);
        if (retval.empty()) {
            retval = "(Rose::Snippet::LocalDeclarationPosition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Snippet::LocalDeclarationPosition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySnippetLocalDeclarationPosition() {
        return stringify::Rose::Snippet::LocalDeclarationPosition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/xomp.c line 63
namespace stringify {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_undefined";
            case 1L: return "e_gomp";
            case 2L: return "e_omni";
            case 3L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_rtl_enum() {
        return stringify::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/ompLowering/omp_lowering.h line 37
namespace stringify { namespace OmpSupport {
    const char* omp_rtl_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gomp";
            case 1L: return "e_omni";
            case 2L: return "e_last_rtl";
            default: return "";
        }
    }

    std::string omp_rtl_enum(int64_t i, const std::string &strip) {
        std::string s = omp_rtl_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_rtl_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_rtl_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_rtl_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_rtl_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_rtl_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_rtl_enum() {
        return stringify::OmpSupport::omp_rtl_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h line 40
namespace stringify { namespace FunctionCallInfo {
    const char* InsertionMode(int64_t i) {
        switch (i) {
            case 0L: return "INSERT_BEFORE";
            case 1L: return "APPEND_SCOPE";
            case 2L: return "INVALID";
            default: return "";
        }
    }

    std::string InsertionMode(int64_t i, const std::string &strip) {
        std::string s = InsertionMode(i);
        if (s.empty())
            s = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertionMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyFunctionCallInfoInsertionMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::FunctionCallInfo::InsertionMode(i);
        if (retval.empty()) {
            retval = "(FunctionCallInfo::InsertionMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "FunctionCallInfo::InsertionMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFunctionCallInfoInsertionMode() {
        return stringify::FunctionCallInfo::InsertionMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C line 17
namespace stringify {
    const char* defaultEnumFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_constructor";
            case 2L: return "e_destructor";
            case 3L: return "e_copy_constructor";
            case 4L: return "e_assignment_operator";
            case 5L: return "e_last_type";
            default: return "";
        }
    }

    std::string defaultEnumFunctionType(int64_t i, const std::string &strip) {
        std::string s = defaultEnumFunctionType(i);
        if (s.empty())
            s = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& defaultEnumFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_defaultEnumFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::defaultEnumFunctionType(i);
        if (retval.empty()) {
            retval = "(defaultEnumFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "defaultEnumFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_defaultEnumFunctionType() {
        return stringify::defaultEnumFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/matcherparser.h line 49
namespace stringify {
    const char* yytokentype(int64_t i) {
        switch (i) {
            case 258L: return "ALTERNATION";
            case 259L: return "NOT";
            case 260L: return "AND";
            case 261L: return "XOR";
            case 262L: return "OR";
            case 263L: return "NEQ";
            case 264L: return "EQ";
            case 265L: return "C_NEQ";
            case 266L: return "C_EQ";
            case 267L: return "WHERE";
            case 268L: return "TRUE";
            case 269L: return "FALSE";
            case 270L: return "IDENT";
            case 271L: return "VARIABLE";
            case 272L: return "INTEGER";
            case 273L: return "SQ_STRING";
            case 274L: return "NULL_NODE";
            case 275L: return "DOTDOT";
            default: return "";
        }
    }

    std::string yytokentype(int64_t i, const std::string &strip) {
        std::string s = yytokentype(i);
        if (s.empty())
            s = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& yytokentype() {
        static const int64_t values[] = {
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_yytokentype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::yytokentype(i);
        if (retval.empty()) {
            retval = "(yytokentype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "yytokentype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_yytokentype() {
        return stringify::yytokentype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 40
namespace stringify { namespace MatchStatus {
    const char* PatternMatchMode(int64_t i) {
        switch (i) {
            case 0L: return "MATCHMODE_SHALLOW";
            case 1L: return "MATCHMODE_DEEP";
            case 2L: return "MATCHMODE_SINGLE";
            default: return "";
        }
    }

    std::string PatternMatchMode(int64_t i, const std::string &strip) {
        std::string s = PatternMatchMode(i);
        if (s.empty())
            s = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PatternMatchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusPatternMatchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::PatternMatchMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::PatternMatchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::PatternMatchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusPatternMatchMode() {
        return stringify::MatchStatus::PatternMatchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astMatching/MatchOperation.h line 41
namespace stringify { namespace MatchStatus {
    const char* CheckNodeMode(int64_t i) {
        switch (i) {
            case 0L: return "NODECHECKMODE_TYPEID";
            case 1L: return "NODECHECKMODE_VARIANT";
            default: return "";
        }
    }

    std::string CheckNodeMode(int64_t i, const std::string &strip) {
        std::string s = CheckNodeMode(i);
        if (s.empty())
            s = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CheckNodeMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMatchStatusCheckNodeMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MatchStatus::CheckNodeMode(i);
        if (retval.empty()) {
            retval = "(MatchStatus::CheckNodeMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MatchStatus::CheckNodeMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMatchStatusCheckNodeMode() {
        return stringify::MatchStatus::CheckNodeMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 52
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "StatementScope";
            case 2L: return "SurroundingScope";
            case 3L: return "Preamble";
            case 4L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::MidLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 66
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfCurrentScope";
            case 3L: return "BeforeCurrentPosition";
            case 4L: return "ReplaceCurrentPosition";
            case 5L: return "AfterCurrentPosition";
            case 6L: return "BottomOfCurrentScope";
            case 7L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 79
namespace stringify { namespace MidLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "CurrentLocationTopOfScope";
            case 3L: return "CurrentLocationAfter";
            case 4L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            case 6L: return "CurrentLocationBottomOfScope";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 141
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* ScopeIdentifier_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownScope";
            case 1L: return "SurroundingScope";
            case 2L: return "ParentScope";
            case 3L: return "NestedLoopScope";
            case 4L: return "NestedConditionalScope";
            case 5L: return "FunctionScope";
            case 6L: return "FileScope";
            case 7L: return "GlobalScope";
            case 8L: return "Preamble";
            case 9L: return "LAST_SCOPE_TAG";
            default: return "";
        }
    }

    std::string ScopeIdentifier_Enum(int64_t i, const std::string &strip) {
        std::string s = ScopeIdentifier_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ScopeIdentifier_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum() {
        return stringify::HighLevelCollectionTypedefs::ScopeIdentifier_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 162
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* PlacementPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownPositionInScope";
            case 1L: return "PreamblePositionInScope";
            case 2L: return "TopOfScope";
            case 3L: return "TopOfIncludeRegion";
            case 4L: return "BottomOfIncludeRegion";
            case 5L: return "BeforeCurrentPosition";
            case 6L: return "ReplaceCurrentPosition";
            case 7L: return "AfterCurrentPosition";
            case 8L: return "BottomOfScope";
            case 9L: return "LAST_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string PlacementPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = PlacementPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PlacementPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::PlacementPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsPlacementPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::PlacementPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/midend/astRewriteMechanism/rewrite.h line 176
namespace stringify { namespace HighLevelCollectionTypedefs {
    const char* IntermediateFileStringPosition_Enum(int64_t i) {
        switch (i) {
            case 0L: return "unknownIntermediatePositionInScope";
            case 1L: return "GlobalScopePreamble";
            case 2L: return "GlobalScopeTopOfScope";
            case 3L: return "GlobalScopeTopOfIncludeRegion";
            case 4L: return "GlobalScopeBottomOfIncludeRegion";
            case 5L: return "GlobalScopeBeforeCurrentPosition";
            case 6L: return "GlobalScopeReplaceCurrentPosition";
            case 7L: return "FunctionScopePreamble";
            case 8L: return "FunctionScopeTopOfScope";
            case 9L: return "FunctionScopeBeforeCurrentPosition";
            case 10L: return "FunctionScopeReplaceCurrentPosition";
            case 11L: return "FunctionScopeAfterCurrentPosition";
            case 12L: return "FunctionScopeBottomOfScope";
            case 13L: return "GlobalScopeAfterCurrentPosition";
            case 14L: return "GlobalScopeBottomOfScope";
            case 15L: return "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG";
            default: return "";
        }
    }

    std::string IntermediateFileStringPosition_Enum(int64_t i, const std::string &strip) {
        std::string s = IntermediateFileStringPosition_Enum(i);
        if (s.empty())
            s = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IntermediateFileStringPosition_Enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum(i);
        if (retval.empty()) {
            retval = "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum() {
        return stringify::HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 4744
namespace stringify { namespace nlohmann { namespace detail {
    const char* input_format_t(int64_t i) {
        switch (i) {
            case 0L: return "json";
            case 1L: return "cbor";
            case 2L: return "msgpack";
            case 3L: return "ubjson";
            case 4L: return "bson";
            default: return "";
        }
    }

    std::string input_format_t(int64_t i, const std::string &strip) {
        std::string s = input_format_t(i);
        if (s.empty())
            s = "(nlohmann::detail::input_format_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& input_format_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_input_format_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::input_format_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::input_format_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::input_format_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_input_format_t() {
        return stringify::nlohmann::detail::input_format_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 5909
namespace stringify { namespace nlohmann { namespace detail { namespace lexer_base {
    const char* token_type(int64_t i) {
        switch (i) {
            case 0L: return "uninitialized";
            case 1L: return "literal_true";
            case 2L: return "literal_false";
            case 3L: return "literal_null";
            case 4L: return "value_string";
            case 5L: return "value_unsigned";
            case 6L: return "value_integer";
            case 7L: return "value_float";
            case 8L: return "begin_array";
            case 9L: return "begin_object";
            case 10L: return "end_array";
            case 11L: return "end_object";
            case 12L: return "name_separator";
            case 13L: return "value_separator";
            case 14L: return "parse_error";
            case 15L: return "end_of_input";
            case 16L: return "literal_or_value";
            default: return "";
        }
    }

    std::string token_type(int64_t i, const std::string &strip) {
        std::string s = token_type(i);
        if (s.empty())
            s = "(nlohmann::detail::lexer_base::token_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringify_nlohmann_detail_lexer_base_token_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::lexer_base::token_type(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::lexer_base::token_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::lexer_base::token_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_lexer_base_token_type() {
        return stringify::nlohmann::detail::lexer_base::token_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 7668
namespace stringify { namespace nlohmann { namespace detail {
    const char* cbor_tag_handler_t(int64_t i) {
        switch (i) {
            case 0L: return "error";
            case 1L: return "ignore";
            default: return "";
        }
    }

    std::string cbor_tag_handler_t(int64_t i, const std::string &strip) {
        std::string s = cbor_tag_handler_t(i);
        if (s.empty())
            s = "(nlohmann::detail::cbor_tag_handler_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cbor_tag_handler_t() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_cbor_tag_handler_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::cbor_tag_handler_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::cbor_tag_handler_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::cbor_tag_handler_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_cbor_tag_handler_t() {
        return stringify::nlohmann::detail::cbor_tag_handler_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 15469
namespace stringify { namespace nlohmann { namespace detail {
    const char* error_handler_t(int64_t i) {
        switch (i) {
            case 0L: return "strict";
            case 1L: return "replace";
            case 2L: return "ignore";
            default: return "";
        }
    }

    std::string error_handler_t(int64_t i, const std::string &strip) {
        std::string s = error_handler_t(i);
        if (s.empty())
            s = "(nlohmann::detail::error_handler_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& error_handler_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_detail_error_handler_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::detail::error_handler_t(i);
        if (retval.empty()) {
            retval = "(nlohmann::detail::error_handler_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::detail::error_handler_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_detail_error_handler_t() {
        return stringify::nlohmann::detail::error_handler_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/json/nlohmann/json.hpp line 24668
namespace stringify { namespace nlohmann { namespace basic_json {
    const char* patch_operations(int64_t i) {
        switch (i) {
            case 0L: return "add";
            case 1L: return "remove";
            case 2L: return "replace";
            case 3L: return "move";
            case 4L: return "copy";
            case 5L: return "test";
            case 6L: return "invalid";
            default: return "";
        }
    }

    std::string patch_operations(int64_t i, const std::string &strip) {
        std::string s = patch_operations(i);
        if (s.empty())
            s = "(nlohmann::basic_json::patch_operations)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& patch_operations() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_nlohmann_basic_json_patch_operations(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::nlohmann::basic_json::patch_operations(i);
        if (retval.empty()) {
            retval = "(nlohmann::basic_json::patch_operations)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "nlohmann::basic_json::patch_operations::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_nlohmann_basic_json_patch_operations() {
        return stringify::nlohmann::basic_json::patch_operations();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 40
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbHighlight";
            case 6L: return "tbLookup";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBoxToolbarIdx() {
        return stringify::qrs::QRTreeBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/TreeBox/QRTreeBox.h line 107
namespace stringify { namespace qrs { namespace QRTreeBox {
    const char* popmenu_nodes_id(int64_t i) {
        switch (i) {
            case 0L: return "pm_set_root";
            case 1L: return "pm_set_default_root";
            case 2L: return "pm_remove";
            case 3L: return "pm_expand";
            case 4L: return "pm_collapse";
            case 5L: return "pm_expand_code";
            default: return "";
        }
    }

    std::string popmenu_nodes_id(int64_t i, const std::string &strip) {
        std::string s = popmenu_nodes_id(i);
        if (s.empty())
            s = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& popmenu_nodes_id() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRTreeBox_popmenu_nodes_id(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRTreeBox::popmenu_nodes_id(i);
        if (retval.empty()) {
            retval = "(qrs::QRTreeBox::popmenu_nodes_id)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRTreeBox::popmenu_nodes_id::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRTreeBox_popmenu_nodes_id() {
        return stringify::qrs::QRTreeBox::popmenu_nodes_id();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qeditor.h line 65
namespace stringify { namespace qrs { namespace QEditor {
    const char* TypeSel(int64_t i) {
        switch (i) {
            case 1000L: return "sel0";
            case 2000L: return "sel1";
            default: return "";
        }
    }

    std::string TypeSel(int64_t i, const std::string &strip) {
        std::string s = TypeSel(i);
        if (s.empty())
            s = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeSel() {
        static const int64_t values[] = {
            1000L,
            2000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQEditorTypeSel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QEditor::TypeSel(i);
        if (retval.empty()) {
            retval = "(qrs::QEditor::TypeSel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QEditor::TypeSel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQEditorTypeSel() {
        return stringify::qrs::QEditor::TypeSel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 37
namespace stringify { namespace qrs { namespace Paren {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Open";
            case 1L: return "Closed";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Paren::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Paren::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Paren::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenType() {
        return stringify::qrs::Paren::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/parenmatcher.h line 48
namespace stringify { namespace qrs { namespace ParenMatcher {
    const char* Selection(int64_t i) {
        switch (i) {
            case 1L: return "Match";
            case 2L: return "Mismatch";
            default: return "";
        }
    }

    std::string Selection(int64_t i, const std::string &strip) {
        std::string s = Selection(i);
        if (s.empty())
            s = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Selection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsParenMatcherSelection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::ParenMatcher::Selection(i);
        if (retval.empty()) {
            retval = "(qrs::ParenMatcher::Selection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::ParenMatcher::Selection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsParenMatcherSelection() {
        return stringify::qrs::ParenMatcher::Selection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/paragdata.h line 36
namespace stringify { namespace qrs { namespace Symbol {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Left";
            case 1L: return "Right";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Symbol::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Symbol::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Symbol::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsSymbolType() {
        return stringify::qrs::Symbol::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/QRSourceBox.h line 39
namespace stringify { namespace qrs { namespace QRSourceBox {
    const char* ToolbarIdx(int64_t i) {
        switch (i) {
            case 0L: return "tbTargetMode";
            case 1L: return "tbCacheView";
            case 2L: return "tbCollectMode";
            case 3L: return "tbClearCache";
            case 4L: return "tbBroadcastCache";
            case 5L: return "tbGoto";
            case 6L: return "tbLookup";
            case 7L: return "tbZoomIn";
            case 8L: return "tbZoomOut";
            default: return "";
        }
    }

    std::string ToolbarIdx(int64_t i, const std::string &strip) {
        std::string s = ToolbarIdx(i);
        if (s.empty())
            s = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ToolbarIdx() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSourceBoxToolbarIdx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSourceBox::ToolbarIdx(i);
        if (retval.empty()) {
            retval = "(qrs::QRSourceBox::ToolbarIdx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSourceBox::ToolbarIdx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSourceBoxToolbarIdx() {
        return stringify::qrs::QRSourceBox::ToolbarIdx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/qsourcecolorizer.h line 257
namespace stringify { namespace qrs { namespace QSourceColorizer {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "PreProcessor";
            case 2L: return "Keyword";
            case 3L: return "BuiltInClass";
            case 4L: return "Operator";
            case 5L: return "Comment";
            case 6L: return "Constant";
            case 7L: return "String";
            case 1000L: return "Custom";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1000L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQSourceColorizerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QSourceColorizer::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QSourceColorizer::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QSourceColorizer::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQSourceColorizerType() {
        return stringify::qrs::QSourceColorizer::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 122
namespace stringify { namespace qrs { namespace Q3TextStringChar {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Regular";
            case 1L: return "Custom";
            case 2L: return "Anchor";
            case 3L: return "CustomAnchor";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextStringCharType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextStringChar::Type(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextStringChar::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextStringChar::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextStringCharType() {
        return stringify::qrs::Q3TextStringChar::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 366
namespace stringify { namespace qrs { namespace Q3TextCursor {
    const char* Operation(int64_t i) {
        switch (i) {
            case 0L: return "EnterBegin";
            case 1L: return "EnterEnd";
            case 2L: return "Next";
            case 3L: return "Prev";
            case 4L: return "Up";
            case 5L: return "Down";
            default: return "";
        }
    }

    std::string Operation(int64_t i, const std::string &strip) {
        std::string s = Operation(i);
        if (s.empty())
            s = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCursorOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCursor::Operation(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCursor::Operation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCursor::Operation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCursorOperation() {
        return stringify::qrs::Q3TextCursor::Operation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 390
namespace stringify { namespace qrs { namespace Q3TextCommand {
    const char* Commands(int64_t i) {
        switch (i) {
            case 0L: return "Invalid";
            case 1L: return "Insert";
            case 2L: return "Delete";
            case 3L: return "Format";
            case 4L: return "Style";
            default: return "";
        }
    }

    std::string Commands(int64_t i, const std::string &strip) {
        std::string s = Commands(i);
        if (s.empty())
            s = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Commands() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCommandCommands(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCommand::Commands(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCommand::Commands)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCommand::Commands::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCommandCommands() {
        return stringify::qrs::Q3TextCommand::Commands();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 451
namespace stringify { namespace qrs { namespace Q3TextCustomItem {
    const char* Placement(int64_t i) {
        switch (i) {
            case 0L: return "PlaceInline";
            case 1L: return "PlaceLeft";
            case 2L: return "PlaceRight";
            default: return "";
        }
    }

    std::string Placement(int64_t i, const std::string &strip) {
        std::string s = Placement(i);
        if (s.empty())
            s = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Placement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextCustomItemPlacement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextCustomItem::Placement(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextCustomItem::Placement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextCustomItem::Placement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextCustomItemPlacement() {
        return stringify::qrs::Q3TextCustomItem::Placement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 724
namespace stringify { namespace qrs { namespace Q3TextDocument {
    const char* SelectionIds(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            case 32000L: return "Temp";
            default: return "";
        }
    }

    std::string SelectionIds(int64_t i, const std::string &strip) {
        std::string s = SelectionIds(i);
        if (s.empty())
            s = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SelectionIds() {
        static const int64_t values[] = {
            0L,
            32000L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextDocumentSelectionIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextDocument::SelectionIds(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextDocument::SelectionIds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextDocument::SelectionIds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextDocumentSelectionIds() {
        return stringify::qrs::Q3TextDocument::SelectionIds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1380
namespace stringify { namespace qrs { namespace Q3TextPreProcessor {
    const char* Ids(int64_t i) {
        switch (i) {
            case 0L: return "Standard";
            default: return "";
        }
    }

    std::string Ids(int64_t i, const std::string &strip) {
        std::string s = Ids(i);
        if (s.empty())
            s = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ids() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextPreProcessorIds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextPreProcessor::Ids(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextPreProcessor::Ids)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextPreProcessor::Ids::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextPreProcessorIds() {
        return stringify::qrs::Q3TextPreProcessor::Ids();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1400
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* Flags(int64_t i) {
        switch (i) {
            case 0L: return "NoFlags";
            case 1L: return "Bold";
            case 2L: return "Italic";
            case 4L: return "Underline";
            case 8L: return "Family";
            case 16L: return "Size";
            case 32L: return "Color";
            case 64L: return "Misspelled";
            case 128L: return "VAlign";
            case 256L: return "StrikeOut";
            case 287L: return "Font";
            case 511L: return "Format";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            287L,
            511L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::Flags(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatFlags() {
        return stringify::qrs::Q3TextFormat::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Components/SourceBox/q3richtext_px.h line 1415
namespace stringify { namespace qrs { namespace Q3TextFormat {
    const char* VerticalAlignment(int64_t i) {
        switch (i) {
            case 0L: return "AlignNormal";
            case 1L: return "AlignSuperScript";
            case 2L: return "AlignSubScript";
            default: return "";
        }
    }

    std::string VerticalAlignment(int64_t i, const std::string &strip) {
        std::string s = VerticalAlignment(i);
        if (s.empty())
            s = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VerticalAlignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQ3TextFormatVerticalAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::Q3TextFormat::VerticalAlignment(i);
        if (retval.empty()) {
            retval = "(qrs::Q3TextFormat::VerticalAlignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::Q3TextFormat::VerticalAlignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQ3TextFormatVerticalAlignment() {
        return stringify::qrs::Q3TextFormat::VerticalAlignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRButtons.h line 29
namespace stringify { namespace qrs { namespace QRButtons {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Normal";
            case 1L: return "Toggle";
            case 2L: return "Check";
            case 3L: return "Radio";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRButtonsType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRButtons::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRButtons::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRButtons::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRButtonsType() {
        return stringify::qrs::QRButtons::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QRSelect.h line 26
namespace stringify { namespace qrs { namespace QRSelect {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Combo";
            case 1L: return "Box";
            case 2L: return "Check";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQRSelectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QRSelect::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QRSelect::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QRSelect::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQRSelectType() {
        return stringify::qrs::QRSelect::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/qrose/Widgets/QREdit.h line 28
namespace stringify { namespace qrs { namespace QREdit {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "Line";
            case 1L: return "Box";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_qrsQREditType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::qrs::QREdit::Type(i);
        if (retval.empty()) {
            retval = "(qrs::QREdit::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "qrs::QREdit::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_qrsQREditType() {
        return stringify::qrs::QREdit::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/3rdPartyLibraries/MSTL/DOTGeneration.h line 48
namespace stringify { namespace DOTGeneration {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "PREORDER";
            case 1L: return "POSTORDER";
            case 2L: return "TOPDOWN";
            case 3L: return "BOTTOMUP";
            case 4L: return "TOPDOWNBOTTOMUP";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGeneration_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGeneration::traversalType(i);
        if (retval.empty()) {
            retval = "(DOTGeneration::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGeneration::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGeneration_traversalType() {
        return stringify::DOTGeneration::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Ast.h line 138
namespace stringify { namespace Rosebud { namespace Ast { namespace CppStack {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "IF";
            case 1L: return "ELSE";
            case 2L: return "END";
            case 3L: return "OTHER";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rosebud::Ast::CppStack::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyRosebudAstCppStackType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Ast::CppStack::Type(i);
        if (retval.empty()) {
            retval = "(Rosebud::Ast::CppStack::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Ast::CppStack::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudAstCppStackType() {
        return stringify::Rosebud::Ast::CppStack::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/BasicTypes.h line 465
namespace stringify { namespace Rosebud {
    const char* Expand(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "INTER";
            case 2L: return "PRIOR";
            default: return "";
        }
    }

    std::string Expand(int64_t i, const std::string &strip) {
        std::string s = Expand(i);
        if (s.empty())
            s = "(Rosebud::Expand)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Expand() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudExpand(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Expand(i);
        if (retval.empty()) {
            retval = "(Rosebud::Expand)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Expand::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudExpand() {
        return stringify::Rosebud::Expand();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/BasicTypes.h line 472
namespace stringify { namespace Rosebud {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "ALWAYS";
            case 2L: return "AUTO";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Rosebud::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::When(i);
        if (retval.empty()) {
            retval = "(Rosebud::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudWhen() {
        return stringify::Rosebud::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Utility.h line 20
namespace stringify { namespace Rosebud {
    const char* Access(int64_t i) {
        switch (i) {
            case 0L: return "PRIVATE";
            case 1L: return "PROTECTED";
            case 2L: return "PUBLIC";
            case 3L: return "DEFAULT";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Rosebud::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::Access(i);
        if (retval.empty()) {
            retval = "(Rosebud::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudAccess() {
        return stringify::Rosebud::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rosebud/Utility.h line 95
namespace stringify { namespace Rosebud {
    const char* CamelCase(int64_t i) {
        switch (i) {
            case 0L: return "LOWER";
            case 1L: return "UPPER";
            case 2L: return "UNCHANGED";
            default: return "";
        }
    }

    std::string CamelCase(int64_t i, const std::string &strip) {
        std::string s = CamelCase(i);
        if (s.empty())
            s = "(Rosebud::CamelCase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CamelCase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyRosebudCamelCase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rosebud::CamelCase(i);
        if (retval.empty()) {
            retval = "(Rosebud::CamelCase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rosebud::CamelCase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyRosebudCamelCase() {
        return stringify::Rosebud::CamelCase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/csharpBuilder.h line 10
namespace stringify { namespace csharp_translator {
    const char* SeqKind(int64_t i) {
        switch (i) {
            case 2L: return "GLOBALSCOPESEQ";
            case 3L: return "CLASSMEMBERSEQ";
            case 4L: return "PARAMETERSEQ";
            case 5L: return "METHODBODYSEQ";
            case 6L: return "EXPRLISTSEQ";
            case 7L: return "IFSTMT";
            case 8L: return "FORSTMT";
            case 9L: return "WHILESTMT";
            default: return "";
        }
    }

    std::string SeqKind(int64_t i, const std::string &strip) {
        std::string s = SeqKind(i);
        if (s.empty())
            s = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SeqKind() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_csharp_translatorSeqKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::csharp_translator::SeqKind(i);
        if (retval.empty()) {
            retval = "(csharp_translator::SeqKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "csharp_translator::SeqKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_csharp_translatorSeqKind() {
        return stringify::csharp_translator::SeqKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Csharp_ROSE_Connection/ast2dot.hpp line 11
namespace stringify { namespace dot {
    const char* attr_set(int64_t i) {
        switch (i) {
            case 0L: return "simple";
            case 1L: return "types";
            case 3L: return "moretypes";
            case 4L: return "decllinks";
            case 5L: return "balanced";
            case 8L: return "symbols";
            case 16L: return "builtins";
            case 31L: return "full";
            default: return "";
        }
    }

    std::string attr_set(int64_t i, const std::string &strip) {
        std::string s = attr_set(i);
        if (s.empty())
            s = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attr_set() {
        static const int64_t values[] = {
            0L,
            1L,
            3L,
            4L,
            5L,
            8L,
            16L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_dot_attr_set(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::dot::attr_set(i);
        if (retval.empty()) {
            retval = "(dot::attr_set)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "dot::attr_set::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_dot_attr_set() {
        return stringify::dot::attr_set();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/ECJ_ROSE_Connection/JavaParserActionROSE.C line 4135
namespace stringify {
    const char* ops(int64_t i) {
        switch (i) {
            case 0L: return "ERROR_OPERATOR";
            case 2L: return "AND";
            case 3L: return "OR";
            case 4L: return "LESS";
            case 5L: return "LESS_EQUAL";
            case 6L: return "GREATER";
            case 7L: return "GREATER_EQUAL";
            case 8L: return "XOR";
            case 9L: return "DIVIDE";
            case 10L: return "LEFT_SHIFT";
            case 13L: return "MINUS";
            case 14L: return "PLUS";
            case 15L: return "MULTIPLY";
            case 16L: return "REMAINDER";
            case 17L: return "RIGHT_SHIFT";
            case 19L: return "UNSIGNED_RIGHT_SHIFT";
            case 100L: return "OR_OR";
            case 101L: return "AND_AND";
            case 102L: return "LAST_OPERATOR";
            default: return "";
        }
    }

    std::string ops(int64_t i, const std::string &strip) {
        std::string s = ops(i);
        if (s.empty())
            s = "(ops)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ops() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            13L,
            14L,
            15L,
            16L,
            17L,
            19L,
            100L,
            101L,
            102L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_ops(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ops(i);
        if (retval.empty()) {
            retval = "(ops)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ops::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_ops() {
        return stringify::ops();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Jovial_ROSE_Connection/Jovial_to_ROSE_translation.h line 11
namespace stringify { namespace Jovial_ROSE_Translation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 1L: return "e_unknown";
            case 9999L: return "e_exponentiateOperator";
            case 10000L: return "e_plusOperator";
            case 10001L: return "e_minusOperator";
            case 10002L: return "e_modOperator";
            case 10003L: return "e_multiplyOperator";
            case 10004L: return "e_divideOperator";
            case 10005L: return "e_notOperator";
            case 10006L: return "e_andOperator";
            case 10007L: return "e_orOperator";
            case 10008L: return "e_xorOperator";
            case 10009L: return "e_equivOperator";
            case 10010L: return "e_lessThanOperator";
            case 10011L: return "e_greaterThanOperator";
            case 10012L: return "e_lessThanOrEqualOperator";
            case 10013L: return "e_greaterThanOrEqualOperator";
            case 10014L: return "e_equalOperator";
            case 10015L: return "e_notEqualOperator";
            case 10016L: return "e_derefOperator";
            case 10017L: return "e_assignOperator";
            case 10018L: return "e_unaryPlusOperator";
            case 10019L: return "e_unaryMinusOperator";
            case 10020L: return "e_notAnOperator";
            case 10021L: return "e_literalExpression";
            case 10022L: return "e_referenceExpression";
            case 10023L: return "e_by_phrase_expr";
            case 10024L: return "e_then_phrase_expr";
            case 10025L: return "e_while_phrase_expr";
            case 10026L: return "e_words_per_entry_w";
            case 10027L: return "e_words_per_entry_v";
            case 10028L: return "e_for_while_by_stmt";
            case 10029L: return "e_for_while_then_stmt";
            case 10030L: return "e_for_by_while_stmt";
            case 10031L: return "e_for_then_while_stmt";
            case 10032L: return "e_simple_block_type_declaration";
            case 10033L: return "e_block_type_declaration";
            case 10034L: return "e_simple_table_type_declaration";
            case 10035L: return "e_table_type_declaration";
            case 10036L: return "e_anonymous_declaration";
            case 10037L: return "e_compool_directive_stmt";
            case 10038L: return "e_reducible_directive_stmt";
            case 10039L: return "e_order_directive_stmt";
            case 10040L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            1L,
            9999L,
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L,
            10023L,
            10024L,
            10025L,
            10026L,
            10027L,
            10028L,
            10029L,
            10030L,
            10031L,
            10032L,
            10033L,
            10034L,
            10035L,
            10036L,
            10037L,
            10038L,
            10039L,
            10040L
        };
        static const std::vector<int64_t> retval(values, values + 43);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyJovial_ROSE_TranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Jovial_ROSE_Translation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(Jovial_ROSE_Translation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Jovial_ROSE_Translation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyJovial_ROSE_TranslationExpressionKind() {
        return stringify::Jovial_ROSE_Translation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Jovial_ROSE_Connection/preprocess.C line 32
namespace stringify { namespace Jovial {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "start_token";
            case 1L: return "E1";
            case 2L: return "F";
            case 3L: return "I";
            case 4L: return "N";
            case 5L: return "E2";
            case 6L: return "WS";
            case 7L: return "name_start";
            case 8L: return "name";
            case 9L: return "close_paren";
            case 10L: return "define_quote1";
            case 11L: return "define_quote2";
            case 12L: return "end_comment_quote1";
            case 13L: return "end_comment_quote2";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Jovial::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyJovialState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Jovial::State(i);
        if (retval.empty()) {
            retval = "(Jovial::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Jovial::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyJovialState() {
        return stringify::Jovial::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 14
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L
        };
        static const std::vector<int64_t> retval(values, values + 126);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 147
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_keywords() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 215
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 242
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_C_CXX_operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_C_CXX_operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_C_CXX_operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_C_CXX_operators() {
        return stringify::ROSE_Fortran_defs::ROSE_C_CXX_operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h line 321
namespace stringify { namespace ROSE_Fortran_defs {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_defs::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 10
namespace stringify {
    const char* ROSE_Fortran_Identifiers(int64_t i) {
        switch (i) {
            case 2L: return "ROSE_ABSTRACT";
            case 3L: return "ROSE_ACCESS";
            case 4L: return "ROSE_ACTION";
            case 5L: return "ROSE_ALLOCATE";
            case 6L: return "ROSE_ALLOCATABLE";
            case 7L: return "ROSE_ASSIGN";
            case 8L: return "ROSE_ASSOCIATE";
            case 9L: return "ROSE_ASYNCHRONOUS";
            case 10L: return "ROSE_BACKSPACE";
            case 11L: return "ROSE_BIND";
            case 12L: return "ROSE_BLANK";
            case 13L: return "ROSE_BLOCK_DATA";
            case 14L: return "ROSE_CALL";
            case 15L: return "ROSE_CHARACTER";
            case 16L: return "ROSE_CLASS";
            case 17L: return "ROSE_CLOSE";
            case 18L: return "ROSE_CONTINUE";
            case 19L: return "ROSE_CYCLE";
            case 20L: return "ROSE_CASE";
            case 21L: return "ROSE_COMMON";
            case 22L: return "ROSE_COMPLEX";
            case 23L: return "ROSE_CONTAINS";
            case 24L: return "ROSE_DEALLOCATE";
            case 25L: return "ROSE_DATA";
            case 26L: return "ROSE_DEFERRED";
            case 27L: return "ROSE_DELIM";
            case 28L: return "ROSE_DIMENSION";
            case 29L: return "ROSE_DO";
            case 30L: return "ROSE_DT";
            case 31L: return "ROSE_DOUBLEPRECISION";
            case 32L: return "ROSE_ENCODING";
            case 33L: return "ROSE_END_CASE";
            case 34L: return "ROSE_ENDDO";
            case 35L: return "ROSE_END_FILE";
            case 36L: return "ROSE_END_ENUM";
            case 37L: return "ROSE_END_INTERFACE";
            case 38L: return "ROSE_END_TYPE";
            case 39L: return "ROSE_ERR";
            case 40L: return "ROSE_ERRMSG";
            case 41L: return "ROSE_EXIT";
            case 42L: return "ROSE_ELSE";
            case 43L: return "ROSE_ELSEWHERE";
            case 44L: return "ROSE_ELSEIF";
            case 45L: return "ROSE_ENDIF";
            case 46L: return "ROSE_ENTRY";
            case 47L: return "ROSE_ENUM";
            case 49L: return "ROSE_ENUMERATOR";
            case 50L: return "ROSE_EQUIVALENCE";
            case 51L: return "ROSE_EXTERNAL";
            case 52L: return "ROSE_EXTENDS";
            case 53L: return "ROSE_FILE";
            case 54L: return "ROSE_FINAL";
            case 55L: return "ROSE_FMT";
            case 56L: return "ROSE_FORALL";
            case 57L: return "ROSE_FORM";
            case 58L: return "ROSE_FORMATTED";
            case 59L: return "ROSE_FORMAT";
            case 60L: return "ROSE_FLUSH";
            case 61L: return "ROSE_FUNCTION";
            case 62L: return "ROSE_GENERIC";
            case 63L: return "ROSE_GOTO";
            case 64L: return "ROSE_ID";
            case 65L: return "ROSE_IF";
            case 66L: return "ROSE_INQUIRE";
            case 67L: return "ROSE_INTEGER";
            case 68L: return "ROSE_IOMSG";
            case 69L: return "ROSE_IOSTAT";
            case 70L: return "ROSE_IMPLICIT";
            case 71L: return "ROSE_IMPLICIT_NONE";
            case 72L: return "ROSE_IMPORT";
            case 73L: return "ROSE_INTERFACE";
            case 74L: return "ROSE_INTENT";
            case 75L: return "ROSE_INTRINSIC";
            case 76L: return "ROSE_LEN";
            case 77L: return "ROSE_LOGICAL";
            case 78L: return "ROSE_KIND";
            case 79L: return "ROSE_MODULE_PROC";
            case 80L: return "ROSE_MODULE";
            case 81L: return "ROSE_NON_INTRINSIC";
            case 82L: return "ROSE_NON_OVERRIDABLE";
            case 83L: return "ROSE_NULL";
            case 84L: return "ROSE_NULLIFY";
            case 85L: return "ROSE_NAMELIST";
            case 86L: return "ROSE_NML";
            case 87L: return "ROSE_NONE";
            case 88L: return "ROSE_NOPASS";
            case 89L: return "ROSE_ONLY";
            case 90L: return "ROSE_OPTIONAL";
            case 91L: return "ROSE_PARAMETER";
            case 92L: return "ROSE_PASS";
            case 93L: return "ROSE_PAUSE";
            case 94L: return "ROSE_POINTER";
            case 96L: return "ROSE_PRINT";
            case 97L: return "ROSE_PRIVATE";
            case 98L: return "ROSE_PROCEDURE";
            case 99L: return "ROSE_PROGRAM";
            case 100L: return "ROSE_PROTECTED";
            case 101L: return "ROSE_READ";
            case 102L: return "ROSE_REAL";
            case 103L: return "ROSE_RETURN";
            case 104L: return "ROSE_REWIND";
            case 105L: return "ROSE_ROUND";
            case 106L: return "ROSE_SELECTCASE";
            case 107L: return "ROSE_SELECTTYPE";
            case 108L: return "ROSE_SEQUENCE";
            case 109L: return "ROSE_SAVE";
            case 110L: return "ROSE_SIGN";
            case 111L: return "ROSE_SIZE";
            case 112L: return "ROSE_SOURCE";
            case 113L: return "ROSE_STAT";
            case 114L: return "ROSE_STOP";
            case 115L: return "ROSE_SUBROUTINE";
            case 116L: return "ROSE_TARGET";
            case 117L: return "ROSE_THEN";
            case 118L: return "ROSE_DERIVED_DECL";
            case 119L: return "ROSE_TYPEIS";
            case 120L: return "ROSE_UNFORMATTED";
            case 121L: return "ROSE_UNIT";
            case 122L: return "ROSE_USE";
            case 123L: return "ROSE_VALUE";
            case 124L: return "ROSE_VOLATILE";
            case 125L: return "ROSE_WAIT";
            case 126L: return "ROSE_WHERE";
            case 127L: return "ROSE_WRITE";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Identifiers(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Identifiers(i);
        if (s.empty())
            s = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Identifiers() {
        static const int64_t values[] = {
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Identifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Identifiers(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Identifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Identifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Identifiers() {
        return stringify::ROSE_Fortran_Identifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 140
namespace stringify {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 1001L: return "ROSE_INTRINSIC_PLUS";
            case 1002L: return "ROSE_INTRINSIC_MINUS";
            case 1003L: return "ROSE_INTRINSIC_POWER";
            case 1004L: return "ROSE_INTRINSIC_CONCAT";
            case 1005L: return "ROSE_INTRINSIC_TIMES";
            case 1006L: return "ROSE_INTRINSIC_DIVIDE";
            case 1007L: return "ROSE_INTRINSIC_AND";
            case 1008L: return "ROSE_INTRINSIC_OR";
            case 1009L: return "ROSE_INTRINSIC_EQV";
            case 1010L: return "ROSE_INTRINSIC_NEQV";
            case 1011L: return "ROSE_INTRINSIC_EQ";
            case 1012L: return "ROSE_INTRINSIC_NE";
            case 1013L: return "ROSE_INTRINSIC_GE";
            case 1014L: return "ROSE_INTRINSIC_LE";
            case 1015L: return "ROSE_INTRINSIC_LT";
            case 1016L: return "ROSE_INTRINSIC_GT";
            case 1017L: return "ROSE_INTRINSIC_NOT";
            case 1018L: return "ROSE_INTRINSIC_OLDEQ";
            case 1019L: return "ROSE_INTRINSIC_OLDNE";
            case 1020L: return "ROSE_INTRINSIC_OLDGE";
            case 1021L: return "ROSE_INTRINSIC_OLDLE";
            case 1022L: return "ROSE_INTRINSIC_OLDLT";
            case 1023L: return "ROSE_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Operators() {
        return stringify::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h line 167
namespace stringify {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 10001L: return "ROSE_FORT_COMMENTS";
            case 10002L: return "ROSE_STRING_LITERALS";
            case 10003L: return "ROSE_IDENTIFIER";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            10001L,
            10002L,
            10003L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_Fortran_Additional_Info() {
        return stringify::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 266
namespace stringify {
    const char* an_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "initk_none";
            case 1L: return "initk_static";
            case 2L: return "initk_dynamic";
            case 3L: return "initk_zero";
            case 4L: return "initk_function_local";
            default: return "";
        }
    }

    std::string an_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_kind_tag(i);
        if (s.empty())
            s = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_kind_tag() {
        return stringify::an_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 1182
namespace stringify {
    const char* a_decl_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "dmt_dllimport";
            case 1L: return "dmt_dllexport";
            case 2L: return "dmt_thread";
            case 3L: return "dmt_microsoft_inline";
            case 4L: return "dmt_forceinline";
            case 5L: return "dmt_selectany";
            case 6L: return "dmt_novtable";
            case 7L: return "dmt_noalias";
            case 8L: return "dmt_restrict";
            case 9L: return "dmt_safebuffers";
            case 10L: return "dmt_global_link_scope";
            case 11L: return "dmt_symbolic_link_scope";
            case 12L: return "dmt_hidden_link_scope";
            case 13L: return "dmt_host";
            case 14L: return "dmt_global";
            case 15L: return "dmt_device";
            case 16L: return "dmt_shared";
            case 17L: return "dmt_local";
            case 18L: return "dmt_constant";
            case 19L: return "dmt_last";
            default: return "";
        }
    }

    std::string a_decl_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_decl_modifier_tag(i);
        if (s.empty())
            s = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_decl_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_decl_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_decl_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_decl_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_decl_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_decl_modifier_tag() {
        return stringify::a_decl_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 7715
namespace stringify {
    const char* a_local_expr_node_ref_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "lerk_none";
            case 1L: return "lerk_typeof";
            case 2L: return "lerk_generic_sizeof";
            case 3L: return "lerk_array_bound";
            case 4L: return "lerk_dep_array_bound";
            case 5L: return "lerk_decltype";
            default: return "";
        }
    }

    std::string a_local_expr_node_ref_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_local_expr_node_ref_kind_tag(i);
        if (s.empty())
            s = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_local_expr_node_ref_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_local_expr_node_ref_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_local_expr_node_ref_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_local_expr_node_ref_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_local_expr_node_ref_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_local_expr_node_ref_kind_tag() {
        return stringify::a_local_expr_node_ref_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 10917
namespace stringify {
    const char* an_operand_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ok_error";
            case 1L: return "ok_expression";
            case 2L: return "ok_constant";
            case 3L: return "ok_indefinite_function";
            case 4L: return "ok_sym_for_member";
            case 5L: return "ok_property_ref";
            case 6L: return "ok_undefined_symbol";
            default: return "";
        }
    }

    std::string an_operand_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_kind_tag(i);
        if (s.empty())
            s = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_kind_tag() {
        return stringify::an_operand_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 13058
namespace stringify {
    const char* a_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pk_none";
            case 1L: return "pk_printf_args";
            case 2L: return "pk_scanf_args";
            case 3L: return "pk_lint_argsused";
            case 4L: return "pk_lint_varargs_count";
            case 5L: return "pk_lint_notreached";
            case 6L: return "pk_instantiate";
            case 7L: return "pk_do_not_instantiate";
            case 8L: return "pk_can_instantiate";
            case 9L: return "pk_inline_template";
            case 10L: return "pk_pack";
            case 11L: return "pk_ident";
            case 12L: return "pk_weak";
            case 13L: return "pk_once";
            case 14L: return "pk_hdrstop";
            case 15L: return "pk_no_pch";
            case 16L: return "pk_define_type_info";
            case 17L: return "pk_stdc";
            case 18L: return "pk_upc";
            case 19L: return "pk_redefine_extname";
            case 20L: return "pk_enable_ldscope";
            case 21L: return "pk_disable_ldscope";
            case 22L: return "pk_gcc";
            case 23L: return "pk_diag_suppress";
            case 24L: return "pk_diag_remark";
            case 25L: return "pk_diag_warning";
            case 26L: return "pk_diag_error";
            case 27L: return "pk_diag_once";
            case 28L: return "pk_diag_default";
            case 29L: return "pk_test_next_statement";
            case 30L: return "pk_test_next_decl";
            case 31L: return "pk_test_immediate";
            case 32L: return "pk_test_immediate_text";
            case 33L: return "pk_test_immediate_pp_text";
            case 34L: return "pk_test_other";
            case 35L: return "pk_test_bind_next_pass";
            case 36L: return "pk_checking_pragma";
            case 37L: return "pk_db_opt";
            case 38L: return "pk_db_name";
            case 39L: return "pk_if_exists";
            case 40L: return "pk_push_macro";
            case 41L: return "pk_pop_macro";
            case 42L: return "pk_start_map_region";
            case 43L: return "pk_stop_map_region";
            case 44L: return "pk_setlocale";
            case 45L: return "pk_comment";
            case 46L: return "pk_conform";
            case 47L: return "pk_include_alias";
            case 48L: return "pk_unrecognized";
            case 49L: return "pk_last";
            default: return "";
        }
    }

    std::string a_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L
        };
        static const std::vector<int64_t> retval(values, values + 50);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_kind_tag() {
        return stringify::a_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/debugging.C line 14113
namespace stringify {
    const char* a_name_linkage_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "nlk_none";
            case 1L: return "nlk_internal";
            case 2L: return "nlk_cplusplus_external";
            case 3L: return "nlk_last_standard";
            default: return "";
        }
    }

    std::string a_name_linkage_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_name_linkage_kind_tag(i);
        if (s.empty())
            s = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_name_linkage_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_name_linkage_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_name_linkage_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_name_linkage_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_name_linkage_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_name_linkage_kind_tag() {
        return stringify::a_name_linkage_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/edgRose.C line 6389
namespace stringify {
    const char* kinds_of_type_references(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_type_reference";
            case 1L: return "e_modifier_type_reference";
            case 2L: return "e_typeof_type_reference";
            case 3L: return "e_decltype_type_reference";
            case 4L: return "e_template_alias_type_reference";
            case 5L: return "e_last_type_reference";
            default: return "";
        }
    }

    std::string kinds_of_type_references(int64_t i, const std::string &strip) {
        std::string s = kinds_of_type_references(i);
        if (s.empty())
            s = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& kinds_of_type_references() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_kinds_of_type_references(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::kinds_of_type_references(i);
        if (retval.empty()) {
            retval = "(kinds_of_type_references)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "kinds_of_type_references::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_kinds_of_type_references() {
        return stringify::kinds_of_type_references();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/edgRose/edgRose.C line 46796
namespace stringify {
    const char* a_special_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfk_none";
            case 1L: return "sfk_constructor";
            case 2L: return "sfk_destructor";
            case 3L: return "sfk_conversion";
            case 4L: return "sfk_udl_operator";
            case 5L: return "sfk_operator";
            case 6L: return "sfk_lambda_entry_point";
            case 7L: return "sfk_static_constructor";
            case 8L: return "sfk_finalizer";
            case 9L: return "sfk_idisposable_dispose";
            case 10L: return "sfk_dispose_bool";
            case 11L: return "sfk_object_finalize";
            case 12L: return "sfk_property_get";
            case 13L: return "sfk_property_set";
            case 14L: return "sfk_event_add";
            case 15L: return "sfk_event_remove";
            case 16L: return "sfk_last_accessor";
            case 17L: return "sfk_gnu_sync_concrete_function";
            case 18L: return "sfk_gnu_atomic_nongeneric_function";
            case 19L: return "sfk_last";
            default: return "";
        }
    }

    std::string a_special_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_special_function_kind_tag(i);
        if (s.empty())
            s = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_special_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_special_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_special_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_special_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_special_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_special_function_kind_tag() {
        return stringify::a_special_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/include/cxxabi.h line 62
namespace stringify { namespace __cxxabiv1 { namespace __base_class_type_info {
    const char* __offset_flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__virtual_mask";
            case 2L: return "__public_mask";
            case 8L: return "__offset_shift";
            default: return "";
        }
    }

    std::string __offset_flags_masks(int64_t i, const std::string &strip) {
        std::string s = __offset_flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __offset_flags_masks() {
        static const int64_t values[] = {
            1L,
            2L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__base_class_type_info__offset_flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__base_class_type_info::__offset_flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__base_class_type_info::__offset_flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__base_class_type_info__offset_flags_masks() {
        return stringify::__cxxabiv1::__base_class_type_info::__offset_flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/include/cxxabi.h line 77
namespace stringify { namespace __cxxabiv1 { namespace __vmi_class_type_info {
    const char* __flags_masks(int64_t i) {
        switch (i) {
            case 1L: return "__non_diamond_repeat_mask";
            case 2L: return "__diamond_shaped_mask";
            default: return "";
        }
    }

    std::string __flags_masks(int64_t i, const std::string &strip) {
        std::string s = __flags_masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __flags_masks() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__vmi_class_type_info__flags_masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__vmi_class_type_info::__flags_masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__vmi_class_type_info::__flags_masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__vmi_class_type_info__flags_masks() {
        return stringify::__cxxabiv1::__vmi_class_type_info::__flags_masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/include/cxxabi.h line 90
namespace stringify { namespace __cxxabiv1 { namespace __pbase_type_info {
    const char* __masks(int64_t i) {
        switch (i) {
            case 1L: return "__const_mask";
            case 2L: return "__volatile_mask";
            case 4L: return "__restrict_mask";
            case 8L: return "__incomplete_mask";
            case 16L: return "__incomplete_class_mask";
            default: return "";
        }
    }

    std::string __masks(int64_t i, const std::string &strip) {
        std::string s = __masks(i);
        if (s.empty())
            s = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& __masks() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify__cxxabiv1__pbase_type_info__masks(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::__cxxabiv1::__pbase_type_info::__masks(i);
        if (retval.empty()) {
            retval = "(__cxxabiv1::__pbase_type_info::__masks)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "__cxxabiv1::__pbase_type_info::__masks::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify__cxxabiv1__pbase_type_info__masks() {
        return stringify::__cxxabiv1::__pbase_type_info::__masks();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/lib_src/eh.h line 348
namespace stringify {
    const char* an_eh_stack_entry_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ehsek_old_try_block";
            case 1L: return "ehsek_function";
            case 2L: return "ehsek_throw_spec";
            case 3L: return "ehsek_throw_processing_marker";
            case 4L: return "ehsek_vec_new_or_delete";
            case 5L: return "ehsek_try_block";
            case 6L: return "ehsek_noexcept";
            default: return "";
        }
    }

    std::string an_eh_stack_entry_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_eh_stack_entry_kind_tag(i);
        if (s.empty())
            s = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_eh_stack_entry_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_eh_stack_entry_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_eh_stack_entry_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_eh_stack_entry_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_eh_stack_entry_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_eh_stack_entry_kind_tag() {
        return stringify::an_eh_stack_entry_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/mem_manage.h line 420
namespace stringify {
    const char* a_function_number_tag(int64_t i) {
        switch (i) {
            case 0L: return "fn_null";
            case 1L: return "fn_hash_attribute_kind";
            case 2L: return "fn_compare_for_attr_corresp_checking_map";
            case 3L: return "fn_hash_source_string";
            case 4L: return "fn_compare_for_attr_name_map";
            case 5L: return "fn_compare_for_asm_name_map";
            case 6L: return "fn_hash_include_search_result";
            case 7L: return "fn_compare_include_search_result";
            case 8L: return "fn_hash_include_file_history";
            case 9L: return "fn_compare_include_file_history";
            case 10L: return "fn_hash_unique_file_id_for_table";
            case 11L: return "fn_compare_unique_file_id";
            case 12L: return "fn_hash_include_alias";
            case 13L: return "fn_compare_include_alias";
            case 14L: return "fn_hash_instantiation";
            case 15L: return "fn_compare_instantiation";
            case 16L: return "fn_hash_prop_or_event_accessor_header_lookup";
            case 17L: return "fn_compare_prop_or_event_accessor_header_lookup";
            case 18L: return "fn_hash_symbol_header_lookup_entry";
            case 19L: return "fn_compare_symbol_header_lookup_entry";
            case 20L: return "fn_record_arg_pragma";
            case 21L: return "fn_instantiation_pragma";
            case 22L: return "fn_pack_pragma";
            case 23L: return "fn_ident_pragma";
            case 24L: return "fn_ident_directive";
            case 25L: return "fn_once_pragma";
            case 26L: return "fn_hdrstop_or_no_pch_pragma";
            case 27L: return "fn_define_type_info_pragma";
            case 28L: return "fn_stdc_pragma";
            case 29L: return "fn_upc_pragma";
            case 30L: return "fn_redefine_extname_pragma";
            case 31L: return "fn_ldscope_pragma";
            case 32L: return "fn_gcc_pragma";
            case 33L: return "fn_diag_pragma";
            case 34L: return "fn_diagnostic_pragma";
            case 35L: return "fn_test_immediate_pragma";
            case 36L: return "fn_test_next_construct_pragma";
            case 37L: return "fn_db_opt_pragma";
            case 38L: return "fn_db_name_pragma";
            case 39L: return "fn_pragma_il_display";
            case 40L: return "fn_if_exists_pragma";
            case 41L: return "fn_push_macro_pragma";
            case 42L: return "fn_pop_macro_pragma";
            case 43L: return "fn_microsoft_start_map_region_pragma";
            case 44L: return "fn_microsoft_stop_map_region_pragma";
            case 45L: return "fn_setlocale_pragma";
            case 46L: return "fn_microsoft_comment_pragma";
            case 47L: return "fn_microsoft_conform_pragma";
            case 48L: return "fn_microsoft_include_alias_pragma";
            case 49L: return "fn_hash_unresolved_type_map_key";
            case 50L: return "fn_compare_for_unresolved_type_map";
            case 51L: return "fn_hash_void_pointer";
            case 52L: return "fn_compare_for_pointer_pair_map";
            case 53L: return "fn_compare_substituted_type_list_entry";
            case 54L: return "fn_hash_token_sequence_xref";
            case 55L: return "fn_compare_token_sequence_xref";
            case 56L: return "fn_hash_module_entity";
            case 57L: return "fn_compare_for_module_entity";
            case 58L: return "fn_hash_id_representation";
            case 59L: return "fn_id_representations_match";
            case 60L: return "fn_last";
            default: return "";
        }
    }

    std::string a_function_number_tag(int64_t i, const std::string &strip) {
        std::string s = a_function_number_tag(i);
        if (s.empty())
            s = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_function_number_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L
        };
        static const std::vector<int64_t> retval(values, values + 61);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_function_number_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_function_number_tag(i);
        if (retval.empty()) {
            retval = "(a_function_number_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_function_number_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_function_number_tag() {
        return stringify::a_function_number_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 397
namespace stringify {
    const char* an_access_specifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "as_public";
            case 1L: return "as_protected";
            case 2L: return "as_private";
            case 3L: return "as_inaccessible";
            default: return "";
        }
    }

    std::string an_access_specifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_access_specifier_tag(i);
        if (s.empty())
            s = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_access_specifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_access_specifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_access_specifier_tag(i);
        if (retval.empty()) {
            retval = "(an_access_specifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_access_specifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_access_specifier_tag() {
        return stringify::an_access_specifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 417
namespace stringify {
    const char* an_assembly_visibility_tag(int64_t i) {
        switch (i) {
            case 0L: return "av_none";
            case 1L: return "av_public";
            case 2L: return "av_private";
            default: return "";
        }
    }

    std::string an_assembly_visibility_tag(int64_t i, const std::string &strip) {
        std::string s = an_assembly_visibility_tag(i);
        if (s.empty())
            s = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_assembly_visibility_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_assembly_visibility_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_assembly_visibility_tag(i);
        if (retval.empty()) {
            retval = "(an_assembly_visibility_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_assembly_visibility_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_assembly_visibility_tag() {
        return stringify::an_assembly_visibility_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 1662
namespace stringify {
    const char* an_element_position_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "epk_error";
            case 1L: return "epk_specialization_header";
            case 2L: return "epk_noreturn";
            case 3L: return "epk_last";
            default: return "";
        }
    }

    std::string an_element_position_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_element_position_kind_tag(i);
        if (s.empty())
            s = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_element_position_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_element_position_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_element_position_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_element_position_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_element_position_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_element_position_kind_tag() {
        return stringify::an_element_position_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 1772
namespace stringify {
    const char* an_ELF_visibility_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "evk_unspecified";
            case 1L: return "evk_hidden";
            case 2L: return "evk_protected";
            case 3L: return "evk_internal";
            case 4L: return "evk_default";
            default: return "";
        }
    }

    std::string an_ELF_visibility_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ELF_visibility_kind_tag(i);
        if (s.empty())
            s = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ELF_visibility_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ELF_visibility_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ELF_visibility_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ELF_visibility_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ELF_visibility_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ELF_visibility_kind_tag() {
        return stringify::an_ELF_visibility_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 2499
namespace stringify {
    const char* an_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aak_empty";
            case 1L: return "aak_raw_token";
            case 2L: return "aak_token";
            case 3L: return "aak_constant";
            case 4L: return "aak_type";
            case 5L: return "aak_expression";
            case 6L: return "aak_last";
            default: return "";
        }
    }

    std::string an_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_arg_kind_tag() {
        return stringify::an_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 2575
namespace stringify {
    const char* an_attribute_family_tag(int64_t i) {
        switch (i) {
            case 0L: return "af_internal";
            case 1L: return "af_std";
            case 2L: return "af_gnu";
            case 3L: return "af_ms_declspec";
            case 4L: return "af_alignas";
            case 5L: return "af_has_cpp_attribute";
            case 6L: return "af_last";
            default: return "";
        }
    }

    std::string an_attribute_family_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_family_tag(i);
        if (s.empty())
            s = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_family_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_family_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_family_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_family_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_family_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_family_tag() {
        return stringify::an_attribute_family_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 2603
namespace stringify {
    const char* an_attribute_location_tag(int64_t i) {
        switch (i) {
            case 0L: return "al_implicit";
            case 1L: return "al_prefix";
            case 2L: return "al_tag_name";
            case 3L: return "al_post_tag_definition";
            case 4L: return "al_base_specifier";
            case 5L: return "al_specifier";
            case 6L: return "al_declarator_id";
            case 7L: return "al_post_ptr_or_ref";
            case 8L: return "al_post_array";
            case 9L: return "al_post_func";
            case 10L: return "al_postfix";
            case 11L: return "al_predeclarator";
            case 12L: return "al_id_equivalent";
            case 13L: return "al_trailing_return";
            case 14L: return "al_post_initializer";
            case 15L: return "al_namespace";
            case 16L: return "al_gnu_namespace";
            case 17L: return "al_label";
            case 18L: return "al_explicit";
            case 19L: return "al_enumerator";
            case 20L: return "al_id_equivalent_as_postfix";
            case 21L: return "al_builtin_has_attribute";
            case 22L: return "al_module";
            case 23L: return "al_last";
            default: return "";
        }
    }

    std::string an_attribute_location_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_location_tag(i);
        if (s.empty())
            s = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_location_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_location_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_location_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_location_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_location_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_location_tag() {
        return stringify::an_attribute_location_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 2678
namespace stringify {
    const char* an_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ak_unrecognized";
            case 1L: return "ak_empty_attr";
            case 2L: return "ak_attr_using_prefix";
            case 3L: return "ak_align";
            case 4L: return "ak_base_check";
            case 5L: return "ak_carries_dependency";
            case 6L: return "ak_deprecated";
            case 7L: return "ak_final";
            case 8L: return "ak_hiding";
            case 9L: return "ak_known_semantics";
            case 10L: return "ak_noreturn";
            case 11L: return "ak_override";
            case 12L: return "ak_nodiscard";
            case 13L: return "ak_noop_dtor";
            case 14L: return "ak_maybe_unused";
            case 15L: return "ak_fallthrough";
            case 16L: return "ak_likely";
            case 17L: return "ak_unlikely";
            case 18L: return "ak_no_unique_address";
            case 19L: return "ak_enable_if";
            case 20L: return "ak_overloadable";
            case 21L: return "ak_naked";
            case 22L: return "ak_noinline";
            case 23L: return "ak_nothrow";
            case 24L: return "ak_pure";
            case 25L: return "ak_section";
            case 26L: return "ak_alias";
            case 27L: return "ak_alloc_size";
            case 28L: return "ak_always_inline";
            case 29L: return "ak_artificial";
            case 30L: return "ak_cdecl";
            case 31L: return "ak_cleanup";
            case 32L: return "ak_cold";
            case 33L: return "ak_common";
            case 34L: return "ak_const";
            case 35L: return "ak_constructor";
            case 36L: return "ak_destructor";
            case 37L: return "ak_error";
            case 38L: return "ak_ext_vector_type";
            case 39L: return "ak_externally_visible";
            case 40L: return "ak_fastcall";
            case 41L: return "ak_flatten";
            case 42L: return "ak_format";
            case 43L: return "ak_format_arg";
            case 44L: return "ak_gnu_inline";
            case 45L: return "ak_hot";
            case 46L: return "ak_ifunc";
            case 47L: return "ak_init_priority";
            case 48L: return "ak_internal_linkage";
            case 49L: return "ak_malloc";
            case 50L: return "ak_may_alias";
            case 51L: return "ak_mode";
            case 52L: return "ak_no_instrument_function";
            case 53L: return "ak_no_check_memory_usage";
            case 54L: return "ak_nocommon";
            case 55L: return "ak_nonnull";
            case 56L: return "ak_noplt";
            case 57L: return "ak_packed";
            case 58L: return "ak_sentinel";
            case 59L: return "ak_stdcall";
            case 60L: return "ak_strong";
            case 61L: return "ak_target";
            case 62L: return "ak_tls_model";
            case 63L: return "ak_transparent_union";
            case 64L: return "ak_unused";
            case 65L: return "ak_used";
            case 66L: return "ak_vector_size";
            case 67L: return "ak_visibility";
            case 68L: return "ak_warn_unused_result";
            case 69L: return "ak_warning";
            case 70L: return "ak_weak";
            case 71L: return "ak_weakref";
            case 72L: return "ak_abi_tag";
            case 73L: return "ak_appdomain";
            case 74L: return "ak_assembly_info";
            case 75L: return "ak_dllexport";
            case 76L: return "ak_dllimport";
            case 77L: return "ak_edg_interior_ptr_alias";
            case 78L: return "ak_edg_pin_ptr_alias";
            case 79L: return "ak_empty_bases";
            case 80L: return "ak_guard";
            case 81L: return "ak_hybrid_patchable";
            case 82L: return "ak_implementation_key";
            case 83L: return "ak_intrin_type";
            case 84L: return "ak_jitintrinsic";
            case 85L: return "ak_no_init_all";
            case 86L: return "ak_noalias";
            case 87L: return "ak_non_user_code";
            case 88L: return "ak_novtable";
            case 89L: return "ak_process";
            case 90L: return "ak_property";
            case 91L: return "ak_restrict";
            case 92L: return "ak_safebuffers";
            case 93L: return "ak_selectany";
            case 94L: return "ak_spectre";
            case 95L: return "ak_thread";
            case 96L: return "ak_uuid";
            case 97L: return "ak_layout_as_external";
            case 98L: return "ak_no_empty_identity_interface";
            case 99L: return "ak_no_ftm";
            case 100L: return "ak_no_refcount";
            case 101L: return "ak_no_release_return";
            case 102L: return "ak_no_weakreferencesource";
            case 103L: return "ak_one_phase_constructed";
            case 104L: return "ak_allocator";
            case 105L: return "ak_host";
            case 106L: return "ak_global";
            case 107L: return "ak_device";
            case 108L: return "ak_shared";
            case 109L: return "ak_local";
            case 110L: return "ak_constant";
            case 111L: return "ak_edg_e1";
            case 112L: return "ak_edg_n1";
            case 113L: return "ak_availability";
            case 114L: return "ak_conditional_explicit";
            case 115L: return "ak_pragma_pack_state";
            case 116L: return "ak_last";
            default: return "";
        }
    }

    std::string an_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L
        };
        static const std::vector<int64_t> retval(values, values + 117);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_attribute_kind_tag() {
        return stringify::an_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 3325
namespace stringify {
    const char* a_constant_repr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ck_error";
            case 1L: return "ck_integer";
            case 2L: return "ck_fixed_point";
            case 3L: return "ck_string";
            case 4L: return "ck_float";
            case 5L: return "ck_complex";
            case 6L: return "ck_imaginary";
            case 7L: return "ck_address";
            case 8L: return "ck_ptr_to_member";
            case 9L: return "ck_label_difference";
            case 10L: return "ck_stack_offset";
            case 11L: return "ck_dynamic_init";
            case 12L: return "ck_aggregate";
            case 13L: return "ck_init_repeat";
            case 14L: return "ck_template_param";
            case 15L: return "ck_designator";
            case 16L: return "ck_upc_threads";
            case 17L: return "ck_upc_mythread";
            case 18L: return "ck_void";
            case 19L: return "ck_last";
            default: return "";
        }
    }

    std::string a_constant_repr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constant_repr_kind_tag(i);
        if (s.empty())
            s = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constant_repr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constant_repr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constant_repr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constant_repr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constant_repr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constant_repr_kind_tag() {
        return stringify::a_constant_repr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 3377
namespace stringify {
    const char* an_address_base_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "abk_routine";
            case 1L: return "abk_variable";
            case 2L: return "abk_constant";
            case 3L: return "abk_temporary";
            case 4L: return "abk_uuidof";
            case 5L: return "abk_typeid";
            case 6L: return "abk_cli_typeid";
            case 7L: return "abk_cli_array";
            case 8L: return "abk_label";
            case 9L: return "abk_last";
            default: return "";
        }
    }

    std::string an_address_base_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_address_base_kind_tag(i);
        if (s.empty())
            s = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_address_base_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_address_base_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_address_base_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_address_base_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_address_base_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_address_base_kind_tag() {
        return stringify::an_address_base_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 3653
namespace stringify {
    const char* a_dynamic_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dik_none";
            case 1L: return "dik_zero";
            case 2L: return "dik_constant";
            case 3L: return "dik_expression";
            case 4L: return "dik_class_result_via_ctor";
            case 5L: return "dik_constructor";
            case 6L: return "dik_nonconstant_aggregate";
            case 7L: return "dik_bitwise_copy";
            case 8L: return "dik_lambda";
            default: return "";
        }
    }

    std::string a_dynamic_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dynamic_init_kind_tag(i);
        if (s.empty())
            s = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dynamic_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dynamic_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dynamic_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dynamic_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dynamic_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dynamic_init_kind_tag() {
        return stringify::a_dynamic_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 4092
namespace stringify {
    const char* a_template_param_constant_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpck_param";
            case 1L: return "tpck_expression";
            case 2L: return "tpck_member";
            case 3L: return "tpck_unknown_function";
            case 4L: return "tpck_address";
            case 5L: return "tpck_sizeof";
            case 6L: return "tpck_alignof";
            case 7L: return "tpck_uuidof";
            case 8L: return "tpck_typeid";
            case 9L: return "tpck_noexcept";
            case 10L: return "tpck_template_ref";
            case 11L: return "tpck_integer_pack";
            case 12L: return "tpck_destructor";
            default: return "";
        }
    }

    std::string a_template_param_constant_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_constant_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_constant_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_constant_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_constant_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_constant_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_constant_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_constant_kind_tag() {
        return stringify::a_template_param_constant_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 4226
namespace stringify {
    const char* a_character_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "chk_default";
            case 1L: return "chk_wchar_t";
            case 2L: return "chk_char8_t";
            case 3L: return "chk_char16_t";
            case 4L: return "chk_char32_t";
            case 5L: return "chk_last";
            default: return "";
        }
    }

    std::string a_character_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_character_kind_tag(i);
        if (s.empty())
            s = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_character_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_character_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_character_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_character_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_character_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_character_kind_tag() {
        return stringify::a_character_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5094
namespace stringify {
    const char* a_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tk_error";
            case 1L: return "tk_void";
            case 2L: return "tk_integer";
            case 3L: return "tk_fixed_point";
            case 4L: return "tk_float";
            case 5L: return "tk_imaginary";
            case 6L: return "tk_complex";
            case 7L: return "tk_pointer";
            case 8L: return "tk_routine";
            case 9L: return "tk_array";
            case 10L: return "tk_class";
            case 11L: return "tk_struct";
            case 12L: return "tk_union";
            case 13L: return "tk_typeref";
            case 14L: return "tk_ptr_to_member";
            case 15L: return "tk_template_param";
            case 16L: return "tk_vector";
            case 17L: return "tk_nullptr";
            case 18L: return "tk_unknown";
            default: return "";
        }
    }

    std::string a_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_kind_tag(i);
        if (s.empty())
            s = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_kind_tag() {
        return stringify::a_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5142
namespace stringify {
    const char* an_integer_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ik_char";
            case 1L: return "ik_signed_char";
            case 2L: return "ik_unsigned_char";
            case 3L: return "ik_short";
            case 4L: return "ik_unsigned_short";
            case 5L: return "ik_int";
            case 6L: return "ik_unsigned_int";
            case 7L: return "ik_long";
            case 8L: return "ik_unsigned_long";
            case 9L: return "ik_long_long";
            case 10L: return "ik_unsigned_long_long";
            case 11L: return "ik_int128";
            case 12L: return "ik_unsigned_int128";
            case 13L: return "ik_none";
            default: return "";
        }
    }

    std::string an_integer_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_integer_kind_tag(i);
        if (s.empty())
            s = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_integer_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_integer_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_integer_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_integer_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_integer_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_integer_kind_tag() {
        return stringify::an_integer_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5232
namespace stringify {
    const char* a_fixed_point_precision_tag(int64_t i) {
        switch (i) {
            case 0L: return "fpp_short";
            case 1L: return "fpp_default";
            case 2L: return "fpp_long";
            case 3L: return "fpp_last";
            default: return "";
        }
    }

    std::string a_fixed_point_precision_tag(int64_t i, const std::string &strip) {
        std::string s = a_fixed_point_precision_tag(i);
        if (s.empty())
            s = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_fixed_point_precision_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_fixed_point_precision_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_fixed_point_precision_tag(i);
        if (retval.empty()) {
            retval = "(a_fixed_point_precision_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_fixed_point_precision_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_fixed_point_precision_tag() {
        return stringify::a_fixed_point_precision_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5264
namespace stringify {
    const char* a_float_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "fk_float";
            case 1L: return "fk_double";
            case 2L: return "fk_long_double";
            case 3L: return "fk_float80";
            case 4L: return "fk_float128";
            case 5L: return "fk_last";
            default: return "";
        }
    }

    std::string a_float_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_float_kind_tag(i);
        if (s.empty())
            s = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_float_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_float_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_float_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_float_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_float_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_float_kind_tag() {
        return stringify::a_float_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5290
namespace stringify {
    const char* a_type_mode_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tmk_error";
            case 1L: return "tmk_first";
            case 2L: return "tmk_HI";
            case 3L: return "tmk_SI";
            case 4L: return "tmk_DI";
            case 5L: return "tmk_TI";
            case 6L: return "tmk_SF";
            case 7L: return "tmk_DF";
            case 8L: return "tmk_XF";
            case 9L: return "tmk_TF";
            case 10L: return "tmk_SC";
            case 11L: return "tmk_DC";
            case 12L: return "tmk_XC";
            case 13L: return "tmk_TC";
            case 14L: return "tmk_none";
            default: return "";
        }
    }

    std::string a_type_mode_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_mode_kind_tag(i);
        if (s.empty())
            s = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_mode_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_mode_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_mode_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_mode_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_mode_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_mode_kind_tag() {
        return stringify::a_type_mode_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5346
namespace stringify {
    const char* an_asm_operand_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "aoc_invalid";
            case 1L: return "aoc_end_of_constraint";
            case 2L: return "aoc_mod_earlyclobber";
            case 3L: return "aoc_mod_commutative_ops";
            case 4L: return "aoc_mod_ignore";
            case 5L: return "aoc_mod_ignore_char";
            case 6L: return "aoc_mod_disparage_slightly";
            case 7L: return "aoc_mod_disparage_severely";
            case 8L: return "aoc_any";
            case 9L: return "aoc_general";
            case 10L: return "aoc_match_0";
            case 11L: return "aoc_match_1";
            case 12L: return "aoc_match_2";
            case 13L: return "aoc_match_3";
            case 14L: return "aoc_match_4";
            case 15L: return "aoc_match_5";
            case 16L: return "aoc_match_6";
            case 17L: return "aoc_match_7";
            case 18L: return "aoc_match_8";
            case 19L: return "aoc_match_9";
            case 20L: return "aoc_reg_integer";
            case 21L: return "aoc_reg_float";
            case 22L: return "aoc_mem_any";
            case 23L: return "aoc_mem_load";
            case 24L: return "aoc_mem_offset";
            case 25L: return "aoc_mem_nonoffset";
            case 26L: return "aoc_mem_autoinc";
            case 27L: return "aoc_mem_autodec";
            case 28L: return "aoc_imm_int";
            case 29L: return "aoc_imm_number";
            case 30L: return "aoc_imm_symbol";
            case 31L: return "aoc_imm_float";
            case 32L: return "aoc_reg_a";
            case 33L: return "aoc_reg_b";
            case 34L: return "aoc_reg_c";
            case 35L: return "aoc_reg_d";
            case 36L: return "aoc_reg_si";
            case 37L: return "aoc_reg_di";
            case 38L: return "aoc_reg_legacy";
            case 39L: return "aoc_reg_q";
            case 40L: return "aoc_reg_Q";
            case 41L: return "aoc_reg_ad";
            case 42L: return "aoc_reg_float_tos";
            case 43L: return "aoc_reg_float_second";
            case 44L: return "aoc_reg_sse";
            case 45L: return "aoc_reg_sse2";
            case 46L: return "aoc_reg_mmx";
            case 47L: return "aoc_imm_short_shift";
            case 48L: return "aoc_imm_long_shift";
            case 49L: return "aoc_imm_lea_shift";
            case 50L: return "aoc_imm_signed8";
            case 51L: return "aoc_imm_unsigned8";
            case 52L: return "aoc_imm_and_zext";
            case 53L: return "aoc_imm_80387";
            case 54L: return "aoc_imm_sse";
            case 55L: return "aoc_imm_sext32";
            case 56L: return "aoc_imm_zext32";
            case 57L: return "aoc_last";
            default: return "";
        }
    }

    std::string an_asm_operand_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_constraint_kind_tag(i);
        if (s.empty())
            s = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L
        };
        static const std::vector<int64_t> retval(values, values + 58);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_constraint_kind_tag() {
        return stringify::an_asm_operand_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5511
namespace stringify {
    const char* an_asm_operand_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "aom_invalid";
            case 1L: return "aom_input";
            case 2L: return "aom_output";
            case 3L: return "aom_modify";
            default: return "";
        }
    }

    std::string an_asm_operand_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = an_asm_operand_modifier_tag(i);
        if (s.empty())
            s = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_asm_operand_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_asm_operand_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_asm_operand_modifier_tag(i);
        if (retval.empty()) {
            retval = "(an_asm_operand_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_asm_operand_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_asm_operand_modifier_tag() {
        return stringify::an_asm_operand_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5522
namespace stringify {
    const char* a_named_register_tag(int64_t i) {
        switch (i) {
            case 0L: return "anr_invalid";
            case 1L: return "anr_memory";
            case 2L: return "anr_a";
            case 3L: return "anr_b";
            case 4L: return "anr_c";
            case 5L: return "anr_d";
            case 6L: return "anr_si";
            case 7L: return "anr_di";
            case 8L: return "anr_bp";
            case 9L: return "anr_sp";
            case 10L: return "anr_r8";
            case 11L: return "anr_r9";
            case 12L: return "anr_r10";
            case 13L: return "anr_r11";
            case 14L: return "anr_r12";
            case 15L: return "anr_r13";
            case 16L: return "anr_r14";
            case 17L: return "anr_r15";
            case 18L: return "anr_st";
            case 19L: return "anr_st1";
            case 20L: return "anr_st2";
            case 21L: return "anr_st3";
            case 22L: return "anr_st4";
            case 23L: return "anr_st5";
            case 24L: return "anr_st6";
            case 25L: return "anr_st7";
            case 26L: return "anr_mm0";
            case 27L: return "anr_mm1";
            case 28L: return "anr_mm2";
            case 29L: return "anr_mm3";
            case 30L: return "anr_mm4";
            case 31L: return "anr_mm5";
            case 32L: return "anr_mm6";
            case 33L: return "anr_mm7";
            case 34L: return "anr_f0";
            case 35L: return "anr_f1";
            case 36L: return "anr_f2";
            case 37L: return "anr_f3";
            case 38L: return "anr_f4";
            case 39L: return "anr_f5";
            case 40L: return "anr_f6";
            case 41L: return "anr_f7";
            case 42L: return "anr_f8";
            case 43L: return "anr_f9";
            case 44L: return "anr_f10";
            case 45L: return "anr_f11";
            case 46L: return "anr_f12";
            case 47L: return "anr_f13";
            case 48L: return "anr_f14";
            case 49L: return "anr_f15";
            case 50L: return "anr_flags";
            case 51L: return "anr_fpsr";
            case 52L: return "anr_dirflag";
            case 53L: return "anr_16";
            case 54L: return "anr_17";
            case 55L: return "anr_18";
            case 56L: return "anr_19";
            case 57L: return "anr_20";
            case 58L: return "anr_unrecognized";
            case 59L: return "anr_last";
            default: return "";
        }
    }

    std::string a_named_register_tag(int64_t i, const std::string &strip) {
        std::string s = a_named_register_tag(i);
        if (s.empty())
            s = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_named_register_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_named_register_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_named_register_tag(i);
        if (retval.empty()) {
            retval = "(a_named_register_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_named_register_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_named_register_tag() {
        return stringify::a_named_register_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5697
namespace stringify {
    const char* a_type_qualifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "tqt_const";
            case 1L: return "tqt_volatile";
            case 2L: return "tqt_restrict";
            case 3L: return "tqt_c11_atomic";
            case 4L: return "tqt_nullable";
            case 5L: return "tqt_nonnull";
            case 6L: return "tqt_null_unspecified";
            case 7L: return "tqt_unaligned";
            case 8L: return "tqt_near";
            case 9L: return "tqt_far";
            case 10L: return "tqt_upc_shared";
            case 11L: return "tqt_upc_strict";
            case 12L: return "tqt_upc_relaxed";
            case 13L: return "tqt_lsb_named_address_space";
            default: return "";
        }
    }

    std::string a_type_qualifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_qualifier_tag(i);
        if (s.empty())
            s = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_qualifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_qualifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_qualifier_tag(i);
        if (retval.empty()) {
            retval = "(a_type_qualifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_qualifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_qualifier_tag() {
        return stringify::a_type_qualifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5799
namespace stringify {
    const char* a_upc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_pk_access";
            case 1L: return "upc_pk_coherence";
            default: return "";
        }
    }

    std::string a_upc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_pragma_kind_tag() {
        return stringify::a_upc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5809
namespace stringify {
    const char* a_upc_access_method_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_access_unspecified";
            case 1L: return "upc_access_strict";
            case 2L: return "upc_access_relaxed";
            default: return "";
        }
    }

    std::string a_upc_access_method_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_access_method_tag(i);
        if (s.empty())
            s = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_access_method_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_access_method_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_access_method_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_access_method_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_access_method_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_access_method_tag() {
        return stringify::a_upc_access_method_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 5820
namespace stringify {
    const char* a_upc_coherence_stack_operation_tag(int64_t i) {
        switch (i) {
            case 0L: return "upc_coherence_stack_noop";
            case 1L: return "upc_coherence_stack_save";
            case 2L: return "upc_coherence_stack_restore";
            default: return "";
        }
    }

    std::string a_upc_coherence_stack_operation_tag(int64_t i, const std::string &strip) {
        std::string s = a_upc_coherence_stack_operation_tag(i);
        if (s.empty())
            s = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_upc_coherence_stack_operation_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_upc_coherence_stack_operation_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_upc_coherence_stack_operation_tag(i);
        if (retval.empty()) {
            retval = "(a_upc_coherence_stack_operation_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_upc_coherence_stack_operation_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_upc_coherence_stack_operation_tag() {
        return stringify::a_upc_coherence_stack_operation_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6009
namespace stringify {
    const char* a_stdc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pk_none";
            case 1L: return "stdc_pk_fp_contract";
            case 2L: return "stdc_pk_fenv_access";
            case 3L: return "stdc_pk_cx_limited_range";
            case 4L: return "stdc_pk_fx_full_precision";
            case 5L: return "stdc_pk_fx_fract_overflow";
            case 6L: return "stdc_pk_fx_accum_overflow";
            case 7L: return "stdc_pk_last";
            default: return "";
        }
    }

    std::string a_stdc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_kind_tag() {
        return stringify::a_stdc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6035
namespace stringify {
    const char* a_stdc_pragma_value_tag(int64_t i) {
        switch (i) {
            case 0L: return "stdc_pv_none";
            case 1L: return "stdc_pv_off";
            case 2L: return "stdc_pv_on";
            case 3L: return "stdc_pv_sat";
            case 4L: return "stdc_pv_default";
            default: return "";
        }
    }

    std::string a_stdc_pragma_value_tag(int64_t i, const std::string &strip) {
        std::string s = a_stdc_pragma_value_tag(i);
        if (s.empty())
            s = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_stdc_pragma_value_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_stdc_pragma_value_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_stdc_pragma_value_tag(i);
        if (retval.empty()) {
            retval = "(a_stdc_pragma_value_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_stdc_pragma_value_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_stdc_pragma_value_tag() {
        return stringify::a_stdc_pragma_value_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6056
namespace stringify {
    const char* a_gcc_pragma_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gcc_pk_none";
            case 1L: return "gcc_pk_system_header";
            case 2L: return "gcc_pk_visibility_push";
            case 3L: return "gcc_pk_visibility_pop";
            case 4L: return "gcc_pk_target";
            case 5L: return "gcc_pk_push_options";
            case 6L: return "gcc_pk_pop_options";
            case 7L: return "gcc_pk_reset_options";
            case 8L: return "gcc_pk_last";
            default: return "";
        }
    }

    std::string a_gcc_pragma_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_gcc_pragma_kind_tag(i);
        if (s.empty())
            s = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_gcc_pragma_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_gcc_pragma_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_gcc_pragma_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_gcc_pragma_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_gcc_pragma_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_gcc_pragma_kind_tag() {
        return stringify::a_gcc_pragma_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6336
namespace stringify {
    const char* a_microsoft_pragma_comment_type_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpct_compiler";
            case 1L: return "mpct_exestr";
            case 2L: return "mpct_lib";
            case 3L: return "mpct_linker";
            case 4L: return "mpct_user";
            case 5L: return "mpct_last";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_comment_type_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_comment_type_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_comment_type_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_comment_type_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_comment_type_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_comment_type_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_comment_type_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_comment_type_tag() {
        return stringify::a_microsoft_pragma_comment_type_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6350
namespace stringify {
    const char* a_microsoft_pragma_conform_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "mpck_forScope";
            default: return "";
        }
    }

    std::string a_microsoft_pragma_conform_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_microsoft_pragma_conform_kind_tag(i);
        if (s.empty())
            s = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_microsoft_pragma_conform_kind_tag() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_microsoft_pragma_conform_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_microsoft_pragma_conform_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_microsoft_pragma_conform_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_microsoft_pragma_conform_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_microsoft_pragma_conform_kind_tag() {
        return stringify::a_microsoft_pragma_conform_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6657
namespace stringify {
    const char* a_calling_convention_tag(int64_t i) {
        switch (i) {
            case 0L: return "cc_default";
            case 1L: return "cc_cdecl";
            case 2L: return "cc_fastcall";
            case 3L: return "cc_stdcall";
            case 4L: return "cc_thiscall";
            case 5L: return "cc_vectorcall";
            case 6L: return "cc_clrcall";
            case 7L: return "cc_last";
            default: return "";
        }
    }

    std::string a_calling_convention_tag(int64_t i, const std::string &strip) {
        std::string s = a_calling_convention_tag(i);
        if (s.empty())
            s = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_calling_convention_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_calling_convention_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_calling_convention_tag(i);
        if (retval.empty()) {
            retval = "(a_calling_convention_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_calling_convention_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_calling_convention_tag() {
        return stringify::a_calling_convention_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 6845
namespace stringify {
    const char* a_ref_qualifier_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rqk_default";
            case 1L: return "rqk_lvalue";
            case 2L: return "rqk_rvalue";
            default: return "";
        }
    }

    std::string a_ref_qualifier_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ref_qualifier_kind_tag(i);
        if (s.empty())
            s = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ref_qualifier_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ref_qualifier_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ref_qualifier_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ref_qualifier_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ref_qualifier_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ref_qualifier_kind_tag() {
        return stringify::a_ref_qualifier_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 7132
namespace stringify {
    const char* a_templ_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tak_type";
            case 1L: return "tak_nontype";
            case 2L: return "tak_template";
            case 3L: return "tak_start_of_pack_expansion";
            default: return "";
        }
    }

    std::string a_templ_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_templ_arg_kind_tag(i);
        if (s.empty())
            s = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_templ_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_templ_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_templ_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_templ_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_templ_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_templ_arg_kind_tag() {
        return stringify::a_templ_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 7789
namespace stringify {
    const char* an_anonymous_union_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "auk_none";
            case 1L: return "auk_variable";
            case 2L: return "auk_field";
            default: return "";
        }
    }

    std::string an_anonymous_union_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_anonymous_union_kind_tag(i);
        if (s.empty())
            s = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_anonymous_union_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_anonymous_union_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_anonymous_union_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_anonymous_union_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_anonymous_union_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_anonymous_union_kind_tag() {
        return stringify::an_anonymous_union_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 7804
namespace stringify {
    const char* an_inheritance_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ihk_none";
            case 1L: return "ihk_single";
            case 2L: return "ihk_multiple";
            case 3L: return "ihk_virtual";
            case 4L: return "ihk_last";
            default: return "";
        }
    }

    std::string an_inheritance_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_inheritance_kind_tag(i);
        if (s.empty())
            s = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_inheritance_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_inheritance_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_inheritance_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_inheritance_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_inheritance_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_inheritance_kind_tag() {
        return stringify::an_inheritance_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 7836
namespace stringify {
    const char* a_cli_class_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cctk_standard";
            case 1L: return "cctk_value";
            case 2L: return "cctk_ref";
            case 3L: return "cctk_interface";
            case 4L: return "cctk_unresolved";
            default: return "";
        }
    }

    std::string a_cli_class_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_class_type_kind_tag(i);
        if (s.empty())
            s = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_class_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_class_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_class_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_class_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_class_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_class_type_kind_tag() {
        return stringify::a_cli_class_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 7869
namespace stringify {
    const char* a_property_or_event_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "pek_declspec_property";
            case 1L: return "pek_cli_property";
            case 2L: return "pek_cli_event";
            default: return "";
        }
    }

    std::string a_property_or_event_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_property_or_event_kind_tag(i);
        if (s.empty())
            s = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_property_or_event_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_property_or_event_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_property_or_event_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_property_or_event_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_property_or_event_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_property_or_event_kind_tag() {
        return stringify::a_property_or_event_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 8002
namespace stringify {
    const char* a_rewritten_property_reference_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "rprk_none";
            case 1L: return "rprk_compound_assignment";
            case 2L: return "rprk_pre_incr_decr";
            case 3L: return "rprk_post_incr_decr";
            case 4L: return "rprk_comma_discard_first";
            case 5L: return "rprk_comma_discard_second";
            default: return "";
        }
    }

    std::string a_rewritten_property_reference_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_rewritten_property_reference_kind_tag(i);
        if (s.empty())
            s = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_rewritten_property_reference_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_rewritten_property_reference_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_rewritten_property_reference_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_rewritten_property_reference_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_rewritten_property_reference_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_rewritten_property_reference_kind_tag() {
        return stringify::a_rewritten_property_reference_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 8680
namespace stringify {
    const char* a_template_param_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tptk_param";
            case 1L: return "tptk_member";
            case 2L: return "tptk_unknown";
            default: return "";
        }
    }

    std::string a_template_param_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_param_type_kind_tag(i);
        if (s.empty())
            s = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_param_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_param_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_param_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_param_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_param_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_param_type_kind_tag() {
        return stringify::a_template_param_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 8959
namespace stringify {
    const char* a_based_type_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "btk_qualified";
            case 1L: return "btk_rvalue_reference";
            case 2L: return "btk_reference";
            case 3L: return "btk_ptr_to_member";
            case 4L: return "btk_unqualified_array_type";
            case 5L: return "btk_handle";
            case 6L: return "btk_tracking_ref";
            case 7L: return "btk_interior_ptr";
            case 8L: return "btk_pin_ptr";
            case 9L: return "btk_cppcx_box";
            case 10L: return "btk_pointer";
            case 11L: return "btk_no_noexcept_exception_spec";
            default: return "";
        }
    }

    std::string a_based_type_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_based_type_kind_tag(i);
        if (s.empty())
            s = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_based_type_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_based_type_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_based_type_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_based_type_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_based_type_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_based_type_kind_tag() {
        return stringify::a_based_type_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 9020
namespace stringify {
    const char* a_pointer_modifier_tag(int64_t i) {
        switch (i) {
            case 0L: return "pmt_ptr32";
            case 1L: return "pmt_ptr64";
            case 2L: return "pmt_sptr";
            case 3L: return "pmt_uptr";
            case 4L: return "pmt_last";
            default: return "";
        }
    }

    std::string a_pointer_modifier_tag(int64_t i, const std::string &strip) {
        std::string s = a_pointer_modifier_tag(i);
        if (s.empty())
            s = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pointer_modifier_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pointer_modifier_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pointer_modifier_tag(i);
        if (retval.empty()) {
            retval = "(a_pointer_modifier_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pointer_modifier_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pointer_modifier_tag() {
        return stringify::a_pointer_modifier_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 10218
namespace stringify {
    const char* a_storage_class_tag(int64_t i) {
        switch (i) {
            case 0L: return "sc_unspecified";
            case 1L: return "sc_extern";
            case 2L: return "sc_static";
            case 3L: return "sc_auto";
            case 4L: return "sc_typedef";
            case 5L: return "sc_register";
            case 6L: return "sc_asm";
            case 7L: return "sc_last";
            default: return "";
        }
    }

    std::string a_storage_class_tag(int64_t i, const std::string &strip) {
        std::string s = a_storage_class_tag(i);
        if (s.empty())
            s = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_storage_class_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_storage_class_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_storage_class_tag(i);
        if (retval.empty()) {
            retval = "(a_storage_class_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_storage_class_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_storage_class_tag() {
        return stringify::a_storage_class_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 11357
namespace stringify {
    const char* an_opname_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "onk_none";
            case 1L: return "onk_new";
            case 2L: return "onk_delete";
            case 3L: return "onk_array_new";
            case 4L: return "onk_array_delete";
            case 5L: return "onk_plus";
            case 6L: return "onk_minus";
            case 7L: return "onk_star";
            case 8L: return "onk_divide";
            case 9L: return "onk_remainder";
            case 10L: return "onk_excl_or";
            case 11L: return "onk_ampersand";
            case 12L: return "onk_or";
            case 13L: return "onk_compl";
            case 14L: return "onk_not";
            case 15L: return "onk_assign";
            case 16L: return "onk_lt";
            case 17L: return "onk_gt";
            case 18L: return "onk_plus_assign";
            case 19L: return "onk_minus_assign";
            case 20L: return "onk_times_assign";
            case 21L: return "onk_divide_assign";
            case 22L: return "onk_remainder_assign";
            case 23L: return "onk_excl_or_assign";
            case 24L: return "onk_and_assign";
            case 25L: return "onk_or_assign";
            case 26L: return "onk_shift_left";
            case 27L: return "onk_shift_right";
            case 28L: return "onk_shift_right_assign";
            case 29L: return "onk_shift_left_assign";
            case 30L: return "onk_eq";
            case 31L: return "onk_ne";
            case 32L: return "onk_le";
            case 33L: return "onk_ge";
            case 34L: return "onk_spaceship";
            case 35L: return "onk_and_and";
            case 36L: return "onk_or_or";
            case 37L: return "onk_plus_plus";
            case 38L: return "onk_minus_minus";
            case 39L: return "onk_comma";
            case 40L: return "onk_arrow_star";
            case 41L: return "onk_arrow";
            case 42L: return "onk_function_call";
            case 43L: return "onk_subscript";
            case 44L: return "onk_question";
            case 45L: return "onk_gnu_min";
            case 46L: return "onk_gnu_max";
            case 47L: return "onk_await";
            case 48L: return "onk_last";
            default: return "";
        }
    }

    std::string an_opname_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_opname_kind_tag(i);
        if (s.empty())
            s = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_opname_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L
        };
        static const std::vector<int64_t> retval(values, values + 49);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_opname_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_opname_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_opname_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_opname_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_opname_kind_tag() {
        return stringify::an_opname_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 11413
namespace stringify {
    const char* a_ctor_or_dtor_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cdk_none";
            case 1L: return "cdk_complete";
            case 2L: return "cdk_subobject";
            case 3L: return "cdk_deleting";
            case 4L: return "cdk_delegation";
            case 5L: return "cdk_last";
            default: return "";
        }
    }

    std::string a_ctor_or_dtor_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_ctor_or_dtor_kind_tag(i);
        if (s.empty())
            s = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_ctor_or_dtor_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_ctor_or_dtor_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_ctor_or_dtor_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_ctor_or_dtor_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_ctor_or_dtor_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_ctor_or_dtor_kind_tag() {
        return stringify::a_ctor_or_dtor_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 12768
namespace stringify {
    const char* an_expr_node_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "enk_error";
            case 1L: return "enk_operation";
            case 2L: return "enk_constant";
            case 3L: return "enk_variable";
            case 4L: return "enk_field";
            case 5L: return "enk_temp_init";
            case 6L: return "enk_lambda";
            case 7L: return "enk_new_delete";
            case 8L: return "enk_gcnew";
            case 9L: return "enk_throw";
            case 10L: return "enk_condition";
            case 11L: return "enk_object_lifetime";
            case 12L: return "enk_typeid";
            case 13L: return "enk_sizeof";
            case 14L: return "enk_sizeof_pack";
            case 15L: return "enk_alignof";
            case 16L: return "enk_address_of_ellipsis";
            case 17L: return "enk_statement";
            case 18L: return "enk_reuse_value";
            case 19L: return "enk_lowered_eh_construct";
            case 20L: return "enk_result_of_overriding_function";
            case 21L: return "enk_routine";
            case 22L: return "enk_vla_dealloc";
            case 23L: return "enk_type_operand";
            case 24L: return "enk_builtin_operation";
            case 25L: return "enk_param_ref";
            case 26L: return "enk_braced_init_list";
            case 27L: return "enk_c11_generic";
            case 28L: return "enk_builtin_choose_expr";
            case 29L: return "enk_yield";
            case 30L: return "enk_await";
            case 31L: return "enk_fold";
            case 32L: return "enk_initializer";
            case 33L: return "enk_concept_id";
            case 34L: return "enk_requires";
            case 35L: return "enk_compound_req";
            case 36L: return "enk_nested_req";
            case 37L: return "enk_last";
            default: return "";
        }
    }

    std::string an_expr_node_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_node_kind_tag(i);
        if (s.empty())
            s = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_node_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L
        };
        static const std::vector<int64_t> retval(values, values + 38);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_node_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_node_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_node_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_node_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_node_kind_tag() {
        return stringify::an_expr_node_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 12898
namespace stringify {
    const char* a_lowered_eh_construct_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "leck_caught_object_address";
            case 1L: return "leck_thrown_object_address";
            case 2L: return "leck_cleanup_state";
            case 3L: return "leck_unreachable_cleanup_state";
            case 4L: return "leck_function_prologue";
            case 5L: return "leck_function_epilogue";
            case 6L: return "leck_catch_epilogue";
            case 7L: return "leck_try_epilogue";
            case 8L: return "leck_exception_caught";
            case 9L: return "leck_exception_started";
            case 10L: return "leck_initialization_completed";
            case 11L: return "leck_internal_try";
            default: return "";
        }
    }

    std::string a_lowered_eh_construct_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_lowered_eh_construct_kind_tag(i);
        if (s.empty())
            s = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_lowered_eh_construct_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_lowered_eh_construct_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_lowered_eh_construct_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_lowered_eh_construct_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_lowered_eh_construct_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_lowered_eh_construct_kind_tag() {
        return stringify::a_lowered_eh_construct_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 12940
namespace stringify {
    const char* an_expr_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "eok_address_of";
            case 1L: return "eok_reference_to";
            case 2L: return "eok_handle_to";
            case 3L: return "eok_indirect";
            case 4L: return "eok_ref_indirect";
            case 5L: return "eok_cast";
            case 6L: return "eok_lvalue_cast";
            case 7L: return "eok_ref_cast";
            case 8L: return "eok_lvalue_adjust";
            case 9L: return "eok_class_rvalue_adjust";
            case 10L: return "eok_box";
            case 11L: return "eok_handle_to_box";
            case 12L: return "eok_unbox";
            case 13L: return "eok_unbox_lvalue";
            case 14L: return "eok_base_class_cast";
            case 15L: return "eok_derived_class_cast";
            case 16L: return "eok_pm_base_class_cast";
            case 17L: return "eok_pm_derived_class_cast";
            case 18L: return "eok_dynamic_cast";
            case 19L: return "eok_ref_dynamic_cast";
            case 20L: return "eok_bool_cast";
            case 21L: return "eok_array_to_pointer";
            case 22L: return "eok_dot_vacuous_destructor_call";
            case 23L: return "eok_points_to_vacuous_destructor_call";
            case 24L: return "eok_assume";
            case 25L: return "eok_noexcept";
            case 26L: return "eok_parens";
            case 27L: return "eok_negate";
            case 28L: return "eok_unary_plus";
            case 29L: return "eok_complement";
            case 30L: return "eok_not";
            case 31L: return "eok_vector_not";
            case 32L: return "eok_vector_fill";
            case 33L: return "eok_xconj";
            case 34L: return "eok_real_part";
            case 35L: return "eok_imag_part";
            case 36L: return "eok_post_incr";
            case 37L: return "eok_post_decr";
            case 38L: return "eok_pre_incr";
            case 39L: return "eok_pre_decr";
            case 40L: return "eok_add";
            case 41L: return "eok_subtract";
            case 42L: return "eok_multiply";
            case 43L: return "eok_divide";
            case 44L: return "eok_remainder";
            case 45L: return "eok_jmultiply";
            case 46L: return "eok_jdivide";
            case 47L: return "eok_fjadd";
            case 48L: return "eok_jfadd";
            case 49L: return "eok_fjsubtract";
            case 50L: return "eok_jfsubtract";
            case 51L: return "eok_padd";
            case 52L: return "eok_psubtract";
            case 53L: return "eok_pdiff";
            case 54L: return "eok_shiftl";
            case 55L: return "eok_shiftr";
            case 56L: return "eok_and";
            case 57L: return "eok_or";
            case 58L: return "eok_xor";
            case 59L: return "eok_eq";
            case 60L: return "eok_ne";
            case 61L: return "eok_gt";
            case 62L: return "eok_lt";
            case 63L: return "eok_ge";
            case 64L: return "eok_le";
            case 65L: return "eok_spaceship";
            case 66L: return "eok_vector_eq";
            case 67L: return "eok_vector_ne";
            case 68L: return "eok_vector_gt";
            case 69L: return "eok_vector_lt";
            case 70L: return "eok_vector_ge";
            case 71L: return "eok_vector_le";
            case 72L: return "eok_gnu_min";
            case 73L: return "eok_gnu_max";
            case 74L: return "eok_assign";
            case 75L: return "eok_add_assign";
            case 76L: return "eok_subtract_assign";
            case 77L: return "eok_multiply_assign";
            case 78L: return "eok_divide_assign";
            case 79L: return "eok_remainder_assign";
            case 80L: return "eok_shiftl_assign";
            case 81L: return "eok_shiftr_assign";
            case 82L: return "eok_and_assign";
            case 83L: return "eok_or_assign";
            case 84L: return "eok_xor_assign";
            case 85L: return "eok_padd_assign";
            case 86L: return "eok_psubtract_assign";
            case 87L: return "eok_bassign";
            case 88L: return "eok_land";
            case 89L: return "eok_lor";
            case 90L: return "eok_vector_land";
            case 91L: return "eok_vector_lor";
            case 92L: return "eok_comma";
            case 93L: return "eok_subscript";
            case 94L: return "eok_vector_subscript";
            case 95L: return "eok_dot_field";
            case 96L: return "eok_points_to_field";
            case 97L: return "eok_pm_field";
            case 98L: return "eok_pm_points_to_field";
            case 99L: return "eok_dot_pm_func_ptr";
            case 100L: return "eok_points_to_pm_func_ptr";
            case 101L: return "eok_dot_static";
            case 102L: return "eok_points_to_static";
            case 103L: return "eok_virtual_function_ptr";
            case 104L: return "eok_question";
            case 105L: return "eok_vector_question";
            case 106L: return "eok_call";
            case 107L: return "eok_dot_member_call";
            case 108L: return "eok_points_to_member_call";
            case 109L: return "eok_dot_pm_call";
            case 110L: return "eok_points_to_pm_call";
            case 111L: return "eok_cli_subscript";
            case 112L: return "eok_va_start";
            case 113L: return "eok_va_arg";
            case 114L: return "eok_va_end";
            case 115L: return "eok_va_copy";
            case 116L: return "eok_va_start_single_operand";
            case 117L: return "eok_lvalue";
            case 118L: return "eok_await";
            case 119L: return "eok_yield";
            case 120L: return "eok_error";
            case 121L: return "eok_last";
            default: return "";
        }
    }

    std::string an_expr_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expr_operator_kind_tag(i);
        if (s.empty())
            s = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expr_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L
        };
        static const std::vector<int64_t> retval(values, values + 122);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expr_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expr_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expr_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expr_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expr_operator_kind_tag() {
        return stringify::an_expr_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 13472
namespace stringify {
    const char* a_builtin_operation_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bok_offsetof";
            case 1L: return "bok_has_assign";
            case 2L: return "bok_has_copy";
            case 3L: return "bok_has_nothrow_assign";
            case 4L: return "bok_has_nothrow_constructor";
            case 5L: return "bok_has_nothrow_copy";
            case 6L: return "bok_has_trivial_assign";
            case 7L: return "bok_has_trivial_constructor";
            case 8L: return "bok_has_trivial_copy";
            case 9L: return "bok_has_trivial_destructor";
            case 10L: return "bok_has_user_destructor";
            case 11L: return "bok_has_virtual_destructor";
            case 12L: return "bok_is_abstract";
            case 13L: return "bok_is_base_of";
            case 14L: return "bok_is_class";
            case 15L: return "bok_is_convertible_to";
            case 16L: return "bok_is_empty";
            case 17L: return "bok_is_enum";
            case 18L: return "bok_is_pod";
            case 19L: return "bok_is_polymorphic";
            case 20L: return "bok_is_union";
            case 21L: return "bok_types_compatible";
            case 22L: return "bok_intaddr";
            case 23L: return "bok_is_trivial";
            case 24L: return "bok_is_standard_layout";
            case 25L: return "bok_is_trivially_copyable";
            case 26L: return "bok_is_literal_type";
            case 27L: return "bok_has_trivial_move_constructor";
            case 28L: return "bok_has_trivial_move_assign";
            case 29L: return "bok_has_nothrow_move_assign";
            case 30L: return "bok_is_constructible";
            case 31L: return "bok_is_nothrow_constructible";
            case 32L: return "bok_has_finalizer";
            case 33L: return "bok_is_delegate";
            case 34L: return "bok_is_interface_class";
            case 35L: return "bok_is_ref_array";
            case 36L: return "bok_is_ref_class";
            case 37L: return "bok_is_sealed";
            case 38L: return "bok_is_simple_value_class";
            case 39L: return "bok_is_value_class";
            case 40L: return "bok_is_final";
            case 41L: return "bok_is_trivially_constructible";
            case 42L: return "bok_is_destructible";
            case 43L: return "bok_is_nothrow_destructible";
            case 44L: return "bok_is_trivially_destructible";
            case 45L: return "bok_is_nothrow_assignable";
            case 46L: return "bok_is_trivially_assignable";
            case 47L: return "bok_builtin_shuffle";
            case 48L: return "bok_builtin_complex";
            case 49L: return "bok_is_valid_winrt_type";
            case 50L: return "bok_is_win_class";
            case 51L: return "bok_is_win_interface";
            case 52L: return "bok_builtin_shufflevector";
            case 53L: return "bok_builtin_convertvector";
            case 54L: return "bok_is_assignable";
            case 55L: return "bok_is_assignable_no_precondition_check";
            case 56L: return "bok_is_trivially_copy_assignable";
            case 57L: return "bok_builtin_addressof";
            case 58L: return "bok_has_unique_object_representations";
            case 59L: return "bok_is_aggregate";
            case 60L: return "bok_reference_binds_to_temporary";
            case 61L: return "bok_is_same";
            case 62L: return "bok_is_same_as";
            case 63L: return "bok_is_function";
            case 64L: return "bok_builtin_has_attribute";
            case 65L: return "bok_builtin_bit_cast";
            case 66L: return "bok_builtin_is_layout_compatible";
            case 67L: return "bok_builtin_is_pointer_interconvertible_base_of";
            case 68L: return "bok_is_array";
            case 69L: return "bok_array_rank";
            case 70L: return "bok_array_extent";
            case 71L: return "bok_is_arithmetic";
            case 72L: return "bok_is_complete_type";
            case 73L: return "bok_is_compound";
            case 74L: return "bok_is_const";
            case 75L: return "bok_is_floating_point";
            case 76L: return "bok_is_fundamental";
            case 77L: return "bok_is_integral";
            case 78L: return "bok_is_lvalue_reference";
            case 79L: return "bok_is_member_function_pointer";
            case 80L: return "bok_is_member_object_pointer";
            case 81L: return "bok_is_member_pointer";
            case 82L: return "bok_is_object";
            case 83L: return "bok_is_pointer";
            case 84L: return "bok_is_reference";
            case 85L: return "bok_is_rvalue_reference";
            case 86L: return "bok_is_scalar";
            case 87L: return "bok_is_signed";
            case 88L: return "bok_is_unsigned";
            case 89L: return "bok_is_void";
            case 90L: return "bok_is_volatile";
            case 91L: return "bok_last";
            default: return "";
        }
    }

    std::string a_builtin_operation_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_operation_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_operation_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L
        };
        static const std::vector<int64_t> retval(values, values + 92);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_operation_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_operation_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_operation_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_operation_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_operation_kind_tag() {
        return stringify::a_builtin_operation_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 14796
namespace stringify {
    const char* a_statement_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "stmk_expr";
            case 1L: return "stmk_if";
            case 2L: return "stmk_constexpr_if";
            case 3L: return "stmk_if_consteval";
            case 4L: return "stmk_if_not_consteval";
            case 5L: return "stmk_while";
            case 6L: return "stmk_goto";
            case 7L: return "stmk_label";
            case 8L: return "stmk_return";
            case 9L: return "stmk_coroutine";
            case 10L: return "stmk_coroutine_return";
            case 11L: return "stmk_block";
            case 12L: return "stmk_end_test_while";
            case 13L: return "stmk_for";
            case 14L: return "stmk_range_based_for";
            case 15L: return "stmk_for_each";
            case 16L: return "stmk_switch_case";
            case 17L: return "stmk_switch";
            case 18L: return "stmk_init";
            case 19L: return "stmk_asm";
            case 20L: return "stmk_asm_func_body";
            case 21L: return "stmk_try_block";
            case 22L: return "stmk_microsoft_try";
            case 23L: return "stmk_decl";
            case 24L: return "stmk_set_vla_size";
            case 25L: return "stmk_vla_decl";
            case 26L: return "stmk_upc_notify";
            case 27L: return "stmk_upc_wait";
            case 28L: return "stmk_upc_barrier";
            case 29L: return "stmk_upc_fence";
            case 30L: return "stmk_upc_forall";
            case 31L: return "stmk_assigned_goto";
            case 32L: return "stmk_empty";
            case 33L: return "stmk_stmt_expr_result";
            case 34L: return "stmk_last";
            default: return "";
        }
    }

    std::string a_statement_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_statement_kind_tag(i);
        if (s.empty())
            s = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_statement_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L
        };
        static const std::vector<int64_t> retval(values, values + 35);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_statement_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_statement_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_statement_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_statement_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_statement_kind_tag() {
        return stringify::a_statement_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 15029
namespace stringify {
    const char* a_for_each_pattern_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sfepk_none";
            case 1L: return "sfepk_stl_pattern";
            case 2L: return "sfepk_cli_pattern";
            case 3L: return "sfepk_cli_array_pattern";
            case 4L: return "sfepk_array_pattern";
            default: return "";
        }
    }

    std::string a_for_each_pattern_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_for_each_pattern_kind_tag(i);
        if (s.empty())
            s = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_for_each_pattern_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_for_each_pattern_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_for_each_pattern_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_for_each_pattern_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_for_each_pattern_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_for_each_pattern_kind_tag() {
        return stringify::a_for_each_pattern_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 15857
namespace stringify {
    const char* a_constructor_init_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cik_virtual_base_class";
            case 1L: return "cik_direct_base_class";
            case 2L: return "cik_field";
            case 3L: return "cik_delegation";
            default: return "";
        }
    }

    std::string a_constructor_init_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_constructor_init_kind_tag(i);
        if (s.empty())
            s = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constructor_init_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constructor_init_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constructor_init_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_constructor_init_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constructor_init_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constructor_init_kind_tag() {
        return stringify::a_constructor_init_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16073
namespace stringify {
    const char* a_generic_constraint_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "gck_none";
            case 1L: return "gck_type";
            case 2L: return "gck_naked_type_param";
            case 3L: return "gck_ref_class";
            case 4L: return "gck_value_class";
            case 5L: return "gck_gcnew";
            case 6L: return "gck_fail";
            default: return "";
        }
    }

    std::string a_generic_constraint_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_generic_constraint_kind_tag(i);
        if (s.empty())
            s = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_generic_constraint_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_generic_constraint_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_generic_constraint_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_generic_constraint_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_generic_constraint_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_generic_constraint_kind_tag() {
        return stringify::a_generic_constraint_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16161
namespace stringify {
    const char* a_template_parameter_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tpk_error";
            case 1L: return "tpk_type";
            case 2L: return "tpk_nontype";
            case 3L: return "tpk_template";
            default: return "";
        }
    }

    std::string a_template_parameter_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_parameter_kind_tag(i);
        if (s.empty())
            s = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_parameter_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_parameter_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_parameter_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_parameter_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_parameter_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_parameter_kind_tag() {
        return stringify::a_template_parameter_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16279
namespace stringify {
    const char* a_template_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "templk_none";
            case 1L: return "templk_class";
            case 2L: return "templk_function";
            case 3L: return "templk_variable";
            case 4L: return "templk_member_function";
            case 5L: return "templk_static_data_member";
            case 6L: return "templk_member_class";
            case 7L: return "templk_member_enum";
            case 8L: return "templk_template_template_param";
            case 9L: return "templk_concept";
            default: return "";
        }
    }

    std::string a_template_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_template_kind_tag(i);
        if (s.empty())
            s = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_template_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_template_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_template_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_template_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_template_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_template_kind_tag() {
        return stringify::a_template_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16632
namespace stringify {
    const char* an_object_lifetime_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "olk_global_static";
            case 1L: return "olk_block";
            case 2L: return "olk_block_after_label";
            case 3L: return "olk_function_static";
            case 4L: return "olk_expr_temporary";
            case 5L: return "olk_try_block";
            default: return "";
        }
    }

    std::string an_object_lifetime_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_object_lifetime_kind_tag(i);
        if (s.empty())
            s = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_object_lifetime_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_object_lifetime_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_object_lifetime_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_object_lifetime_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_object_lifetime_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_object_lifetime_kind_tag() {
        return stringify::an_object_lifetime_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16775
namespace stringify {
    const char* an_ms_attribute_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msak_none";
            case 1L: return "msak_unrecognized";
            case 2L: return "msak_misc";
            case 3L: return "msak_uuid";
            case 4L: return "msak_custom";
            case 5L: return "msak_edg_test";
            case 6L: return "msak_coclass";
            case 7L: return "msak_no_injected_text";
            case 8L: return "msak_last";
            default: return "";
        }
    }

    std::string an_ms_attribute_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_kind_tag() {
        return stringify::an_ms_attribute_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 16797
namespace stringify {
    const char* an_ms_attribute_arg_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "msaak_none";
            case 1L: return "msaak_integer";
            case 2L: return "msaak_boolean";
            case 3L: return "msaak_string";
            case 4L: return "msaak_uuid";
            case 5L: return "msaak_enumeration";
            case 6L: return "msaak_other";
            default: return "";
        }
    }

    std::string an_ms_attribute_arg_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_ms_attribute_arg_kind_tag(i);
        if (s.empty())
            s = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_ms_attribute_arg_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_ms_attribute_arg_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ms_attribute_arg_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_ms_attribute_arg_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ms_attribute_arg_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ms_attribute_arg_kind_tag() {
        return stringify::an_ms_attribute_arg_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il_def.h line 17219
namespace stringify {
    const char* a_scope_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sck_file";
            case 1L: return "sck_func_prototype";
            case 2L: return "sck_block";
            case 3L: return "sck_namespace";
            case 4L: return "sck_namespace_extension";
            case 5L: return "sck_namespace_reactivation";
            case 6L: return "sck_class_struct_union";
            case 7L: return "sck_class_reactivation";
            case 8L: return "sck_template_declaration";
            case 9L: return "sck_template_instantiation";
            case 10L: return "sck_instantiation_context";
            case 11L: return "sck_module_decl_import";
            case 12L: return "sck_pragma";
            case 13L: return "sck_function_access";
            case 14L: return "sck_condition";
            case 15L: return "sck_enum";
            case 16L: return "sck_function";
            case 17L: return "sck_none";
            default: return "";
        }
    }

    std::string a_scope_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_scope_kind_tag(i);
        if (s.empty())
            s = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_scope_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_scope_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_scope_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_scope_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_scope_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_scope_kind_tag() {
        return stringify::a_scope_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/statements.h line 56
namespace stringify {
    const char* a_control_flow_descr_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cfdk_block";
            case 1L: return "cfdk_init";
            case 2L: return "cfdk_goto";
            case 3L: return "cfdk_label";
            case 4L: return "cfdk_case_label";
            case 5L: return "cfdk_end_of_block";
            default: return "";
        }
    }

    std::string a_control_flow_descr_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_control_flow_descr_kind_tag(i);
        if (s.empty())
            s = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_control_flow_descr_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_control_flow_descr_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_control_flow_descr_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_control_flow_descr_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_control_flow_descr_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_control_flow_descr_kind_tag() {
        return stringify::a_control_flow_descr_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/host_envir.h line 2536
namespace stringify {
    const char* a_unicode_source_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "usk_none";
            case 1L: return "usk_utf8";
            case 2L: return "usk_utf16LE";
            case 3L: return "usk_utf16BE";
            default: return "";
        }
    }

    std::string a_unicode_source_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_unicode_source_kind_tag(i);
        if (s.empty())
            s = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_unicode_source_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_unicode_source_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_unicode_source_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_unicode_source_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_unicode_source_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_unicode_source_kind_tag() {
        return stringify::a_unicode_source_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/host_envir.h line 3982
namespace stringify {
    const char* a_predef_macro_mode(int64_t i) {
        switch (i) {
            case 0L: return "pmm_none";
            case 1L: return "pmm_gnu";
            case 2L: return "pmm_gcc";
            case 3L: return "pmm_gpp";
            case 4L: return "pmm_clang";
            case 5L: return "pmm_clang_c";
            case 6L: return "pmm_clang_cpp";
            case 7L: return "pmm_gnu_or_clang";
            case 8L: return "pmm_microsoft";
            case 9L: return "pmm_strict";
            case 10L: return "pmm_cpp";
            case 11L: return "pmm_all";
            case 12L: return "pmm_last";
            default: return "";
        }
    }

    std::string a_predef_macro_mode(int64_t i, const std::string &strip) {
        std::string s = a_predef_macro_mode(i);
        if (s.empty())
            s = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_predef_macro_mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_predef_macro_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_predef_macro_mode(i);
        if (retval.empty()) {
            retval = "(a_predef_macro_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_predef_macro_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_predef_macro_mode() {
        return stringify::a_predef_macro_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/sys_predef.h line 224
namespace stringify {
    const char* a_builtin_user_function_kind_tag(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string a_builtin_user_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_user_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_user_function_kind_tag() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_user_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_user_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_user_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_user_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_user_function_kind_tag() {
        return stringify::a_builtin_user_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/sys_predef.h line 494
namespace stringify {
    const char* a_multiversion_arch_kind_tag(int64_t i) {
        switch (i) {
            case -1L: return "mvak_invalid";
            case 0L: return "mvak_unknown";
            case 1L: return "mvak_lowest_cpu";
            case 2L: return "mvak_cpu_bdver2";
            case 3L: return "mvak_cpu_corei7";
            case 4L: return "mvak_cpu_amdfam10h";
            case 5L: return "mvak_cpu_core2";
            case 6L: return "mvak_highest_cpu";
            case 7L: return "mvak_default_target";
            case 8L: return "mvak_lowest_isa";
            case 9L: return "mvak_isa_sse";
            case 10L: return "mvak_isa_sse2";
            case 11L: return "mvak_isa_sse3";
            case 12L: return "mvak_isa_ssse3";
            case 13L: return "mvak_isa_sse4";
            case 14L: return "mvak_isa_sse4a";
            case 15L: return "mvak_isa_sse4_1";
            case 16L: return "mvak_isa_sse4_2";
            case 17L: return "mvak_isa_popcnt";
            case 18L: return "mvak_isa_aes";
            case 19L: return "mvak_isa_pclmul";
            case 20L: return "mvak_isa_avx";
            case 21L: return "mvak_isa_bmi";
            case 22L: return "mvak_isa_fma4";
            case 23L: return "mvak_isa_xop";
            case 24L: return "mvak_isa_fma";
            case 25L: return "mvak_isa_bmi2";
            case 26L: return "mvak_isa_avx2";
            case 27L: return "mvak_isa_avx512f";
            case 28L: return "mvak_last";
            default: return "";
        }
    }

    std::string a_multiversion_arch_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_multiversion_arch_kind_tag(i);
        if (s.empty())
            s = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_multiversion_arch_kind_tag() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_multiversion_arch_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_multiversion_arch_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_multiversion_arch_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_multiversion_arch_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_multiversion_arch_kind_tag() {
        return stringify::a_multiversion_arch_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/expr.h line 106
namespace stringify {
    const char* an_init_component_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ick_expression";
            case 1L: return "ick_braced";
            case 2L: return "ick_designator";
            case 3L: return "ick_continued";
            default: return "";
        }
    }

    std::string an_init_component_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_init_component_kind_tag(i);
        if (s.empty())
            s = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_init_component_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_init_component_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_init_component_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_init_component_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_init_component_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_init_component_kind_tag() {
        return stringify::an_init_component_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/decls.h line 28
namespace stringify {
    const char* a_tu_decl_stage(int64_t i) {
        switch (i) {
            case 0L: return "tud_none";
            case 1L: return "tud_basic_tu";
            case 2L: return "tud_global_module_fgmt";
            case 3L: return "tud_module_unit";
            case 4L: return "tud_private_module_fgmt";
            default: return "";
        }
    }

    std::string a_tu_decl_stage(int64_t i, const std::string &strip) {
        std::string s = a_tu_decl_stage(i);
        if (s.empty())
            s = "(a_tu_decl_stage)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_tu_decl_stage() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_tu_decl_stage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_tu_decl_stage(i);
        if (retval.empty()) {
            retval = "(a_tu_decl_stage)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_tu_decl_stage::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_tu_decl_stage() {
        return stringify::a_tu_decl_stage();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/lexical.h line 2059
namespace stringify {
    const char* a_token_extra_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "teik_none";
            case 1L: return "teik_identifier";
            case 2L: return "teik_constant";
            case 3L: return "teik_pragma";
            case 4L: return "teik_pp_token";
            case 5L: return "teik_extracted_body";
            case 6L: return "teik_asm_string";
            case 7L: return "teik_insert_string";
            case 8L: return "teik_ud_lit";
            case 9L: return "teik_ifc_decl";
            default: return "";
        }
    }

    std::string a_token_extra_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_token_extra_info_kind_tag(i);
        if (s.empty())
            s = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_token_extra_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_token_extra_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_token_extra_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_token_extra_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_token_extra_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_token_extra_info_kind_tag() {
        return stringify::a_token_extra_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/exprutil.h line 106
namespace stringify {
    const char* an_expression_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "ek_pp";
            case 1L: return "ek_integral_constant";
            case 2L: return "ek_template_arg";
            case 3L: return "ek_init_constant";
            case 4L: return "ek_normal";
            case 5L: return "ek_sizeof";
            default: return "";
        }
    }

    std::string an_expression_kind_tag(int64_t i, const std::string &strip) {
        std::string s = an_expression_kind_tag(i);
        if (s.empty())
            s = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_expression_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_expression_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_expression_kind_tag(i);
        if (retval.empty()) {
            retval = "(an_expression_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_expression_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_expression_kind_tag() {
        return stringify::an_expression_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/exprutil.h line 143
namespace stringify {
    const char* a_cast_source_form(int64_t i) {
        switch (i) {
            case 0L: return "csf_none";
            case 1L: return "csf_old_style";
            case 2L: return "csf_functional";
            case 3L: return "csf_static_cast";
            case 4L: return "csf_const_cast";
            case 5L: return "csf_reinterpret_cast";
            case 6L: return "csf_safe_cast";
            case 7L: return "csf_dynamic_cast";
            default: return "";
        }
    }

    std::string a_cast_source_form(int64_t i, const std::string &strip) {
        std::string s = a_cast_source_form(i);
        if (s.empty())
            s = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cast_source_form() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cast_source_form(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cast_source_form(i);
        if (retval.empty()) {
            retval = "(a_cast_source_form)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cast_source_form::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cast_source_form() {
        return stringify::a_cast_source_form();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/exprutil.h line 162
namespace stringify {
    const char* an_overload_context(int64_t i) {
        switch (i) {
            case 0L: return "oc_default";
            case 1L: return "oc_constructor";
            case 2L: return "oc_new_expression";
            case 3L: return "oc_range_based_for_bounds";
            case 4L: return "oc_for_each_bounds";
            case 5L: return "oc_cppcx_for_each_bounds";
            case 6L: return "oc_property_access";
            case 7L: return "oc_event_access";
            case 8L: return "oc_synthesized_member_call";
            case 9L: return "oc_ctad";
            case 10L: return "oc_tuple_like_binding";
            case 11L: return "oc_reversed_cmp_candidate";
            case 12L: return "oc_last";
            default: return "";
        }
    }

    std::string an_overload_context(int64_t i, const std::string &strip) {
        std::string s = an_overload_context(i);
        if (s.empty())
            s = "(an_overload_context)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_overload_context() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_overload_context(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_overload_context(i);
        if (retval.empty()) {
            retval = "(an_overload_context)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_overload_context::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_overload_context() {
        return stringify::an_overload_context();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/exprutil.h line 195
namespace stringify {
    const char* a_type_class_kind(int64_t i) {
        switch (i) {
            case -1L: return "tck_none";
            case 0L: return "tck_void";
            case 1L: return "tck_integer";
            case 2L: return "tck_char";
            case 3L: return "tck_enum";
            case 4L: return "tck_bool";
            case 5L: return "tck_pointer";
            case 6L: return "tck_reference";
            case 7L: return "tck_offset";
            case 8L: return "tck_float";
            case 9L: return "tck_complex";
            case 10L: return "tck_routine";
            case 11L: return "tck_method";
            case 12L: return "tck_struct";
            case 13L: return "tck_union";
            case 14L: return "tck_array";
            case 15L: return "tck_string";
            default: return "";
        }
    }

    std::string a_type_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_class_kind(i);
        if (s.empty())
            s = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_class_kind() {
        static const int64_t values[] = {
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_class_kind(i);
        if (retval.empty()) {
            retval = "(a_type_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_class_kind() {
        return stringify::a_type_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/exprutil.h line 323
namespace stringify {
    const char* an_operand_state_tag(int64_t i) {
        switch (i) {
            case 0L: return "os_none";
            case 1L: return "os_glvalue";
            case 2L: return "os_prvalue";
            case 3L: return "os_function_designator";
            default: return "";
        }
    }

    std::string an_operand_state_tag(int64_t i, const std::string &strip) {
        std::string s = an_operand_state_tag(i);
        if (s.empty())
            s = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_operand_state_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_operand_state_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_operand_state_tag(i);
        if (retval.empty()) {
            retval = "(an_operand_state_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_operand_state_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_operand_state_tag() {
        return stringify::an_operand_state_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 1032
namespace stringify { namespace a_type_wrapper {
    const char* a_kind(int64_t i) {
        switch (i) {
            case 0L: return "twk_invalid";
            case 1L: return "twk_void";
            case 2L: return "twk_cxx_udt_return";
            case 3L: return "twk_copy_ctor";
            case 4L: return "twk_bool";
            case 5L: return "twk_char";
            case 6L: return "twk_signed_char";
            case 7L: return "twk_unsigned_char";
            case 8L: return "twk_short";
            case 9L: return "twk_unsigned_short";
            case 10L: return "twk_wchar_t";
            case 11L: return "twk_int";
            case 12L: return "twk_unsigned_int";
            case 13L: return "twk_long";
            case 14L: return "twk_unsigned_long";
            case 15L: return "twk_long_long";
            case 16L: return "twk_unsigned_long_long";
            case 17L: return "twk_float";
            case 18L: return "twk_double";
            case 19L: return "twk_long_double";
            case 20L: return "twk_class";
            case 21L: return "twk_array";
            case 22L: return "twk_indirection";
            case 23L: return "twk_function";
            default: return "";
        }
    }

    std::string a_kind(int64_t i, const std::string &strip) {
        std::string s = a_kind(i);
        if (s.empty())
            s = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_wrapper_a_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_wrapper::a_kind(i);
        if (retval.empty()) {
            retval = "(a_type_wrapper::a_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_wrapper::a_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_wrapper_a_kind() {
        return stringify::a_type_wrapper::a_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 1293
namespace stringify { namespace a_class_type_wrapper {
    const char* a_class_kind(int64_t i) {
        switch (i) {
            case 0L: return "ck_invalid";
            case 1L: return "ck_unresolved";
            case 2L: return "ck_class";
            case 3L: return "ck_generic_parameter";
            default: return "";
        }
    }

    std::string a_class_kind(int64_t i, const std::string &strip) {
        std::string s = a_class_kind(i);
        if (s.empty())
            s = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_class_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_class_type_wrapper_a_class_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_class_type_wrapper::a_class_kind(i);
        if (retval.empty()) {
            retval = "(a_class_type_wrapper::a_class_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_class_type_wrapper::a_class_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_class_type_wrapper_a_class_kind() {
        return stringify::a_class_type_wrapper::a_class_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 1414
namespace stringify { namespace a_type_indirection {
    const char* an_indirection_kind(int64_t i) {
        switch (i) {
            case 0L: return "tik_invalid";
            case 1L: return "tik_pointer";
            case 2L: return "tik_interior_pointer";
            case 3L: return "tik_handle";
            case 4L: return "tik_reference";
            case 5L: return "tik_rvalue_reference";
            case 6L: return "tik_tracking_reference";
            case 7L: return "tik_tentative_byref";
            default: return "";
        }
    }

    std::string an_indirection_kind(int64_t i, const std::string &strip) {
        std::string s = an_indirection_kind(i);
        if (s.empty())
            s = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_indirection_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_indirection_an_indirection_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_indirection::an_indirection_kind(i);
        if (retval.empty()) {
            retval = "(a_type_indirection::an_indirection_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_indirection::an_indirection_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_indirection_an_indirection_kind() {
        return stringify::a_type_indirection::an_indirection_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 1566
namespace stringify { namespace an_array_type_wrapper {
    const char* an_array_kind(int64_t i) {
        switch (i) {
            case 0L: return "ak_invalid";
            case 1L: return "ak_array";
            case 2L: return "ak_param_array";
            case 3L: return "ak_write_only_array";
            default: return "";
        }
    }

    std::string an_array_kind(int64_t i, const std::string &strip) {
        std::string s = an_array_kind(i);
        if (s.empty())
            s = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_array_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_array_type_wrapper_an_array_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_array_type_wrapper::an_array_kind(i);
        if (retval.empty()) {
            retval = "(an_array_type_wrapper::an_array_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_array_type_wrapper::an_array_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_array_type_wrapper_an_array_kind() {
        return stringify::an_array_type_wrapper::an_array_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 3807
namespace stringify { namespace an_accessibility {
    const char* access_kind(int64_t i) {
        switch (i) {
            case 0L: return "access_unknown";
            case 1L: return "access_none";
            case 2L: return "access_private";
            case 3L: return "access_imported_private";
            case 4L: return "access_private_as_friend";
            case 5L: return "access_family_and_assembly";
            case 6L: return "access_imported_family_and_assembly";
            case 7L: return "access_family_and_assembly_as_friend";
            case 8L: return "access_assembly";
            case 9L: return "access_imported_assembly";
            case 10L: return "access_assembly_as_friend";
            case 11L: return "access_family";
            case 12L: return "access_family_or_assembly";
            case 13L: return "access_family_or_assembly_as_friend";
            case 14L: return "access_public";
            default: return "";
        }
    }

    std::string access_kind(int64_t i, const std::string &strip) {
        std::string s = access_kind(i);
        if (s.empty())
            s = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_accessibility_access_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_accessibility::access_kind(i);
        if (retval.empty()) {
            retval = "(an_accessibility::access_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_accessibility::access_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_accessibility_access_kind() {
        return stringify::an_accessibility::access_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.cpp line 3846
namespace stringify { namespace a_type_definition {
    const char* a_type_definition_kind(int64_t i) {
        switch (i) {
            case 0L: return "tdk_unknown";
            case 1L: return "tdk_ref_class";
            case 2L: return "tdk_interface_class";
            case 3L: return "tdk_value_class";
            case 4L: return "tdk_enum_class";
            case 5L: return "tdk_delegate";
            case 6L: return "tdk_native_class";
            case 7L: return "tdk_native_enum";
            default: return "";
        }
    }

    std::string a_type_definition_kind(int64_t i, const std::string &strip) {
        std::string s = a_type_definition_kind(i);
        if (s.empty())
            s = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_definition_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_a_type_definition_a_type_definition_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_definition::a_type_definition_kind(i);
        if (retval.empty()) {
            retval = "(a_type_definition::a_type_definition_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_definition::a_type_definition_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_definition_a_type_definition_kind() {
        return stringify::a_type_definition::a_type_definition_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/pragma.h line 52
namespace stringify {
    const char* a_pragma_binding_kind(int64_t i) {
        switch (i) {
            case 0L: return "pbk_none";
            case 1L: return "pbk_next_construct";
            case 2L: return "pbk_next_token";
            case 3L: return "pbk_immediate";
            case 4L: return "pbk_other";
            case 5L: return "pbk_preproc_immediate";
            case 6L: return "pbk_last";
            default: return "";
        }
    }

    std::string a_pragma_binding_kind(int64_t i, const std::string &strip) {
        std::string s = a_pragma_binding_kind(i);
        if (s.empty())
            s = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_pragma_binding_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_pragma_binding_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_pragma_binding_kind(i);
        if (retval.empty()) {
            retval = "(a_pragma_binding_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_pragma_binding_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_pragma_binding_kind() {
        return stringify::a_pragma_binding_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/lower_il.h line 424
namespace stringify {
    const char* an_insert_location_kind(int64_t i) {
        switch (i) {
            case 0L: return "ilk_after_statement";
            case 1L: return "ilk_block_start";
            case 2L: return "ilk_statement_creation";
            case 3L: return "ilk_before_expr";
            case 4L: return "ilk_after_expr";
            case 5L: return "ilk_expr_creation";
            default: return "";
        }
    }

    std::string an_insert_location_kind(int64_t i, const std::string &strip) {
        std::string s = an_insert_location_kind(i);
        if (s.empty())
            s = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_insert_location_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_insert_location_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_insert_location_kind(i);
        if (retval.empty()) {
            retval = "(an_insert_location_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_insert_location_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_insert_location_kind() {
        return stringify::an_insert_location_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ms_metadata.h line 22
namespace stringify {
    const char* a_cpp_cli_import_flag_tag(int64_t i) {
        switch (i) {
            case 0L: return "cpp_cli_none";
            case 1L: return "cpp_cli_as_friend_assembly";
            case 2L: return "cpp_cli_declspec_assembly_info";
            case 4L: return "cpp_cli_declspec_member_info";
            case 8L: return "cpp_cli_define_all_types";
            case 16L: return "cpp_cli_wchar_t_is_keyword";
            case 32L: return "cpp_cli_ide_custom_attributes";
            case 64L: return "cpp_cli_all_custom_attributes";
            default: return "";
        }
    }

    std::string a_cpp_cli_import_flag_tag(int64_t i, const std::string &strip) {
        std::string s = a_cpp_cli_import_flag_tag(i);
        if (s.empty())
            s = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cpp_cli_import_flag_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cpp_cli_import_flag_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cpp_cli_import_flag_tag(i);
        if (retval.empty()) {
            retval = "(a_cpp_cli_import_flag_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cpp_cli_import_flag_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cpp_cli_import_flag_tag() {
        return stringify::a_cpp_cli_import_flag_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/builtin_defs.h line 25
namespace stringify {
    const char* a_builtin_function_type_index(int64_t i) {
        switch (i) {
            case 0L: return "bfti_000db6619e";
            case 1L: return "bfti_001e209a45";
            case 2L: return "bfti_003d6de10d";
            case 3L: return "bfti_003fa00724";
            case 4L: return "bfti_004086891a";
            case 5L: return "bfti_0056490ab6";
            case 6L: return "bfti_0063dc7557";
            case 7L: return "bfti_00a69d8b4b";
            case 8L: return "bfti_00bfd9928a";
            case 9L: return "bfti_00c8cfa7e7";
            case 10L: return "bfti_00cce8bfc5";
            case 11L: return "bfti_00d9b248c7";
            case 12L: return "bfti_00f5fef98c";
            case 13L: return "bfti_0125fc19ed";
            case 14L: return "bfti_013bed6256";
            case 15L: return "bfti_015b244f65";
            case 16L: return "bfti_01678b0e31";
            case 17L: return "bfti_018e095f15";
            case 18L: return "bfti_019980e3fc";
            case 19L: return "bfti_01a390af99";
            case 20L: return "bfti_01ad6f2ea7";
            case 21L: return "bfti_01b5072cbd";
            case 22L: return "bfti_01ed60f438";
            case 23L: return "bfti_02075a7818";
            case 24L: return "bfti_021feda6a2";
            case 25L: return "bfti_0261491605";
            case 26L: return "bfti_02a7d41178";
            case 27L: return "bfti_02b5a15283";
            case 28L: return "bfti_02e6f23732";
            case 29L: return "bfti_030dd242f7";
            case 30L: return "bfti_0360cd1add";
            case 31L: return "bfti_03aa168638";
            case 32L: return "bfti_03c7ae9ece";
            case 33L: return "bfti_03d5cb95bf";
            case 34L: return "bfti_03e0a9391a";
            case 35L: return "bfti_03ea8a6e53";
            case 36L: return "bfti_04022dca7a";
            case 37L: return "bfti_041f722932";
            case 38L: return "bfti_04228dccc6";
            case 39L: return "bfti_0438d503e1";
            case 40L: return "bfti_043f0f6bdd";
            case 41L: return "bfti_043f1742a6";
            case 42L: return "bfti_049f994f52";
            case 43L: return "bfti_04a02a19bd";
            case 44L: return "bfti_04b6378005";
            case 45L: return "bfti_04c4ebcda3";
            case 46L: return "bfti_0506407bd3";
            case 47L: return "bfti_050f43759e";
            case 48L: return "bfti_053aad4f6b";
            case 49L: return "bfti_054ab132f8";
            case 50L: return "bfti_0553518b14";
            case 51L: return "bfti_05d1694fef";
            case 52L: return "bfti_05db792456";
            case 53L: return "bfti_05f0e64002";
            case 54L: return "bfti_05f212d199";
            case 55L: return "bfti_05f2b70bad";
            case 56L: return "bfti_0635a955f7";
            case 57L: return "bfti_06786e9f2b";
            case 58L: return "bfti_067adc41e3";
            case 59L: return "bfti_069e99e161";
            case 60L: return "bfti_06c519c321";
            case 61L: return "bfti_06ee14db2f";
            case 62L: return "bfti_06f1e4b6db";
            case 63L: return "bfti_072a41f47f";
            case 64L: return "bfti_073f5e849d";
            case 65L: return "bfti_076d9dc90a";
            case 66L: return "bfti_076e140dd7";
            case 67L: return "bfti_07734d6839";
            case 68L: return "bfti_078c102556";
            case 69L: return "bfti_079010e56c";
            case 70L: return "bfti_0792fee631";
            case 71L: return "bfti_079f4de5a6";
            case 72L: return "bfti_07c96ecc2b";
            case 73L: return "bfti_07cec8b399";
            case 74L: return "bfti_08224e710e";
            case 75L: return "bfti_0827f0a803";
            case 76L: return "bfti_0829edf422";
            case 77L: return "bfti_083d2d8dcd";
            case 78L: return "bfti_08550e996a";
            case 79L: return "bfti_085bb00c77";
            case 80L: return "bfti_0878a3dbd1";
            case 81L: return "bfti_087b01bf81";
            case 82L: return "bfti_087be52f11";
            case 83L: return "bfti_088bc89552";
            case 84L: return "bfti_08aba71b16";
            case 85L: return "bfti_08d2223f23";
            case 86L: return "bfti_08d56cfd51";
            case 87L: return "bfti_08f83fcc74";
            case 88L: return "bfti_090d29b6c6";
            case 89L: return "bfti_094a4a928e";
            case 90L: return "bfti_09629c2306";
            case 91L: return "bfti_09671bacac";
            case 92L: return "bfti_096a3b13bd";
            case 93L: return "bfti_0973c161e2";
            case 94L: return "bfti_097d49d2c4";
            case 95L: return "bfti_0990c2bd50";
            case 96L: return "bfti_0997187e9a";
            case 97L: return "bfti_09a3fdab76";
            case 98L: return "bfti_09cc70d50c";
            case 99L: return "bfti_09dc3854c8";
            case 100L: return "bfti_09fbe2b5e1";
            case 101L: return "bfti_0a0ae45507";
            case 102L: return "bfti_0a19a2d5c0";
            case 103L: return "bfti_0a1fae4344";
            case 104L: return "bfti_0a2e9f10a4";
            case 105L: return "bfti_0a4a1950d1";
            case 106L: return "bfti_0a4a8dc832";
            case 107L: return "bfti_0ab459d8f9";
            case 108L: return "bfti_0ad0083bce";
            case 109L: return "bfti_0ad5e8efd6";
            case 110L: return "bfti_0ae7c3c252";
            case 111L: return "bfti_0b144dbb6d";
            case 112L: return "bfti_0b1a7c543d";
            case 113L: return "bfti_0b3e1a0d9c";
            case 114L: return "bfti_0b493e41c9";
            case 115L: return "bfti_0b4db9a264";
            case 116L: return "bfti_0b646cddc6";
            case 117L: return "bfti_0b667519de";
            case 118L: return "bfti_0b875308d0";
            case 119L: return "bfti_0bb7f15d41";
            case 120L: return "bfti_0bcb8b17b5";
            case 121L: return "bfti_0bce84f3ab";
            case 122L: return "bfti_0bd530539f";
            case 123L: return "bfti_0bdff635b8";
            case 124L: return "bfti_0c0e8645bc";
            case 125L: return "bfti_0c12f9b9d2";
            case 126L: return "bfti_0c1ce1dbd8";
            case 127L: return "bfti_0c1d031183";
            case 128L: return "bfti_0c48dcecd8";
            case 129L: return "bfti_0cd91d57ab";
            case 130L: return "bfti_0ceb38c49d";
            case 131L: return "bfti_0d2af5ce76";
            case 132L: return "bfti_0d44f81ccc";
            case 133L: return "bfti_0d584dbeaa";
            case 134L: return "bfti_0d6f1fdfcb";
            case 135L: return "bfti_0d7ec2a155";
            case 136L: return "bfti_0d9a31fcc7";
            case 137L: return "bfti_0da2b2ac63";
            case 138L: return "bfti_0da3b4892e";
            case 139L: return "bfti_0dac31fc8d";
            case 140L: return "bfti_0ddee3dcb1";
            case 141L: return "bfti_0dfa3c8404";
            case 142L: return "bfti_0e11e9b7d8";
            case 143L: return "bfti_0e15c9775d";
            case 144L: return "bfti_0e21d503a9";
            case 145L: return "bfti_0e3fefe412";
            case 146L: return "bfti_0e4fd898c7";
            case 147L: return "bfti_0e5649d107";
            case 148L: return "bfti_0e5906147f";
            case 149L: return "bfti_0e6a4e2beb";
            case 150L: return "bfti_0e6eb99a03";
            case 151L: return "bfti_0e7894567a";
            case 152L: return "bfti_0e89e8268b";
            case 153L: return "bfti_0e9b9d2319";
            case 154L: return "bfti_0eadfe1dba";
            case 155L: return "bfti_0ec7628210";
            case 156L: return "bfti_0ee8659d68";
            case 157L: return "bfti_0ee9cb5436";
            case 158L: return "bfti_0f050f2633";
            case 159L: return "bfti_0f097d6f7e";
            case 160L: return "bfti_0f2fd6445b";
            case 161L: return "bfti_0f33396cec";
            case 162L: return "bfti_0f3903a67e";
            case 163L: return "bfti_0f54e1c803";
            case 164L: return "bfti_0f5ccd6998";
            case 165L: return "bfti_0f61c53ab9";
            case 166L: return "bfti_0f9efae8ce";
            case 167L: return "bfti_0fa4f4bf2b";
            case 168L: return "bfti_0fb2ceae5f";
            case 169L: return "bfti_0fc006bdcc";
            case 170L: return "bfti_0fe17cad73";
            case 171L: return "bfti_0fedb54ba6";
            case 172L: return "bfti_10154e817b";
            case 173L: return "bfti_10275706e1";
            case 174L: return "bfti_1041c6a791";
            case 175L: return "bfti_105a2c6d64";
            case 176L: return "bfti_106f9cad20";
            case 177L: return "bfti_10ac05c17e";
            case 178L: return "bfti_10deec183f";
            case 179L: return "bfti_10e2a64785";
            case 180L: return "bfti_110084a10b";
            case 181L: return "bfti_115865b8c5";
            case 182L: return "bfti_117b024bdc";
            case 183L: return "bfti_11a957515b";
            case 184L: return "bfti_11ab1a3a1f";
            case 185L: return "bfti_11bf806960";
            case 186L: return "bfti_11ef997505";
            case 187L: return "bfti_11f28b741a";
            case 188L: return "bfti_122fefe0ac";
            case 189L: return "bfti_123c1ea119";
            case 190L: return "bfti_123ef40d00";
            case 191L: return "bfti_12489ae6ff";
            case 192L: return "bfti_12a19d76dc";
            case 193L: return "bfti_12cd2a04b6";
            case 194L: return "bfti_12e249d08f";
            case 195L: return "bfti_12fd3e8468";
            case 196L: return "bfti_133b9a35bb";
            case 197L: return "bfti_1345213053";
            case 198L: return "bfti_135c501a56";
            case 199L: return "bfti_1363dd796e";
            case 200L: return "bfti_138d138eb0";
            case 201L: return "bfti_13b7be6f37";
            case 202L: return "bfti_13cacdc41f";
            case 203L: return "bfti_13d1000887";
            case 204L: return "bfti_13d9a0dfac";
            case 205L: return "bfti_13f171890a";
            case 206L: return "bfti_1429007ea9";
            case 207L: return "bfti_144f9138f1";
            case 208L: return "bfti_1451b004cc";
            case 209L: return "bfti_147b004c22";
            case 210L: return "bfti_14854d240b";
            case 211L: return "bfti_14970992c6";
            case 212L: return "bfti_14a0812d09";
            case 213L: return "bfti_14edb45f9a";
            case 214L: return "bfti_14f74930d4";
            case 215L: return "bfti_152e047e40";
            case 216L: return "bfti_155380c999";
            case 217L: return "bfti_157092cbcc";
            case 218L: return "bfti_1579595730";
            case 219L: return "bfti_1594b1776b";
            case 220L: return "bfti_15a0583e78";
            case 221L: return "bfti_15b201edad";
            case 222L: return "bfti_15b3d0e346";
            case 223L: return "bfti_15c82d0793";
            case 224L: return "bfti_15d5e0e930";
            case 225L: return "bfti_15fe1865b6";
            case 226L: return "bfti_16083eecf1";
            case 227L: return "bfti_16232d7f39";
            case 228L: return "bfti_1623a621a8";
            case 229L: return "bfti_164b9005d6";
            case 230L: return "bfti_164fee816a";
            case 231L: return "bfti_165c3107a6";
            case 232L: return "bfti_165e80e4d0";
            case 233L: return "bfti_166ba9bb06";
            case 234L: return "bfti_16771fd934";
            case 235L: return "bfti_16835c8cb2";
            case 236L: return "bfti_16844cfcaa";
            case 237L: return "bfti_1693e41d99";
            case 238L: return "bfti_16c5c386dd";
            case 239L: return "bfti_16c5d1ee97";
            case 240L: return "bfti_16d2dd0c23";
            case 241L: return "bfti_16d896f164";
            case 242L: return "bfti_16e6ce0874";
            case 243L: return "bfti_170a15172f";
            case 244L: return "bfti_172d4ded1c";
            case 245L: return "bfti_1746cd3964";
            case 246L: return "bfti_17655780d3";
            case 247L: return "bfti_176c6e5d8c";
            case 248L: return "bfti_177cb42b60";
            case 249L: return "bfti_17abda1ad3";
            case 250L: return "bfti_17fbb9aabb";
            case 251L: return "bfti_17fe3e6ec9";
            case 252L: return "bfti_17ff20a35b";
            case 253L: return "bfti_1804314289";
            case 254L: return "bfti_180cd5420b";
            case 255L: return "bfti_181ccc9767";
            case 256L: return "bfti_183bb9fd6f";
            case 257L: return "bfti_183cc632bc";
            case 258L: return "bfti_18533dbc3a";
            case 259L: return "bfti_1855e653cb";
            case 260L: return "bfti_1861131fba";
            case 261L: return "bfti_188a8e0cf3";
            case 262L: return "bfti_18b345b24e";
            case 263L: return "bfti_18ba52f8d5";
            case 264L: return "bfti_18d42eabcb";
            case 265L: return "bfti_18e2a741d3";
            case 266L: return "bfti_18e72fe806";
            case 267L: return "bfti_1902b04093";
            case 268L: return "bfti_191e459932";
            case 269L: return "bfti_19243598d1";
            case 270L: return "bfti_1928deaae4";
            case 271L: return "bfti_19372dee47";
            case 272L: return "bfti_194afe8ee8";
            case 273L: return "bfti_19856b98b2";
            case 274L: return "bfti_19ac9c70e8";
            case 275L: return "bfti_1a03221fa2";
            case 276L: return "bfti_1a1ed1aeb3";
            case 277L: return "bfti_1a53f11758";
            case 278L: return "bfti_1a7f5cdd07";
            case 279L: return "bfti_1a82453c56";
            case 280L: return "bfti_1aa81332d2";
            case 281L: return "bfti_1aa8f02153";
            case 282L: return "bfti_1aad43899a";
            case 283L: return "bfti_1af3646a6f";
            case 284L: return "bfti_1afd5d7557";
            case 285L: return "bfti_1b09479a2c";
            case 286L: return "bfti_1b36b7dd5d";
            case 287L: return "bfti_1b3c2c2d9b";
            case 288L: return "bfti_1b4c3772a3";
            case 289L: return "bfti_1b649b8436";
            case 290L: return "bfti_1b8490292a";
            case 291L: return "bfti_1b8b4142f0";
            case 292L: return "bfti_1bd10470e2";
            case 293L: return "bfti_1bd7c59031";
            case 294L: return "bfti_1c5d3c4cd6";
            case 295L: return "bfti_1c6b8b4074";
            case 296L: return "bfti_1c948f1b69";
            case 297L: return "bfti_1c989dc11b";
            case 298L: return "bfti_1ca2328b73";
            case 299L: return "bfti_1ca724dbdf";
            case 300L: return "bfti_1ccf5477ea";
            case 301L: return "bfti_1cd9d945ec";
            case 302L: return "bfti_1cdcc627f2";
            case 303L: return "bfti_1cf7409a55";
            case 304L: return "bfti_1d1d7d60fb";
            case 305L: return "bfti_1d4e5c82bc";
            case 306L: return "bfti_1d6e6627e3";
            case 307L: return "bfti_1d9c36e5de";
            case 308L: return "bfti_1dafa7d608";
            case 309L: return "bfti_1db66d695f";
            case 310L: return "bfti_1dc718c508";
            case 311L: return "bfti_1e0b76f123";
            case 312L: return "bfti_1e17a03d28";
            case 313L: return "bfti_1e1aad424d";
            case 314L: return "bfti_1e1b3b7da0";
            case 315L: return "bfti_1e1daf59c4";
            case 316L: return "bfti_1e5188cc74";
            case 317L: return "bfti_1e6e568d5c";
            case 318L: return "bfti_1e72c68fe4";
            case 319L: return "bfti_1e7863e94a";
            case 320L: return "bfti_1e7ee3d778";
            case 321L: return "bfti_1e805f0fe7";
            case 322L: return "bfti_1e91885a56";
            case 323L: return "bfti_1e951e261f";
            case 324L: return "bfti_1e9c717db7";
            case 325L: return "bfti_1ea1135519";
            case 326L: return "bfti_1ecbaf9c15";
            case 327L: return "bfti_1ecc530d17";
            case 328L: return "bfti_1ed0d6a678";
            case 329L: return "bfti_1ed174492c";
            case 330L: return "bfti_1f02a1e4b8";
            case 331L: return "bfti_1f119532c8";
            case 332L: return "bfti_1f31d40504";
            case 333L: return "bfti_1f545dde45";
            case 334L: return "bfti_1f5e04cb20";
            case 335L: return "bfti_1f5f913fa4";
            case 336L: return "bfti_1f5fbc696e";
            case 337L: return "bfti_1f6f079742";
            case 338L: return "bfti_1f70583313";
            case 339L: return "bfti_1f7be337fc";
            case 340L: return "bfti_1fe349f6d3";
            case 341L: return "bfti_1ffd4e60d6";
            case 342L: return "bfti_202b5991f4";
            case 343L: return "bfti_2041624b53";
            case 344L: return "bfti_204ca5bac5";
            case 345L: return "bfti_2071e2464d";
            case 346L: return "bfti_20a5af4621";
            case 347L: return "bfti_20c87514ce";
            case 348L: return "bfti_20d4922265";
            case 349L: return "bfti_20db90a2f5";
            case 350L: return "bfti_21184779dc";
            case 351L: return "bfti_212b0b9eab";
            case 352L: return "bfti_212c142e9e";
            case 353L: return "bfti_212fc8185d";
            case 354L: return "bfti_2161a8acff";
            case 355L: return "bfti_217015e55d";
            case 356L: return "bfti_21793971f6";
            case 357L: return "bfti_218f04023e";
            case 358L: return "bfti_21aa5fec2d";
            case 359L: return "bfti_21aa7c5185";
            case 360L: return "bfti_21b6466dcf";
            case 361L: return "bfti_21c3169413";
            case 362L: return "bfti_21e71befc5";
            case 363L: return "bfti_220cfa4d95";
            case 364L: return "bfti_22228caa6f";
            case 365L: return "bfti_222b95de68";
            case 366L: return "bfti_2238731621";
            case 367L: return "bfti_224444a7fd";
            case 368L: return "bfti_224d69c947";
            case 369L: return "bfti_2260d709bc";
            case 370L: return "bfti_22697324e3";
            case 371L: return "bfti_226ae106f4";
            case 372L: return "bfti_227a57d7d6";
            case 373L: return "bfti_22b228fcd9";
            case 374L: return "bfti_22bb934c05";
            case 375L: return "bfti_22fd32d531";
            case 376L: return "bfti_22fdc9ba40";
            case 377L: return "bfti_2309315d4d";
            case 378L: return "bfti_230c54c0f6";
            case 379L: return "bfti_231195c162";
            case 380L: return "bfti_233ee2cc6b";
            case 381L: return "bfti_2342d8ed5d";
            case 382L: return "bfti_234978f903";
            case 383L: return "bfti_235ac0fe86";
            case 384L: return "bfti_235d6c3e2c";
            case 385L: return "bfti_23c0dca960";
            case 386L: return "bfti_23d48c14f7";
            case 387L: return "bfti_23ee1d49bd";
            case 388L: return "bfti_23f8b1cc1d";
            case 389L: return "bfti_240db23826";
            case 390L: return "bfti_24124c69a5";
            case 391L: return "bfti_2417476ffe";
            case 392L: return "bfti_241f446680";
            case 393L: return "bfti_2421c7878b";
            case 394L: return "bfti_242803315b";
            case 395L: return "bfti_244ed5fe2c";
            case 396L: return "bfti_24620a103e";
            case 397L: return "bfti_2478fe37ff";
            case 398L: return "bfti_247f8d5dee";
            case 399L: return "bfti_249257dea6";
            case 400L: return "bfti_2498af02d8";
            case 401L: return "bfti_24a17495d6";
            case 402L: return "bfti_24b66da9c1";
            case 403L: return "bfti_24df04c7e0";
            case 404L: return "bfti_24e889906c";
            case 405L: return "bfti_24f4753ab4";
            case 406L: return "bfti_2526a73369";
            case 407L: return "bfti_25272939f9";
            case 408L: return "bfti_25431b5719";
            case 409L: return "bfti_2566557da0";
            case 410L: return "bfti_259a571579";
            case 411L: return "bfti_25b669ecaa";
            case 412L: return "bfti_25d14c1b7c";
            case 413L: return "bfti_25d43151c6";
            case 414L: return "bfti_25d623a33d";
            case 415L: return "bfti_25e8ab162e";
            case 416L: return "bfti_25f6da5aa0";
            case 417L: return "bfti_260558396a";
            case 418L: return "bfti_2608d45b84";
            case 419L: return "bfti_263945ad49";
            case 420L: return "bfti_266990a8bb";
            case 421L: return "bfti_26cab0e481";
            case 422L: return "bfti_26cbc3eb59";
            case 423L: return "bfti_26d251ab8e";
            case 424L: return "bfti_26d710ec0f";
            case 425L: return "bfti_26dbc5ee4a";
            case 426L: return "bfti_26fcc50d0f";
            case 427L: return "bfti_2714b3ad29";
            case 428L: return "bfti_272295074f";
            case 429L: return "bfti_273c13de41";
            case 430L: return "bfti_273edd8f10";
            case 431L: return "bfti_27409c86f3";
            case 432L: return "bfti_2761d18f84";
            case 433L: return "bfti_276a020309";
            case 434L: return "bfti_277b297420";
            case 435L: return "bfti_27802a1e54";
            case 436L: return "bfti_278282b6d8";
            case 437L: return "bfti_27b4d59c87";
            case 438L: return "bfti_2817fc3990";
            case 439L: return "bfti_281e73f96d";
            case 440L: return "bfti_2820c907ec";
            case 441L: return "bfti_282b8bb919";
            case 442L: return "bfti_2832191c17";
            case 443L: return "bfti_2838f64533";
            case 444L: return "bfti_2845c42e98";
            case 445L: return "bfti_285267d41c";
            case 446L: return "bfti_2880c3fb37";
            case 447L: return "bfti_28a9c5f1b8";
            case 448L: return "bfti_28ac9e657f";
            case 449L: return "bfti_28afb5604b";
            case 450L: return "bfti_28e5df3f2d";
            case 451L: return "bfti_28f2bae353";
            case 452L: return "bfti_28f33d91de";
            case 453L: return "bfti_28f9dc7344";
            case 454L: return "bfti_290357eb1d";
            case 455L: return "bfti_292e78f164";
            case 456L: return "bfti_293d8500ad";
            case 457L: return "bfti_293da61e8d";
            case 458L: return "bfti_297367ee56";
            case 459L: return "bfti_297ac95dc2";
            case 460L: return "bfti_29df303b2a";
            case 461L: return "bfti_29f1d32960";
            case 462L: return "bfti_2a0912a53b";
            case 463L: return "bfti_2a0b6e540b";
            case 464L: return "bfti_2a1787a280";
            case 465L: return "bfti_2a432e4116";
            case 466L: return "bfti_2a6bab061c";
            case 467L: return "bfti_2a73b66867";
            case 468L: return "bfti_2a7d61e66a";
            case 469L: return "bfti_2ab6fad262";
            case 470L: return "bfti_2abc22675d";
            case 471L: return "bfti_2abc32c8df";
            case 472L: return "bfti_2ad4106e0d";
            case 473L: return "bfti_2b087e7d18";
            case 474L: return "bfti_2b09870e84";
            case 475L: return "bfti_2b2a43cb09";
            case 476L: return "bfti_2b3f6c3302";
            case 477L: return "bfti_2b60a06226";
            case 478L: return "bfti_2b6c384072";
            case 479L: return "bfti_2b8f4eb0ca";
            case 480L: return "bfti_2bb3743966";
            case 481L: return "bfti_2bc7f2ffa8";
            case 482L: return "bfti_2bcc8a204b";
            case 483L: return "bfti_2bd9265718";
            case 484L: return "bfti_2c1300f922";
            case 485L: return "bfti_2c20414721";
            case 486L: return "bfti_2c5fc38c7b";
            case 487L: return "bfti_2c904955e6";
            case 488L: return "bfti_2c99316882";
            case 489L: return "bfti_2c9b734dbf";
            case 490L: return "bfti_2c9e0ab48f";
            case 491L: return "bfti_2ca344f3b8";
            case 492L: return "bfti_2cc508f1f7";
            case 493L: return "bfti_2cca3f2760";
            case 494L: return "bfti_2cce874428";
            case 495L: return "bfti_2cd13b956a";
            case 496L: return "bfti_2ce28c271b";
            case 497L: return "bfti_2ce9808990";
            case 498L: return "bfti_2cfc52d1ad";
            case 499L: return "bfti_2d0e87f00a";
            case 500L: return "bfti_2d4097d376";
            case 501L: return "bfti_2d493c24d7";
            case 502L: return "bfti_2d6ffd7c91";
            case 503L: return "bfti_2d7eb42a37";
            case 504L: return "bfti_2d8a4b62f4";
            case 505L: return "bfti_2da1a95297";
            case 506L: return "bfti_2dbdc9ab22";
            case 507L: return "bfti_2ddbc4ef5c";
            case 508L: return "bfti_2de4fa95b7";
            case 509L: return "bfti_2e0abffd7b";
            case 510L: return "bfti_2e160ce4fc";
            case 511L: return "bfti_2e2cf8ce97";
            case 512L: return "bfti_2e54f51f17";
            case 513L: return "bfti_2e7326905b";
            case 514L: return "bfti_2e77b0dad8";
            case 515L: return "bfti_2eb68153fb";
            case 516L: return "bfti_2ee41c62cf";
            case 517L: return "bfti_2efcf7acce";
            case 518L: return "bfti_2f25d8b1b4";
            case 519L: return "bfti_2f26d8ab17";
            case 520L: return "bfti_2f2c340741";
            case 521L: return "bfti_2f3af666a6";
            case 522L: return "bfti_2f3b2b2e38";
            case 523L: return "bfti_2f4ae67303";
            case 524L: return "bfti_2f7e50467a";
            case 525L: return "bfti_2f80c5a85b";
            case 526L: return "bfti_2f815c605e";
            case 527L: return "bfti_2f8f306fb1";
            case 528L: return "bfti_2fb59735b3";
            case 529L: return "bfti_2fc9b972de";
            case 530L: return "bfti_2fe793f356";
            case 531L: return "bfti_2ff7822286";
            case 532L: return "bfti_3065534615";
            case 533L: return "bfti_3068b59990";
            case 534L: return "bfti_3077ebe9e0";
            case 535L: return "bfti_3095af88ee";
            case 536L: return "bfti_30afc18be7";
            case 537L: return "bfti_30d166a274";
            case 538L: return "bfti_30f8b7f7a5";
            case 539L: return "bfti_315ecf6dc3";
            case 540L: return "bfti_31644d2fb2";
            case 541L: return "bfti_3164afa260";
            case 542L: return "bfti_318bf74fc3";
            case 543L: return "bfti_318f92063d";
            case 544L: return "bfti_319eafd31d";
            case 545L: return "bfti_31d077a664";
            case 546L: return "bfti_32088d8163";
            case 547L: return "bfti_32136ef373";
            case 548L: return "bfti_32267eb497";
            case 549L: return "bfti_322956ccf0";
            case 550L: return "bfti_3247052e7b";
            case 551L: return "bfti_3248e36e71";
            case 552L: return "bfti_3285875503";
            case 553L: return "bfti_3297c9cf8d";
            case 554L: return "bfti_32ab7102de";
            case 555L: return "bfti_32ac6dbdad";
            case 556L: return "bfti_32c3a3055f";
            case 557L: return "bfti_32c70784fc";
            case 558L: return "bfti_32f1e3b7da";
            case 559L: return "bfti_32f35d75ce";
            case 560L: return "bfti_32fd940ac7";
            case 561L: return "bfti_3329d4c20c";
            case 562L: return "bfti_33b09ff8e8";
            case 563L: return "bfti_33c7f0cd4c";
            case 564L: return "bfti_33cb510d37";
            case 565L: return "bfti_33f43e6d23";
            case 566L: return "bfti_33f4552478";
            case 567L: return "bfti_33f643305a";
            case 568L: return "bfti_341be6a056";
            case 569L: return "bfti_34250a0390";
            case 570L: return "bfti_34327292b3";
            case 571L: return "bfti_344272427c";
            case 572L: return "bfti_3442f023a1";
            case 573L: return "bfti_34492eaf8c";
            case 574L: return "bfti_34679d528f";
            case 575L: return "bfti_3468fb73ca";
            case 576L: return "bfti_3472aee82a";
            case 577L: return "bfti_3477445486";
            case 578L: return "bfti_34814e8652";
            case 579L: return "bfti_34a545e62d";
            case 580L: return "bfti_34a63c7ea4";
            case 581L: return "bfti_34bba01201";
            case 582L: return "bfti_350b112c28";
            case 583L: return "bfti_352386b389";
            case 584L: return "bfti_35311cafb8";
            case 585L: return "bfti_3585c2985e";
            case 586L: return "bfti_359ab02841";
            case 587L: return "bfti_35b3447b04";
            case 588L: return "bfti_35c69b7855";
            case 589L: return "bfti_35d4f7e96f";
            case 590L: return "bfti_35f2899b52";
            case 591L: return "bfti_35ff8de1a8";
            case 592L: return "bfti_361617e5d8";
            case 593L: return "bfti_3629449bd9";
            case 594L: return "bfti_363dec7adf";
            case 595L: return "bfti_3657405da2";
            case 596L: return "bfti_36610ed3e3";
            case 597L: return "bfti_366b60a9ae";
            case 598L: return "bfti_36702b92bb";
            case 599L: return "bfti_3675b7642c";
            case 600L: return "bfti_36b39148b9";
            case 601L: return "bfti_36bd36f49e";
            case 602L: return "bfti_36c479a82b";
            case 603L: return "bfti_36dd12046d";
            case 604L: return "bfti_36fc5336c4";
            case 605L: return "bfti_374a046371";
            case 606L: return "bfti_37501c21c3";
            case 607L: return "bfti_3771c33244";
            case 608L: return "bfti_377eab1137";
            case 609L: return "bfti_3798b2fc0c";
            case 610L: return "bfti_37a2b8453b";
            case 611L: return "bfti_37a5b54e02";
            case 612L: return "bfti_37b2dee55d";
            case 613L: return "bfti_37b61f5386";
            case 614L: return "bfti_37d8ed8ff2";
            case 615L: return "bfti_37f3160927";
            case 616L: return "bfti_3823efa837";
            case 617L: return "bfti_387cc159a8";
            case 618L: return "bfti_388523c7c7";
            case 619L: return "bfti_388c1c59ae";
            case 620L: return "bfti_388c979dc2";
            case 621L: return "bfti_38f0e7ad6f";
            case 622L: return "bfti_3900d90676";
            case 623L: return "bfti_39316066a6";
            case 624L: return "bfti_394783bd51";
            case 625L: return "bfti_39516bd715";
            case 626L: return "bfti_395554f443";
            case 627L: return "bfti_3981d04884";
            case 628L: return "bfti_398d10a7b2";
            case 629L: return "bfti_3991fc513c";
            case 630L: return "bfti_39a479a8b9";
            case 631L: return "bfti_39b13e8b07";
            case 632L: return "bfti_39d283f70e";
            case 633L: return "bfti_39de673ebd";
            case 634L: return "bfti_39e4ecdfd9";
            case 635L: return "bfti_3a09309298";
            case 636L: return "bfti_3a36ec7a93";
            case 637L: return "bfti_3a4518ce54";
            case 638L: return "bfti_3a5388b465";
            case 639L: return "bfti_3aa20e919e";
            case 640L: return "bfti_3aac1a6863";
            case 641L: return "bfti_3abb0346ea";
            case 642L: return "bfti_3acb137cf2";
            case 643L: return "bfti_3ae136b830";
            case 644L: return "bfti_3b25b06d5d";
            case 645L: return "bfti_3b98ccca7f";
            case 646L: return "bfti_3baf7d31d6";
            case 647L: return "bfti_3bb2299456";
            case 648L: return "bfti_3bddf33085";
            case 649L: return "bfti_3c1345f125";
            case 650L: return "bfti_3c147d7954";
            case 651L: return "bfti_3c3cba7786";
            case 652L: return "bfti_3c4777897f";
            case 653L: return "bfti_3c4c1fa4ab";
            case 654L: return "bfti_3c643bfab6";
            case 655L: return "bfti_3c73745a2e";
            case 656L: return "bfti_3c95dd4ddf";
            case 657L: return "bfti_3c9e99e75c";
            case 658L: return "bfti_3ca5ad7d5f";
            case 659L: return "bfti_3cc6c80751";
            case 660L: return "bfti_3ceee99c80";
            case 661L: return "bfti_3d1f71a790";
            case 662L: return "bfti_3d27d748e8";
            case 663L: return "bfti_3d2c4ee27d";
            case 664L: return "bfti_3d6b046bc9";
            case 665L: return "bfti_3d72e67a9e";
            case 666L: return "bfti_3d75148905";
            case 667L: return "bfti_3d94720c77";
            case 668L: return "bfti_3da02ae9e5";
            case 669L: return "bfti_3dcf5021c2";
            case 670L: return "bfti_3ddbc292a4";
            case 671L: return "bfti_3df37a15b3";
            case 672L: return "bfti_3e29362db1";
            case 673L: return "bfti_3e474d7770";
            case 674L: return "bfti_3e4e552e80";
            case 675L: return "bfti_3e4eecbe66";
            case 676L: return "bfti_3e5cc7cedf";
            case 677L: return "bfti_3e67bcdeb4";
            case 678L: return "bfti_3e71f41b7a";
            case 679L: return "bfti_3e8a243bf6";
            case 680L: return "bfti_3e8cd1e1d9";
            case 681L: return "bfti_3e8e103c62";
            case 682L: return "bfti_3e922cf548";
            case 683L: return "bfti_3e9282df2c";
            case 684L: return "bfti_3ea2f12fd2";
            case 685L: return "bfti_3eba34f35e";
            case 686L: return "bfti_3ec11acbdf";
            case 687L: return "bfti_3ed06857c3";
            case 688L: return "bfti_3eeb86a455";
            case 689L: return "bfti_3f072b1c89";
            case 690L: return "bfti_3f324d93cd";
            case 691L: return "bfti_3f3402878e";
            case 692L: return "bfti_3f3db6ce76";
            case 693L: return "bfti_3f50677318";
            case 694L: return "bfti_3f6b32d7bf";
            case 695L: return "bfti_3f8bcd7340";
            case 696L: return "bfti_3fc94965ed";
            case 697L: return "bfti_3febe103ee";
            case 698L: return "bfti_3fed034f7c";
            case 699L: return "bfti_3ff25f2d91";
            case 700L: return "bfti_3ff34ff33d";
            case 701L: return "bfti_3ffbfacfc3";
            case 702L: return "bfti_403582992a";
            case 703L: return "bfti_403da3b35d";
            case 704L: return "bfti_4040f84db6";
            case 705L: return "bfti_404e40353f";
            case 706L: return "bfti_40673eee8c";
            case 707L: return "bfti_406c4ea7b8";
            case 708L: return "bfti_408b5724d8";
            case 709L: return "bfti_40b7bd1bcb";
            case 710L: return "bfti_40bcc1f7d1";
            case 711L: return "bfti_40d6a07eb4";
            case 712L: return "bfti_40daf2c28c";
            case 713L: return "bfti_40f3baab83";
            case 714L: return "bfti_41081d5062";
            case 715L: return "bfti_412f071fcd";
            case 716L: return "bfti_41600a9f86";
            case 717L: return "bfti_41637b73d6";
            case 718L: return "bfti_417031a38a";
            case 719L: return "bfti_4170d01296";
            case 720L: return "bfti_417549c2e6";
            case 721L: return "bfti_417bedfde4";
            case 722L: return "bfti_41869691ac";
            case 723L: return "bfti_41b96e589f";
            case 724L: return "bfti_41c9a48555";
            case 725L: return "bfti_41d628ef36";
            case 726L: return "bfti_421fdb32b1";
            case 727L: return "bfti_422bb9b600";
            case 728L: return "bfti_422ef8d863";
            case 729L: return "bfti_423721d757";
            case 730L: return "bfti_426ef947ad";
            case 731L: return "bfti_427b820ade";
            case 732L: return "bfti_4284ce7dcf";
            case 733L: return "bfti_428e410b8a";
            case 734L: return "bfti_4295aa69ff";
            case 735L: return "bfti_42a2c403b7";
            case 736L: return "bfti_42bd796283";
            case 737L: return "bfti_42c834f38b";
            case 738L: return "bfti_42ebb46e51";
            case 739L: return "bfti_4307049193";
            case 740L: return "bfti_4352a2daf7";
            case 741L: return "bfti_4364615e0d";
            case 742L: return "bfti_436880ca74";
            case 743L: return "bfti_4373ab6d1b";
            case 744L: return "bfti_4373d64d40";
            case 745L: return "bfti_4378888800";
            case 746L: return "bfti_437ce74e1e";
            case 747L: return "bfti_43a0acf2a4";
            case 748L: return "bfti_43a1c4ddc8";
            case 749L: return "bfti_43d3b793d2";
            case 750L: return "bfti_43eb91e2d3";
            case 751L: return "bfti_43faf6d454";
            case 752L: return "bfti_4403f83dae";
            case 753L: return "bfti_44110a9e5d";
            case 754L: return "bfti_441d47c3d3";
            case 755L: return "bfti_4424efedb8";
            case 756L: return "bfti_442cf100a3";
            case 757L: return "bfti_444abf4183";
            case 758L: return "bfti_44596024fc";
            case 759L: return "bfti_44a2a2ae3b";
            case 760L: return "bfti_44dffe79e7";
            case 761L: return "bfti_44edf9602f";
            case 762L: return "bfti_450182a55c";
            case 763L: return "bfti_45400bfcdc";
            case 764L: return "bfti_455973f3f6";
            case 765L: return "bfti_45638abfb1";
            case 766L: return "bfti_456f951988";
            case 767L: return "bfti_457426a792";
            case 768L: return "bfti_4586e4f8c9";
            case 769L: return "bfti_458a3f0142";
            case 770L: return "bfti_45908ace6e";
            case 771L: return "bfti_45e1492dcb";
            case 772L: return "bfti_4602dc1244";
            case 773L: return "bfti_46102dcf72";
            case 774L: return "bfti_463c502e30";
            case 775L: return "bfti_4645fe6737";
            case 776L: return "bfti_46659d9534";
            case 777L: return "bfti_4682e1f02d";
            case 778L: return "bfti_46a5c99211";
            case 779L: return "bfti_46ae6ba4d6";
            case 780L: return "bfti_46d26eb3a8";
            case 781L: return "bfti_46d4fe894d";
            case 782L: return "bfti_470302a3c0";
            case 783L: return "bfti_470932a5ac";
            case 784L: return "bfti_474dc5fc8a";
            case 785L: return "bfti_4757a12fb1";
            case 786L: return "bfti_475fcf2c4e";
            case 787L: return "bfti_477d8c1396";
            case 788L: return "bfti_4785656737";
            case 789L: return "bfti_4799211e97";
            case 790L: return "bfti_47a8b5f3fd";
            case 791L: return "bfti_47b4b98ed7";
            case 792L: return "bfti_47b82ed471";
            case 793L: return "bfti_47bae7dc53";
            case 794L: return "bfti_47cb13d7a9";
            case 795L: return "bfti_47d1984159";
            case 796L: return "bfti_47d8bd8d7a";
            case 797L: return "bfti_4817eeff3a";
            case 798L: return "bfti_481ddf023c";
            case 799L: return "bfti_483b401f1f";
            case 800L: return "bfti_4876daa300";
            case 801L: return "bfti_4884d3475a";
            case 802L: return "bfti_48bd2a9674";
            case 803L: return "bfti_48c356215b";
            case 804L: return "bfti_48c3c00d6a";
            case 805L: return "bfti_48d4e9296d";
            case 806L: return "bfti_48d603f662";
            case 807L: return "bfti_48e2c1ddfe";
            case 808L: return "bfti_49000971f7";
            case 809L: return "bfti_4939bab4fa";
            case 810L: return "bfti_49660415ac";
            case 811L: return "bfti_4979c21dc3";
            case 812L: return "bfti_4984a6814f";
            case 813L: return "bfti_49b36b6014";
            case 814L: return "bfti_49c75cbafe";
            case 815L: return "bfti_49ccee4c1e";
            case 816L: return "bfti_49e90027eb";
            case 817L: return "bfti_49eb4a1432";
            case 818L: return "bfti_4a090a46a0";
            case 819L: return "bfti_4a6c6687cf";
            case 820L: return "bfti_4a78974318";
            case 821L: return "bfti_4a8732c1ae";
            case 822L: return "bfti_4aa69f6d86";
            case 823L: return "bfti_4ac6f38309";
            case 824L: return "bfti_4ad61914a0";
            case 825L: return "bfti_4ae3ac6470";
            case 826L: return "bfti_4af1ab3e8e";
            case 827L: return "bfti_4af6814e0f";
            case 828L: return "bfti_4afcabad8a";
            case 829L: return "bfti_4b04fb1d35";
            case 830L: return "bfti_4b4582c555";
            case 831L: return "bfti_4b633d9cbc";
            case 832L: return "bfti_4b6b1c29aa";
            case 833L: return "bfti_4b85220956";
            case 834L: return "bfti_4b8db75463";
            case 835L: return "bfti_4ba076afbb";
            case 836L: return "bfti_4bb5fd52bc";
            case 837L: return "bfti_4be58825fa";
            case 838L: return "bfti_4be9e502b0";
            case 839L: return "bfti_4bedc3b05c";
            case 840L: return "bfti_4bee96831e";
            case 841L: return "bfti_4c169845e4";
            case 842L: return "bfti_4c2151908d";
            case 843L: return "bfti_4c4cdcfa31";
            case 844L: return "bfti_4c5a390a21";
            case 845L: return "bfti_4c7a626b08";
            case 846L: return "bfti_4c9b8adf5c";
            case 847L: return "bfti_4ca51e68d1";
            case 848L: return "bfti_4cbe9cb39d";
            case 849L: return "bfti_4cdf7ff37f";
            case 850L: return "bfti_4d08dfc9ca";
            case 851L: return "bfti_4d1a3308cb";
            case 852L: return "bfti_4d23fb85a5";
            case 853L: return "bfti_4d35cc6e38";
            case 854L: return "bfti_4d6b0cf554";
            case 855L: return "bfti_4d7ec1b5b6";
            case 856L: return "bfti_4d84c521c9";
            case 857L: return "bfti_4d91193f49";
            case 858L: return "bfti_4da1bcf6df";
            case 859L: return "bfti_4dc7faec00";
            case 860L: return "bfti_4dce24c368";
            case 861L: return "bfti_4de463a752";
            case 862L: return "bfti_4df3447d7c";
            case 863L: return "bfti_4dfdcdd55d";
            case 864L: return "bfti_4e01e0dcb2";
            case 865L: return "bfti_4e2222416a";
            case 866L: return "bfti_4e253a0dca";
            case 867L: return "bfti_4e2738c91d";
            case 868L: return "bfti_4e2ba1cf4e";
            case 869L: return "bfti_4e2d025300";
            case 870L: return "bfti_4e30ed76e3";
            case 871L: return "bfti_4e514e8fcc";
            case 872L: return "bfti_4e53ff546b";
            case 873L: return "bfti_4e68df38f0";
            case 874L: return "bfti_4e77af121b";
            case 875L: return "bfti_4e81f85206";
            case 876L: return "bfti_4e8eddc10b";
            case 877L: return "bfti_4e98ee60b8";
            case 878L: return "bfti_4ebf1b6a81";
            case 879L: return "bfti_4ec12718cf";
            case 880L: return "bfti_4ee11c6a8b";
            case 881L: return "bfti_4ee908688c";
            case 882L: return "bfti_4ef071cab2";
            case 883L: return "bfti_4f06b662b7";
            case 884L: return "bfti_4f0dc3b304";
            case 885L: return "bfti_4f264094c7";
            case 886L: return "bfti_4f2b7708dc";
            case 887L: return "bfti_4f5ed5c11a";
            case 888L: return "bfti_4f6a73628d";
            case 889L: return "bfti_4f71abd9b9";
            case 890L: return "bfti_4f9da4f4e5";
            case 891L: return "bfti_4fa4e71e8a";
            case 892L: return "bfti_4faf560655";
            case 893L: return "bfti_4fc336fff2";
            case 894L: return "bfti_4fc9499d5e";
            case 895L: return "bfti_4ff92dc33a";
            case 896L: return "bfti_4ffa10350c";
            case 897L: return "bfti_5036c0f447";
            case 898L: return "bfti_5048e2c4b3";
            case 899L: return "bfti_507160dbeb";
            case 900L: return "bfti_507badf080";
            case 901L: return "bfti_5094540cbb";
            case 902L: return "bfti_50b00b97fa";
            case 903L: return "bfti_50bae3ce44";
            case 904L: return "bfti_50d43e3dd0";
            case 905L: return "bfti_50f7f6fb2a";
            case 906L: return "bfti_510b93e19a";
            case 907L: return "bfti_51473f9c3c";
            case 908L: return "bfti_5148cd2787";
            case 909L: return "bfti_5165552c19";
            case 910L: return "bfti_5188944c45";
            case 911L: return "bfti_51bd8e1f07";
            case 912L: return "bfti_51e5b050fa";
            case 913L: return "bfti_51e9c544e3";
            case 914L: return "bfti_51ea5a07b3";
            case 915L: return "bfti_520ed58b15";
            case 916L: return "bfti_522fd4b577";
            case 917L: return "bfti_5235b0a01d";
            case 918L: return "bfti_5236609f1c";
            case 919L: return "bfti_527044a525";
            case 920L: return "bfti_528031f1fe";
            case 921L: return "bfti_52ac882da1";
            case 922L: return "bfti_52ac889299";
            case 923L: return "bfti_52b23b5ded";
            case 924L: return "bfti_52b50b66c6";
            case 925L: return "bfti_52f04be5ae";
            case 926L: return "bfti_53209be2ab";
            case 927L: return "bfti_53464fcd8a";
            case 928L: return "bfti_5374aff85c";
            case 929L: return "bfti_53b024cffe";
            case 930L: return "bfti_53b033cc6e";
            case 931L: return "bfti_53b2719dff";
            case 932L: return "bfti_53c0e4f12e";
            case 933L: return "bfti_53e3eef58b";
            case 934L: return "bfti_54072d8762";
            case 935L: return "bfti_5412963e41";
            case 936L: return "bfti_54422d3191";
            case 937L: return "bfti_548c8f97c1";
            case 938L: return "bfti_5495a81987";
            case 939L: return "bfti_549c8f7452";
            case 940L: return "bfti_54ad3d7405";
            case 941L: return "bfti_54b0342cb8";
            case 942L: return "bfti_54b5e110d9";
            case 943L: return "bfti_54d55504de";
            case 944L: return "bfti_54d639c341";
            case 945L: return "bfti_54d7c0492d";
            case 946L: return "bfti_54ea68ef33";
            case 947L: return "bfti_54f008bbbd";
            case 948L: return "bfti_54fb04ae11";
            case 949L: return "bfti_5510dd39df";
            case 950L: return "bfti_5532f26055";
            case 951L: return "bfti_554d2db086";
            case 952L: return "bfti_555ee3ec16";
            case 953L: return "bfti_556b745490";
            case 954L: return "bfti_556ef063ed";
            case 955L: return "bfti_557f40c247";
            case 956L: return "bfti_55b9e35a19";
            case 957L: return "bfti_55d6ad988c";
            case 958L: return "bfti_55dc777bbe";
            case 959L: return "bfti_55dc7a75b6";
            case 960L: return "bfti_55e1d85c26";
            case 961L: return "bfti_55fa978734";
            case 962L: return "bfti_55ffe4d76e";
            case 963L: return "bfti_5600b89fd5";
            case 964L: return "bfti_563408a166";
            case 965L: return "bfti_56490b90b8";
            case 966L: return "bfti_5650a84842";
            case 967L: return "bfti_566717f9aa";
            case 968L: return "bfti_566eb6f210";
            case 969L: return "bfti_5672c56d58";
            case 970L: return "bfti_56744b8225";
            case 971L: return "bfti_568ba34659";
            case 972L: return "bfti_568d43212b";
            case 973L: return "bfti_569d8ea359";
            case 974L: return "bfti_56d7dbf543";
            case 975L: return "bfti_56da617834";
            case 976L: return "bfti_56dd756e86";
            case 977L: return "bfti_56e399212c";
            case 978L: return "bfti_56e56a7f2e";
            case 979L: return "bfti_56f84e68bd";
            case 980L: return "bfti_56ff68c99c";
            case 981L: return "bfti_57107191e6";
            case 982L: return "bfti_5717ed9692";
            case 983L: return "bfti_5752d33fef";
            case 984L: return "bfti_5756ce5be7";
            case 985L: return "bfti_576d87228e";
            case 986L: return "bfti_57bafbbe87";
            case 987L: return "bfti_57bd7a3571";
            case 988L: return "bfti_57d21eda0d";
            case 989L: return "bfti_57d7d6afe6";
            case 990L: return "bfti_57df6de23d";
            case 991L: return "bfti_57e5f58e89";
            case 992L: return "bfti_57f14f0812";
            case 993L: return "bfti_57f3db37f0";
            case 994L: return "bfti_5829a92b79";
            case 995L: return "bfti_5842e842ea";
            case 996L: return "bfti_585274d3be";
            case 997L: return "bfti_586ccf83d1";
            case 998L: return "bfti_5879796c42";
            case 999L: return "bfti_58851e798f";
            case 1000L: return "bfti_58b118f542";
            case 1001L: return "bfti_58bccfb62e";
            case 1002L: return "bfti_58be3ee29e";
            case 1003L: return "bfti_58c88381cb";
            case 1004L: return "bfti_58f5ed42b3";
            case 1005L: return "bfti_58faabcc80";
            case 1006L: return "bfti_58fb50007d";
            case 1007L: return "bfti_5917650572";
            case 1008L: return "bfti_5922d2768b";
            case 1009L: return "bfti_59848f7f99";
            case 1010L: return "bfti_59a0cbfcfc";
            case 1011L: return "bfti_59b0c6b3dc";
            case 1012L: return "bfti_59bf9475d1";
            case 1013L: return "bfti_59eef96f39";
            case 1014L: return "bfti_5a00c77bb3";
            case 1015L: return "bfti_5a09702542";
            case 1016L: return "bfti_5a1ee53b7e";
            case 1017L: return "bfti_5a2c468a36";
            case 1018L: return "bfti_5a367c62dd";
            case 1019L: return "bfti_5a663ff1fe";
            case 1020L: return "bfti_5a66a83110";
            case 1021L: return "bfti_5a8d417e14";
            case 1022L: return "bfti_5aa1785ada";
            case 1023L: return "bfti_5aaef128f8";
            case 1024L: return "bfti_5ab407de35";
            case 1025L: return "bfti_5ab415eb94";
            case 1026L: return "bfti_5ad8b960b0";
            case 1027L: return "bfti_5ae746feef";
            case 1028L: return "bfti_5b0aa6e33f";
            case 1029L: return "bfti_5b21732c7e";
            case 1030L: return "bfti_5b272ac382";
            case 1031L: return "bfti_5b43ee1d9f";
            case 1032L: return "bfti_5b54cb7b58";
            case 1033L: return "bfti_5b64f01311";
            case 1034L: return "bfti_5b6a01accc";
            case 1035L: return "bfti_5ba2717956";
            case 1036L: return "bfti_5bc5c3a22c";
            case 1037L: return "bfti_5bd162420f";
            case 1038L: return "bfti_5beab249b9";
            case 1039L: return "bfti_5bf1df01df";
            case 1040L: return "bfti_5bf4274a7e";
            case 1041L: return "bfti_5bfe209403";
            case 1042L: return "bfti_5c01e14cab";
            case 1043L: return "bfti_5c0ef2135b";
            case 1044L: return "bfti_5c1040cee4";
            case 1045L: return "bfti_5c33ef6594";
            case 1046L: return "bfti_5c3da66fbd";
            case 1047L: return "bfti_5c6c72ff3e";
            case 1048L: return "bfti_5ca9edbf8b";
            case 1049L: return "bfti_5cca26ddbf";
            case 1050L: return "bfti_5cef6f8de9";
            case 1051L: return "bfti_5cf86be1b2";
            case 1052L: return "bfti_5cfc3b5b4c";
            case 1053L: return "bfti_5d0ffbe003";
            case 1054L: return "bfti_5d56089899";
            case 1055L: return "bfti_5d65fd793c";
            case 1056L: return "bfti_5d701bf554";
            case 1057L: return "bfti_5d776c52eb";
            case 1058L: return "bfti_5daf90f8fb";
            case 1059L: return "bfti_5dca11e244";
            case 1060L: return "bfti_5dd2bf0fec";
            case 1061L: return "bfti_5de4bb3dcb";
            case 1062L: return "bfti_5dffeb6de1";
            case 1063L: return "bfti_5e1bd120c8";
            case 1064L: return "bfti_5e2d8648dc";
            case 1065L: return "bfti_5e32022ca0";
            case 1066L: return "bfti_5e4296a4bb";
            case 1067L: return "bfti_5e45be2598";
            case 1068L: return "bfti_5e935510ab";
            case 1069L: return "bfti_5ead6621d0";
            case 1070L: return "bfti_5ed293acf4";
            case 1071L: return "bfti_5ee8e11dc8";
            case 1072L: return "bfti_5efb6d310c";
            case 1073L: return "bfti_5f09e99a9b";
            case 1074L: return "bfti_5f28546ef8";
            case 1075L: return "bfti_5f2c578696";
            case 1076L: return "bfti_5f33e1ee3f";
            case 1077L: return "bfti_5f36a958b6";
            case 1078L: return "bfti_5f3ea06228";
            case 1079L: return "bfti_5f8e9bc1c7";
            case 1080L: return "bfti_6001b0602b";
            case 1081L: return "bfti_6004795e19";
            case 1082L: return "bfti_602d8b495f";
            case 1083L: return "bfti_60308b2432";
            case 1084L: return "bfti_608d22ceb1";
            case 1085L: return "bfti_60b6d6e300";
            case 1086L: return "bfti_60de612447";
            case 1087L: return "bfti_60e8754fa5";
            case 1088L: return "bfti_611000e820";
            case 1089L: return "bfti_6154b35a15";
            case 1090L: return "bfti_6156ef68e2";
            case 1091L: return "bfti_6174c38813";
            case 1092L: return "bfti_617a569928";
            case 1093L: return "bfti_6185d55604";
            case 1094L: return "bfti_61a3861bfb";
            case 1095L: return "bfti_61b0bb3150";
            case 1096L: return "bfti_61b7287efc";
            case 1097L: return "bfti_61cfa1935a";
            case 1098L: return "bfti_61fc71ca74";
            case 1099L: return "bfti_621eaae811";
            case 1100L: return "bfti_6220654784";
            case 1101L: return "bfti_6225c8441a";
            case 1102L: return "bfti_626589aa1e";
            case 1103L: return "bfti_62726d0377";
            case 1104L: return "bfti_62863fdc37";
            case 1105L: return "bfti_62895f6452";
            case 1106L: return "bfti_628aa1bb7b";
            case 1107L: return "bfti_62afdd195f";
            case 1108L: return "bfti_62bde0e3b2";
            case 1109L: return "bfti_62d06fcc44";
            case 1110L: return "bfti_62e6248dfb";
            case 1111L: return "bfti_62fbff47e9";
            case 1112L: return "bfti_6307f35cf6";
            case 1113L: return "bfti_630a94c7fc";
            case 1114L: return "bfti_6325990ecb";
            case 1115L: return "bfti_632ae2754f";
            case 1116L: return "bfti_63353c311d";
            case 1117L: return "bfti_634d3e2463";
            case 1118L: return "bfti_63bc224f4d";
            case 1119L: return "bfti_63f94d0014";
            case 1120L: return "bfti_63fa16e110";
            case 1121L: return "bfti_6400341218";
            case 1122L: return "bfti_6412de3a55";
            case 1123L: return "bfti_641e6931d5";
            case 1124L: return "bfti_642df1468c";
            case 1125L: return "bfti_64338b297c";
            case 1126L: return "bfti_643c64b54f";
            case 1127L: return "bfti_646f236585";
            case 1128L: return "bfti_647e07d40b";
            case 1129L: return "bfti_648bd8e36d";
            case 1130L: return "bfti_64e10c4b08";
            case 1131L: return "bfti_64eb464466";
            case 1132L: return "bfti_64f861b7ea";
            case 1133L: return "bfti_64f86da40e";
            case 1134L: return "bfti_65341e1028";
            case 1135L: return "bfti_65363641c1";
            case 1136L: return "bfti_65455c44b5";
            case 1137L: return "bfti_6585c33912";
            case 1138L: return "bfti_658ed20145";
            case 1139L: return "bfti_6596ba3751";
            case 1140L: return "bfti_659920f694";
            case 1141L: return "bfti_65b0f41f99";
            case 1142L: return "bfti_65cfa4cf9d";
            case 1143L: return "bfti_65d50e9b22";
            case 1144L: return "bfti_65dd9e9278";
            case 1145L: return "bfti_65e7364f54";
            case 1146L: return "bfti_664fdbbc45";
            case 1147L: return "bfti_66613df1fb";
            case 1148L: return "bfti_666d2df0db";
            case 1149L: return "bfti_666ecb44ba";
            case 1150L: return "bfti_667454597b";
            case 1151L: return "bfti_66b65cb961";
            case 1152L: return "bfti_66c1bdd41a";
            case 1153L: return "bfti_66dcd1ee08";
            case 1154L: return "bfti_66f75a06f7";
            case 1155L: return "bfti_670425f0a4";
            case 1156L: return "bfti_6711b35bde";
            case 1157L: return "bfti_671d9e8d01";
            case 1158L: return "bfti_6727816bea";
            case 1159L: return "bfti_672ad8cf38";
            case 1160L: return "bfti_673d711aa8";
            case 1161L: return "bfti_6751434510";
            case 1162L: return "bfti_676fa16616";
            case 1163L: return "bfti_678269df04";
            case 1164L: return "bfti_678499d39c";
            case 1165L: return "bfti_6788710305";
            case 1166L: return "bfti_6791cb787e";
            case 1167L: return "bfti_67b1e10145";
            case 1168L: return "bfti_67e57c88d9";
            case 1169L: return "bfti_67ffe7d88a";
            case 1170L: return "bfti_681676f263";
            case 1171L: return "bfti_6847aef2d0";
            case 1172L: return "bfti_684ca27f5e";
            case 1173L: return "bfti_6853828c1e";
            case 1174L: return "bfti_6882d463f1";
            case 1175L: return "bfti_68aa34da03";
            case 1176L: return "bfti_68b900647a";
            case 1177L: return "bfti_68bb1d6b9c";
            case 1178L: return "bfti_68c7ff3363";
            case 1179L: return "bfti_68dc77b428";
            case 1180L: return "bfti_68dcc8b04f";
            case 1181L: return "bfti_692bd1692d";
            case 1182L: return "bfti_695d50b9d9";
            case 1183L: return "bfti_696dfad892";
            case 1184L: return "bfti_698a84e6e3";
            case 1185L: return "bfti_6993792391";
            case 1186L: return "bfti_69cfccc059";
            case 1187L: return "bfti_69f1dc9a05";
            case 1188L: return "bfti_6a3273b3c5";
            case 1189L: return "bfti_6a5c596d54";
            case 1190L: return "bfti_6a5eb80f2e";
            case 1191L: return "bfti_6a6a898c31";
            case 1192L: return "bfti_6a7366d080";
            case 1193L: return "bfti_6a74f732b1";
            case 1194L: return "bfti_6a7c077641";
            case 1195L: return "bfti_6a8e1c26c8";
            case 1196L: return "bfti_6aa5608d1a";
            case 1197L: return "bfti_6ab0803ece";
            case 1198L: return "bfti_6ac6754936";
            case 1199L: return "bfti_6accf35747";
            case 1200L: return "bfti_6afe975f02";
            case 1201L: return "bfti_6b227023a4";
            case 1202L: return "bfti_6b294172ca";
            case 1203L: return "bfti_6b334bd7c4";
            case 1204L: return "bfti_6b3be7d373";
            case 1205L: return "bfti_6b411082d4";
            case 1206L: return "bfti_6b4412ad13";
            case 1207L: return "bfti_6b5a1ef617";
            case 1208L: return "bfti_6b6d3d4711";
            case 1209L: return "bfti_6b71de1a33";
            case 1210L: return "bfti_6b74b5863c";
            case 1211L: return "bfti_6b89e81494";
            case 1212L: return "bfti_6b93ac8b16";
            case 1213L: return "bfti_6bae6594b0";
            case 1214L: return "bfti_6bb0fe7a87";
            case 1215L: return "bfti_6bb3b86a9e";
            case 1216L: return "bfti_6bc51f00e4";
            case 1217L: return "bfti_6bc86b6d7f";
            case 1218L: return "bfti_6be124b729";
            case 1219L: return "bfti_6be1585ac8";
            case 1220L: return "bfti_6bfbdcf5df";
            case 1221L: return "bfti_6bfd735dc1";
            case 1222L: return "bfti_6c13141f62";
            case 1223L: return "bfti_6c1a352e13";
            case 1224L: return "bfti_6c4f7d12ab";
            case 1225L: return "bfti_6c5afbbc39";
            case 1226L: return "bfti_6c5bef80bd";
            case 1227L: return "bfti_6c6bfbb57b";
            case 1228L: return "bfti_6c6cd604ff";
            case 1229L: return "bfti_6c7c6ab40b";
            case 1230L: return "bfti_6c82d4260f";
            case 1231L: return "bfti_6c841bbabc";
            case 1232L: return "bfti_6c8af6322c";
            case 1233L: return "bfti_6ca238a1e9";
            case 1234L: return "bfti_6cd43f7c21";
            case 1235L: return "bfti_6cfbd87d48";
            case 1236L: return "bfti_6d4fd0355b";
            case 1237L: return "bfti_6d61ba0933";
            case 1238L: return "bfti_6d66796070";
            case 1239L: return "bfti_6d75f3ee99";
            case 1240L: return "bfti_6db9a8442d";
            case 1241L: return "bfti_6dbb58adf2";
            case 1242L: return "bfti_6e08b3c5a7";
            case 1243L: return "bfti_6e0bcf23e9";
            case 1244L: return "bfti_6e10f1bcd7";
            case 1245L: return "bfti_6e17abbfa0";
            case 1246L: return "bfti_6e1bcd41da";
            case 1247L: return "bfti_6e3fa6b510";
            case 1248L: return "bfti_6e48ee4c63";
            case 1249L: return "bfti_6e5d48e096";
            case 1250L: return "bfti_6e646ba9d4";
            case 1251L: return "bfti_6e680051dd";
            case 1252L: return "bfti_6e988b32e4";
            case 1253L: return "bfti_6e99696f59";
            case 1254L: return "bfti_6e9e02c373";
            case 1255L: return "bfti_6edf78bf06";
            case 1256L: return "bfti_6ef714b581";
            case 1257L: return "bfti_6ef7356bd2";
            case 1258L: return "bfti_6f1d85b9e5";
            case 1259L: return "bfti_6f21be9e55";
            case 1260L: return "bfti_6f31963edd";
            case 1261L: return "bfti_6f3e0dfa3d";
            case 1262L: return "bfti_6f49a728e3";
            case 1263L: return "bfti_6f5a002bb2";
            case 1264L: return "bfti_6f6855a2cb";
            case 1265L: return "bfti_6f99823a66";
            case 1266L: return "bfti_6fc057ff31";
            case 1267L: return "bfti_6fd2dd172c";
            case 1268L: return "bfti_6fd7c1cd44";
            case 1269L: return "bfti_6ffe6b7c8f";
            case 1270L: return "bfti_7023b8e0ec";
            case 1271L: return "bfti_702597fbdd";
            case 1272L: return "bfti_702d78eb89";
            case 1273L: return "bfti_7072b04016";
            case 1274L: return "bfti_707f245cdc";
            case 1275L: return "bfti_7089767499";
            case 1276L: return "bfti_7090ed7c7c";
            case 1277L: return "bfti_70920f81b3";
            case 1278L: return "bfti_70a70c9e90";
            case 1279L: return "bfti_70afc720aa";
            case 1280L: return "bfti_70b79f07b2";
            case 1281L: return "bfti_70dfa4e2e5";
            case 1282L: return "bfti_70e1c53177";
            case 1283L: return "bfti_70e3bbe604";
            case 1284L: return "bfti_70f8d53332";
            case 1285L: return "bfti_712aa8ad81";
            case 1286L: return "bfti_715714a07c";
            case 1287L: return "bfti_717a714881";
            case 1288L: return "bfti_717c9d662e";
            case 1289L: return "bfti_7181266eeb";
            case 1290L: return "bfti_71a5a931e6";
            case 1291L: return "bfti_71a5e60126";
            case 1292L: return "bfti_71f1d7aaba";
            case 1293L: return "bfti_71fbe24941";
            case 1294L: return "bfti_721164f9da";
            case 1295L: return "bfti_7230e03d5c";
            case 1296L: return "bfti_7236860958";
            case 1297L: return "bfti_7245bc68e3";
            case 1298L: return "bfti_725a9a695a";
            case 1299L: return "bfti_7266fdc43b";
            case 1300L: return "bfti_728b46bce7";
            case 1301L: return "bfti_729206740d";
            case 1302L: return "bfti_72bdc4b521";
            case 1303L: return "bfti_72ca2bee94";
            case 1304L: return "bfti_72d204903a";
            case 1305L: return "bfti_72d3fcf28b";
            case 1306L: return "bfti_73062210d5";
            case 1307L: return "bfti_732c687617";
            case 1308L: return "bfti_735b9bce52";
            case 1309L: return "bfti_7372bd6505";
            case 1310L: return "bfti_73c071bc40";
            case 1311L: return "bfti_73e4f09d59";
            case 1312L: return "bfti_73e645533e";
            case 1313L: return "bfti_73eece56e8";
            case 1314L: return "bfti_73f984a044";
            case 1315L: return "bfti_73fb713f69";
            case 1316L: return "bfti_7411e2da0d";
            case 1317L: return "bfti_741946d37b";
            case 1318L: return "bfti_7422c7d7b7";
            case 1319L: return "bfti_743606e7f3";
            case 1320L: return "bfti_7439f6e74d";
            case 1321L: return "bfti_743ba986ab";
            case 1322L: return "bfti_74512b55a3";
            case 1323L: return "bfti_747ab28a91";
            case 1324L: return "bfti_747b19d04f";
            case 1325L: return "bfti_748a0901f7";
            case 1326L: return "bfti_748ea550d6";
            case 1327L: return "bfti_74adcc9c7a";
            case 1328L: return "bfti_74c6ba983f";
            case 1329L: return "bfti_74d45d7226";
            case 1330L: return "bfti_75032dae16";
            case 1331L: return "bfti_7527a7241e";
            case 1332L: return "bfti_753183cb90";
            case 1333L: return "bfti_75321455a2";
            case 1334L: return "bfti_75506a9fbd";
            case 1335L: return "bfti_7551897a7a";
            case 1336L: return "bfti_756b26544d";
            case 1337L: return "bfti_75714d6b13";
            case 1338L: return "bfti_757b6a50ea";
            case 1339L: return "bfti_758c664d2f";
            case 1340L: return "bfti_7596fe3896";
            case 1341L: return "bfti_759fc3ac3f";
            case 1342L: return "bfti_75a90d6bb2";
            case 1343L: return "bfti_75c7ddd248";
            case 1344L: return "bfti_75cbe8aace";
            case 1345L: return "bfti_761a592f26";
            case 1346L: return "bfti_762b03f892";
            case 1347L: return "bfti_765808e277";
            case 1348L: return "bfti_767a6c232a";
            case 1349L: return "bfti_767b523732";
            case 1350L: return "bfti_767df0e69f";
            case 1351L: return "bfti_768a23be16";
            case 1352L: return "bfti_76953745d1";
            case 1353L: return "bfti_76a574762b";
            case 1354L: return "bfti_76b90ffb57";
            case 1355L: return "bfti_76fb86b28b";
            case 1356L: return "bfti_770e3a912d";
            case 1357L: return "bfti_7716adb227";
            case 1358L: return "bfti_772d8be62a";
            case 1359L: return "bfti_7734c25e8d";
            case 1360L: return "bfti_773ad86447";
            case 1361L: return "bfti_7749d2b0f0";
            case 1362L: return "bfti_77821d8ecb";
            case 1363L: return "bfti_77978735fe";
            case 1364L: return "bfti_779f1ece73";
            case 1365L: return "bfti_77cbe5a02b";
            case 1366L: return "bfti_77e2032769";
            case 1367L: return "bfti_780217fc81";
            case 1368L: return "bfti_780aab42df";
            case 1369L: return "bfti_78415e51a4";
            case 1370L: return "bfti_78496e62ca";
            case 1371L: return "bfti_785186aee1";
            case 1372L: return "bfti_7869d6ad75";
            case 1373L: return "bfti_78885ab579";
            case 1374L: return "bfti_78947e7514";
            case 1375L: return "bfti_78a3349585";
            case 1376L: return "bfti_78c654566e";
            case 1377L: return "bfti_78d26dde9d";
            case 1378L: return "bfti_78dc022076";
            case 1379L: return "bfti_78eb0dec70";
            case 1380L: return "bfti_78f4bf7828";
            case 1381L: return "bfti_78faf1b713";
            case 1382L: return "bfti_790af77de7";
            case 1383L: return "bfti_791263ccb3";
            case 1384L: return "bfti_791c6b1993";
            case 1385L: return "bfti_792fc3e2af";
            case 1386L: return "bfti_79461406af";
            case 1387L: return "bfti_7957ac3dc7";
            case 1388L: return "bfti_796ae22273";
            case 1389L: return "bfti_799483b0b3";
            case 1390L: return "bfti_79b4878404";
            case 1391L: return "bfti_79bbf2c981";
            case 1392L: return "bfti_79bc89269f";
            case 1393L: return "bfti_79c80226a2";
            case 1394L: return "bfti_79c8f35835";
            case 1395L: return "bfti_79f56ee6aa";
            case 1396L: return "bfti_7a135cd2e3";
            case 1397L: return "bfti_7a1a8262b2";
            case 1398L: return "bfti_7a4875e18d";
            case 1399L: return "bfti_7a5bb6640d";
            case 1400L: return "bfti_7a5d479dc9";
            case 1401L: return "bfti_7a9a4016d3";
            case 1402L: return "bfti_7abcc47105";
            case 1403L: return "bfti_7adc19a344";
            case 1404L: return "bfti_7ae711cde9";
            case 1405L: return "bfti_7b077cb8e2";
            case 1406L: return "bfti_7b1302731d";
            case 1407L: return "bfti_7b1f73d02f";
            case 1408L: return "bfti_7b4593557f";
            case 1409L: return "bfti_7b7348433e";
            case 1410L: return "bfti_7b939ac3d7";
            case 1411L: return "bfti_7b9c6ee492";
            case 1412L: return "bfti_7bb7cbcbc4";
            case 1413L: return "bfti_7bcaaf9cdd";
            case 1414L: return "bfti_7c052fcc47";
            case 1415L: return "bfti_7c106b0ea5";
            case 1416L: return "bfti_7c12c4cc47";
            case 1417L: return "bfti_7c46a5e875";
            case 1418L: return "bfti_7c4b744606";
            case 1419L: return "bfti_7c54706b23";
            case 1420L: return "bfti_7c6a60942e";
            case 1421L: return "bfti_7c6c8d8ea8";
            case 1422L: return "bfti_7c7104a0ca";
            case 1423L: return "bfti_7c7aad3878";
            case 1424L: return "bfti_7c8fa948d7";
            case 1425L: return "bfti_7c970c1edf";
            case 1426L: return "bfti_7c9879911c";
            case 1427L: return "bfti_7ca53d1ebb";
            case 1428L: return "bfti_7cb6f8c99c";
            case 1429L: return "bfti_7cbec3735a";
            case 1430L: return "bfti_7cc8f91f16";
            case 1431L: return "bfti_7cd22b5acf";
            case 1432L: return "bfti_7ceaa3f156";
            case 1433L: return "bfti_7cf621f125";
            case 1434L: return "bfti_7d0aeab0d6";
            case 1435L: return "bfti_7d36b925a3";
            case 1436L: return "bfti_7d545a5ae9";
            case 1437L: return "bfti_7d6b5a3746";
            case 1438L: return "bfti_7d6ee203f1";
            case 1439L: return "bfti_7d8ab33925";
            case 1440L: return "bfti_7d953cd087";
            case 1441L: return "bfti_7dac1befb2";
            case 1442L: return "bfti_7dc2e5bc01";
            case 1443L: return "bfti_7de06301e8";
            case 1444L: return "bfti_7e0f00dc21";
            case 1445L: return "bfti_7e1cd19b4c";
            case 1446L: return "bfti_7e1d5d238c";
            case 1447L: return "bfti_7e3d1faa0c";
            case 1448L: return "bfti_7e41646a22";
            case 1449L: return "bfti_7e4cb54b4f";
            case 1450L: return "bfti_7e4d9d1016";
            case 1451L: return "bfti_7e4f601f20";
            case 1452L: return "bfti_7e6f5df02c";
            case 1453L: return "bfti_7e75c36d49";
            case 1454L: return "bfti_7e8c304830";
            case 1455L: return "bfti_7e8df83414";
            case 1456L: return "bfti_7ea365444c";
            case 1457L: return "bfti_7eb2a471ca";
            case 1458L: return "bfti_7ec86b1335";
            case 1459L: return "bfti_7ecebe0382";
            case 1460L: return "bfti_7edd8a020f";
            case 1461L: return "bfti_7ee31bbb80";
            case 1462L: return "bfti_7eefa0c57d";
            case 1463L: return "bfti_7ef2fcf593";
            case 1464L: return "bfti_7f0094cd11";
            case 1465L: return "bfti_7f16bee6b9";
            case 1466L: return "bfti_7f1eff7f58";
            case 1467L: return "bfti_7f35854a1a";
            case 1468L: return "bfti_7f4b55dad1";
            case 1469L: return "bfti_7f603a621e";
            case 1470L: return "bfti_7f815df06a";
            case 1471L: return "bfti_7f99260594";
            case 1472L: return "bfti_7f9a0d779d";
            case 1473L: return "bfti_7fa1a35ff2";
            case 1474L: return "bfti_7fa56021a9";
            case 1475L: return "bfti_7fa9c09285";
            case 1476L: return "bfti_7fb63dbc16";
            case 1477L: return "bfti_7fc1d03eb9";
            case 1478L: return "bfti_7fcaa7083d";
            case 1479L: return "bfti_7fcc43d717";
            case 1480L: return "bfti_7fceb30d1f";
            case 1481L: return "bfti_7fdd38def1";
            case 1482L: return "bfti_7ff203e31d";
            case 1483L: return "bfti_7ffbec0d8d";
            case 1484L: return "bfti_80023cfe4a";
            case 1485L: return "bfti_800ec5a23b";
            case 1486L: return "bfti_802b38c238";
            case 1487L: return "bfti_802b59ea3f";
            case 1488L: return "bfti_802c9619fe";
            case 1489L: return "bfti_8090747d6d";
            case 1490L: return "bfti_80b3863bbe";
            case 1491L: return "bfti_80dbf677e8";
            case 1492L: return "bfti_814ef3bf53";
            case 1493L: return "bfti_8154db458a";
            case 1494L: return "bfti_8169f75e7c";
            case 1495L: return "bfti_817c32e01e";
            case 1496L: return "bfti_818b38abd3";
            case 1497L: return "bfti_818f007437";
            case 1498L: return "bfti_81acf5a82c";
            case 1499L: return "bfti_81f589ce33";
            case 1500L: return "bfti_81f67702c9";
            case 1501L: return "bfti_81faad84e6";
            case 1502L: return "bfti_8246563c0c";
            case 1503L: return "bfti_8257e0c20e";
            case 1504L: return "bfti_826de42190";
            case 1505L: return "bfti_8275570935";
            case 1506L: return "bfti_828c59ce75";
            case 1507L: return "bfti_829821141a";
            case 1508L: return "bfti_829f612161";
            case 1509L: return "bfti_82a6170b6e";
            case 1510L: return "bfti_83050ac835";
            case 1511L: return "bfti_830e60ab0f";
            case 1512L: return "bfti_832ad8fb99";
            case 1513L: return "bfti_8355bb71a3";
            case 1514L: return "bfti_8377428c99";
            case 1515L: return "bfti_838dd5feee";
            case 1516L: return "bfti_83a0321e57";
            case 1517L: return "bfti_83b8be0c44";
            case 1518L: return "bfti_83c835413e";
            case 1519L: return "bfti_83e28d4e33";
            case 1520L: return "bfti_83eb0a5d0b";
            case 1521L: return "bfti_83ee670f7d";
            case 1522L: return "bfti_83f8880f1a";
            case 1523L: return "bfti_83f948b132";
            case 1524L: return "bfti_84115dc2ba";
            case 1525L: return "bfti_84240b8163";
            case 1526L: return "bfti_842b316134";
            case 1527L: return "bfti_843090a24e";
            case 1528L: return "bfti_8440dda2ba";
            case 1529L: return "bfti_8442d8ed74";
            case 1530L: return "bfti_8449b8116e";
            case 1531L: return "bfti_844c407da5";
            case 1532L: return "bfti_846a362da5";
            case 1533L: return "bfti_8471ce24ab";
            case 1534L: return "bfti_84746f3a70";
            case 1535L: return "bfti_84852bb2c8";
            case 1536L: return "bfti_849d95b902";
            case 1537L: return "bfti_84a4681591";
            case 1538L: return "bfti_84dfe4b1d9";
            case 1539L: return "bfti_84fedfd13f";
            case 1540L: return "bfti_850e191f84";
            case 1541L: return "bfti_851d974afd";
            case 1542L: return "bfti_853d7986ec";
            case 1543L: return "bfti_85790e53b6";
            case 1544L: return "bfti_859bbb8cb6";
            case 1545L: return "bfti_85c244bcaf";
            case 1546L: return "bfti_85d37f9103";
            case 1547L: return "bfti_85d4bc1b19";
            case 1548L: return "bfti_85d66c3d91";
            case 1549L: return "bfti_85ff3417dc";
            case 1550L: return "bfti_8646e1151d";
            case 1551L: return "bfti_865a40b8c9";
            case 1552L: return "bfti_8665dae4ba";
            case 1553L: return "bfti_8672bb54e3";
            case 1554L: return "bfti_8676f92db7";
            case 1555L: return "bfti_867f565c91";
            case 1556L: return "bfti_8697257f79";
            case 1557L: return "bfti_86c357ebda";
            case 1558L: return "bfti_86cef64642";
            case 1559L: return "bfti_8707a39e7b";
            case 1560L: return "bfti_870c26909d";
            case 1561L: return "bfti_871f558281";
            case 1562L: return "bfti_87345842ab";
            case 1563L: return "bfti_878ed2ae74";
            case 1564L: return "bfti_879534b906";
            case 1565L: return "bfti_87980cec03";
            case 1566L: return "bfti_87b8f10e09";
            case 1567L: return "bfti_87c2ca69e1";
            case 1568L: return "bfti_87c60fa6b2";
            case 1569L: return "bfti_8802fe90eb";
            case 1570L: return "bfti_88065e0aa0";
            case 1571L: return "bfti_881e4c6c23";
            case 1572L: return "bfti_88293189c5";
            case 1573L: return "bfti_883242dce2";
            case 1574L: return "bfti_883f6adc56";
            case 1575L: return "bfti_88551720eb";
            case 1576L: return "bfti_8859e75d90";
            case 1577L: return "bfti_885fb44f96";
            case 1578L: return "bfti_8860dc6b8d";
            case 1579L: return "bfti_887704a522";
            case 1580L: return "bfti_888b2e1e88";
            case 1581L: return "bfti_888cefc610";
            case 1582L: return "bfti_888d66db7e";
            case 1583L: return "bfti_888d6a9e35";
            case 1584L: return "bfti_88b4a9e6de";
            case 1585L: return "bfti_88bbdd7354";
            case 1586L: return "bfti_8901e37e2d";
            case 1587L: return "bfti_8901e92b1e";
            case 1588L: return "bfti_893acb134f";
            case 1589L: return "bfti_8944855e7c";
            case 1590L: return "bfti_89555fb5aa";
            case 1591L: return "bfti_8962467c9c";
            case 1592L: return "bfti_89c63bd3e2";
            case 1593L: return "bfti_89cfe5ff4e";
            case 1594L: return "bfti_89dbfcdba9";
            case 1595L: return "bfti_89ebf08bd5";
            case 1596L: return "bfti_89f038cf77";
            case 1597L: return "bfti_8a0031cf7d";
            case 1598L: return "bfti_8a175f291c";
            case 1599L: return "bfti_8a1f027f51";
            case 1600L: return "bfti_8a263e5df0";
            case 1601L: return "bfti_8a2e144d0d";
            case 1602L: return "bfti_8a46514417";
            case 1603L: return "bfti_8a5ae09fc8";
            case 1604L: return "bfti_8a63515b1f";
            case 1605L: return "bfti_8a6bcb14b1";
            case 1606L: return "bfti_8a823f3f44";
            case 1607L: return "bfti_8a825b073d";
            case 1608L: return "bfti_8a8b91c6a3";
            case 1609L: return "bfti_8ab153fae0";
            case 1610L: return "bfti_8ab42c4d0a";
            case 1611L: return "bfti_8ac5e843d9";
            case 1612L: return "bfti_8ac61f4909";
            case 1613L: return "bfti_8ad0cfdc75";
            case 1614L: return "bfti_8ae608cb8a";
            case 1615L: return "bfti_8afdebfd34";
            case 1616L: return "bfti_8b22e205f9";
            case 1617L: return "bfti_8b2a3f8317";
            case 1618L: return "bfti_8b448fc92d";
            case 1619L: return "bfti_8b58045a11";
            case 1620L: return "bfti_8b5d19d4e6";
            case 1621L: return "bfti_8b7a5eac03";
            case 1622L: return "bfti_8b9abc1b83";
            case 1623L: return "bfti_8babb34e2d";
            case 1624L: return "bfti_8bba56991b";
            case 1625L: return "bfti_8bbe7c0b61";
            case 1626L: return "bfti_8c1316c7e1";
            case 1627L: return "bfti_8c200dfdab";
            case 1628L: return "bfti_8c3fccadfc";
            case 1629L: return "bfti_8c4e63baad";
            case 1630L: return "bfti_8c556d4310";
            case 1631L: return "bfti_8c75d580ec";
            case 1632L: return "bfti_8c814367d5";
            case 1633L: return "bfti_8c991fed4b";
            case 1634L: return "bfti_8c9cdd3ba6";
            case 1635L: return "bfti_8ca80b6f2c";
            case 1636L: return "bfti_8cacc881d1";
            case 1637L: return "bfti_8cc15f077a";
            case 1638L: return "bfti_8ce6b32c00";
            case 1639L: return "bfti_8ce82669a9";
            case 1640L: return "bfti_8cf03fbb56";
            case 1641L: return "bfti_8cfa5fc13f";
            case 1642L: return "bfti_8d2425844c";
            case 1643L: return "bfti_8d2996e4ff";
            case 1644L: return "bfti_8d3ea03ea6";
            case 1645L: return "bfti_8d58be22c0";
            case 1646L: return "bfti_8d74f225aa";
            case 1647L: return "bfti_8d7f261b94";
            case 1648L: return "bfti_8d8570ffbe";
            case 1649L: return "bfti_8d93cc8539";
            case 1650L: return "bfti_8db8e8846a";
            case 1651L: return "bfti_8dd523172d";
            case 1652L: return "bfti_8dd54a3602";
            case 1653L: return "bfti_8dd7a724c2";
            case 1654L: return "bfti_8dddf37754";
            case 1655L: return "bfti_8dfa7492c2";
            case 1656L: return "bfti_8e1750941a";
            case 1657L: return "bfti_8e6ff73718";
            case 1658L: return "bfti_8e761642d3";
            case 1659L: return "bfti_8e78caf0b8";
            case 1660L: return "bfti_8e85aa8c80";
            case 1661L: return "bfti_8e88135b65";
            case 1662L: return "bfti_8ea56efd1c";
            case 1663L: return "bfti_8eb2a5206b";
            case 1664L: return "bfti_8eccfdc9c5";
            case 1665L: return "bfti_8ed19acb4e";
            case 1666L: return "bfti_8ef094cc09";
            case 1667L: return "bfti_8ef399e737";
            case 1668L: return "bfti_8f049409cf";
            case 1669L: return "bfti_8f0948a99c";
            case 1670L: return "bfti_8f3119796d";
            case 1671L: return "bfti_8f91001cfe";
            case 1672L: return "bfti_8f93358894";
            case 1673L: return "bfti_8f98b359fc";
            case 1674L: return "bfti_8fa819c5e0";
            case 1675L: return "bfti_8fb2adc19f";
            case 1676L: return "bfti_8fb7b71f78";
            case 1677L: return "bfti_8fbd684992";
            case 1678L: return "bfti_8fc07089c1";
            case 1679L: return "bfti_8fca868f46";
            case 1680L: return "bfti_8fcd162684";
            case 1681L: return "bfti_8fd81c449b";
            case 1682L: return "bfti_8fedea9993";
            case 1683L: return "bfti_90287907ae";
            case 1684L: return "bfti_903f2e8e42";
            case 1685L: return "bfti_9082235c8a";
            case 1686L: return "bfti_908cc1b2c2";
            case 1687L: return "bfti_90a1b28862";
            case 1688L: return "bfti_90a77ae83b";
            case 1689L: return "bfti_90b4c59578";
            case 1690L: return "bfti_90b8b3556a";
            case 1691L: return "bfti_90c8fe242e";
            case 1692L: return "bfti_90cb165f50";
            case 1693L: return "bfti_90cd025cac";
            case 1694L: return "bfti_90e0db847d";
            case 1695L: return "bfti_90e0eed036";
            case 1696L: return "bfti_90e396f8f1";
            case 1697L: return "bfti_910bd70433";
            case 1698L: return "bfti_91472e1e75";
            case 1699L: return "bfti_914777912e";
            case 1700L: return "bfti_914f5877d3";
            case 1701L: return "bfti_9186a98e0e";
            case 1702L: return "bfti_918c5ae284";
            case 1703L: return "bfti_9191735c60";
            case 1704L: return "bfti_919b8d92fe";
            case 1705L: return "bfti_91f4c61dec";
            case 1706L: return "bfti_91fecf7a97";
            case 1707L: return "bfti_9212e386a9";
            case 1708L: return "bfti_9213386b58";
            case 1709L: return "bfti_9215b2afdc";
            case 1710L: return "bfti_922365f3e9";
            case 1711L: return "bfti_923cd52cf0";
            case 1712L: return "bfti_9268346067";
            case 1713L: return "bfti_92697c92f0";
            case 1714L: return "bfti_9276a479f5";
            case 1715L: return "bfti_928f76d224";
            case 1716L: return "bfti_9292dd5902";
            case 1717L: return "bfti_929367f132";
            case 1718L: return "bfti_929420f50d";
            case 1719L: return "bfti_92a8506d94";
            case 1720L: return "bfti_92b544b032";
            case 1721L: return "bfti_92e29c4ec3";
            case 1722L: return "bfti_92e8fb5cdf";
            case 1723L: return "bfti_92fac32ce7";
            case 1724L: return "bfti_92fca0e078";
            case 1725L: return "bfti_9314613908";
            case 1726L: return "bfti_9317465577";
            case 1727L: return "bfti_931d32cf99";
            case 1728L: return "bfti_932db00782";
            case 1729L: return "bfti_9335f317c0";
            case 1730L: return "bfti_934d603d27";
            case 1731L: return "bfti_9351bf8db3";
            case 1732L: return "bfti_93546e9764";
            case 1733L: return "bfti_93629b2c9a";
            case 1734L: return "bfti_936774a04e";
            case 1735L: return "bfti_936b43cd84";
            case 1736L: return "bfti_9372915e3b";
            case 1737L: return "bfti_937a6ee62b";
            case 1738L: return "bfti_937a8aa664";
            case 1739L: return "bfti_937d8cf101";
            case 1740L: return "bfti_937fd3f25a";
            case 1741L: return "bfti_93a94e7a42";
            case 1742L: return "bfti_93b45aaff5";
            case 1743L: return "bfti_93f79ea781";
            case 1744L: return "bfti_93f7b61038";
            case 1745L: return "bfti_9428db02d4";
            case 1746L: return "bfti_942d3ce4c1";
            case 1747L: return "bfti_9459b060b0";
            case 1748L: return "bfti_9463e91674";
            case 1749L: return "bfti_94736eba2b";
            case 1750L: return "bfti_947a975f94";
            case 1751L: return "bfti_94db325a8d";
            case 1752L: return "bfti_94df962df5";
            case 1753L: return "bfti_94e8231f3e";
            case 1754L: return "bfti_94f3b7f0c2";
            case 1755L: return "bfti_94fa74057d";
            case 1756L: return "bfti_94fb1315c4";
            case 1757L: return "bfti_94ff17b124";
            case 1758L: return "bfti_9506a185f5";
            case 1759L: return "bfti_95155f3818";
            case 1760L: return "bfti_951f637c83";
            case 1761L: return "bfti_951f89baa0";
            case 1762L: return "bfti_9524df024a";
            case 1763L: return "bfti_9527cc2b95";
            case 1764L: return "bfti_95509ca9f7";
            case 1765L: return "bfti_9553f2dee7";
            case 1766L: return "bfti_95625e988a";
            case 1767L: return "bfti_957e064fee";
            case 1768L: return "bfti_95841a910a";
            case 1769L: return "bfti_958d7936a2";
            case 1770L: return "bfti_95d7ebddb5";
            case 1771L: return "bfti_95dc1d54bc";
            case 1772L: return "bfti_95e007dd65";
            case 1773L: return "bfti_95f84f5bc4";
            case 1774L: return "bfti_95fd0159c9";
            case 1775L: return "bfti_9643dd1241";
            case 1776L: return "bfti_9645f5f25e";
            case 1777L: return "bfti_9646648c78";
            case 1778L: return "bfti_966e5ea019";
            case 1779L: return "bfti_9670cc57a6";
            case 1780L: return "bfti_96786b1422";
            case 1781L: return "bfti_969e915b3e";
            case 1782L: return "bfti_96a23b3f1c";
            case 1783L: return "bfti_96d278b868";
            case 1784L: return "bfti_96d86a9418";
            case 1785L: return "bfti_96e46b2a48";
            case 1786L: return "bfti_96e814a136";
            case 1787L: return "bfti_97157e1a99";
            case 1788L: return "bfti_9719c90f1e";
            case 1789L: return "bfti_97223697d6";
            case 1790L: return "bfti_9750598bf2";
            case 1791L: return "bfti_975e62d841";
            case 1792L: return "bfti_9771186bad";
            case 1793L: return "bfti_97782deb09";
            case 1794L: return "bfti_977f627e4e";
            case 1795L: return "bfti_9780112df8";
            case 1796L: return "bfti_978f35adff";
            case 1797L: return "bfti_979dce71ed";
            case 1798L: return "bfti_97a228aaf7";
            case 1799L: return "bfti_97a272029b";
            case 1800L: return "bfti_97a77dc9dc";
            case 1801L: return "bfti_97ac70d21f";
            case 1802L: return "bfti_97c6334ab2";
            case 1803L: return "bfti_97d060587d";
            case 1804L: return "bfti_97d092c547";
            case 1805L: return "bfti_97d423b41b";
            case 1806L: return "bfti_981612122f";
            case 1807L: return "bfti_9817260056";
            case 1808L: return "bfti_98190337db";
            case 1809L: return "bfti_9822fb0c67";
            case 1810L: return "bfti_98232855aa";
            case 1811L: return "bfti_9826748757";
            case 1812L: return "bfti_9845602035";
            case 1813L: return "bfti_985122aa14";
            case 1814L: return "bfti_9858c0595e";
            case 1815L: return "bfti_98697cd677";
            case 1816L: return "bfti_989a717567";
            case 1817L: return "bfti_98af3a9f55";
            case 1818L: return "bfti_98b2a2d1c7";
            case 1819L: return "bfti_98b7ebccb3";
            case 1820L: return "bfti_994c7236f2";
            case 1821L: return "bfti_995ea30375";
            case 1822L: return "bfti_996e402141";
            case 1823L: return "bfti_9997ef5e05";
            case 1824L: return "bfti_999a34e85a";
            case 1825L: return "bfti_999c842d08";
            case 1826L: return "bfti_99cb856a25";
            case 1827L: return "bfti_99d45a72e5";
            case 1828L: return "bfti_99d83c3201";
            case 1829L: return "bfti_99e529b269";
            case 1830L: return "bfti_99f544403d";
            case 1831L: return "bfti_9a14ae649e";
            case 1832L: return "bfti_9a25299429";
            case 1833L: return "bfti_9a2c6b0ab5";
            case 1834L: return "bfti_9a35c52eb0";
            case 1835L: return "bfti_9a3665e8ec";
            case 1836L: return "bfti_9a725a31bb";
            case 1837L: return "bfti_9ac2950c02";
            case 1838L: return "bfti_9ae1438f06";
            case 1839L: return "bfti_9af05014d7";
            case 1840L: return "bfti_9b027c8388";
            case 1841L: return "bfti_9b0ea52974";
            case 1842L: return "bfti_9b0fd11ad7";
            case 1843L: return "bfti_9b476090e0";
            case 1844L: return "bfti_9b554b353e";
            case 1845L: return "bfti_9b5b3864d7";
            case 1846L: return "bfti_9b5c8f0dd4";
            case 1847L: return "bfti_9b6c293511";
            case 1848L: return "bfti_9b6c9961ca";
            case 1849L: return "bfti_9ba01e673a";
            case 1850L: return "bfti_9ba69135a2";
            case 1851L: return "bfti_9bace442ee";
            case 1852L: return "bfti_9bb741341e";
            case 1853L: return "bfti_9bc66e54c6";
            case 1854L: return "bfti_9be1126281";
            case 1855L: return "bfti_9beaeb9f69";
            case 1856L: return "bfti_9c05874aa1";
            case 1857L: return "bfti_9c24c014fc";
            case 1858L: return "bfti_9c27f920d2";
            case 1859L: return "bfti_9c3dc1cb99";
            case 1860L: return "bfti_9c44510568";
            case 1861L: return "bfti_9c6a8df921";
            case 1862L: return "bfti_9c6bfc8e8c";
            case 1863L: return "bfti_9c8a784289";
            case 1864L: return "bfti_9c982f2035";
            case 1865L: return "bfti_9ca365f3f3";
            case 1866L: return "bfti_9ca6fdd901";
            case 1867L: return "bfti_9cb2fdb668";
            case 1868L: return "bfti_9cc87fba14";
            case 1869L: return "bfti_9cdb773d13";
            case 1870L: return "bfti_9ceab2593a";
            case 1871L: return "bfti_9d097d2653";
            case 1872L: return "bfti_9d09a2749e";
            case 1873L: return "bfti_9d172ca88f";
            case 1874L: return "bfti_9d4a25fd11";
            case 1875L: return "bfti_9d4f5d2000";
            case 1876L: return "bfti_9d5be4102b";
            case 1877L: return "bfti_9d5d8c7bd5";
            case 1878L: return "bfti_9d88dad950";
            case 1879L: return "bfti_9d9dfaa7e7";
            case 1880L: return "bfti_9db2980d40";
            case 1881L: return "bfti_9dcaca3832";
            case 1882L: return "bfti_9dd85b86b4";
            case 1883L: return "bfti_9de588181a";
            case 1884L: return "bfti_9de5f3219a";
            case 1885L: return "bfti_9e506ef4ce";
            case 1886L: return "bfti_9e68a45d49";
            case 1887L: return "bfti_9e8d557493";
            case 1888L: return "bfti_9ed912b678";
            case 1889L: return "bfti_9ed9764c12";
            case 1890L: return "bfti_9ee67e6238";
            case 1891L: return "bfti_9ee6bec364";
            case 1892L: return "bfti_9f066b0fd4";
            case 1893L: return "bfti_9f1be8ddbe";
            case 1894L: return "bfti_9f3b620db0";
            case 1895L: return "bfti_9f58365915";
            case 1896L: return "bfti_9f5e73aa28";
            case 1897L: return "bfti_9f781f2e39";
            case 1898L: return "bfti_9fa982c787";
            case 1899L: return "bfti_9fc29ba203";
            case 1900L: return "bfti_9fe0a505bd";
            case 1901L: return "bfti_9fe134b9ff";
            case 1902L: return "bfti_a06bf9107c";
            case 1903L: return "bfti_a087fe322e";
            case 1904L: return "bfti_a095ba66eb";
            case 1905L: return "bfti_a09b0703e5";
            case 1906L: return "bfti_a0ec6a4837";
            case 1907L: return "bfti_a114e3f6fd";
            case 1908L: return "bfti_a13b30e4f8";
            case 1909L: return "bfti_a18a45dfc7";
            case 1910L: return "bfti_a1b13a90e9";
            case 1911L: return "bfti_a1ce9b0d12";
            case 1912L: return "bfti_a22e651be8";
            case 1913L: return "bfti_a2340c9b69";
            case 1914L: return "bfti_a23caced50";
            case 1915L: return "bfti_a24109854b";
            case 1916L: return "bfti_a249b963d9";
            case 1917L: return "bfti_a25a9ce7b0";
            case 1918L: return "bfti_a2a588eb56";
            case 1919L: return "bfti_a2af9dda47";
            case 1920L: return "bfti_a2db2f77d6";
            case 1921L: return "bfti_a2dee1851d";
            case 1922L: return "bfti_a2dfb3b7f2";
            case 1923L: return "bfti_a301630ae9";
            case 1924L: return "bfti_a303677d17";
            case 1925L: return "bfti_a31a0bfab6";
            case 1926L: return "bfti_a320b5ba15";
            case 1927L: return "bfti_a3326a87e2";
            case 1928L: return "bfti_a349db3324";
            case 1929L: return "bfti_a36c7a0074";
            case 1930L: return "bfti_a391348047";
            case 1931L: return "bfti_a3a53b51a9";
            case 1932L: return "bfti_a3eaf38220";
            case 1933L: return "bfti_a421c3755c";
            case 1934L: return "bfti_a4cc855666";
            case 1935L: return "bfti_a4d8f4fbce";
            case 1936L: return "bfti_a4e2625b44";
            case 1937L: return "bfti_a4e443f89a";
            case 1938L: return "bfti_a5027bba35";
            case 1939L: return "bfti_a50500fb68";
            case 1940L: return "bfti_a50c6981f1";
            case 1941L: return "bfti_a513da5d94";
            case 1942L: return "bfti_a523e1b056";
            case 1943L: return "bfti_a5614a5e34";
            case 1944L: return "bfti_a564a35e91";
            case 1945L: return "bfti_a570067b11";
            case 1946L: return "bfti_a576213dc5";
            case 1947L: return "bfti_a57cf152e5";
            case 1948L: return "bfti_a5e563f273";
            case 1949L: return "bfti_a60dd6abfc";
            case 1950L: return "bfti_a61495ffc3";
            case 1951L: return "bfti_a622b194a8";
            case 1952L: return "bfti_a6350825e4";
            case 1953L: return "bfti_a67d6a64e5";
            case 1954L: return "bfti_a68bee1010";
            case 1955L: return "bfti_a6a2e8bebd";
            case 1956L: return "bfti_a6bb7fd805";
            case 1957L: return "bfti_a6bc69ffdd";
            case 1958L: return "bfti_a6c9489aa5";
            case 1959L: return "bfti_a6d666c02a";
            case 1960L: return "bfti_a6dc9edac5";
            case 1961L: return "bfti_a6e9f1d2e8";
            case 1962L: return "bfti_a6f4a33394";
            case 1963L: return "bfti_a7000984b7";
            case 1964L: return "bfti_a713a6426f";
            case 1965L: return "bfti_a72b5b08af";
            case 1966L: return "bfti_a73910d0f1";
            case 1967L: return "bfti_a74c7064c4";
            case 1968L: return "bfti_a76c74de6f";
            case 1969L: return "bfti_a77f6f6a8d";
            case 1970L: return "bfti_a7b4b49d20";
            case 1971L: return "bfti_a7b9a561a6";
            case 1972L: return "bfti_a7e1873b50";
            case 1973L: return "bfti_a7e1f8822b";
            case 1974L: return "bfti_a7e6c7f882";
            case 1975L: return "bfti_a80d60191c";
            case 1976L: return "bfti_a831c26b99";
            case 1977L: return "bfti_a832f7f2ab";
            case 1978L: return "bfti_a8839e3e10";
            case 1979L: return "bfti_a8bf2e34cf";
            case 1980L: return "bfti_a8dbd2813a";
            case 1981L: return "bfti_a8dca33c0e";
            case 1982L: return "bfti_a916af4bf3";
            case 1983L: return "bfti_a931c261ce";
            case 1984L: return "bfti_a94a4521ff";
            case 1985L: return "bfti_a964a28eaf";
            case 1986L: return "bfti_a973125eab";
            case 1987L: return "bfti_a97df6728c";
            case 1988L: return "bfti_a98b196786";
            case 1989L: return "bfti_a99c03f5e2";
            case 1990L: return "bfti_a9ac3d2f90";
            case 1991L: return "bfti_a9ac565719";
            case 1992L: return "bfti_a9bbdd2f2a";
            case 1993L: return "bfti_a9dc9f480f";
            case 1994L: return "bfti_aa0ecd0181";
            case 1995L: return "bfti_aa1551ff72";
            case 1996L: return "bfti_aa250a4d86";
            case 1997L: return "bfti_aa4fe955ad";
            case 1998L: return "bfti_aa5c57371b";
            case 1999L: return "bfti_aa71e26b43";
            case 2000L: return "bfti_aa8f324063";
            case 2001L: return "bfti_aa9b69b48f";
            case 2002L: return "bfti_aa9c8f3492";
            case 2003L: return "bfti_aabc219878";
            case 2004L: return "bfti_aae661aa9e";
            case 2005L: return "bfti_aaf10250c1";
            case 2006L: return "bfti_ab0e69c6fe";
            case 2007L: return "bfti_ab2b023c48";
            case 2008L: return "bfti_ab83421b46";
            case 2009L: return "bfti_ab8f77493f";
            case 2010L: return "bfti_ababf8a4d4";
            case 2011L: return "bfti_abcb9a4eba";
            case 2012L: return "bfti_abd707cfe7";
            case 2013L: return "bfti_abe3ec3b0e";
            case 2014L: return "bfti_abf8a281a5";
            case 2015L: return "bfti_ac32ae5925";
            case 2016L: return "bfti_ac5a891877";
            case 2017L: return "bfti_ac611a7665";
            case 2018L: return "bfti_ac65215cf6";
            case 2019L: return "bfti_ac8458a5b9";
            case 2020L: return "bfti_ac8621d692";
            case 2021L: return "bfti_ac9ee299f0";
            case 2022L: return "bfti_acb4ad318c";
            case 2023L: return "bfti_acbad091a4";
            case 2024L: return "bfti_ad14f6e8d1";
            case 2025L: return "bfti_ad225dea50";
            case 2026L: return "bfti_ad7c16d446";
            case 2027L: return "bfti_ad7cb7d315";
            case 2028L: return "bfti_ad91e997c5";
            case 2029L: return "bfti_ada3f8b024";
            case 2030L: return "bfti_ada8ed44d5";
            case 2031L: return "bfti_adb78c3c8c";
            case 2032L: return "bfti_add6c40a2d";
            case 2033L: return "bfti_ae43d05fec";
            case 2034L: return "bfti_ae50b85cee";
            case 2035L: return "bfti_ae756ed007";
            case 2036L: return "bfti_ae81de53d6";
            case 2037L: return "bfti_ae9107da3a";
            case 2038L: return "bfti_ae979e7184";
            case 2039L: return "bfti_aea98fb72f";
            case 2040L: return "bfti_aeb6b2560f";
            case 2041L: return "bfti_aeefc643d4";
            case 2042L: return "bfti_aef717b197";
            case 2043L: return "bfti_af1960020c";
            case 2044L: return "bfti_af37b6bc8e";
            case 2045L: return "bfti_af6827f9a7";
            case 2046L: return "bfti_af7762bd8f";
            case 2047L: return "bfti_af8c728dea";
            case 2048L: return "bfti_af8f05590f";
            case 2049L: return "bfti_afb77f928f";
            case 2050L: return "bfti_afb846b145";
            case 2051L: return "bfti_afbfbd170c";
            case 2052L: return "bfti_affd719774";
            case 2053L: return "bfti_b01314301e";
            case 2054L: return "bfti_b03b6e32d8";
            case 2055L: return "bfti_b03da5d6ea";
            case 2056L: return "bfti_b05181a71b";
            case 2057L: return "bfti_b052bf6f17";
            case 2058L: return "bfti_b05d3152a5";
            case 2059L: return "bfti_b09c63b4e1";
            case 2060L: return "bfti_b0a32ea7f6";
            case 2061L: return "bfti_b0a5707e4b";
            case 2062L: return "bfti_b100a3b395";
            case 2063L: return "bfti_b10c2a0cf8";
            case 2064L: return "bfti_b121cb5651";
            case 2065L: return "bfti_b12b724257";
            case 2066L: return "bfti_b13ad3fc7f";
            case 2067L: return "bfti_b13ea8f07b";
            case 2068L: return "bfti_b147103a23";
            case 2069L: return "bfti_b16b545bf5";
            case 2070L: return "bfti_b172b9cdb7";
            case 2071L: return "bfti_b179c28184";
            case 2072L: return "bfti_b17ed5dcbb";
            case 2073L: return "bfti_b17f3f93d0";
            case 2074L: return "bfti_b18b6a8af7";
            case 2075L: return "bfti_b1a3240aac";
            case 2076L: return "bfti_b1a5f6b398";
            case 2077L: return "bfti_b1a8992f50";
            case 2078L: return "bfti_b1b2447001";
            case 2079L: return "bfti_b1b9be06e6";
            case 2080L: return "bfti_b1c1f02ee1";
            case 2081L: return "bfti_b1c8b657df";
            case 2082L: return "bfti_b1d92c4a5c";
            case 2083L: return "bfti_b23bd24559";
            case 2084L: return "bfti_b23c5f0658";
            case 2085L: return "bfti_b245f78b5a";
            case 2086L: return "bfti_b255bff837";
            case 2087L: return "bfti_b26f2b317e";
            case 2088L: return "bfti_b29f52b932";
            case 2089L: return "bfti_b2ba7aab3c";
            case 2090L: return "bfti_b2c6c7a8c0";
            case 2091L: return "bfti_b2ca075328";
            case 2092L: return "bfti_b2f5c19545";
            case 2093L: return "bfti_b318412877";
            case 2094L: return "bfti_b32020f057";
            case 2095L: return "bfti_b320aba05b";
            case 2096L: return "bfti_b33a26757f";
            case 2097L: return "bfti_b356bc9028";
            case 2098L: return "bfti_b37707aa3f";
            case 2099L: return "bfti_b3c1c9347a";
            case 2100L: return "bfti_b4112262cc";
            case 2101L: return "bfti_b412716bc2";
            case 2102L: return "bfti_b4315995ad";
            case 2103L: return "bfti_b47257c93f";
            case 2104L: return "bfti_b48192f5d3";
            case 2105L: return "bfti_b4984ec0ef";
            case 2106L: return "bfti_b4a1d31f2e";
            case 2107L: return "bfti_b4a3100cbc";
            case 2108L: return "bfti_b4a3e2be21";
            case 2109L: return "bfti_b4ac1fafe1";
            case 2110L: return "bfti_b4c5441a31";
            case 2111L: return "bfti_b4e586f7fc";
            case 2112L: return "bfti_b4ee5ccba2";
            case 2113L: return "bfti_b4f69ec6b7";
            case 2114L: return "bfti_b50de25c37";
            case 2115L: return "bfti_b54abe79c8";
            case 2116L: return "bfti_b554c02ce2";
            case 2117L: return "bfti_b56bc815e5";
            case 2118L: return "bfti_b56f335e55";
            case 2119L: return "bfti_b591649efe";
            case 2120L: return "bfti_b5a2ee518b";
            case 2121L: return "bfti_b5a7112f46";
            case 2122L: return "bfti_b5af0d529f";
            case 2123L: return "bfti_b5c501764b";
            case 2124L: return "bfti_b5c8c0bbda";
            case 2125L: return "bfti_b5d02b5eb7";
            case 2126L: return "bfti_b5e7283042";
            case 2127L: return "bfti_b5ee15bd1a";
            case 2128L: return "bfti_b6245f4003";
            case 2129L: return "bfti_b63bbd445a";
            case 2130L: return "bfti_b64704e414";
            case 2131L: return "bfti_b65b741dea";
            case 2132L: return "bfti_b6634d205c";
            case 2133L: return "bfti_b6a2cf437b";
            case 2134L: return "bfti_b6e5c02d17";
            case 2135L: return "bfti_b6f5a0d7c1";
            case 2136L: return "bfti_b714be47eb";
            case 2137L: return "bfti_b76ab8c883";
            case 2138L: return "bfti_b78658f4e1";
            case 2139L: return "bfti_b79cb61f2e";
            case 2140L: return "bfti_b7aad2b6c5";
            case 2141L: return "bfti_b7bba6847c";
            case 2142L: return "bfti_b7df1437c7";
            case 2143L: return "bfti_b7e0638101";
            case 2144L: return "bfti_b7e40fe912";
            case 2145L: return "bfti_b7f83bff13";
            case 2146L: return "bfti_b7fa8d58f9";
            case 2147L: return "bfti_b809e5f64e";
            case 2148L: return "bfti_b819cd2277";
            case 2149L: return "bfti_b81ae9d571";
            case 2150L: return "bfti_b82389717b";
            case 2151L: return "bfti_b835f85e76";
            case 2152L: return "bfti_b83c52ca18";
            case 2153L: return "bfti_b8546d8341";
            case 2154L: return "bfti_b860bd6059";
            case 2155L: return "bfti_b861cd456c";
            case 2156L: return "bfti_b86b8ed237";
            case 2157L: return "bfti_b87a129aa0";
            case 2158L: return "bfti_b882e72e69";
            case 2159L: return "bfti_b8b65349d2";
            case 2160L: return "bfti_b8dec5f274";
            case 2161L: return "bfti_b8fb3c39ef";
            case 2162L: return "bfti_b90e8a9365";
            case 2163L: return "bfti_b91a7e7347";
            case 2164L: return "bfti_b921391022";
            case 2165L: return "bfti_b950d05de8";
            case 2166L: return "bfti_b9beb23acb";
            case 2167L: return "bfti_b9caf1ec14";
            case 2168L: return "bfti_b9f528dee4";
            case 2169L: return "bfti_b9fe771df3";
            case 2170L: return "bfti_ba0e3247a0";
            case 2171L: return "bfti_ba3e5d93bd";
            case 2172L: return "bfti_ba477bbdc0";
            case 2173L: return "bfti_ba4f0f6d28";
            case 2174L: return "bfti_baa2656971";
            case 2175L: return "bfti_baab380765";
            case 2176L: return "bfti_baed55dfbb";
            case 2177L: return "bfti_baf28ede80";
            case 2178L: return "bfti_baf3b2dfcf";
            case 2179L: return "bfti_baf82fd146";
            case 2180L: return "bfti_bb16e940b2";
            case 2181L: return "bfti_bb29e28c23";
            case 2182L: return "bfti_bb2e076aa5";
            case 2183L: return "bfti_bb315dbb21";
            case 2184L: return "bfti_bb351775e5";
            case 2185L: return "bfti_bb44225be0";
            case 2186L: return "bfti_bb487b2a53";
            case 2187L: return "bfti_bb523499cd";
            case 2188L: return "bfti_bb574affa7";
            case 2189L: return "bfti_bb5997c548";
            case 2190L: return "bfti_bb6ed2ce2e";
            case 2191L: return "bfti_bb7829c5b9";
            case 2192L: return "bfti_bbb987c096";
            case 2193L: return "bfti_bbc25e0dc2";
            case 2194L: return "bfti_bbc5d4c040";
            case 2195L: return "bfti_bbd4d841c4";
            case 2196L: return "bfti_bbe5e95ac5";
            case 2197L: return "bfti_bbf2ffcd1c";
            case 2198L: return "bfti_bbfb1332fc";
            case 2199L: return "bfti_bc0b7b8489";
            case 2200L: return "bfti_bc51497c04";
            case 2201L: return "bfti_bc5aa605e4";
            case 2202L: return "bfti_bc6274496d";
            case 2203L: return "bfti_bc8d46fb1a";
            case 2204L: return "bfti_bca2424fdb";
            case 2205L: return "bfti_bca4101e33";
            case 2206L: return "bfti_bcab3ce0f1";
            case 2207L: return "bfti_bcb2ad201a";
            case 2208L: return "bfti_bcb322c85e";
            case 2209L: return "bfti_bcb92d7395";
            case 2210L: return "bfti_bcc918d61c";
            case 2211L: return "bfti_bcd62b5e65";
            case 2212L: return "bfti_bcdc397f47";
            case 2213L: return "bfti_bcde0dedc5";
            case 2214L: return "bfti_bce767038d";
            case 2215L: return "bfti_bcfb9b3225";
            case 2216L: return "bfti_bd1558b62f";
            case 2217L: return "bfti_bd1d3d9c37";
            case 2218L: return "bfti_bd2356546c";
            case 2219L: return "bfti_bd2ab5c502";
            case 2220L: return "bfti_bd32056632";
            case 2221L: return "bfti_bd4ceb4932";
            case 2222L: return "bfti_bd621682b6";
            case 2223L: return "bfti_bd8c77ba6b";
            case 2224L: return "bfti_bd9819dc18";
            case 2225L: return "bfti_bdc1956832";
            case 2226L: return "bfti_bdcd8083e4";
            case 2227L: return "bfti_bdd2b92448";
            case 2228L: return "bfti_bdd81c65f2";
            case 2229L: return "bfti_bde022c46a";
            case 2230L: return "bfti_bdebe478f1";
            case 2231L: return "bfti_bdec379159";
            case 2232L: return "bfti_be596be481";
            case 2233L: return "bfti_be5b4fa6c2";
            case 2234L: return "bfti_be861bb9a5";
            case 2235L: return "bfti_be9f8a325d";
            case 2236L: return "bfti_bef0d3b28d";
            case 2237L: return "bfti_bf0d377f9d";
            case 2238L: return "bfti_bf1aa577a0";
            case 2239L: return "bfti_bf1ce0b344";
            case 2240L: return "bfti_bf4fd453ea";
            case 2241L: return "bfti_bf5d896392";
            case 2242L: return "bfti_bf7138da88";
            case 2243L: return "bfti_bf925784db";
            case 2244L: return "bfti_bf93e91c21";
            case 2245L: return "bfti_bfa8b8f089";
            case 2246L: return "bfti_bfd0306c9b";
            case 2247L: return "bfti_bfef6b4679";
            case 2248L: return "bfti_bffe5089a8";
            case 2249L: return "bfti_c00738ccbc";
            case 2250L: return "bfti_c046c3de04";
            case 2251L: return "bfti_c04fedad66";
            case 2252L: return "bfti_c06a217627";
            case 2253L: return "bfti_c07b55824b";
            case 2254L: return "bfti_c090b4da80";
            case 2255L: return "bfti_c0ad293ee9";
            case 2256L: return "bfti_c0b9a64723";
            case 2257L: return "bfti_c0bf68e2cd";
            case 2258L: return "bfti_c0ced6310a";
            case 2259L: return "bfti_c1462f7be1";
            case 2260L: return "bfti_c1a8628bd2";
            case 2261L: return "bfti_c1ad3876b0";
            case 2262L: return "bfti_c1bff6ca19";
            case 2263L: return "bfti_c1c10f6aa6";
            case 2264L: return "bfti_c1d6e8432a";
            case 2265L: return "bfti_c1efdbc200";
            case 2266L: return "bfti_c2009fd9ab";
            case 2267L: return "bfti_c223500f6d";
            case 2268L: return "bfti_c2340d1d37";
            case 2269L: return "bfti_c24e344492";
            case 2270L: return "bfti_c29041c36e";
            case 2271L: return "bfti_c2b80612d6";
            case 2272L: return "bfti_c2c14da164";
            case 2273L: return "bfti_c2e3d90748";
            case 2274L: return "bfti_c2e53f9658";
            case 2275L: return "bfti_c32fc88bd0";
            case 2276L: return "bfti_c33009e127";
            case 2277L: return "bfti_c338109c5f";
            case 2278L: return "bfti_c3392e25ed";
            case 2279L: return "bfti_c346bd1fcf";
            case 2280L: return "bfti_c374f16abb";
            case 2281L: return "bfti_c37512cb13";
            case 2282L: return "bfti_c38303da51";
            case 2283L: return "bfti_c39b9d298e";
            case 2284L: return "bfti_c3b5a8412b";
            case 2285L: return "bfti_c3b6b58f93";
            case 2286L: return "bfti_c3be8f26bf";
            case 2287L: return "bfti_c3d4ef9433";
            case 2288L: return "bfti_c3f0bd713a";
            case 2289L: return "bfti_c3f9222f82";
            case 2290L: return "bfti_c40c7a3275";
            case 2291L: return "bfti_c4268824f4";
            case 2292L: return "bfti_c4297fc795";
            case 2293L: return "bfti_c4405dc80c";
            case 2294L: return "bfti_c4504ef4c4";
            case 2295L: return "bfti_c4529931c7";
            case 2296L: return "bfti_c453e83cd1";
            case 2297L: return "bfti_c4683b629f";
            case 2298L: return "bfti_c486763381";
            case 2299L: return "bfti_c48aa2cb1f";
            case 2300L: return "bfti_c490887da3";
            case 2301L: return "bfti_c490eece28";
            case 2302L: return "bfti_c494c62ea0";
            case 2303L: return "bfti_c496889b3a";
            case 2304L: return "bfti_c49f1724b4";
            case 2305L: return "bfti_c4b6487e95";
            case 2306L: return "bfti_c4b9ba9800";
            case 2307L: return "bfti_c4de4e68f2";
            case 2308L: return "bfti_c4ebf1ddc4";
            case 2309L: return "bfti_c4f5fad99a";
            case 2310L: return "bfti_c4f7dcaba1";
            case 2311L: return "bfti_c532468eae";
            case 2312L: return "bfti_c54d9bc801";
            case 2313L: return "bfti_c55ce00b27";
            case 2314L: return "bfti_c56e0926eb";
            case 2315L: return "bfti_c58134e999";
            case 2316L: return "bfti_c5a45828bd";
            case 2317L: return "bfti_c5e144957a";
            case 2318L: return "bfti_c5e2c98b4b";
            case 2319L: return "bfti_c5e386daca";
            case 2320L: return "bfti_c5ed5c3921";
            case 2321L: return "bfti_c5f0e385df";
            case 2322L: return "bfti_c608d1e9fe";
            case 2323L: return "bfti_c63833fcf7";
            case 2324L: return "bfti_c640f31d68";
            case 2325L: return "bfti_c659e7568e";
            case 2326L: return "bfti_c689a0ffc4";
            case 2327L: return "bfti_c697583e6b";
            case 2328L: return "bfti_c6b60f984e";
            case 2329L: return "bfti_c6dd9b460c";
            case 2330L: return "bfti_c6ff840450";
            case 2331L: return "bfti_c7007499b2";
            case 2332L: return "bfti_c707207fe7";
            case 2333L: return "bfti_c738da4d9e";
            case 2334L: return "bfti_c75b1f89e7";
            case 2335L: return "bfti_c764c56728";
            case 2336L: return "bfti_c76a3e75e0";
            case 2337L: return "bfti_c777c8fad5";
            case 2338L: return "bfti_c7792ddeb7";
            case 2339L: return "bfti_c7989b2e00";
            case 2340L: return "bfti_c7ab251502";
            case 2341L: return "bfti_c7b0779a73";
            case 2342L: return "bfti_c7b517a1b1";
            case 2343L: return "bfti_c7b9951cea";
            case 2344L: return "bfti_c7c395da0f";
            case 2345L: return "bfti_c7df608793";
            case 2346L: return "bfti_c7fda86b96";
            case 2347L: return "bfti_c8136316b5";
            case 2348L: return "bfti_c8327ef2dd";
            case 2349L: return "bfti_c833811d37";
            case 2350L: return "bfti_c83455426e";
            case 2351L: return "bfti_c86aa80f14";
            case 2352L: return "bfti_c87589206d";
            case 2353L: return "bfti_c8846b59d3";
            case 2354L: return "bfti_c8a2ddf896";
            case 2355L: return "bfti_c8cfe57591";
            case 2356L: return "bfti_c8d8accf5f";
            case 2357L: return "bfti_c8ebf7c9dd";
            case 2358L: return "bfti_c8ecfe09e8";
            case 2359L: return "bfti_c9079f5330";
            case 2360L: return "bfti_c910cf5051";
            case 2361L: return "bfti_c922566151";
            case 2362L: return "bfti_c92453a0a7";
            case 2363L: return "bfti_c955cca201";
            case 2364L: return "bfti_c9630d09dc";
            case 2365L: return "bfti_c96c630c47";
            case 2366L: return "bfti_c96e076b7e";
            case 2367L: return "bfti_c97258b9ee";
            case 2368L: return "bfti_c979e19b7f";
            case 2369L: return "bfti_c98236df38";
            case 2370L: return "bfti_c9aac098a5";
            case 2371L: return "bfti_c9b1d07410";
            case 2372L: return "bfti_c9b4b2d405";
            case 2373L: return "bfti_c9d8d1fc87";
            case 2374L: return "bfti_ca1c9559d7";
            case 2375L: return "bfti_ca58a2a76f";
            case 2376L: return "bfti_ca6f7b483a";
            case 2377L: return "bfti_ca82943ec4";
            case 2378L: return "bfti_cae4f0d655";
            case 2379L: return "bfti_cb068188fe";
            case 2380L: return "bfti_cb08d9acdd";
            case 2381L: return "bfti_cb2e3c0d19";
            case 2382L: return "bfti_cb51215561";
            case 2383L: return "bfti_cb615dfef4";
            case 2384L: return "bfti_cb82911f50";
            case 2385L: return "bfti_cb9f72e7da";
            case 2386L: return "bfti_cba2107c00";
            case 2387L: return "bfti_cbc277c523";
            case 2388L: return "bfti_cbd3e996ec";
            case 2389L: return "bfti_cbd9894a96";
            case 2390L: return "bfti_cbe3c97219";
            case 2391L: return "bfti_cc0b0f1337";
            case 2392L: return "bfti_cc39c5e2ac";
            case 2393L: return "bfti_cc4c54e835";
            case 2394L: return "bfti_cc5fb7ed79";
            case 2395L: return "bfti_cc6260b2e9";
            case 2396L: return "bfti_cc6bc683af";
            case 2397L: return "bfti_cc98505991";
            case 2398L: return "bfti_ccaaf9af09";
            case 2399L: return "bfti_ccb370f3b2";
            case 2400L: return "bfti_ccc273dcf6";
            case 2401L: return "bfti_ccc9f01bb6";
            case 2402L: return "bfti_cce576adeb";
            case 2403L: return "bfti_ccf31a1797";
            case 2404L: return "bfti_cd430465f5";
            case 2405L: return "bfti_cd67dcc966";
            case 2406L: return "bfti_cd68c004c9";
            case 2407L: return "bfti_cd9d6e69ac";
            case 2408L: return "bfti_cdb3ae5237";
            case 2409L: return "bfti_cdb44d631c";
            case 2410L: return "bfti_cdb64f8594";
            case 2411L: return "bfti_cdc173fd55";
            case 2412L: return "bfti_cdd2355e00";
            case 2413L: return "bfti_cdfe41ac24";
            case 2414L: return "bfti_ce0804814a";
            case 2415L: return "bfti_ce1514baf2";
            case 2416L: return "bfti_ce27cb807f";
            case 2417L: return "bfti_ce30e7e6f6";
            case 2418L: return "bfti_ce6391ecda";
            case 2419L: return "bfti_ce64a83900";
            case 2420L: return "bfti_ceab1b8cd5";
            case 2421L: return "bfti_ceba7bd7ee";
            case 2422L: return "bfti_cec05a888a";
            case 2423L: return "bfti_cec0bfab0c";
            case 2424L: return "bfti_cec652711f";
            case 2425L: return "bfti_cec909ed39";
            case 2426L: return "bfti_ced0dc715b";
            case 2427L: return "bfti_cedc14d25c";
            case 2428L: return "bfti_cf1272f225";
            case 2429L: return "bfti_cf22057832";
            case 2430L: return "bfti_cf467abd62";
            case 2431L: return "bfti_cf5ff952f2";
            case 2432L: return "bfti_cf61138d5c";
            case 2433L: return "bfti_cf7938e882";
            case 2434L: return "bfti_cfa9d49722";
            case 2435L: return "bfti_cfd0be8b3c";
            case 2436L: return "bfti_cfd4683658";
            case 2437L: return "bfti_cfee8e1f3a";
            case 2438L: return "bfti_d01b2ed9f0";
            case 2439L: return "bfti_d03f5672de";
            case 2440L: return "bfti_d073fda265";
            case 2441L: return "bfti_d09216e200";
            case 2442L: return "bfti_d09a1e33d9";
            case 2443L: return "bfti_d09e01a8e5";
            case 2444L: return "bfti_d09e62a95e";
            case 2445L: return "bfti_d0d4814a40";
            case 2446L: return "bfti_d0f14e168d";
            case 2447L: return "bfti_d0fa8fe4ce";
            case 2448L: return "bfti_d0fdbdb40d";
            case 2449L: return "bfti_d0ff042992";
            case 2450L: return "bfti_d10aafd5a3";
            case 2451L: return "bfti_d10e6d91c1";
            case 2452L: return "bfti_d1539785fc";
            case 2453L: return "bfti_d155030d64";
            case 2454L: return "bfti_d156b6898a";
            case 2455L: return "bfti_d18b29ea35";
            case 2456L: return "bfti_d18f0cc527";
            case 2457L: return "bfti_d195fa1e38";
            case 2458L: return "bfti_d19686246a";
            case 2459L: return "bfti_d1bf93f85a";
            case 2460L: return "bfti_d206537496";
            case 2461L: return "bfti_d215731d67";
            case 2462L: return "bfti_d23b2a69b6";
            case 2463L: return "bfti_d2469ffa77";
            case 2464L: return "bfti_d25b677b38";
            case 2465L: return "bfti_d275e5d4e6";
            case 2466L: return "bfti_d28bcd8da9";
            case 2467L: return "bfti_d29eca8d67";
            case 2468L: return "bfti_d2b73518d2";
            case 2469L: return "bfti_d2b7e74eda";
            case 2470L: return "bfti_d2dec1838b";
            case 2471L: return "bfti_d2e074961c";
            case 2472L: return "bfti_d2e97c17cc";
            case 2473L: return "bfti_d2f9401152";
            case 2474L: return "bfti_d30110d3fb";
            case 2475L: return "bfti_d31456abaa";
            case 2476L: return "bfti_d35d7b8e13";
            case 2477L: return "bfti_d36b9a2182";
            case 2478L: return "bfti_d37c091506";
            case 2479L: return "bfti_d39659f2ab";
            case 2480L: return "bfti_d3c0217805";
            case 2481L: return "bfti_d3d6136347";
            case 2482L: return "bfti_d3e3c773d9";
            case 2483L: return "bfti_d3ea2c77cd";
            case 2484L: return "bfti_d3f623646c";
            case 2485L: return "bfti_d3ff668cbf";
            case 2486L: return "bfti_d408b1ef2e";
            case 2487L: return "bfti_d410ba086b";
            case 2488L: return "bfti_d41d549174";
            case 2489L: return "bfti_d45473f6de";
            case 2490L: return "bfti_d45eea814d";
            case 2491L: return "bfti_d494954117";
            case 2492L: return "bfti_d4a2038c67";
            case 2493L: return "bfti_d4a876c514";
            case 2494L: return "bfti_d4afbc5b3b";
            case 2495L: return "bfti_d4c9ce383a";
            case 2496L: return "bfti_d4dbbf6949";
            case 2497L: return "bfti_d4e8d2026f";
            case 2498L: return "bfti_d4ef95ae10";
            case 2499L: return "bfti_d4f6569585";
            case 2500L: return "bfti_d518665079";
            case 2501L: return "bfti_d51bcf4fe6";
            case 2502L: return "bfti_d5317f6a19";
            case 2503L: return "bfti_d54836d3d4";
            case 2504L: return "bfti_d573552715";
            case 2505L: return "bfti_d58e2de4dc";
            case 2506L: return "bfti_d58ee2f5ff";
            case 2507L: return "bfti_d59475e5a6";
            case 2508L: return "bfti_d5954c2bbd";
            case 2509L: return "bfti_d59de47a45";
            case 2510L: return "bfti_d5acd53784";
            case 2511L: return "bfti_d5e0afcb65";
            case 2512L: return "bfti_d5e4a911fd";
            case 2513L: return "bfti_d5e96f9474";
            case 2514L: return "bfti_d60608391d";
            case 2515L: return "bfti_d617cfd87c";
            case 2516L: return "bfti_d66dbb3d53";
            case 2517L: return "bfti_d688d49c70";
            case 2518L: return "bfti_d6cf059146";
            case 2519L: return "bfti_d6e5a130af";
            case 2520L: return "bfti_d6eaa3bded";
            case 2521L: return "bfti_d71edc2775";
            case 2522L: return "bfti_d764410123";
            case 2523L: return "bfti_d769be6c4b";
            case 2524L: return "bfti_d76a199920";
            case 2525L: return "bfti_d771daa69d";
            case 2526L: return "bfti_d7885d2b11";
            case 2527L: return "bfti_d7bc6f4522";
            case 2528L: return "bfti_d7f5582c63";
            case 2529L: return "bfti_d7f86f4474";
            case 2530L: return "bfti_d81d222b15";
            case 2531L: return "bfti_d82b92e658";
            case 2532L: return "bfti_d83fa8462e";
            case 2533L: return "bfti_d85b84eee8";
            case 2534L: return "bfti_d86859bfe2";
            case 2535L: return "bfti_d88f511064";
            case 2536L: return "bfti_d91239a169";
            case 2537L: return "bfti_d91cbf36fa";
            case 2538L: return "bfti_d9629cde9c";
            case 2539L: return "bfti_d981a6fe0b";
            case 2540L: return "bfti_d98fac9738";
            case 2541L: return "bfti_d98fda487c";
            case 2542L: return "bfti_d9a22ef3b7";
            case 2543L: return "bfti_d9af0bc253";
            case 2544L: return "bfti_da0c05bdea";
            case 2545L: return "bfti_da1b23ce08";
            case 2546L: return "bfti_da23cbda82";
            case 2547L: return "bfti_da2ae06c81";
            case 2548L: return "bfti_da479757b6";
            case 2549L: return "bfti_da509d69d8";
            case 2550L: return "bfti_da51c943f2";
            case 2551L: return "bfti_da6f63fa25";
            case 2552L: return "bfti_da7aeece0f";
            case 2553L: return "bfti_daa9a51b8f";
            case 2554L: return "bfti_dac269456c";
            case 2555L: return "bfti_dad5950f38";
            case 2556L: return "bfti_dafb9f78bc";
            case 2557L: return "bfti_db13c0f900";
            case 2558L: return "bfti_db1484c146";
            case 2559L: return "bfti_db1e578566";
            case 2560L: return "bfti_db27305150";
            case 2561L: return "bfti_db3e8bcf93";
            case 2562L: return "bfti_db4a4eba52";
            case 2563L: return "bfti_db523ae1e7";
            case 2564L: return "bfti_db6fa28728";
            case 2565L: return "bfti_db7b4183db";
            case 2566L: return "bfti_db81816ecd";
            case 2567L: return "bfti_db932471d7";
            case 2568L: return "bfti_dbac1e5ee4";
            case 2569L: return "bfti_dc01001a53";
            case 2570L: return "bfti_dc41587246";
            case 2571L: return "bfti_dc55d8e45c";
            case 2572L: return "bfti_dc59fded37";
            case 2573L: return "bfti_dcbf0c9924";
            case 2574L: return "bfti_dcda675c5e";
            case 2575L: return "bfti_dcea53887f";
            case 2576L: return "bfti_dcf6f1d6bf";
            case 2577L: return "bfti_dd0544598a";
            case 2578L: return "bfti_dd0edf0911";
            case 2579L: return "bfti_dd1dccfad5";
            case 2580L: return "bfti_dd28ae7c26";
            case 2581L: return "bfti_dd5c34f83a";
            case 2582L: return "bfti_dd925c690b";
            case 2583L: return "bfti_dda79210d5";
            case 2584L: return "bfti_ddaef1085b";
            case 2585L: return "bfti_ddbaa69943";
            case 2586L: return "bfti_dde2d2df2e";
            case 2587L: return "bfti_dde9c31aab";
            case 2588L: return "bfti_ddeaddad2a";
            case 2589L: return "bfti_ddeefbc544";
            case 2590L: return "bfti_de11980b8e";
            case 2591L: return "bfti_de121de5f9";
            case 2592L: return "bfti_de39384a90";
            case 2593L: return "bfti_de4ada85b6";
            case 2594L: return "bfti_de4bc29402";
            case 2595L: return "bfti_de7ba1a682";
            case 2596L: return "bfti_de826caa72";
            case 2597L: return "bfti_de8ba52df3";
            case 2598L: return "bfti_deb4a5042b";
            case 2599L: return "bfti_debe442f2e";
            case 2600L: return "bfti_dec1ea95c7";
            case 2601L: return "bfti_decc8423bf";
            case 2602L: return "bfti_decd0bd8c4";
            case 2603L: return "bfti_ded1e53cc0";
            case 2604L: return "bfti_dee8d7ed9e";
            case 2605L: return "bfti_def576084b";
            case 2606L: return "bfti_defb063cfb";
            case 2607L: return "bfti_df03cea8d8";
            case 2608L: return "bfti_df04730baf";
            case 2609L: return "bfti_df047ee4cb";
            case 2610L: return "bfti_df120f4412";
            case 2611L: return "bfti_df4d8f86e5";
            case 2612L: return "bfti_df502df456";
            case 2613L: return "bfti_df68fabc68";
            case 2614L: return "bfti_df6a583863";
            case 2615L: return "bfti_df7afde2a6";
            case 2616L: return "bfti_dfb5b095d4";
            case 2617L: return "bfti_dfba09f926";
            case 2618L: return "bfti_dfd5970a83";
            case 2619L: return "bfti_dfe7984531";
            case 2620L: return "bfti_dfffb43f8a";
            case 2621L: return "bfti_e0036e3da2";
            case 2622L: return "bfti_e02d34d7fe";
            case 2623L: return "bfti_e0376efc04";
            case 2624L: return "bfti_e04dbe1ed1";
            case 2625L: return "bfti_e0724b2ea7";
            case 2626L: return "bfti_e094af64d6";
            case 2627L: return "bfti_e0c6110752";
            case 2628L: return "bfti_e0d03ab848";
            case 2629L: return "bfti_e0db2a4a53";
            case 2630L: return "bfti_e0e377c1bd";
            case 2631L: return "bfti_e0f016d195";
            case 2632L: return "bfti_e10177b3df";
            case 2633L: return "bfti_e1066b5ec4";
            case 2634L: return "bfti_e11fbc319c";
            case 2635L: return "bfti_e150a4d6a7";
            case 2636L: return "bfti_e173c3bdad";
            case 2637L: return "bfti_e1b9eda92e";
            case 2638L: return "bfti_e1be22c277";
            case 2639L: return "bfti_e1c0492848";
            case 2640L: return "bfti_e1d2731998";
            case 2641L: return "bfti_e1e58145da";
            case 2642L: return "bfti_e1f0e8999f";
            case 2643L: return "bfti_e1fb5e1fe8";
            case 2644L: return "bfti_e21b2ece9e";
            case 2645L: return "bfti_e23bf60b57";
            case 2646L: return "bfti_e25287f555";
            case 2647L: return "bfti_e256fbb843";
            case 2648L: return "bfti_e263f16f9e";
            case 2649L: return "bfti_e27df2d830";
            case 2650L: return "bfti_e29e8c76f5";
            case 2651L: return "bfti_e2b1e35e94";
            case 2652L: return "bfti_e2b8528272";
            case 2653L: return "bfti_e2ba2f25f2";
            case 2654L: return "bfti_e2bf034f20";
            case 2655L: return "bfti_e2dcbe343e";
            case 2656L: return "bfti_e2dd9e2e56";
            case 2657L: return "bfti_e2e4d7865c";
            case 2658L: return "bfti_e307270b1f";
            case 2659L: return "bfti_e3075b9388";
            case 2660L: return "bfti_e326673aec";
            case 2661L: return "bfti_e330738694";
            case 2662L: return "bfti_e3394256ac";
            case 2663L: return "bfti_e3a2e4983e";
            case 2664L: return "bfti_e3ae10b090";
            case 2665L: return "bfti_e402efe3af";
            case 2666L: return "bfti_e41b3d135d";
            case 2667L: return "bfti_e42963e8e2";
            case 2668L: return "bfti_e44bf2bd1c";
            case 2669L: return "bfti_e46136fb52";
            case 2670L: return "bfti_e467e41671";
            case 2671L: return "bfti_e4c2962623";
            case 2672L: return "bfti_e4e20f172b";
            case 2673L: return "bfti_e4fc7a1cc8";
            case 2674L: return "bfti_e51a9102f6";
            case 2675L: return "bfti_e51e3a2fcb";
            case 2676L: return "bfti_e522dade13";
            case 2677L: return "bfti_e53440bad4";
            case 2678L: return "bfti_e53c9ad5af";
            case 2679L: return "bfti_e5d921181f";
            case 2680L: return "bfti_e6103617cb";
            case 2681L: return "bfti_e62982b650";
            case 2682L: return "bfti_e6470ea292";
            case 2683L: return "bfti_e658c32910";
            case 2684L: return "bfti_e66eedb580";
            case 2685L: return "bfti_e67424b084";
            case 2686L: return "bfti_e68a5c2caf";
            case 2687L: return "bfti_e69d6edd95";
            case 2688L: return "bfti_e6c6ba8e25";
            case 2689L: return "bfti_e6dae0b968";
            case 2690L: return "bfti_e6df4483d3";
            case 2691L: return "bfti_e6df7e3040";
            case 2692L: return "bfti_e7110292a4";
            case 2693L: return "bfti_e7223491ae";
            case 2694L: return "bfti_e72b870587";
            case 2695L: return "bfti_e72d0bc0dd";
            case 2696L: return "bfti_e7498b0c2a";
            case 2697L: return "bfti_e784cbea37";
            case 2698L: return "bfti_e791e571c0";
            case 2699L: return "bfti_e7a095423e";
            case 2700L: return "bfti_e7bf8df06e";
            case 2701L: return "bfti_e7ea306c2e";
            case 2702L: return "bfti_e80fc1d2a3";
            case 2703L: return "bfti_e81ba5a612";
            case 2704L: return "bfti_e81f140e1a";
            case 2705L: return "bfti_e82e20a540";
            case 2706L: return "bfti_e8320ce01e";
            case 2707L: return "bfti_e8341b76ec";
            case 2708L: return "bfti_e8378314e4";
            case 2709L: return "bfti_e8395d327b";
            case 2710L: return "bfti_e8531a1bd8";
            case 2711L: return "bfti_e86032bd75";
            case 2712L: return "bfti_e86f5fc5bc";
            case 2713L: return "bfti_e888b40562";
            case 2714L: return "bfti_e89a02e09f";
            case 2715L: return "bfti_e8abb52925";
            case 2716L: return "bfti_e8cd92253a";
            case 2717L: return "bfti_e8d8539733";
            case 2718L: return "bfti_e91a9eefe2";
            case 2719L: return "bfti_e92ecd5d63";
            case 2720L: return "bfti_e944e016ac";
            case 2721L: return "bfti_e94efe43f7";
            case 2722L: return "bfti_e95ca7a9ed";
            case 2723L: return "bfti_e9787a51d7";
            case 2724L: return "bfti_e9940d4b68";
            case 2725L: return "bfti_e996f47390";
            case 2726L: return "bfti_e9d83db84f";
            case 2727L: return "bfti_e9db9c5af0";
            case 2728L: return "bfti_e9fdf9e610";
            case 2729L: return "bfti_ea186403d9";
            case 2730L: return "bfti_ea18a9682b";
            case 2731L: return "bfti_ea3d7c0b91";
            case 2732L: return "bfti_ea44be3ef1";
            case 2733L: return "bfti_ea531035ce";
            case 2734L: return "bfti_eab9d74080";
            case 2735L: return "bfti_eac41a89c8";
            case 2736L: return "bfti_ead9a4aae5";
            case 2737L: return "bfti_eade1f14ce";
            case 2738L: return "bfti_eaeabc9957";
            case 2739L: return "bfti_eaf552bbd5";
            case 2740L: return "bfti_eb0f764104";
            case 2741L: return "bfti_eb249ec982";
            case 2742L: return "bfti_eb53e38271";
            case 2743L: return "bfti_eb712f0bdb";
            case 2744L: return "bfti_eb774769c9";
            case 2745L: return "bfti_eb800a3ed7";
            case 2746L: return "bfti_eb991ad3f8";
            case 2747L: return "bfti_eba6079ecb";
            case 2748L: return "bfti_eba8fe603d";
            case 2749L: return "bfti_ebb47ef126";
            case 2750L: return "bfti_ebca67decf";
            case 2751L: return "bfti_ebcb25d721";
            case 2752L: return "bfti_ebe12987ea";
            case 2753L: return "bfti_ebf31d7e78";
            case 2754L: return "bfti_ec1c4fc343";
            case 2755L: return "bfti_ec3991cdb3";
            case 2756L: return "bfti_ec4e93048b";
            case 2757L: return "bfti_ec510b378a";
            case 2758L: return "bfti_ec8294af72";
            case 2759L: return "bfti_ec9eaa6cc9";
            case 2760L: return "bfti_eca5dcd6fd";
            case 2761L: return "bfti_ecbf7c3952";
            case 2762L: return "bfti_ecc1777e00";
            case 2763L: return "bfti_ecd989c159";
            case 2764L: return "bfti_ece9cd73a7";
            case 2765L: return "bfti_ed1bd06043";
            case 2766L: return "bfti_ed1f9fee39";
            case 2767L: return "bfti_ed2a28af9f";
            case 2768L: return "bfti_ed3c271523";
            case 2769L: return "bfti_ed6b7fc650";
            case 2770L: return "bfti_ed71d54665";
            case 2771L: return "bfti_ed83f24fc9";
            case 2772L: return "bfti_edb0d22177";
            case 2773L: return "bfti_edbc91ac4f";
            case 2774L: return "bfti_ee07931288";
            case 2775L: return "bfti_ee0e12d5d8";
            case 2776L: return "bfti_ee1399701a";
            case 2777L: return "bfti_ee27c81565";
            case 2778L: return "bfti_ee4e80e92e";
            case 2779L: return "bfti_ee781628c3";
            case 2780L: return "bfti_ee7dbfc59b";
            case 2781L: return "bfti_ee9498a725";
            case 2782L: return "bfti_eebb362371";
            case 2783L: return "bfti_ef0879a007";
            case 2784L: return "bfti_ef45e5427a";
            case 2785L: return "bfti_ef69064538";
            case 2786L: return "bfti_ef6b16135c";
            case 2787L: return "bfti_ef9c2a2588";
            case 2788L: return "bfti_ef9c6c7138";
            case 2789L: return "bfti_efa0ef3f8b";
            case 2790L: return "bfti_efa15b104e";
            case 2791L: return "bfti_efc83f14da";
            case 2792L: return "bfti_efdfb5ab89";
            case 2793L: return "bfti_efe666961d";
            case 2794L: return "bfti_efefccb61e";
            case 2795L: return "bfti_f00037c220";
            case 2796L: return "bfti_f0005979bc";
            case 2797L: return "bfti_f004038852";
            case 2798L: return "bfti_f04bca1267";
            case 2799L: return "bfti_f07f86a340";
            case 2800L: return "bfti_f098fd319a";
            case 2801L: return "bfti_f0cc077772";
            case 2802L: return "bfti_f0e48fbf1d";
            case 2803L: return "bfti_f0e7a08dc6";
            case 2804L: return "bfti_f1061ac2ec";
            case 2805L: return "bfti_f11709c0ca";
            case 2806L: return "bfti_f138ac7f54";
            case 2807L: return "bfti_f14d5f0e55";
            case 2808L: return "bfti_f14f60a211";
            case 2809L: return "bfti_f161ef81d6";
            case 2810L: return "bfti_f16def1781";
            case 2811L: return "bfti_f175fa97ba";
            case 2812L: return "bfti_f17bd906f1";
            case 2813L: return "bfti_f1ae98068c";
            case 2814L: return "bfti_f1ec082751";
            case 2815L: return "bfti_f23cd7545e";
            case 2816L: return "bfti_f28ea9078f";
            case 2817L: return "bfti_f2d52bb3a2";
            case 2818L: return "bfti_f2e82fe7eb";
            case 2819L: return "bfti_f2f1cb2c84";
            case 2820L: return "bfti_f2f30c1868";
            case 2821L: return "bfti_f2f537231c";
            case 2822L: return "bfti_f303144c3a";
            case 2823L: return "bfti_f31078c017";
            case 2824L: return "bfti_f31fa9d57d";
            case 2825L: return "bfti_f328af8e55";
            case 2826L: return "bfti_f349b86ad0";
            case 2827L: return "bfti_f3625a753e";
            case 2828L: return "bfti_f3631a7563";
            case 2829L: return "bfti_f36a819e53";
            case 2830L: return "bfti_f388485362";
            case 2831L: return "bfti_f3a9c0ffa8";
            case 2832L: return "bfti_f3abd7f47f";
            case 2833L: return "bfti_f3b7558a14";
            case 2834L: return "bfti_f3c4691d8b";
            case 2835L: return "bfti_f3c8d4357c";
            case 2836L: return "bfti_f3cad457a7";
            case 2837L: return "bfti_f3dc909b34";
            case 2838L: return "bfti_f3fe702729";
            case 2839L: return "bfti_f40211b778";
            case 2840L: return "bfti_f41a7e5346";
            case 2841L: return "bfti_f42ad892e3";
            case 2842L: return "bfti_f45819239a";
            case 2843L: return "bfti_f47907394b";
            case 2844L: return "bfti_f48de439d2";
            case 2845L: return "bfti_f48e738432";
            case 2846L: return "bfti_f4ab981150";
            case 2847L: return "bfti_f4b8e269fd";
            case 2848L: return "bfti_f4cf58d722";
            case 2849L: return "bfti_f4d5595ade";
            case 2850L: return "bfti_f4efa1f3e0";
            case 2851L: return "bfti_f50f840b0a";
            case 2852L: return "bfti_f522976c00";
            case 2853L: return "bfti_f53fc97195";
            case 2854L: return "bfti_f546d4cc7d";
            case 2855L: return "bfti_f5a37604a0";
            case 2856L: return "bfti_f5af8f0f9d";
            case 2857L: return "bfti_f5cfb4b36d";
            case 2858L: return "bfti_f6139a5b1c";
            case 2859L: return "bfti_f619988375";
            case 2860L: return "bfti_f667f7472c";
            case 2861L: return "bfti_f66a6e2446";
            case 2862L: return "bfti_f675857266";
            case 2863L: return "bfti_f68345ce77";
            case 2864L: return "bfti_f68f94e898";
            case 2865L: return "bfti_f6b167f49c";
            case 2866L: return "bfti_f6e13c6253";
            case 2867L: return "bfti_f6f6715eae";
            case 2868L: return "bfti_f701d29bf6";
            case 2869L: return "bfti_f7096e66b8";
            case 2870L: return "bfti_f7469c46ee";
            case 2871L: return "bfti_f7541e2606";
            case 2872L: return "bfti_f7a9dd4858";
            case 2873L: return "bfti_f7b5c01d95";
            case 2874L: return "bfti_f7bce644c8";
            case 2875L: return "bfti_f7dd90f22c";
            case 2876L: return "bfti_f7e06f26f2";
            case 2877L: return "bfti_f7e85347c6";
            case 2878L: return "bfti_f7fa335e50";
            case 2879L: return "bfti_f80defb21e";
            case 2880L: return "bfti_f81185710d";
            case 2881L: return "bfti_f825c51446";
            case 2882L: return "bfti_f827dc336c";
            case 2883L: return "bfti_f84b461ec8";
            case 2884L: return "bfti_f8b96e2714";
            case 2885L: return "bfti_f8bcc4fb0c";
            case 2886L: return "bfti_f8e01da3da";
            case 2887L: return "bfti_f8e4c00692";
            case 2888L: return "bfti_f8e6203699";
            case 2889L: return "bfti_f8ed161325";
            case 2890L: return "bfti_f8fcfa7f69";
            case 2891L: return "bfti_f906837692";
            case 2892L: return "bfti_f90ca5d33f";
            case 2893L: return "bfti_f9520da84b";
            case 2894L: return "bfti_f970022bc4";
            case 2895L: return "bfti_f9837438ff";
            case 2896L: return "bfti_f986b2d5ce";
            case 2897L: return "bfti_f98fef8652";
            case 2898L: return "bfti_f99710fc1d";
            case 2899L: return "bfti_f99e661969";
            case 2900L: return "bfti_f9af11a632";
            case 2901L: return "bfti_f9b0b4e9b6";
            case 2902L: return "bfti_f9c3a519e6";
            case 2903L: return "bfti_f9cc71ca3b";
            case 2904L: return "bfti_f9e54aadd6";
            case 2905L: return "bfti_f9f39af3ae";
            case 2906L: return "bfti_f9f6259885";
            case 2907L: return "bfti_f9f6640629";
            case 2908L: return "bfti_fa286ce8af";
            case 2909L: return "bfti_fa64ad19f0";
            case 2910L: return "bfti_fa6659b90b";
            case 2911L: return "bfti_fa6e4f625e";
            case 2912L: return "bfti_fab6ab5d90";
            case 2913L: return "bfti_fabc3d4a4f";
            case 2914L: return "bfti_fac1365817";
            case 2915L: return "bfti_fad8f8ea4d";
            case 2916L: return "bfti_fafc65e875";
            case 2917L: return "bfti_fb39ee2ab0";
            case 2918L: return "bfti_fb3b241720";
            case 2919L: return "bfti_fb4e42ae06";
            case 2920L: return "bfti_fb54521f24";
            case 2921L: return "bfti_fb5ad52db3";
            case 2922L: return "bfti_fb602dd132";
            case 2923L: return "bfti_fb60ac0bc9";
            case 2924L: return "bfti_fb85c61cbb";
            case 2925L: return "bfti_fbc6154444";
            case 2926L: return "bfti_fbf1af9eea";
            case 2927L: return "bfti_fbf79674c5";
            case 2928L: return "bfti_fc0bd128f4";
            case 2929L: return "bfti_fc17e96675";
            case 2930L: return "bfti_fc24ed5436";
            case 2931L: return "bfti_fc2a05412b";
            case 2932L: return "bfti_fc2c65657f";
            case 2933L: return "bfti_fc3c52a0fb";
            case 2934L: return "bfti_fc4bb5e11c";
            case 2935L: return "bfti_fc75304bbc";
            case 2936L: return "bfti_fc839f5c89";
            case 2937L: return "bfti_fc86f4b82a";
            case 2938L: return "bfti_fcbd8758e7";
            case 2939L: return "bfti_fcc97b2911";
            case 2940L: return "bfti_fd0eba518d";
            case 2941L: return "bfti_fd10cb23ff";
            case 2942L: return "bfti_fd30bc8201";
            case 2943L: return "bfti_fd44bab025";
            case 2944L: return "bfti_fd5562a3ff";
            case 2945L: return "bfti_fd5aaa6f87";
            case 2946L: return "bfti_fdb89a20cb";
            case 2947L: return "bfti_fdc8662281";
            case 2948L: return "bfti_fdd6928843";
            case 2949L: return "bfti_fdd7a5e331";
            case 2950L: return "bfti_fdd7f1e60f";
            case 2951L: return "bfti_fde1636073";
            case 2952L: return "bfti_fdeb8449f8";
            case 2953L: return "bfti_fdec4e1bd1";
            case 2954L: return "bfti_fe18d6e969";
            case 2955L: return "bfti_fe1db9286a";
            case 2956L: return "bfti_fe21681a75";
            case 2957L: return "bfti_fe7269efe4";
            case 2958L: return "bfti_fe95eb849c";
            case 2959L: return "bfti_fea59671c2";
            case 2960L: return "bfti_feb8bcf217";
            case 2961L: return "bfti_fec957fd30";
            case 2962L: return "bfti_fece9e70ec";
            case 2963L: return "bfti_fedc099f48";
            case 2964L: return "bfti_fee91dd795";
            case 2965L: return "bfti_feeac38fe4";
            case 2966L: return "bfti_fef2f6fe56";
            case 2967L: return "bfti_fef9f2a799";
            case 2968L: return "bfti_ff12d56947";
            case 2969L: return "bfti_ff3d9cb127";
            case 2970L: return "bfti_ff661598c1";
            case 2971L: return "bfti_ff744f940f";
            case 2972L: return "bfti_ff7e5ae566";
            case 2973L: return "bfti_ff8d0d91d9";
            case 2974L: return "bfti_ff9d63b71f";
            case 2975L: return "bfti_ff9d993979";
            case 2976L: return "bfti_ff9dfa626a";
            case 2977L: return "bfti_ffc841e027";
            case 2978L: return "bfti_ffe16e5df8";
            case 2979L: return "bfti_ffe4addc6d";
            case 2980L: return "bfti_last";
            default: return "";
        }
    }

    std::string a_builtin_function_type_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_type_index(i);
        if (s.empty())
            s = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_type_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L,
            2122L,
            2123L,
            2124L,
            2125L,
            2126L,
            2127L,
            2128L,
            2129L,
            2130L,
            2131L,
            2132L,
            2133L,
            2134L,
            2135L,
            2136L,
            2137L,
            2138L,
            2139L,
            2140L,
            2141L,
            2142L,
            2143L,
            2144L,
            2145L,
            2146L,
            2147L,
            2148L,
            2149L,
            2150L,
            2151L,
            2152L,
            2153L,
            2154L,
            2155L,
            2156L,
            2157L,
            2158L,
            2159L,
            2160L,
            2161L,
            2162L,
            2163L,
            2164L,
            2165L,
            2166L,
            2167L,
            2168L,
            2169L,
            2170L,
            2171L,
            2172L,
            2173L,
            2174L,
            2175L,
            2176L,
            2177L,
            2178L,
            2179L,
            2180L,
            2181L,
            2182L,
            2183L,
            2184L,
            2185L,
            2186L,
            2187L,
            2188L,
            2189L,
            2190L,
            2191L,
            2192L,
            2193L,
            2194L,
            2195L,
            2196L,
            2197L,
            2198L,
            2199L,
            2200L,
            2201L,
            2202L,
            2203L,
            2204L,
            2205L,
            2206L,
            2207L,
            2208L,
            2209L,
            2210L,
            2211L,
            2212L,
            2213L,
            2214L,
            2215L,
            2216L,
            2217L,
            2218L,
            2219L,
            2220L,
            2221L,
            2222L,
            2223L,
            2224L,
            2225L,
            2226L,
            2227L,
            2228L,
            2229L,
            2230L,
            2231L,
            2232L,
            2233L,
            2234L,
            2235L,
            2236L,
            2237L,
            2238L,
            2239L,
            2240L,
            2241L,
            2242L,
            2243L,
            2244L,
            2245L,
            2246L,
            2247L,
            2248L,
            2249L,
            2250L,
            2251L,
            2252L,
            2253L,
            2254L,
            2255L,
            2256L,
            2257L,
            2258L,
            2259L,
            2260L,
            2261L,
            2262L,
            2263L,
            2264L,
            2265L,
            2266L,
            2267L,
            2268L,
            2269L,
            2270L,
            2271L,
            2272L,
            2273L,
            2274L,
            2275L,
            2276L,
            2277L,
            2278L,
            2279L,
            2280L,
            2281L,
            2282L,
            2283L,
            2284L,
            2285L,
            2286L,
            2287L,
            2288L,
            2289L,
            2290L,
            2291L,
            2292L,
            2293L,
            2294L,
            2295L,
            2296L,
            2297L,
            2298L,
            2299L,
            2300L,
            2301L,
            2302L,
            2303L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2320L,
            2321L,
            2322L,
            2323L,
            2324L,
            2325L,
            2326L,
            2327L,
            2328L,
            2329L,
            2330L,
            2331L,
            2332L,
            2333L,
            2334L,
            2335L,
            2336L,
            2337L,
            2338L,
            2339L,
            2340L,
            2341L,
            2342L,
            2343L,
            2344L,
            2345L,
            2346L,
            2347L,
            2348L,
            2349L,
            2350L,
            2351L,
            2352L,
            2353L,
            2354L,
            2355L,
            2356L,
            2357L,
            2358L,
            2359L,
            2360L,
            2361L,
            2362L,
            2363L,
            2364L,
            2365L,
            2366L,
            2367L,
            2368L,
            2369L,
            2370L,
            2371L,
            2372L,
            2373L,
            2374L,
            2375L,
            2376L,
            2377L,
            2378L,
            2379L,
            2380L,
            2381L,
            2382L,
            2383L,
            2384L,
            2385L,
            2386L,
            2387L,
            2388L,
            2389L,
            2390L,
            2391L,
            2392L,
            2393L,
            2394L,
            2395L,
            2396L,
            2397L,
            2398L,
            2399L,
            2400L,
            2401L,
            2402L,
            2403L,
            2404L,
            2405L,
            2406L,
            2407L,
            2408L,
            2409L,
            2410L,
            2411L,
            2412L,
            2413L,
            2414L,
            2415L,
            2416L,
            2417L,
            2418L,
            2419L,
            2420L,
            2421L,
            2422L,
            2423L,
            2424L,
            2425L,
            2426L,
            2427L,
            2428L,
            2429L,
            2430L,
            2431L,
            2432L,
            2433L,
            2434L,
            2435L,
            2436L,
            2437L,
            2438L,
            2439L,
            2440L,
            2441L,
            2442L,
            2443L,
            2444L,
            2445L,
            2446L,
            2447L,
            2448L,
            2449L,
            2450L,
            2451L,
            2452L,
            2453L,
            2454L,
            2455L,
            2456L,
            2457L,
            2458L,
            2459L,
            2460L,
            2461L,
            2462L,
            2463L,
            2464L,
            2465L,
            2466L,
            2467L,
            2468L,
            2469L,
            2470L,
            2471L,
            2472L,
            2473L,
            2474L,
            2475L,
            2476L,
            2477L,
            2478L,
            2479L,
            2480L,
            2481L,
            2482L,
            2483L,
            2484L,
            2485L,
            2486L,
            2487L,
            2488L,
            2489L,
            2490L,
            2491L,
            2492L,
            2493L,
            2494L,
            2495L,
            2496L,
            2497L,
            2498L,
            2499L,
            2500L,
            2501L,
            2502L,
            2503L,
            2504L,
            2505L,
            2506L,
            2507L,
            2508L,
            2509L,
            2510L,
            2511L,
            2512L,
            2513L,
            2514L,
            2515L,
            2516L,
            2517L,
            2518L,
            2519L,
            2520L,
            2521L,
            2522L,
            2523L,
            2524L,
            2525L,
            2526L,
            2527L,
            2528L,
            2529L,
            2530L,
            2531L,
            2532L,
            2533L,
            2534L,
            2535L,
            2536L,
            2537L,
            2538L,
            2539L,
            2540L,
            2541L,
            2542L,
            2543L,
            2544L,
            2545L,
            2546L,
            2547L,
            2548L,
            2549L,
            2550L,
            2551L,
            2552L,
            2553L,
            2554L,
            2555L,
            2556L,
            2557L,
            2558L,
            2559L,
            2560L,
            2561L,
            2562L,
            2563L,
            2564L,
            2565L,
            2566L,
            2567L,
            2568L,
            2569L,
            2570L,
            2571L,
            2572L,
            2573L,
            2574L,
            2575L,
            2576L,
            2577L,
            2578L,
            2579L,
            2580L,
            2581L,
            2582L,
            2583L,
            2584L,
            2585L,
            2586L,
            2587L,
            2588L,
            2589L,
            2590L,
            2591L,
            2592L,
            2593L,
            2594L,
            2595L,
            2596L,
            2597L,
            2598L,
            2599L,
            2600L,
            2601L,
            2602L,
            2603L,
            2604L,
            2605L,
            2606L,
            2607L,
            2608L,
            2609L,
            2610L,
            2611L,
            2612L,
            2613L,
            2614L,
            2615L,
            2616L,
            2617L,
            2618L,
            2619L,
            2620L,
            2621L,
            2622L,
            2623L,
            2624L,
            2625L,
            2626L,
            2627L,
            2628L,
            2629L,
            2630L,
            2631L,
            2632L,
            2633L,
            2634L,
            2635L,
            2636L,
            2637L,
            2638L,
            2639L,
            2640L,
            2641L,
            2642L,
            2643L,
            2644L,
            2645L,
            2646L,
            2647L,
            2648L,
            2649L,
            2650L,
            2651L,
            2652L,
            2653L,
            2654L,
            2655L,
            2656L,
            2657L,
            2658L,
            2659L,
            2660L,
            2661L,
            2662L,
            2663L,
            2664L,
            2665L,
            2666L,
            2667L,
            2668L,
            2669L,
            2670L,
            2671L,
            2672L,
            2673L,
            2674L,
            2675L,
            2676L,
            2677L,
            2678L,
            2679L,
            2680L,
            2681L,
            2682L,
            2683L,
            2684L,
            2685L,
            2686L,
            2687L,
            2688L,
            2689L,
            2690L,
            2691L,
            2692L,
            2693L,
            2694L,
            2695L,
            2696L,
            2697L,
            2698L,
            2699L,
            2700L,
            2701L,
            2702L,
            2703L,
            2704L,
            2705L,
            2706L,
            2707L,
            2708L,
            2709L,
            2710L,
            2711L,
            2712L,
            2713L,
            2714L,
            2715L,
            2716L,
            2717L,
            2718L,
            2719L,
            2720L,
            2721L,
            2722L,
            2723L,
            2724L,
            2725L,
            2726L,
            2727L,
            2728L,
            2729L,
            2730L,
            2731L,
            2732L,
            2733L,
            2734L,
            2735L,
            2736L,
            2737L,
            2738L,
            2739L,
            2740L,
            2741L,
            2742L,
            2743L,
            2744L,
            2745L,
            2746L,
            2747L,
            2748L,
            2749L,
            2750L,
            2751L,
            2752L,
            2753L,
            2754L,
            2755L,
            2756L,
            2757L,
            2758L,
            2759L,
            2760L,
            2761L,
            2762L,
            2763L,
            2764L,
            2765L,
            2766L,
            2767L,
            2768L,
            2769L,
            2770L,
            2771L,
            2772L,
            2773L,
            2774L,
            2775L,
            2776L,
            2777L,
            2778L,
            2779L,
            2780L,
            2781L,
            2782L,
            2783L,
            2784L,
            2785L,
            2786L,
            2787L,
            2788L,
            2789L,
            2790L,
            2791L,
            2792L,
            2793L,
            2794L,
            2795L,
            2796L,
            2797L,
            2798L,
            2799L,
            2800L,
            2801L,
            2802L,
            2803L,
            2804L,
            2805L,
            2806L,
            2807L,
            2808L,
            2809L,
            2810L,
            2811L,
            2812L,
            2813L,
            2814L,
            2815L,
            2816L,
            2817L,
            2818L,
            2819L,
            2820L,
            2821L,
            2822L,
            2823L,
            2824L,
            2825L,
            2826L,
            2827L,
            2828L,
            2829L,
            2830L,
            2831L,
            2832L,
            2833L,
            2834L,
            2835L,
            2836L,
            2837L,
            2838L,
            2839L,
            2840L,
            2841L,
            2842L,
            2843L,
            2844L,
            2845L,
            2846L,
            2847L,
            2848L,
            2849L,
            2850L,
            2851L,
            2852L,
            2853L,
            2854L,
            2855L,
            2856L,
            2857L,
            2858L,
            2859L,
            2860L,
            2861L,
            2862L,
            2863L,
            2864L,
            2865L,
            2866L,
            2867L,
            2868L,
            2869L,
            2870L,
            2871L,
            2872L,
            2873L,
            2874L,
            2875L,
            2876L,
            2877L,
            2878L,
            2879L,
            2880L,
            2881L,
            2882L,
            2883L,
            2884L,
            2885L,
            2886L,
            2887L,
            2888L,
            2889L,
            2890L,
            2891L,
            2892L,
            2893L,
            2894L,
            2895L,
            2896L,
            2897L,
            2898L,
            2899L,
            2900L,
            2901L,
            2902L,
            2903L,
            2904L,
            2905L,
            2906L,
            2907L,
            2908L,
            2909L,
            2910L,
            2911L,
            2912L,
            2913L,
            2914L,
            2915L,
            2916L,
            2917L,
            2918L,
            2919L,
            2920L,
            2921L,
            2922L,
            2923L,
            2924L,
            2925L,
            2926L,
            2927L,
            2928L,
            2929L,
            2930L,
            2931L,
            2932L,
            2933L,
            2934L,
            2935L,
            2936L,
            2937L,
            2938L,
            2939L,
            2940L,
            2941L,
            2942L,
            2943L,
            2944L,
            2945L,
            2946L,
            2947L,
            2948L,
            2949L,
            2950L,
            2951L,
            2952L,
            2953L,
            2954L,
            2955L,
            2956L,
            2957L,
            2958L,
            2959L,
            2960L,
            2961L,
            2962L,
            2963L,
            2964L,
            2965L,
            2966L,
            2967L,
            2968L,
            2969L,
            2970L,
            2971L,
            2972L,
            2973L,
            2974L,
            2975L,
            2976L,
            2977L,
            2978L,
            2979L,
            2980L
        };
        static const std::vector<int64_t> retval(values, values + 2981);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_type_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_type_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_type_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_type_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_type_index() {
        return stringify::a_builtin_function_type_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/builtin_defs.h line 5998
namespace stringify {
    const char* a_builtin_function_condition_index(int64_t i) {
        switch (i) {
            case 0L: return "bfci_00f7898ac1";
            case 1L: return "bfci_023c888429";
            case 2L: return "bfci_02af039f89";
            case 3L: return "bfci_02d1f320e8";
            case 4L: return "bfci_03cc0a7dc4";
            case 5L: return "bfci_05f1854379";
            case 6L: return "bfci_06cc7a5344";
            case 7L: return "bfci_06f5a8045f";
            case 8L: return "bfci_07754772cf";
            case 9L: return "bfci_07fddcd316";
            case 10L: return "bfci_0897a8b410";
            case 11L: return "bfci_08b3aa4129";
            case 12L: return "bfci_0904b91f4a";
            case 13L: return "bfci_0a94310b00";
            case 14L: return "bfci_0ad6a55c34";
            case 15L: return "bfci_0aefd6143b";
            case 16L: return "bfci_0af8691a7c";
            case 17L: return "bfci_0bb687c5e4";
            case 18L: return "bfci_0d0a9f18c9";
            case 19L: return "bfci_0d10935287";
            case 20L: return "bfci_0dfb27eb98";
            case 21L: return "bfci_0e2c11caa7";
            case 22L: return "bfci_0e8745dd6f";
            case 23L: return "bfci_0ef7a205c0";
            case 24L: return "bfci_0f0fdd84b4";
            case 25L: return "bfci_0f44978c31";
            case 26L: return "bfci_0f450964bb";
            case 27L: return "bfci_0fbbca9837";
            case 28L: return "bfci_1198a24cac";
            case 29L: return "bfci_122d7c153b";
            case 30L: return "bfci_135553476e";
            case 31L: return "bfci_13c0119692";
            case 32L: return "bfci_13d7c9c82c";
            case 33L: return "bfci_14f926a96f";
            case 34L: return "bfci_1584883a5c";
            case 35L: return "bfci_15ebbdebe4";
            case 36L: return "bfci_160e35243c";
            case 37L: return "bfci_1639e4d87e";
            case 38L: return "bfci_166c46465e";
            case 39L: return "bfci_16e0f137b7";
            case 40L: return "bfci_16f3f18c14";
            case 41L: return "bfci_170d16fb66";
            case 42L: return "bfci_18105219d6";
            case 43L: return "bfci_1885733069";
            case 44L: return "bfci_189110168a";
            case 45L: return "bfci_19ce555c49";
            case 46L: return "bfci_1b22e07cde";
            case 47L: return "bfci_1cf925f27f";
            case 48L: return "bfci_1f03bb2de9";
            case 49L: return "bfci_207a602b16";
            case 50L: return "bfci_2140592716";
            case 51L: return "bfci_22cb5f6c47";
            case 52L: return "bfci_24c1f47fe6";
            case 53L: return "bfci_24d7b6c650";
            case 54L: return "bfci_251bba9b08";
            case 55L: return "bfci_2571367846";
            case 56L: return "bfci_26e4e2dd44";
            case 57L: return "bfci_271bd9e275";
            case 58L: return "bfci_28d016cf40";
            case 59L: return "bfci_2ada77ff95";
            case 60L: return "bfci_2b6a6ccbfd";
            case 61L: return "bfci_2b83d5c086";
            case 62L: return "bfci_2bdc9b7c53";
            case 63L: return "bfci_2e3d8a2d64";
            case 64L: return "bfci_2eda4ca466";
            case 65L: return "bfci_2fb7d11850";
            case 66L: return "bfci_2ffc57d066";
            case 67L: return "bfci_30a8f841d0";
            case 68L: return "bfci_31381ad87d";
            case 69L: return "bfci_3184ecb0eb";
            case 70L: return "bfci_32163ae6f8";
            case 71L: return "bfci_3325a27549";
            case 72L: return "bfci_33d2cd07a4";
            case 73L: return "bfci_360945a0aa";
            case 74L: return "bfci_3658d5daaf";
            case 75L: return "bfci_383686b422";
            case 76L: return "bfci_38b3fa5b0c";
            case 77L: return "bfci_3949302733";
            case 78L: return "bfci_396f29aaa8";
            case 79L: return "bfci_39931913b1";
            case 80L: return "bfci_3ad620d37f";
            case 81L: return "bfci_3b106353e2";
            case 82L: return "bfci_3b4d939364";
            case 83L: return "bfci_3b79ad16b9";
            case 84L: return "bfci_3bbad874be";
            case 85L: return "bfci_3cfb8e7c97";
            case 86L: return "bfci_3d7e578457";
            case 87L: return "bfci_3f173fe05a";
            case 88L: return "bfci_3f4487dc71";
            case 89L: return "bfci_3f8db3aebf";
            case 90L: return "bfci_3fb038e323";
            case 91L: return "bfci_405b7f8d43";
            case 92L: return "bfci_406d0b7d5c";
            case 93L: return "bfci_408e2de9f7";
            case 94L: return "bfci_40976ba5d4";
            case 95L: return "bfci_430603b963";
            case 96L: return "bfci_43401f0c3e";
            case 97L: return "bfci_45b1e2f4fa";
            case 98L: return "bfci_4749af9536";
            case 99L: return "bfci_47a905f2ba";
            case 100L: return "bfci_49263981c7";
            case 101L: return "bfci_4abb53d66f";
            case 102L: return "bfci_4acd1a4ba9";
            case 103L: return "bfci_4b50e9d406";
            case 104L: return "bfci_4b9fc82931";
            case 105L: return "bfci_4e1252c20f";
            case 106L: return "bfci_4f5330d140";
            case 107L: return "bfci_4f8b9a2b7f";
            case 108L: return "bfci_502ffc9ecc";
            case 109L: return "bfci_504febb698";
            case 110L: return "bfci_508053f403";
            case 111L: return "bfci_50e8f3eeef";
            case 112L: return "bfci_50f1dc2088";
            case 113L: return "bfci_513a431293";
            case 114L: return "bfci_51be25405b";
            case 115L: return "bfci_520a754f09";
            case 116L: return "bfci_522a7362cf";
            case 117L: return "bfci_5440a29628";
            case 118L: return "bfci_54a29ecd4b";
            case 119L: return "bfci_55c72c9da6";
            case 120L: return "bfci_560e3af986";
            case 121L: return "bfci_5774453750";
            case 122L: return "bfci_577b2906b3";
            case 123L: return "bfci_57ae73720e";
            case 124L: return "bfci_57e928b997";
            case 125L: return "bfci_58bcc6410c";
            case 126L: return "bfci_59aa2e490d";
            case 127L: return "bfci_5a36eb321d";
            case 128L: return "bfci_5aef966e27";
            case 129L: return "bfci_5be90c6b88";
            case 130L: return "bfci_5bf906970b";
            case 131L: return "bfci_5d0cbe9254";
            case 132L: return "bfci_5d201f633a";
            case 133L: return "bfci_5d2530522e";
            case 134L: return "bfci_5dc24131ca";
            case 135L: return "bfci_5df115a66d";
            case 136L: return "bfci_5e4b26a750";
            case 137L: return "bfci_5ebf9a8708";
            case 138L: return "bfci_5f64aa4ac8";
            case 139L: return "bfci_5feba30d04";
            case 140L: return "bfci_603352d909";
            case 141L: return "bfci_60dac71855";
            case 142L: return "bfci_6233187660";
            case 143L: return "bfci_62c10382ca";
            case 144L: return "bfci_634ad11953";
            case 145L: return "bfci_648771df08";
            case 146L: return "bfci_65c40afa78";
            case 147L: return "bfci_6697624632";
            case 148L: return "bfci_670852f41a";
            case 149L: return "bfci_6744492a20";
            case 150L: return "bfci_67ee8aac99";
            case 151L: return "bfci_681f11368e";
            case 152L: return "bfci_6824786031";
            case 153L: return "bfci_683cfc86f1";
            case 154L: return "bfci_69d4f189e6";
            case 155L: return "bfci_6a4e73b1f7";
            case 156L: return "bfci_6a8022365a";
            case 157L: return "bfci_6a8da69fa1";
            case 158L: return "bfci_6abc4780b6";
            case 159L: return "bfci_6b92f59576";
            case 160L: return "bfci_6c559f46f1";
            case 161L: return "bfci_6ccda99e01";
            case 162L: return "bfci_6cce347c98";
            case 163L: return "bfci_6cee601ca5";
            case 164L: return "bfci_6e8695f6e1";
            case 165L: return "bfci_6eb90db662";
            case 166L: return "bfci_6edf5a16fc";
            case 167L: return "bfci_6fdde64436";
            case 168L: return "bfci_70203bfabd";
            case 169L: return "bfci_715cee0f46";
            case 170L: return "bfci_716f146207";
            case 171L: return "bfci_7223e6309d";
            case 172L: return "bfci_7292666ab4";
            case 173L: return "bfci_72943f5562";
            case 174L: return "bfci_73bf97c902";
            case 175L: return "bfci_745ba8dc3a";
            case 176L: return "bfci_74877ae309";
            case 177L: return "bfci_74973482fa";
            case 178L: return "bfci_752da8b1fe";
            case 179L: return "bfci_75bfa6e611";
            case 180L: return "bfci_779f906272";
            case 181L: return "bfci_77e865c6a2";
            case 182L: return "bfci_79815881ff";
            case 183L: return "bfci_79a986e667";
            case 184L: return "bfci_7be4b0dc76";
            case 185L: return "bfci_7de2ca1029";
            case 186L: return "bfci_819b663547";
            case 187L: return "bfci_819dfc40c9";
            case 188L: return "bfci_81c684609e";
            case 189L: return "bfci_81f7ddea30";
            case 190L: return "bfci_822510f655";
            case 191L: return "bfci_828d52a9f4";
            case 192L: return "bfci_829d78317c";
            case 193L: return "bfci_83526e0f46";
            case 194L: return "bfci_835e2d4ab6";
            case 195L: return "bfci_83dcf0b45e";
            case 196L: return "bfci_858b2c1758";
            case 197L: return "bfci_85c0226b73";
            case 198L: return "bfci_85c092f8a8";
            case 199L: return "bfci_863b97bf5d";
            case 200L: return "bfci_87c8ad8477";
            case 201L: return "bfci_88a563dd31";
            case 202L: return "bfci_89f7654db7";
            case 203L: return "bfci_89fcc8ec92";
            case 204L: return "bfci_8ad4effd96";
            case 205L: return "bfci_8bbfd5604c";
            case 206L: return "bfci_8ceeea3173";
            case 207L: return "bfci_8d1a82004d";
            case 208L: return "bfci_8d63ad8ab4";
            case 209L: return "bfci_8f30ba5abe";
            case 210L: return "bfci_915c9bd439";
            case 211L: return "bfci_91aef79def";
            case 212L: return "bfci_92436a153d";
            case 213L: return "bfci_9264184f34";
            case 214L: return "bfci_92b298e77f";
            case 215L: return "bfci_9377bbcfa7";
            case 216L: return "bfci_94fe8631f9";
            case 217L: return "bfci_9502adfe46";
            case 218L: return "bfci_959812e8be";
            case 219L: return "bfci_95deeaeb59";
            case 220L: return "bfci_95ef0a52d2";
            case 221L: return "bfci_9602b2a587";
            case 222L: return "bfci_9687f85046";
            case 223L: return "bfci_96f682c9f3";
            case 224L: return "bfci_97cd2838f9";
            case 225L: return "bfci_99788cf313";
            case 226L: return "bfci_997f8f376f";
            case 227L: return "bfci_99cfd45cc2";
            case 228L: return "bfci_99d7e22373";
            case 229L: return "bfci_99f247e3d3";
            case 230L: return "bfci_9a6fa67179";
            case 231L: return "bfci_9c3f64c544";
            case 232L: return "bfci_9cb3f2de6d";
            case 233L: return "bfci_9e3f2d008e";
            case 234L: return "bfci_9ed43877aa";
            case 235L: return "bfci_9efa353721";
            case 236L: return "bfci_9f717821a0";
            case 237L: return "bfci_9fa29d44e3";
            case 238L: return "bfci_a11751e8c7";
            case 239L: return "bfci_a1ea1d44f4";
            case 240L: return "bfci_a201931f77";
            case 241L: return "bfci_a275c997e3";
            case 242L: return "bfci_a2cc09eead";
            case 243L: return "bfci_a33b49d4c4";
            case 244L: return "bfci_a3a7437041";
            case 245L: return "bfci_a4537c68bd";
            case 246L: return "bfci_a480f66892";
            case 247L: return "bfci_a4fe5f2994";
            case 248L: return "bfci_a5385dc887";
            case 249L: return "bfci_a53fd2bb41";
            case 250L: return "bfci_a64b37e87e";
            case 251L: return "bfci_a7330460b7";
            case 252L: return "bfci_a781bfe8c7";
            case 253L: return "bfci_a7dd4c94b3";
            case 254L: return "bfci_a7e9ce229c";
            case 255L: return "bfci_a7eea323e0";
            case 256L: return "bfci_a7eff8f1a4";
            case 257L: return "bfci_a82603eeaa";
            case 258L: return "bfci_a86ccbad83";
            case 259L: return "bfci_a90062d397";
            case 260L: return "bfci_a90c2facfa";
            case 261L: return "bfci_a97d66f655";
            case 262L: return "bfci_a9c6b361c8";
            case 263L: return "bfci_aa36cf1d2e";
            case 264L: return "bfci_ab11f6964c";
            case 265L: return "bfci_ab51cb3c48";
            case 266L: return "bfci_ab65adfe0e";
            case 267L: return "bfci_ad36df3502";
            case 268L: return "bfci_ad3825c933";
            case 269L: return "bfci_ad4ee88e3a";
            case 270L: return "bfci_adc63abe75";
            case 271L: return "bfci_adef37cffd";
            case 272L: return "bfci_ae8af20cc2";
            case 273L: return "bfci_aee848c9e9";
            case 274L: return "bfci_af12fea7d2";
            case 275L: return "bfci_af2178e4b7";
            case 276L: return "bfci_af556fac96";
            case 277L: return "bfci_b03ddf20b3";
            case 278L: return "bfci_b10b51ded7";
            case 279L: return "bfci_b114fd9a3e";
            case 280L: return "bfci_b1cec7092e";
            case 281L: return "bfci_b44ceb883d";
            case 282L: return "bfci_b455251d81";
            case 283L: return "bfci_b4aa481bef";
            case 284L: return "bfci_b51a2bbe85";
            case 285L: return "bfci_b539c6f0a8";
            case 286L: return "bfci_b57a37d661";
            case 287L: return "bfci_b6356096ce";
            case 288L: return "bfci_b686ebed1a";
            case 289L: return "bfci_b73c4f16e5";
            case 290L: return "bfci_b813592eb0";
            case 291L: return "bfci_b90efe4b7e";
            case 292L: return "bfci_b9b8bcff61";
            case 293L: return "bfci_bad392549e";
            case 294L: return "bfci_bb902b1b0f";
            case 295L: return "bfci_bd0ab013c9";
            case 296L: return "bfci_bdbd39ad4d";
            case 297L: return "bfci_be54ae379d";
            case 298L: return "bfci_c05dc7594c";
            case 299L: return "bfci_c0cfdaf944";
            case 300L: return "bfci_c35b2ef921";
            case 301L: return "bfci_c382276e7f";
            case 302L: return "bfci_c3a192d6c1";
            case 303L: return "bfci_c4ab5466eb";
            case 304L: return "bfci_c5fa5926f2";
            case 305L: return "bfci_c607fd9992";
            case 306L: return "bfci_c643c030aa";
            case 307L: return "bfci_c69f9a4f8b";
            case 308L: return "bfci_c6feacf333";
            case 309L: return "bfci_c777f677f3";
            case 310L: return "bfci_c786ccfb66";
            case 311L: return "bfci_c798f5e9ea";
            case 312L: return "bfci_c8e6be958a";
            case 313L: return "bfci_c9c7312b28";
            case 314L: return "bfci_c9f1aecdc8";
            case 315L: return "bfci_ca711666f3";
            case 316L: return "bfci_cc0c786b5d";
            case 317L: return "bfci_cc1e0d9edc";
            case 318L: return "bfci_cd45f1821e";
            case 319L: return "bfci_cd9f9d0b56";
            case 320L: return "bfci_cdce0d2180";
            case 321L: return "bfci_ce2a96ed38";
            case 322L: return "bfci_ce961ebf23";
            case 323L: return "bfci_cec983dfe6";
            case 324L: return "bfci_cee21c23e8";
            case 325L: return "bfci_d0df5649d4";
            case 326L: return "bfci_d1e4e25761";
            case 327L: return "bfci_d23485c2ea";
            case 328L: return "bfci_d24f7b9365";
            case 329L: return "bfci_d35abe7739";
            case 330L: return "bfci_d433cc386c";
            case 331L: return "bfci_d4799f266b";
            case 332L: return "bfci_d76d02e310";
            case 333L: return "bfci_da325b342e";
            case 334L: return "bfci_dacb367fda";
            case 335L: return "bfci_db0aa07e4d";
            case 336L: return "bfci_dc3e7aaf4d";
            case 337L: return "bfci_dd24ef61c4";
            case 338L: return "bfci_ddcf876873";
            case 339L: return "bfci_de9d5193d7";
            case 340L: return "bfci_debe17f022";
            case 341L: return "bfci_df46b9ba82";
            case 342L: return "bfci_e153c0eaa5";
            case 343L: return "bfci_e155f0607a";
            case 344L: return "bfci_e179dfdcd8";
            case 345L: return "bfci_e2a99c7094";
            case 346L: return "bfci_e374bf567b";
            case 347L: return "bfci_e5275a059a";
            case 348L: return "bfci_e55047361b";
            case 349L: return "bfci_e64364acdb";
            case 350L: return "bfci_e6b4e03721";
            case 351L: return "bfci_e73f511266";
            case 352L: return "bfci_e7ab46e012";
            case 353L: return "bfci_e890b96da4";
            case 354L: return "bfci_e91242a7aa";
            case 355L: return "bfci_e9223a9620";
            case 356L: return "bfci_e97e9b924a";
            case 357L: return "bfci_ea9c300354";
            case 358L: return "bfci_eba83ed205";
            case 359L: return "bfci_ec6b7e9ab8";
            case 360L: return "bfci_ed67fabb51";
            case 361L: return "bfci_ed7b044a3b";
            case 362L: return "bfci_ee31a2268f";
            case 363L: return "bfci_ee6ba5fd86";
            case 364L: return "bfci_ee8d14ad41";
            case 365L: return "bfci_ef0582593d";
            case 366L: return "bfci_f023265b7b";
            case 367L: return "bfci_f0347be580";
            case 368L: return "bfci_f0892cd42c";
            case 369L: return "bfci_f0ca9ebb2a";
            case 370L: return "bfci_f1a07309fd";
            case 371L: return "bfci_f1bcd01647";
            case 372L: return "bfci_f328633379";
            case 373L: return "bfci_f38d5e9172";
            case 374L: return "bfci_f3f5ce09c8";
            case 375L: return "bfci_f40ffd293a";
            case 376L: return "bfci_f4471a96d1";
            case 377L: return "bfci_f6c14e39e6";
            case 378L: return "bfci_f7bb06f3b6";
            case 379L: return "bfci_f8fb60295c";
            case 380L: return "bfci_fa0252ddf6";
            case 381L: return "bfci_fb44431c81";
            case 382L: return "bfci_fbeac09b3b";
            case 383L: return "bfci_fc1eb2921c";
            case 384L: return "bfci_fcef52416a";
            case 385L: return "bfci_fcf334be72";
            case 386L: return "bfci_fd1f445e0f";
            case 387L: return "bfci_fd9a903e86";
            case 388L: return "bfci_ff000f0c81";
            case 389L: return "bfci_ff337d6933";
            case 390L: return "bfci_ffd4a0cf4a";
            case 391L: return "bfci_fffb27cc7e";
            case 392L: return "bfci_last";
            default: return "";
        }
    }

    std::string a_builtin_function_condition_index(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_condition_index(i);
        if (s.empty())
            s = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_condition_index() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L
        };
        static const std::vector<int64_t> retval(values, values + 393);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_condition_index(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_condition_index(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_condition_index)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_condition_index::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_condition_index() {
        return stringify::a_builtin_function_condition_index();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/builtin_defs.h line 6795
namespace stringify {
    const char* a_builtin_function_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "bfk_none";
            case 1L: return "bfk_COLUMN";
            case 2L: return "bfk_FILE";
            case 3L: return "bfk_FUNCTION";
            case 4L: return "bfk_GOMP_atomic_end";
            case 5L: return "bfk_GOMP_atomic_start";
            case 6L: return "bfk_GOMP_barrier";
            case 7L: return "bfk_GOMP_barrier_cancel";
            case 8L: return "bfk_GOMP_cancel";
            case 9L: return "bfk_GOMP_cancellation_point";
            case 10L: return "bfk_GOMP_critical_end";
            case 11L: return "bfk_GOMP_critical_name_end";
            case 12L: return "bfk_GOMP_critical_name_start";
            case 13L: return "bfk_GOMP_critical_start";
            case 14L: return "bfk_GOMP_loop_dynamic_next";
            case 15L: return "bfk_GOMP_loop_dynamic_start";
            case 16L: return "bfk_GOMP_loop_end";
            case 17L: return "bfk_GOMP_loop_end_cancel";
            case 18L: return "bfk_GOMP_loop_end_nowait";
            case 19L: return "bfk_GOMP_loop_guided_next";
            case 20L: return "bfk_GOMP_loop_guided_start";
            case 21L: return "bfk_GOMP_loop_ordered_dynamic_next";
            case 22L: return "bfk_GOMP_loop_ordered_dynamic_start";
            case 23L: return "bfk_GOMP_loop_ordered_guided_next";
            case 24L: return "bfk_GOMP_loop_ordered_guided_start";
            case 25L: return "bfk_GOMP_loop_ordered_runtime_next";
            case 26L: return "bfk_GOMP_loop_ordered_runtime_start";
            case 27L: return "bfk_GOMP_loop_ordered_static_next";
            case 28L: return "bfk_GOMP_loop_ordered_static_start";
            case 29L: return "bfk_GOMP_loop_runtime_next";
            case 30L: return "bfk_GOMP_loop_runtime_start";
            case 31L: return "bfk_GOMP_loop_static_next";
            case 32L: return "bfk_GOMP_loop_static_start";
            case 33L: return "bfk_GOMP_loop_ull_dynamic_next";
            case 34L: return "bfk_GOMP_loop_ull_dynamic_start";
            case 35L: return "bfk_GOMP_loop_ull_guided_next";
            case 36L: return "bfk_GOMP_loop_ull_guided_start";
            case 37L: return "bfk_GOMP_loop_ull_ordered_dynamic_next";
            case 38L: return "bfk_GOMP_loop_ull_ordered_dynamic_start";
            case 39L: return "bfk_GOMP_loop_ull_ordered_guided_next";
            case 40L: return "bfk_GOMP_loop_ull_ordered_guided_start";
            case 41L: return "bfk_GOMP_loop_ull_ordered_runtime_next";
            case 42L: return "bfk_GOMP_loop_ull_ordered_runtime_start";
            case 43L: return "bfk_GOMP_loop_ull_ordered_static_next";
            case 44L: return "bfk_GOMP_loop_ull_ordered_static_start";
            case 45L: return "bfk_GOMP_loop_ull_runtime_next";
            case 46L: return "bfk_GOMP_loop_ull_runtime_start";
            case 47L: return "bfk_GOMP_loop_ull_static_next";
            case 48L: return "bfk_GOMP_loop_ull_static_start";
            case 49L: return "bfk_GOMP_ordered_end";
            case 50L: return "bfk_GOMP_ordered_start";
            case 51L: return "bfk_GOMP_parallel";
            case 52L: return "bfk_GOMP_parallel_end";
            case 53L: return "bfk_GOMP_parallel_loop_dynamic";
            case 54L: return "bfk_GOMP_parallel_loop_dynamic_start";
            case 55L: return "bfk_GOMP_parallel_loop_guided";
            case 56L: return "bfk_GOMP_parallel_loop_guided_start";
            case 57L: return "bfk_GOMP_parallel_loop_runtime";
            case 58L: return "bfk_GOMP_parallel_loop_runtime_start";
            case 59L: return "bfk_GOMP_parallel_loop_static";
            case 60L: return "bfk_GOMP_parallel_loop_static_start";
            case 61L: return "bfk_GOMP_parallel_sections";
            case 62L: return "bfk_GOMP_parallel_sections_start";
            case 63L: return "bfk_GOMP_parallel_start";
            case 64L: return "bfk_GOMP_sections_end";
            case 65L: return "bfk_GOMP_sections_end_cancel";
            case 66L: return "bfk_GOMP_sections_end_nowait";
            case 67L: return "bfk_GOMP_sections_next";
            case 68L: return "bfk_GOMP_sections_start";
            case 69L: return "bfk_GOMP_single_copy_end";
            case 70L: return "bfk_GOMP_single_copy_start";
            case 71L: return "bfk_GOMP_single_start";
            case 72L: return "bfk_GOMP_target";
            case 73L: return "bfk_GOMP_target_data";
            case 74L: return "bfk_GOMP_target_end_data";
            case 75L: return "bfk_GOMP_target_update";
            case 76L: return "bfk_GOMP_task";
            case 77L: return "bfk_GOMP_taskgroup_end";
            case 78L: return "bfk_GOMP_taskgroup_start";
            case 79L: return "bfk_GOMP_taskwait";
            case 80L: return "bfk_GOMP_taskyield";
            case 81L: return "bfk_GOMP_teams";
            case 82L: return "bfk_LINE";
            case 83L: return "bfk__Block_object_assign";
            case 84L: return "bfk__Block_object_dispose";
            case 85L: return "bfk__Exit";
            case 86L: return "bfk___CFStringMakeConstantString";
            case 87L: return "bfk___NSStringMakeConstantString";
            case 88L: return "bfk___annotation";
            case 89L: return "bfk___arithmetic_fence";
            case 90L: return "bfk___bnd_chk_ptr_bounds";
            case 91L: return "bfk___bnd_chk_ptr_lbounds";
            case 92L: return "bfk___bnd_chk_ptr_ubounds";
            case 93L: return "bfk___bnd_copy_ptr_bounds";
            case 94L: return "bfk___bnd_get_ptr_lbound";
            case 95L: return "bfk___bnd_get_ptr_ubound";
            case 96L: return "bfk___bnd_init_ptr_bounds";
            case 97L: return "bfk___bnd_narrow_ptr_bounds";
            case 98L: return "bfk___bnd_null_ptr_bounds";
            case 99L: return "bfk___bnd_set_ptr_bounds";
            case 100L: return "bfk___bnd_store_ptr_bounds";
            case 101L: return "bfk___c11_atomic_compare_exchange_strong";
            case 102L: return "bfk___c11_atomic_compare_exchange_weak";
            case 103L: return "bfk___c11_atomic_exchange";
            case 104L: return "bfk___c11_atomic_fetch_add";
            case 105L: return "bfk___c11_atomic_fetch_and";
            case 106L: return "bfk___c11_atomic_fetch_max";
            case 107L: return "bfk___c11_atomic_fetch_min";
            case 108L: return "bfk___c11_atomic_fetch_or";
            case 109L: return "bfk___c11_atomic_fetch_sub";
            case 110L: return "bfk___c11_atomic_fetch_xor";
            case 111L: return "bfk___c11_atomic_init";
            case 112L: return "bfk___c11_atomic_is_lock_free";
            case 113L: return "bfk___c11_atomic_load";
            case 114L: return "bfk___c11_atomic_signal_fence";
            case 115L: return "bfk___c11_atomic_store";
            case 116L: return "bfk___c11_atomic_thread_fence";
            case 117L: return "bfk___chkp_bndldx";
            case 118L: return "bfk___clear_cache";
            case 119L: return "bfk___cospi";
            case 120L: return "bfk___cospif";
            case 121L: return "bfk___cxa_call_unexpected";
            case 122L: return "bfk___cyg_profile_func_enter";
            case 123L: return "bfk___cyg_profile_func_exit";
            case 124L: return "bfk___debugbreak";
            case 125L: return "bfk___divdc3";
            case 126L: return "bfk___divsc3";
            case 127L: return "bfk___divxc3";
            case 128L: return "bfk___exp10";
            case 129L: return "bfk___exp10f";
            case 130L: return "bfk___finite";
            case 131L: return "bfk___finitef";
            case 132L: return "bfk___finitel";
            case 133L: return "bfk___fprintf_chk";
            case 134L: return "bfk___get_unsafe_stack_bottom";
            case 135L: return "bfk___get_unsafe_stack_ptr";
            case 136L: return "bfk___get_unsafe_stack_start";
            case 137L: return "bfk___get_unsafe_stack_top";
            case 138L: return "bfk___memccpy_chk";
            case 139L: return "bfk___memcpy_chk";
            case 140L: return "bfk___memmove_chk";
            case 141L: return "bfk___mempcpy_chk";
            case 142L: return "bfk___memset_chk";
            case 143L: return "bfk___muldc3";
            case 144L: return "bfk___mulsc3";
            case 145L: return "bfk___mulxc3";
            case 146L: return "bfk___opencl_atomic_compare_exchange_strong";
            case 147L: return "bfk___opencl_atomic_compare_exchange_weak";
            case 148L: return "bfk___opencl_atomic_exchange";
            case 149L: return "bfk___opencl_atomic_fetch_add";
            case 150L: return "bfk___opencl_atomic_fetch_and";
            case 151L: return "bfk___opencl_atomic_fetch_max";
            case 152L: return "bfk___opencl_atomic_fetch_min";
            case 153L: return "bfk___opencl_atomic_fetch_or";
            case 154L: return "bfk___opencl_atomic_fetch_sub";
            case 155L: return "bfk___opencl_atomic_fetch_xor";
            case 156L: return "bfk___opencl_atomic_init";
            case 157L: return "bfk___opencl_atomic_load";
            case 158L: return "bfk___opencl_atomic_store";
            case 159L: return "bfk___printf_chk";
            case 160L: return "bfk___rdtsc";
            case 161L: return "bfk___sinpi";
            case 162L: return "bfk___sinpif";
            case 163L: return "bfk___snprintf_chk";
            case 164L: return "bfk___sprintf_chk";
            case 165L: return "bfk___stpcpy_chk";
            case 166L: return "bfk___stpncpy_chk";
            case 167L: return "bfk___strcat_chk";
            case 168L: return "bfk___strcpy_chk";
            case 169L: return "bfk___strlcat_chk";
            case 170L: return "bfk___strlcpy_chk";
            case 171L: return "bfk___strncat_chk";
            case 172L: return "bfk___strncpy_chk";
            case 173L: return "bfk___tanpi";
            case 174L: return "bfk___tanpif";
            case 175L: return "bfk___vfprintf_chk";
            case 176L: return "bfk___vprintf_chk";
            case 177L: return "bfk___vsnprintf_chk";
            case 178L: return "bfk___vsprintf_chk";
            case 179L: return "bfk___warn_memset_zero_len";
            case 180L: return "bfk___xray_customevent";
            case 181L: return "bfk___xray_typedevent";
            case 182L: return "bfk__exit";
            case 183L: return "bfk__mm_clflush";
            case 184L: return "bfk__mm_getcsr";
            case 185L: return "bfk__mm_lfence";
            case 186L: return "bfk__mm_mfence";
            case 187L: return "bfk__mm_pause";
            case 188L: return "bfk__mm_prefetch";
            case 189L: return "bfk__mm_setcsr";
            case 190L: return "bfk__mm_sfence";
            case 191L: return "bfk_abort";
            case 192L: return "bfk_abs";
            case 193L: return "bfk_acc_on_device";
            case 194L: return "bfk_acos";
            case 195L: return "bfk_acosf";
            case 196L: return "bfk_acosf128";
            case 197L: return "bfk_acosh";
            case 198L: return "bfk_acoshf";
            case 199L: return "bfk_acoshf128";
            case 200L: return "bfk_acoshl";
            case 201L: return "bfk_acosl";
            case 202L: return "bfk_add_overflow";
            case 203L: return "bfk_add_overflow_p";
            case 204L: return "bfk_addc";
            case 205L: return "bfk_addcb";
            case 206L: return "bfk_addcl";
            case 207L: return "bfk_addcll";
            case 208L: return "bfk_addcs";
            case 209L: return "bfk_addressof";
            case 210L: return "bfk_adjust_descriptor";
            case 211L: return "bfk_adjust_trampoline";
            case 212L: return "bfk_aggregate_incoming_address";
            case 213L: return "bfk_align_down";
            case 214L: return "bfk_align_up";
            case 215L: return "bfk_aligned_alloc";
            case 216L: return "bfk_alloca";
            case 217L: return "bfk_alloca_with_align";
            case 218L: return "bfk_alloca_with_align_and_max";
            case 219L: return "bfk_annotation";
            case 220L: return "bfk_apply";
            case 221L: return "bfk_apply_args";
            case 222L: return "bfk_args_info";
            case 223L: return "bfk_asin";
            case 224L: return "bfk_asinf";
            case 225L: return "bfk_asinf128";
            case 226L: return "bfk_asinh";
            case 227L: return "bfk_asinhf";
            case 228L: return "bfk_asinhf128";
            case 229L: return "bfk_asinhl";
            case 230L: return "bfk_asinl";
            case 231L: return "bfk_assume";
            case 232L: return "bfk_assume_aligned";
            case 233L: return "bfk_atan";
            case 234L: return "bfk_atan2";
            case 235L: return "bfk_atan2f";
            case 236L: return "bfk_atan2f128";
            case 237L: return "bfk_atan2l";
            case 238L: return "bfk_atanf";
            case 239L: return "bfk_atanf128";
            case 240L: return "bfk_atanh";
            case 241L: return "bfk_atanhf";
            case 242L: return "bfk_atanhf128";
            case 243L: return "bfk_atanhl";
            case 244L: return "bfk_atanl";
            case 245L: return "bfk_atomic_add_fetch";
            case 246L: return "bfk_atomic_add_fetch_1";
            case 247L: return "bfk_atomic_add_fetch_16";
            case 248L: return "bfk_atomic_add_fetch_2";
            case 249L: return "bfk_atomic_add_fetch_4";
            case 250L: return "bfk_atomic_add_fetch_8";
            case 251L: return "bfk_atomic_always_lock_free";
            case 252L: return "bfk_atomic_and_fetch";
            case 253L: return "bfk_atomic_and_fetch_1";
            case 254L: return "bfk_atomic_and_fetch_16";
            case 255L: return "bfk_atomic_and_fetch_2";
            case 256L: return "bfk_atomic_and_fetch_4";
            case 257L: return "bfk_atomic_and_fetch_8";
            case 258L: return "bfk_atomic_clear";
            case 259L: return "bfk_atomic_compare_exchange";
            case 260L: return "bfk_atomic_compare_exchange_1";
            case 261L: return "bfk_atomic_compare_exchange_16";
            case 262L: return "bfk_atomic_compare_exchange_2";
            case 263L: return "bfk_atomic_compare_exchange_4";
            case 264L: return "bfk_atomic_compare_exchange_8";
            case 265L: return "bfk_atomic_compare_exchange_n";
            case 266L: return "bfk_atomic_exchange";
            case 267L: return "bfk_atomic_exchange_1";
            case 268L: return "bfk_atomic_exchange_16";
            case 269L: return "bfk_atomic_exchange_2";
            case 270L: return "bfk_atomic_exchange_4";
            case 271L: return "bfk_atomic_exchange_8";
            case 272L: return "bfk_atomic_exchange_n";
            case 273L: return "bfk_atomic_feraiseexcept";
            case 274L: return "bfk_atomic_fetch_add";
            case 275L: return "bfk_atomic_fetch_add_1";
            case 276L: return "bfk_atomic_fetch_add_16";
            case 277L: return "bfk_atomic_fetch_add_2";
            case 278L: return "bfk_atomic_fetch_add_4";
            case 279L: return "bfk_atomic_fetch_add_8";
            case 280L: return "bfk_atomic_fetch_and";
            case 281L: return "bfk_atomic_fetch_and_1";
            case 282L: return "bfk_atomic_fetch_and_16";
            case 283L: return "bfk_atomic_fetch_and_2";
            case 284L: return "bfk_atomic_fetch_and_4";
            case 285L: return "bfk_atomic_fetch_and_8";
            case 286L: return "bfk_atomic_fetch_max";
            case 287L: return "bfk_atomic_fetch_min";
            case 288L: return "bfk_atomic_fetch_nand";
            case 289L: return "bfk_atomic_fetch_nand_1";
            case 290L: return "bfk_atomic_fetch_nand_16";
            case 291L: return "bfk_atomic_fetch_nand_2";
            case 292L: return "bfk_atomic_fetch_nand_4";
            case 293L: return "bfk_atomic_fetch_nand_8";
            case 294L: return "bfk_atomic_fetch_or";
            case 295L: return "bfk_atomic_fetch_or_1";
            case 296L: return "bfk_atomic_fetch_or_16";
            case 297L: return "bfk_atomic_fetch_or_2";
            case 298L: return "bfk_atomic_fetch_or_4";
            case 299L: return "bfk_atomic_fetch_or_8";
            case 300L: return "bfk_atomic_fetch_sub";
            case 301L: return "bfk_atomic_fetch_sub_1";
            case 302L: return "bfk_atomic_fetch_sub_16";
            case 303L: return "bfk_atomic_fetch_sub_2";
            case 304L: return "bfk_atomic_fetch_sub_4";
            case 305L: return "bfk_atomic_fetch_sub_8";
            case 306L: return "bfk_atomic_fetch_xor";
            case 307L: return "bfk_atomic_fetch_xor_1";
            case 308L: return "bfk_atomic_fetch_xor_16";
            case 309L: return "bfk_atomic_fetch_xor_2";
            case 310L: return "bfk_atomic_fetch_xor_4";
            case 311L: return "bfk_atomic_fetch_xor_8";
            case 312L: return "bfk_atomic_is_lock_free";
            case 313L: return "bfk_atomic_load";
            case 314L: return "bfk_atomic_load_1";
            case 315L: return "bfk_atomic_load_16";
            case 316L: return "bfk_atomic_load_2";
            case 317L: return "bfk_atomic_load_4";
            case 318L: return "bfk_atomic_load_8";
            case 319L: return "bfk_atomic_load_n";
            case 320L: return "bfk_atomic_max_fetch";
            case 321L: return "bfk_atomic_min_fetch";
            case 322L: return "bfk_atomic_nand_fetch";
            case 323L: return "bfk_atomic_nand_fetch_1";
            case 324L: return "bfk_atomic_nand_fetch_16";
            case 325L: return "bfk_atomic_nand_fetch_2";
            case 326L: return "bfk_atomic_nand_fetch_4";
            case 327L: return "bfk_atomic_nand_fetch_8";
            case 328L: return "bfk_atomic_or_fetch";
            case 329L: return "bfk_atomic_or_fetch_1";
            case 330L: return "bfk_atomic_or_fetch_16";
            case 331L: return "bfk_atomic_or_fetch_2";
            case 332L: return "bfk_atomic_or_fetch_4";
            case 333L: return "bfk_atomic_or_fetch_8";
            case 334L: return "bfk_atomic_signal_fence";
            case 335L: return "bfk_atomic_store";
            case 336L: return "bfk_atomic_store_1";
            case 337L: return "bfk_atomic_store_16";
            case 338L: return "bfk_atomic_store_2";
            case 339L: return "bfk_atomic_store_4";
            case 340L: return "bfk_atomic_store_8";
            case 341L: return "bfk_atomic_store_n";
            case 342L: return "bfk_atomic_sub_fetch";
            case 343L: return "bfk_atomic_sub_fetch_1";
            case 344L: return "bfk_atomic_sub_fetch_16";
            case 345L: return "bfk_atomic_sub_fetch_2";
            case 346L: return "bfk_atomic_sub_fetch_4";
            case 347L: return "bfk_atomic_sub_fetch_8";
            case 348L: return "bfk_atomic_test_and_set";
            case 349L: return "bfk_atomic_thread_fence";
            case 350L: return "bfk_atomic_xor_fetch";
            case 351L: return "bfk_atomic_xor_fetch_1";
            case 352L: return "bfk_atomic_xor_fetch_16";
            case 353L: return "bfk_atomic_xor_fetch_2";
            case 354L: return "bfk_atomic_xor_fetch_4";
            case 355L: return "bfk_atomic_xor_fetch_8";
            case 356L: return "bfk_bcmp";
            case 357L: return "bfk_bcopy";
            case 358L: return "bfk_bitreverse16";
            case 359L: return "bfk_bitreverse32";
            case 360L: return "bfk_bitreverse64";
            case 361L: return "bfk_bitreverse8";
            case 362L: return "bfk_bswap128";
            case 363L: return "bfk_bswap16";
            case 364L: return "bfk_bswap32";
            case 365L: return "bfk_bswap64";
            case 366L: return "bfk_bzero";
            case 367L: return "bfk_cabs";
            case 368L: return "bfk_cabsf";
            case 369L: return "bfk_cabsl";
            case 370L: return "bfk_cacos";
            case 371L: return "bfk_cacosf";
            case 372L: return "bfk_cacosh";
            case 373L: return "bfk_cacoshf";
            case 374L: return "bfk_cacoshl";
            case 375L: return "bfk_cacosl";
            case 376L: return "bfk_call_with_static_chain";
            case 377L: return "bfk_calloc";
            case 378L: return "bfk_canonicalize";
            case 379L: return "bfk_canonicalizef";
            case 380L: return "bfk_canonicalizef16";
            case 381L: return "bfk_canonicalizel";
            case 382L: return "bfk_carg";
            case 383L: return "bfk_cargf";
            case 384L: return "bfk_cargl";
            case 385L: return "bfk_casin";
            case 386L: return "bfk_casinf";
            case 387L: return "bfk_casinh";
            case 388L: return "bfk_casinhf";
            case 389L: return "bfk_casinhl";
            case 390L: return "bfk_casinl";
            case 391L: return "bfk_catan";
            case 392L: return "bfk_catanf";
            case 393L: return "bfk_catanh";
            case 394L: return "bfk_catanhf";
            case 395L: return "bfk_catanhl";
            case 396L: return "bfk_catanl";
            case 397L: return "bfk_cbrt";
            case 398L: return "bfk_cbrtf";
            case 399L: return "bfk_cbrtf128";
            case 400L: return "bfk_cbrtl";
            case 401L: return "bfk_ccos";
            case 402L: return "bfk_ccosf";
            case 403L: return "bfk_ccosh";
            case 404L: return "bfk_ccoshf";
            case 405L: return "bfk_ccoshl";
            case 406L: return "bfk_ccosl";
            case 407L: return "bfk_ceil";
            case 408L: return "bfk_ceilf";
            case 409L: return "bfk_ceilf128";
            case 410L: return "bfk_ceilf16";
            case 411L: return "bfk_ceilf32";
            case 412L: return "bfk_ceilf32x";
            case 413L: return "bfk_ceilf64";
            case 414L: return "bfk_ceilf64x";
            case 415L: return "bfk_ceill";
            case 416L: return "bfk_cexp";
            case 417L: return "bfk_cexpf";
            case 418L: return "bfk_cexpi";
            case 419L: return "bfk_cexpif";
            case 420L: return "bfk_cexpil";
            case 421L: return "bfk_cexpl";
            case 422L: return "bfk_char_memchr";
            case 423L: return "bfk_chkp_memcpy_nobnd";
            case 424L: return "bfk_chkp_memcpy_nobnd_nochk";
            case 425L: return "bfk_chkp_memcpy_nochk";
            case 426L: return "bfk_chkp_memmove_nobnd";
            case 427L: return "bfk_chkp_memmove_nobnd_nochk";
            case 428L: return "bfk_chkp_memmove_nochk";
            case 429L: return "bfk_chkp_mempcpy_nobnd";
            case 430L: return "bfk_chkp_mempcpy_nobnd_nochk";
            case 431L: return "bfk_chkp_mempcpy_nochk";
            case 432L: return "bfk_chkp_memset_nobnd";
            case 433L: return "bfk_chkp_memset_nobnd_nochk";
            case 434L: return "bfk_chkp_memset_nochk";
            case 435L: return "bfk_cimag";
            case 436L: return "bfk_cimagf";
            case 437L: return "bfk_cimagl";
            case 438L: return "bfk_classify_type";
            case 439L: return "bfk_clear_padding";
            case 440L: return "bfk_clog";
            case 441L: return "bfk_clog10";
            case 442L: return "bfk_clog10f";
            case 443L: return "bfk_clog10l";
            case 444L: return "bfk_clogf";
            case 445L: return "bfk_clogl";
            case 446L: return "bfk_clrsb";
            case 447L: return "bfk_clrsbimax";
            case 448L: return "bfk_clrsbl";
            case 449L: return "bfk_clrsbll";
            case 450L: return "bfk_clz";
            case 451L: return "bfk_clzimax";
            case 452L: return "bfk_clzl";
            case 453L: return "bfk_clzll";
            case 454L: return "bfk_clzs";
            case 455L: return "bfk_complex";
            case 456L: return "bfk_conj";
            case 457L: return "bfk_conjf";
            case 458L: return "bfk_conjl";
            case 459L: return "bfk_constant_p";
            case 460L: return "bfk_convertvector";
            case 461L: return "bfk_copysign";
            case 462L: return "bfk_copysignf";
            case 463L: return "bfk_copysignf128";
            case 464L: return "bfk_copysignf16";
            case 465L: return "bfk_copysignf32";
            case 466L: return "bfk_copysignf32x";
            case 467L: return "bfk_copysignf64";
            case 468L: return "bfk_copysignf64x";
            case 469L: return "bfk_copysignl";
            case 470L: return "bfk_coro_alloc";
            case 471L: return "bfk_coro_begin";
            case 472L: return "bfk_coro_destroy";
            case 473L: return "bfk_coro_done";
            case 474L: return "bfk_coro_end";
            case 475L: return "bfk_coro_frame";
            case 476L: return "bfk_coro_free";
            case 477L: return "bfk_coro_id";
            case 478L: return "bfk_coro_noop";
            case 479L: return "bfk_coro_param";
            case 480L: return "bfk_coro_promise";
            case 481L: return "bfk_coro_resume";
            case 482L: return "bfk_coro_size";
            case 483L: return "bfk_coro_suspend";
            case 484L: return "bfk_cos";
            case 485L: return "bfk_cosf";
            case 486L: return "bfk_cosf128";
            case 487L: return "bfk_cosf16";
            case 488L: return "bfk_cosh";
            case 489L: return "bfk_coshf";
            case 490L: return "bfk_coshf128";
            case 491L: return "bfk_coshl";
            case 492L: return "bfk_cosl";
            case 493L: return "bfk_cpow";
            case 494L: return "bfk_cpowf";
            case 495L: return "bfk_cpowl";
            case 496L: return "bfk_cproj";
            case 497L: return "bfk_cprojf";
            case 498L: return "bfk_cprojl";
            case 499L: return "bfk_cpu_init";
            case 500L: return "bfk_cpu_is";
            case 501L: return "bfk_cpu_supports";
            case 502L: return "bfk_creal";
            case 503L: return "bfk_crealf";
            case 504L: return "bfk_creall";
            case 505L: return "bfk_csin";
            case 506L: return "bfk_csinf";
            case 507L: return "bfk_csinh";
            case 508L: return "bfk_csinhf";
            case 509L: return "bfk_csinhl";
            case 510L: return "bfk_csinl";
            case 511L: return "bfk_csqrt";
            case 512L: return "bfk_csqrtf";
            case 513L: return "bfk_csqrtl";
            case 514L: return "bfk_ctan";
            case 515L: return "bfk_ctanf";
            case 516L: return "bfk_ctanh";
            case 517L: return "bfk_ctanhf";
            case 518L: return "bfk_ctanhl";
            case 519L: return "bfk_ctanl";
            case 520L: return "bfk_ctz";
            case 521L: return "bfk_ctzimax";
            case 522L: return "bfk_ctzl";
            case 523L: return "bfk_ctzll";
            case 524L: return "bfk_ctzs";
            case 525L: return "bfk_dcgettext";
            case 526L: return "bfk_debugtrap";
            case 527L: return "bfk_dgettext";
            case 528L: return "bfk_drem";
            case 529L: return "bfk_dremf";
            case 530L: return "bfk_dreml";
            case 531L: return "bfk_dump_struct";
            case 532L: return "bfk_dwarf_cfa";
            case 533L: return "bfk_dwarf_fp_regnum";
            case 534L: return "bfk_dwarf_sp_column";
            case 535L: return "bfk_dynamic_object_size";
            case 536L: return "bfk_eh_copy_values";
            case 537L: return "bfk_eh_filter";
            case 538L: return "bfk_eh_pointer";
            case 539L: return "bfk_eh_return";
            case 540L: return "bfk_eh_return_data_regno";
            case 541L: return "bfk_erf";
            case 542L: return "bfk_erfc";
            case 543L: return "bfk_erfcf";
            case 544L: return "bfk_erfcf128";
            case 545L: return "bfk_erfcl";
            case 546L: return "bfk_erff";
            case 547L: return "bfk_erff128";
            case 548L: return "bfk_erfl";
            case 549L: return "bfk_execl";
            case 550L: return "bfk_execle";
            case 551L: return "bfk_execlp";
            case 552L: return "bfk_execv";
            case 553L: return "bfk_execve";
            case 554L: return "bfk_execvp";
            case 555L: return "bfk_exit";
            case 556L: return "bfk_exp";
            case 557L: return "bfk_exp10";
            case 558L: return "bfk_exp10f";
            case 559L: return "bfk_exp10l";
            case 560L: return "bfk_exp2";
            case 561L: return "bfk_exp2f";
            case 562L: return "bfk_exp2f128";
            case 563L: return "bfk_exp2f16";
            case 564L: return "bfk_exp2l";
            case 565L: return "bfk_expect";
            case 566L: return "bfk_expect_with_probability";
            case 567L: return "bfk_expf";
            case 568L: return "bfk_expf128";
            case 569L: return "bfk_expf16";
            case 570L: return "bfk_expl";
            case 571L: return "bfk_expm1";
            case 572L: return "bfk_expm1f";
            case 573L: return "bfk_expm1f128";
            case 574L: return "bfk_expm1l";
            case 575L: return "bfk_extend_pointer";
            case 576L: return "bfk_extract_return_addr";
            case 577L: return "bfk_fabs";
            case 578L: return "bfk_fabsf";
            case 579L: return "bfk_fabsf128";
            case 580L: return "bfk_fabsf16";
            case 581L: return "bfk_fabsf32";
            case 582L: return "bfk_fabsf32x";
            case 583L: return "bfk_fabsf64";
            case 584L: return "bfk_fabsf64x";
            case 585L: return "bfk_fabsl";
            case 586L: return "bfk_fdim";
            case 587L: return "bfk_fdimf";
            case 588L: return "bfk_fdimf128";
            case 589L: return "bfk_fdiml";
            case 590L: return "bfk_feclearexcept";
            case 591L: return "bfk_fegetenv";
            case 592L: return "bfk_fegetexceptflag";
            case 593L: return "bfk_fegetround";
            case 594L: return "bfk_feholdexcept";
            case 595L: return "bfk_feraiseexcept";
            case 596L: return "bfk_fesetenv";
            case 597L: return "bfk_fesetexceptflag";
            case 598L: return "bfk_fesetround";
            case 599L: return "bfk_fetestexcept";
            case 600L: return "bfk_feupdateenv";
            case 601L: return "bfk_ffs";
            case 602L: return "bfk_ffsimax";
            case 603L: return "bfk_ffsl";
            case 604L: return "bfk_ffsll";
            case 605L: return "bfk_finite";
            case 606L: return "bfk_finitef";
            case 607L: return "bfk_finitel";
            case 608L: return "bfk_floor";
            case 609L: return "bfk_floorf";
            case 610L: return "bfk_floorf128";
            case 611L: return "bfk_floorf16";
            case 612L: return "bfk_floorf32";
            case 613L: return "bfk_floorf32x";
            case 614L: return "bfk_floorf64";
            case 615L: return "bfk_floorf64x";
            case 616L: return "bfk_floorl";
            case 617L: return "bfk_flt_rounds";
            case 618L: return "bfk_fma";
            case 619L: return "bfk_fmaf";
            case 620L: return "bfk_fmaf128";
            case 621L: return "bfk_fmaf16";
            case 622L: return "bfk_fmaf32";
            case 623L: return "bfk_fmaf32x";
            case 624L: return "bfk_fmaf64";
            case 625L: return "bfk_fmaf64x";
            case 626L: return "bfk_fmal";
            case 627L: return "bfk_fmax";
            case 628L: return "bfk_fmaxf";
            case 629L: return "bfk_fmaxf128";
            case 630L: return "bfk_fmaxf16";
            case 631L: return "bfk_fmaxf32";
            case 632L: return "bfk_fmaxf32x";
            case 633L: return "bfk_fmaxf64";
            case 634L: return "bfk_fmaxf64x";
            case 635L: return "bfk_fmaxl";
            case 636L: return "bfk_fmin";
            case 637L: return "bfk_fminf";
            case 638L: return "bfk_fminf128";
            case 639L: return "bfk_fminf16";
            case 640L: return "bfk_fminf32";
            case 641L: return "bfk_fminf32x";
            case 642L: return "bfk_fminf64";
            case 643L: return "bfk_fminf64x";
            case 644L: return "bfk_fminl";
            case 645L: return "bfk_fmod";
            case 646L: return "bfk_fmodf";
            case 647L: return "bfk_fmodf128";
            case 648L: return "bfk_fmodf16";
            case 649L: return "bfk_fmodl";
            case 650L: return "bfk_fork";
            case 651L: return "bfk_fpclassify";
            case 652L: return "bfk_fprintf";
            case 653L: return "bfk_fprintf_unlocked";
            case 654L: return "bfk_fputc";
            case 655L: return "bfk_fputc_unlocked";
            case 656L: return "bfk_fputs";
            case 657L: return "bfk_fputs_unlocked";
            case 658L: return "bfk_frame_address";
            case 659L: return "bfk_free";
            case 660L: return "bfk_frexp";
            case 661L: return "bfk_frexpf";
            case 662L: return "bfk_frexpf128";
            case 663L: return "bfk_frexpl";
            case 664L: return "bfk_frob_return_addr";
            case 665L: return "bfk_fscanf";
            case 666L: return "bfk_fwrite";
            case 667L: return "bfk_fwrite_unlocked";
            case 668L: return "bfk_gamma";
            case 669L: return "bfk_gamma_r";
            case 670L: return "bfk_gammaf";
            case 671L: return "bfk_gammaf_r";
            case 672L: return "bfk_gammal";
            case 673L: return "bfk_gammal_r";
            case 674L: return "bfk_gettext";
            case 675L: return "bfk_huge_val";
            case 676L: return "bfk_huge_valf";
            case 677L: return "bfk_huge_valf128";
            case 678L: return "bfk_huge_valf32";
            case 679L: return "bfk_huge_valf32x";
            case 680L: return "bfk_huge_valf64";
            case 681L: return "bfk_huge_valf64x";
            case 682L: return "bfk_huge_vall";
            case 683L: return "bfk_hypot";
            case 684L: return "bfk_hypotf";
            case 685L: return "bfk_hypotf128";
            case 686L: return "bfk_hypotl";
            case 687L: return "bfk_ia32_2intersectd128";
            case 688L: return "bfk_ia32_2intersectd256";
            case 689L: return "bfk_ia32_2intersectd512";
            case 690L: return "bfk_ia32_2intersectq128";
            case 691L: return "bfk_ia32_2intersectq256";
            case 692L: return "bfk_ia32_2intersectq512";
            case 693L: return "bfk_ia32_4fmaddps";
            case 694L: return "bfk_ia32_4fmaddps_mask";
            case 695L: return "bfk_ia32_4fmaddss";
            case 696L: return "bfk_ia32_4fmaddss_mask";
            case 697L: return "bfk_ia32_4fnmaddps";
            case 698L: return "bfk_ia32_4fnmaddps_mask";
            case 699L: return "bfk_ia32_4fnmaddss";
            case 700L: return "bfk_ia32_4fnmaddss_mask";
            case 701L: return "bfk_ia32_addcarry_u32";
            case 702L: return "bfk_ia32_addcarry_u64";
            case 703L: return "bfk_ia32_addcarryx_u32";
            case 704L: return "bfk_ia32_addcarryx_u64";
            case 705L: return "bfk_ia32_addpd";
            case 706L: return "bfk_ia32_addpd128_mask";
            case 707L: return "bfk_ia32_addpd256";
            case 708L: return "bfk_ia32_addpd256_mask";
            case 709L: return "bfk_ia32_addpd512";
            case 710L: return "bfk_ia32_addpd512_mask";
            case 711L: return "bfk_ia32_addps";
            case 712L: return "bfk_ia32_addps128_mask";
            case 713L: return "bfk_ia32_addps256";
            case 714L: return "bfk_ia32_addps256_mask";
            case 715L: return "bfk_ia32_addps512";
            case 716L: return "bfk_ia32_addps512_mask";
            case 717L: return "bfk_ia32_addsd";
            case 718L: return "bfk_ia32_addsd_mask_round";
            case 719L: return "bfk_ia32_addsd_round";
            case 720L: return "bfk_ia32_addsd_round_mask";
            case 721L: return "bfk_ia32_addss";
            case 722L: return "bfk_ia32_addss_mask_round";
            case 723L: return "bfk_ia32_addss_round";
            case 724L: return "bfk_ia32_addss_round_mask";
            case 725L: return "bfk_ia32_addsubpd";
            case 726L: return "bfk_ia32_addsubpd256";
            case 727L: return "bfk_ia32_addsubps";
            case 728L: return "bfk_ia32_addsubps256";
            case 729L: return "bfk_ia32_aesdec128";
            case 730L: return "bfk_ia32_aesdec128kl_u8";
            case 731L: return "bfk_ia32_aesdec256";
            case 732L: return "bfk_ia32_aesdec256kl_u8";
            case 733L: return "bfk_ia32_aesdec512";
            case 734L: return "bfk_ia32_aesdeclast128";
            case 735L: return "bfk_ia32_aesdeclast256";
            case 736L: return "bfk_ia32_aesdeclast512";
            case 737L: return "bfk_ia32_aesdecwide128kl_u8";
            case 738L: return "bfk_ia32_aesdecwide256kl_u8";
            case 739L: return "bfk_ia32_aesenc128";
            case 740L: return "bfk_ia32_aesenc128kl_u8";
            case 741L: return "bfk_ia32_aesenc256";
            case 742L: return "bfk_ia32_aesenc256kl_u8";
            case 743L: return "bfk_ia32_aesenc512";
            case 744L: return "bfk_ia32_aesenclast128";
            case 745L: return "bfk_ia32_aesenclast256";
            case 746L: return "bfk_ia32_aesenclast512";
            case 747L: return "bfk_ia32_aesencwide128kl_u8";
            case 748L: return "bfk_ia32_aesencwide256kl_u8";
            case 749L: return "bfk_ia32_aesimc128";
            case 750L: return "bfk_ia32_aeskeygenassist128";
            case 751L: return "bfk_ia32_alignd128";
            case 752L: return "bfk_ia32_alignd128_mask";
            case 753L: return "bfk_ia32_alignd256";
            case 754L: return "bfk_ia32_alignd256_mask";
            case 755L: return "bfk_ia32_alignd512";
            case 756L: return "bfk_ia32_alignd512_mask";
            case 757L: return "bfk_ia32_alignq128";
            case 758L: return "bfk_ia32_alignq128_mask";
            case 759L: return "bfk_ia32_alignq256";
            case 760L: return "bfk_ia32_alignq256_mask";
            case 761L: return "bfk_ia32_alignq512";
            case 762L: return "bfk_ia32_alignq512_mask";
            case 763L: return "bfk_ia32_andnotsi256";
            case 764L: return "bfk_ia32_andnpd";
            case 765L: return "bfk_ia32_andnpd128_mask";
            case 766L: return "bfk_ia32_andnpd256";
            case 767L: return "bfk_ia32_andnpd256_mask";
            case 768L: return "bfk_ia32_andnpd512_mask";
            case 769L: return "bfk_ia32_andnps";
            case 770L: return "bfk_ia32_andnps128_mask";
            case 771L: return "bfk_ia32_andnps256";
            case 772L: return "bfk_ia32_andnps256_mask";
            case 773L: return "bfk_ia32_andnps512_mask";
            case 774L: return "bfk_ia32_andpd";
            case 775L: return "bfk_ia32_andpd128_mask";
            case 776L: return "bfk_ia32_andpd256";
            case 777L: return "bfk_ia32_andpd256_mask";
            case 778L: return "bfk_ia32_andpd512_mask";
            case 779L: return "bfk_ia32_andps";
            case 780L: return "bfk_ia32_andps128_mask";
            case 781L: return "bfk_ia32_andps256";
            case 782L: return "bfk_ia32_andps256_mask";
            case 783L: return "bfk_ia32_andps512_mask";
            case 784L: return "bfk_ia32_andsi256";
            case 785L: return "bfk_ia32_bextr_u32";
            case 786L: return "bfk_ia32_bextr_u64";
            case 787L: return "bfk_ia32_bextri_u32";
            case 788L: return "bfk_ia32_bextri_u64";
            case 789L: return "bfk_ia32_blendmb_128_mask";
            case 790L: return "bfk_ia32_blendmb_256_mask";
            case 791L: return "bfk_ia32_blendmb_512_mask";
            case 792L: return "bfk_ia32_blendmd_128_mask";
            case 793L: return "bfk_ia32_blendmd_256_mask";
            case 794L: return "bfk_ia32_blendmd_512_mask";
            case 795L: return "bfk_ia32_blendmpd_128_mask";
            case 796L: return "bfk_ia32_blendmpd_256_mask";
            case 797L: return "bfk_ia32_blendmpd_512_mask";
            case 798L: return "bfk_ia32_blendmps_128_mask";
            case 799L: return "bfk_ia32_blendmps_256_mask";
            case 800L: return "bfk_ia32_blendmps_512_mask";
            case 801L: return "bfk_ia32_blendmq_128_mask";
            case 802L: return "bfk_ia32_blendmq_256_mask";
            case 803L: return "bfk_ia32_blendmq_512_mask";
            case 804L: return "bfk_ia32_blendmw_128_mask";
            case 805L: return "bfk_ia32_blendmw_256_mask";
            case 806L: return "bfk_ia32_blendmw_512_mask";
            case 807L: return "bfk_ia32_blendpd";
            case 808L: return "bfk_ia32_blendpd256";
            case 809L: return "bfk_ia32_blendps";
            case 810L: return "bfk_ia32_blendps256";
            case 811L: return "bfk_ia32_blendvpd";
            case 812L: return "bfk_ia32_blendvpd256";
            case 813L: return "bfk_ia32_blendvps";
            case 814L: return "bfk_ia32_blendvps256";
            case 815L: return "bfk_ia32_broadcastf32x2_256_mask";
            case 816L: return "bfk_ia32_broadcastf32x2_512_mask";
            case 817L: return "bfk_ia32_broadcastf32x4_256_mask";
            case 818L: return "bfk_ia32_broadcastf32x4_512";
            case 819L: return "bfk_ia32_broadcastf32x8_512_mask";
            case 820L: return "bfk_ia32_broadcastf64x2_256_mask";
            case 821L: return "bfk_ia32_broadcastf64x2_512_mask";
            case 822L: return "bfk_ia32_broadcastf64x4_512";
            case 823L: return "bfk_ia32_broadcasti32x2_128_mask";
            case 824L: return "bfk_ia32_broadcasti32x2_256_mask";
            case 825L: return "bfk_ia32_broadcasti32x2_512_mask";
            case 826L: return "bfk_ia32_broadcasti32x4_256_mask";
            case 827L: return "bfk_ia32_broadcasti32x4_512";
            case 828L: return "bfk_ia32_broadcasti32x8_512_mask";
            case 829L: return "bfk_ia32_broadcasti64x2_256_mask";
            case 830L: return "bfk_ia32_broadcasti64x2_512_mask";
            case 831L: return "bfk_ia32_broadcasti64x4_512";
            case 832L: return "bfk_ia32_broadcastmb128";
            case 833L: return "bfk_ia32_broadcastmb256";
            case 834L: return "bfk_ia32_broadcastmb512";
            case 835L: return "bfk_ia32_broadcastmw128";
            case 836L: return "bfk_ia32_broadcastmw256";
            case 837L: return "bfk_ia32_broadcastmw512";
            case 838L: return "bfk_ia32_broadcastsd256_mask";
            case 839L: return "bfk_ia32_broadcastsd512";
            case 840L: return "bfk_ia32_broadcastss128_mask";
            case 841L: return "bfk_ia32_broadcastss256_mask";
            case 842L: return "bfk_ia32_broadcastss512";
            case 843L: return "bfk_ia32_bsrdi";
            case 844L: return "bfk_ia32_bsrsi";
            case 845L: return "bfk_ia32_bzhi_di";
            case 846L: return "bfk_ia32_bzhi_si";
            case 847L: return "bfk_ia32_ceilpd";
            case 848L: return "bfk_ia32_ceilpd256";
            case 849L: return "bfk_ia32_ceilpd512";
            case 850L: return "bfk_ia32_ceilpd_vec_pack_sfix";
            case 851L: return "bfk_ia32_ceilpd_vec_pack_sfix256";
            case 852L: return "bfk_ia32_ceilpd_vec_pack_sfix512";
            case 853L: return "bfk_ia32_ceilps";
            case 854L: return "bfk_ia32_ceilps256";
            case 855L: return "bfk_ia32_ceilps512";
            case 856L: return "bfk_ia32_ceilps_sfix";
            case 857L: return "bfk_ia32_ceilps_sfix256";
            case 858L: return "bfk_ia32_ceilps_sfix512";
            case 859L: return "bfk_ia32_cldemote";
            case 860L: return "bfk_ia32_clflush";
            case 861L: return "bfk_ia32_clflushopt";
            case 862L: return "bfk_ia32_clrssbsy";
            case 863L: return "bfk_ia32_clui";
            case 864L: return "bfk_ia32_clwb";
            case 865L: return "bfk_ia32_clzero";
            case 866L: return "bfk_ia32_cmpb128_mask";
            case 867L: return "bfk_ia32_cmpb256_mask";
            case 868L: return "bfk_ia32_cmpb512_mask";
            case 869L: return "bfk_ia32_cmpd128_mask";
            case 870L: return "bfk_ia32_cmpd256_mask";
            case 871L: return "bfk_ia32_cmpd512_mask";
            case 872L: return "bfk_ia32_cmpeqpd";
            case 873L: return "bfk_ia32_cmpeqps";
            case 874L: return "bfk_ia32_cmpeqsd";
            case 875L: return "bfk_ia32_cmpeqss";
            case 876L: return "bfk_ia32_cmpgepd";
            case 877L: return "bfk_ia32_cmpgeps";
            case 878L: return "bfk_ia32_cmpgtpd";
            case 879L: return "bfk_ia32_cmpgtps";
            case 880L: return "bfk_ia32_cmplepd";
            case 881L: return "bfk_ia32_cmpleps";
            case 882L: return "bfk_ia32_cmplesd";
            case 883L: return "bfk_ia32_cmpless";
            case 884L: return "bfk_ia32_cmpltpd";
            case 885L: return "bfk_ia32_cmpltps";
            case 886L: return "bfk_ia32_cmpltsd";
            case 887L: return "bfk_ia32_cmpltss";
            case 888L: return "bfk_ia32_cmpneqpd";
            case 889L: return "bfk_ia32_cmpneqps";
            case 890L: return "bfk_ia32_cmpneqsd";
            case 891L: return "bfk_ia32_cmpneqss";
            case 892L: return "bfk_ia32_cmpngepd";
            case 893L: return "bfk_ia32_cmpngeps";
            case 894L: return "bfk_ia32_cmpngess";
            case 895L: return "bfk_ia32_cmpngtpd";
            case 896L: return "bfk_ia32_cmpngtps";
            case 897L: return "bfk_ia32_cmpngtss";
            case 898L: return "bfk_ia32_cmpnlepd";
            case 899L: return "bfk_ia32_cmpnleps";
            case 900L: return "bfk_ia32_cmpnlesd";
            case 901L: return "bfk_ia32_cmpnless";
            case 902L: return "bfk_ia32_cmpnltpd";
            case 903L: return "bfk_ia32_cmpnltps";
            case 904L: return "bfk_ia32_cmpnltsd";
            case 905L: return "bfk_ia32_cmpnltss";
            case 906L: return "bfk_ia32_cmpordpd";
            case 907L: return "bfk_ia32_cmpordps";
            case 908L: return "bfk_ia32_cmpordsd";
            case 909L: return "bfk_ia32_cmpordss";
            case 910L: return "bfk_ia32_cmppd";
            case 911L: return "bfk_ia32_cmppd128_mask";
            case 912L: return "bfk_ia32_cmppd256";
            case 913L: return "bfk_ia32_cmppd256_mask";
            case 914L: return "bfk_ia32_cmppd512_mask";
            case 915L: return "bfk_ia32_cmpps";
            case 916L: return "bfk_ia32_cmpps128_mask";
            case 917L: return "bfk_ia32_cmpps256";
            case 918L: return "bfk_ia32_cmpps256_mask";
            case 919L: return "bfk_ia32_cmpps512_mask";
            case 920L: return "bfk_ia32_cmpq128_mask";
            case 921L: return "bfk_ia32_cmpq256_mask";
            case 922L: return "bfk_ia32_cmpq512_mask";
            case 923L: return "bfk_ia32_cmpsd";
            case 924L: return "bfk_ia32_cmpsd_mask";
            case 925L: return "bfk_ia32_cmpss";
            case 926L: return "bfk_ia32_cmpss_mask";
            case 927L: return "bfk_ia32_cmpunordpd";
            case 928L: return "bfk_ia32_cmpunordps";
            case 929L: return "bfk_ia32_cmpunordsd";
            case 930L: return "bfk_ia32_cmpunordss";
            case 931L: return "bfk_ia32_cmpw128_mask";
            case 932L: return "bfk_ia32_cmpw256_mask";
            case 933L: return "bfk_ia32_cmpw512_mask";
            case 934L: return "bfk_ia32_comeqpd";
            case 935L: return "bfk_ia32_comeqps";
            case 936L: return "bfk_ia32_comeqsd";
            case 937L: return "bfk_ia32_comeqss";
            case 938L: return "bfk_ia32_comfalsepd";
            case 939L: return "bfk_ia32_comfalseps";
            case 940L: return "bfk_ia32_comfalsesd";
            case 941L: return "bfk_ia32_comfalsess";
            case 942L: return "bfk_ia32_comgepd";
            case 943L: return "bfk_ia32_comgeps";
            case 944L: return "bfk_ia32_comgesd";
            case 945L: return "bfk_ia32_comgess";
            case 946L: return "bfk_ia32_comgtpd";
            case 947L: return "bfk_ia32_comgtps";
            case 948L: return "bfk_ia32_comgtsd";
            case 949L: return "bfk_ia32_comgtss";
            case 950L: return "bfk_ia32_comieq";
            case 951L: return "bfk_ia32_comige";
            case 952L: return "bfk_ia32_comigt";
            case 953L: return "bfk_ia32_comile";
            case 954L: return "bfk_ia32_comilt";
            case 955L: return "bfk_ia32_comineq";
            case 956L: return "bfk_ia32_comisdeq";
            case 957L: return "bfk_ia32_comisdge";
            case 958L: return "bfk_ia32_comisdgt";
            case 959L: return "bfk_ia32_comisdle";
            case 960L: return "bfk_ia32_comisdlt";
            case 961L: return "bfk_ia32_comisdneq";
            case 962L: return "bfk_ia32_comlepd";
            case 963L: return "bfk_ia32_comleps";
            case 964L: return "bfk_ia32_comlesd";
            case 965L: return "bfk_ia32_comless";
            case 966L: return "bfk_ia32_comltpd";
            case 967L: return "bfk_ia32_comltps";
            case 968L: return "bfk_ia32_comltsd";
            case 969L: return "bfk_ia32_comltss";
            case 970L: return "bfk_ia32_comnepd";
            case 971L: return "bfk_ia32_comneps";
            case 972L: return "bfk_ia32_comnesd";
            case 973L: return "bfk_ia32_comness";
            case 974L: return "bfk_ia32_comordpd";
            case 975L: return "bfk_ia32_comordps";
            case 976L: return "bfk_ia32_comordsd";
            case 977L: return "bfk_ia32_comordss";
            case 978L: return "bfk_ia32_compressdf128_mask";
            case 979L: return "bfk_ia32_compressdf256_mask";
            case 980L: return "bfk_ia32_compressdf512_mask";
            case 981L: return "bfk_ia32_compressdi128_mask";
            case 982L: return "bfk_ia32_compressdi256_mask";
            case 983L: return "bfk_ia32_compressdi512_mask";
            case 984L: return "bfk_ia32_compresshi128_mask";
            case 985L: return "bfk_ia32_compresshi256_mask";
            case 986L: return "bfk_ia32_compresshi512_mask";
            case 987L: return "bfk_ia32_compressqi128_mask";
            case 988L: return "bfk_ia32_compressqi256_mask";
            case 989L: return "bfk_ia32_compressqi512_mask";
            case 990L: return "bfk_ia32_compresssf128_mask";
            case 991L: return "bfk_ia32_compresssf256_mask";
            case 992L: return "bfk_ia32_compresssf512_mask";
            case 993L: return "bfk_ia32_compresssi128_mask";
            case 994L: return "bfk_ia32_compresssi256_mask";
            case 995L: return "bfk_ia32_compresssi512_mask";
            case 996L: return "bfk_ia32_compressstoredf128_mask";
            case 997L: return "bfk_ia32_compressstoredf256_mask";
            case 998L: return "bfk_ia32_compressstoredf512_mask";
            case 999L: return "bfk_ia32_compressstoredi128_mask";
            case 1000L: return "bfk_ia32_compressstoredi256_mask";
            case 1001L: return "bfk_ia32_compressstoredi512_mask";
            case 1002L: return "bfk_ia32_compressstorehi128_mask";
            case 1003L: return "bfk_ia32_compressstorehi256_mask";
            case 1004L: return "bfk_ia32_compressstorehi512_mask";
            case 1005L: return "bfk_ia32_compressstoreqi128_mask";
            case 1006L: return "bfk_ia32_compressstoreqi256_mask";
            case 1007L: return "bfk_ia32_compressstoreqi512_mask";
            case 1008L: return "bfk_ia32_compressstoresf128_mask";
            case 1009L: return "bfk_ia32_compressstoresf256_mask";
            case 1010L: return "bfk_ia32_compressstoresf512_mask";
            case 1011L: return "bfk_ia32_compressstoresi128_mask";
            case 1012L: return "bfk_ia32_compressstoresi256_mask";
            case 1013L: return "bfk_ia32_compressstoresi512_mask";
            case 1014L: return "bfk_ia32_compressstoreuhi128_mask";
            case 1015L: return "bfk_ia32_compressstoreuhi256_mask";
            case 1016L: return "bfk_ia32_compressstoreuhi512_mask";
            case 1017L: return "bfk_ia32_compressstoreuqi128_mask";
            case 1018L: return "bfk_ia32_compressstoreuqi256_mask";
            case 1019L: return "bfk_ia32_compressstoreuqi512_mask";
            case 1020L: return "bfk_ia32_comtruepd";
            case 1021L: return "bfk_ia32_comtrueps";
            case 1022L: return "bfk_ia32_comtruesd";
            case 1023L: return "bfk_ia32_comtruess";
            case 1024L: return "bfk_ia32_comueqpd";
            case 1025L: return "bfk_ia32_comueqps";
            case 1026L: return "bfk_ia32_comueqsd";
            case 1027L: return "bfk_ia32_comueqss";
            case 1028L: return "bfk_ia32_comunepd";
            case 1029L: return "bfk_ia32_comuneps";
            case 1030L: return "bfk_ia32_comunesd";
            case 1031L: return "bfk_ia32_comuness";
            case 1032L: return "bfk_ia32_comunordpd";
            case 1033L: return "bfk_ia32_comunordps";
            case 1034L: return "bfk_ia32_comunordsd";
            case 1035L: return "bfk_ia32_comunordss";
            case 1036L: return "bfk_ia32_copysignpd";
            case 1037L: return "bfk_ia32_copysignpd256";
            case 1038L: return "bfk_ia32_copysignpd512";
            case 1039L: return "bfk_ia32_copysignps";
            case 1040L: return "bfk_ia32_copysignps256";
            case 1041L: return "bfk_ia32_copysignps512";
            case 1042L: return "bfk_ia32_crc32di";
            case 1043L: return "bfk_ia32_crc32hi";
            case 1044L: return "bfk_ia32_crc32qi";
            case 1045L: return "bfk_ia32_crc32si";
            case 1046L: return "bfk_ia32_cvtb2mask128";
            case 1047L: return "bfk_ia32_cvtb2mask256";
            case 1048L: return "bfk_ia32_cvtb2mask512";
            case 1049L: return "bfk_ia32_cvtd2mask128";
            case 1050L: return "bfk_ia32_cvtd2mask256";
            case 1051L: return "bfk_ia32_cvtd2mask512";
            case 1052L: return "bfk_ia32_cvtdq2pd";
            case 1053L: return "bfk_ia32_cvtdq2pd128_mask";
            case 1054L: return "bfk_ia32_cvtdq2pd256";
            case 1055L: return "bfk_ia32_cvtdq2pd256_mask";
            case 1056L: return "bfk_ia32_cvtdq2pd512_mask";
            case 1057L: return "bfk_ia32_cvtdq2ps";
            case 1058L: return "bfk_ia32_cvtdq2ps128_mask";
            case 1059L: return "bfk_ia32_cvtdq2ps256";
            case 1060L: return "bfk_ia32_cvtdq2ps256_mask";
            case 1061L: return "bfk_ia32_cvtdq2ps512_mask";
            case 1062L: return "bfk_ia32_cvtmask2b128";
            case 1063L: return "bfk_ia32_cvtmask2b256";
            case 1064L: return "bfk_ia32_cvtmask2b512";
            case 1065L: return "bfk_ia32_cvtmask2d128";
            case 1066L: return "bfk_ia32_cvtmask2d256";
            case 1067L: return "bfk_ia32_cvtmask2d512";
            case 1068L: return "bfk_ia32_cvtmask2q128";
            case 1069L: return "bfk_ia32_cvtmask2q256";
            case 1070L: return "bfk_ia32_cvtmask2q512";
            case 1071L: return "bfk_ia32_cvtmask2w128";
            case 1072L: return "bfk_ia32_cvtmask2w256";
            case 1073L: return "bfk_ia32_cvtmask2w512";
            case 1074L: return "bfk_ia32_cvtne2ps2bf16_128";
            case 1075L: return "bfk_ia32_cvtne2ps2bf16_256";
            case 1076L: return "bfk_ia32_cvtne2ps2bf16_512";
            case 1077L: return "bfk_ia32_cvtne2ps2bf16_v16hi";
            case 1078L: return "bfk_ia32_cvtne2ps2bf16_v16hi_mask";
            case 1079L: return "bfk_ia32_cvtne2ps2bf16_v16hi_maskz";
            case 1080L: return "bfk_ia32_cvtne2ps2bf16_v32hi";
            case 1081L: return "bfk_ia32_cvtne2ps2bf16_v32hi_mask";
            case 1082L: return "bfk_ia32_cvtne2ps2bf16_v32hi_maskz";
            case 1083L: return "bfk_ia32_cvtne2ps2bf16_v8hi";
            case 1084L: return "bfk_ia32_cvtne2ps2bf16_v8hi_mask";
            case 1085L: return "bfk_ia32_cvtne2ps2bf16_v8hi_maskz";
            case 1086L: return "bfk_ia32_cvtneps2bf16_128_mask";
            case 1087L: return "bfk_ia32_cvtneps2bf16_256_mask";
            case 1088L: return "bfk_ia32_cvtneps2bf16_512_mask";
            case 1089L: return "bfk_ia32_cvtneps2bf16_v16sf";
            case 1090L: return "bfk_ia32_cvtneps2bf16_v16sf_mask";
            case 1091L: return "bfk_ia32_cvtneps2bf16_v16sf_maskz";
            case 1092L: return "bfk_ia32_cvtneps2bf16_v4sf";
            case 1093L: return "bfk_ia32_cvtneps2bf16_v4sf_mask";
            case 1094L: return "bfk_ia32_cvtneps2bf16_v4sf_maskz";
            case 1095L: return "bfk_ia32_cvtneps2bf16_v8sf";
            case 1096L: return "bfk_ia32_cvtneps2bf16_v8sf_mask";
            case 1097L: return "bfk_ia32_cvtneps2bf16_v8sf_maskz";
            case 1098L: return "bfk_ia32_cvtpd2dq";
            case 1099L: return "bfk_ia32_cvtpd2dq128_mask";
            case 1100L: return "bfk_ia32_cvtpd2dq256";
            case 1101L: return "bfk_ia32_cvtpd2dq256_mask";
            case 1102L: return "bfk_ia32_cvtpd2dq512_mask";
            case 1103L: return "bfk_ia32_cvtpd2pi";
            case 1104L: return "bfk_ia32_cvtpd2ps";
            case 1105L: return "bfk_ia32_cvtpd2ps256";
            case 1106L: return "bfk_ia32_cvtpd2ps256_mask";
            case 1107L: return "bfk_ia32_cvtpd2ps512_mask";
            case 1108L: return "bfk_ia32_cvtpd2ps_mask";
            case 1109L: return "bfk_ia32_cvtpd2qq128_mask";
            case 1110L: return "bfk_ia32_cvtpd2qq256_mask";
            case 1111L: return "bfk_ia32_cvtpd2qq512_mask";
            case 1112L: return "bfk_ia32_cvtpd2udq128_mask";
            case 1113L: return "bfk_ia32_cvtpd2udq256_mask";
            case 1114L: return "bfk_ia32_cvtpd2udq512_mask";
            case 1115L: return "bfk_ia32_cvtpd2uqq128_mask";
            case 1116L: return "bfk_ia32_cvtpd2uqq256_mask";
            case 1117L: return "bfk_ia32_cvtpd2uqq512_mask";
            case 1118L: return "bfk_ia32_cvtpi2pd";
            case 1119L: return "bfk_ia32_cvtpi2ps";
            case 1120L: return "bfk_ia32_cvtps2dq";
            case 1121L: return "bfk_ia32_cvtps2dq128_mask";
            case 1122L: return "bfk_ia32_cvtps2dq256";
            case 1123L: return "bfk_ia32_cvtps2dq256_mask";
            case 1124L: return "bfk_ia32_cvtps2dq512";
            case 1125L: return "bfk_ia32_cvtps2dq512_mask";
            case 1126L: return "bfk_ia32_cvtps2pd";
            case 1127L: return "bfk_ia32_cvtps2pd128_mask";
            case 1128L: return "bfk_ia32_cvtps2pd256";
            case 1129L: return "bfk_ia32_cvtps2pd256_mask";
            case 1130L: return "bfk_ia32_cvtps2pd512_mask";
            case 1131L: return "bfk_ia32_cvtps2pi";
            case 1132L: return "bfk_ia32_cvtps2qq128_mask";
            case 1133L: return "bfk_ia32_cvtps2qq256_mask";
            case 1134L: return "bfk_ia32_cvtps2qq512_mask";
            case 1135L: return "bfk_ia32_cvtps2udq128_mask";
            case 1136L: return "bfk_ia32_cvtps2udq256_mask";
            case 1137L: return "bfk_ia32_cvtps2udq512_mask";
            case 1138L: return "bfk_ia32_cvtps2uqq128_mask";
            case 1139L: return "bfk_ia32_cvtps2uqq256_mask";
            case 1140L: return "bfk_ia32_cvtps2uqq512_mask";
            case 1141L: return "bfk_ia32_cvtq2mask128";
            case 1142L: return "bfk_ia32_cvtq2mask256";
            case 1143L: return "bfk_ia32_cvtq2mask512";
            case 1144L: return "bfk_ia32_cvtqq2pd128_mask";
            case 1145L: return "bfk_ia32_cvtqq2pd256_mask";
            case 1146L: return "bfk_ia32_cvtqq2pd512_mask";
            case 1147L: return "bfk_ia32_cvtqq2ps128_mask";
            case 1148L: return "bfk_ia32_cvtqq2ps256_mask";
            case 1149L: return "bfk_ia32_cvtqq2ps512_mask";
            case 1150L: return "bfk_ia32_cvtsbf162ss_32";
            case 1151L: return "bfk_ia32_cvtsd2si";
            case 1152L: return "bfk_ia32_cvtsd2si64";
            case 1153L: return "bfk_ia32_cvtsd2ss";
            case 1154L: return "bfk_ia32_cvtsd2ss_mask_round";
            case 1155L: return "bfk_ia32_cvtsd2ss_round";
            case 1156L: return "bfk_ia32_cvtsd2ss_round_mask";
            case 1157L: return "bfk_ia32_cvtsi2sd";
            case 1158L: return "bfk_ia32_cvtsi2sd64";
            case 1159L: return "bfk_ia32_cvtsi2ss";
            case 1160L: return "bfk_ia32_cvtsi2ss32";
            case 1161L: return "bfk_ia32_cvtsi2ss64";
            case 1162L: return "bfk_ia32_cvtsi642sd";
            case 1163L: return "bfk_ia32_cvtsi642ss";
            case 1164L: return "bfk_ia32_cvtss2sd";
            case 1165L: return "bfk_ia32_cvtss2sd_mask_round";
            case 1166L: return "bfk_ia32_cvtss2sd_round";
            case 1167L: return "bfk_ia32_cvtss2sd_round_mask";
            case 1168L: return "bfk_ia32_cvtss2si";
            case 1169L: return "bfk_ia32_cvtss2si64";
            case 1170L: return "bfk_ia32_cvttpd2dq";
            case 1171L: return "bfk_ia32_cvttpd2dq128_mask";
            case 1172L: return "bfk_ia32_cvttpd2dq256";
            case 1173L: return "bfk_ia32_cvttpd2dq256_mask";
            case 1174L: return "bfk_ia32_cvttpd2dq512_mask";
            case 1175L: return "bfk_ia32_cvttpd2pi";
            case 1176L: return "bfk_ia32_cvttpd2qq128_mask";
            case 1177L: return "bfk_ia32_cvttpd2qq256_mask";
            case 1178L: return "bfk_ia32_cvttpd2qq512_mask";
            case 1179L: return "bfk_ia32_cvttpd2udq128_mask";
            case 1180L: return "bfk_ia32_cvttpd2udq256_mask";
            case 1181L: return "bfk_ia32_cvttpd2udq512_mask";
            case 1182L: return "bfk_ia32_cvttpd2uqq128_mask";
            case 1183L: return "bfk_ia32_cvttpd2uqq256_mask";
            case 1184L: return "bfk_ia32_cvttpd2uqq512_mask";
            case 1185L: return "bfk_ia32_cvttps2dq";
            case 1186L: return "bfk_ia32_cvttps2dq128_mask";
            case 1187L: return "bfk_ia32_cvttps2dq256";
            case 1188L: return "bfk_ia32_cvttps2dq256_mask";
            case 1189L: return "bfk_ia32_cvttps2dq512_mask";
            case 1190L: return "bfk_ia32_cvttps2pi";
            case 1191L: return "bfk_ia32_cvttps2qq128_mask";
            case 1192L: return "bfk_ia32_cvttps2qq256_mask";
            case 1193L: return "bfk_ia32_cvttps2qq512_mask";
            case 1194L: return "bfk_ia32_cvttps2udq128_mask";
            case 1195L: return "bfk_ia32_cvttps2udq256_mask";
            case 1196L: return "bfk_ia32_cvttps2udq512_mask";
            case 1197L: return "bfk_ia32_cvttps2uqq128_mask";
            case 1198L: return "bfk_ia32_cvttps2uqq256_mask";
            case 1199L: return "bfk_ia32_cvttps2uqq512_mask";
            case 1200L: return "bfk_ia32_cvttsd2si";
            case 1201L: return "bfk_ia32_cvttsd2si64";
            case 1202L: return "bfk_ia32_cvttss2si";
            case 1203L: return "bfk_ia32_cvttss2si64";
            case 1204L: return "bfk_ia32_cvtudq2pd128_mask";
            case 1205L: return "bfk_ia32_cvtudq2pd256_mask";
            case 1206L: return "bfk_ia32_cvtudq2pd512_mask";
            case 1207L: return "bfk_ia32_cvtudq2ps";
            case 1208L: return "bfk_ia32_cvtudq2ps128_mask";
            case 1209L: return "bfk_ia32_cvtudq2ps256_mask";
            case 1210L: return "bfk_ia32_cvtudq2ps512_mask";
            case 1211L: return "bfk_ia32_cvtuqq2pd128_mask";
            case 1212L: return "bfk_ia32_cvtuqq2pd256_mask";
            case 1213L: return "bfk_ia32_cvtuqq2pd512_mask";
            case 1214L: return "bfk_ia32_cvtuqq2ps128_mask";
            case 1215L: return "bfk_ia32_cvtuqq2ps256_mask";
            case 1216L: return "bfk_ia32_cvtuqq2ps512_mask";
            case 1217L: return "bfk_ia32_cvtusi2sd32";
            case 1218L: return "bfk_ia32_cvtusi2sd64";
            case 1219L: return "bfk_ia32_cvtusi2ss32";
            case 1220L: return "bfk_ia32_cvtusi2ss64";
            case 1221L: return "bfk_ia32_cvtw2mask128";
            case 1222L: return "bfk_ia32_cvtw2mask256";
            case 1223L: return "bfk_ia32_cvtw2mask512";
            case 1224L: return "bfk_ia32_dbpsadbw128";
            case 1225L: return "bfk_ia32_dbpsadbw128_mask";
            case 1226L: return "bfk_ia32_dbpsadbw256";
            case 1227L: return "bfk_ia32_dbpsadbw256_mask";
            case 1228L: return "bfk_ia32_dbpsadbw512";
            case 1229L: return "bfk_ia32_dbpsadbw512_mask";
            case 1230L: return "bfk_ia32_directstore_u32";
            case 1231L: return "bfk_ia32_directstore_u64";
            case 1232L: return "bfk_ia32_directstoreu_u32";
            case 1233L: return "bfk_ia32_directstoreu_u64";
            case 1234L: return "bfk_ia32_divpd";
            case 1235L: return "bfk_ia32_divpd256";
            case 1236L: return "bfk_ia32_divpd256_mask";
            case 1237L: return "bfk_ia32_divpd512";
            case 1238L: return "bfk_ia32_divpd512_mask";
            case 1239L: return "bfk_ia32_divpd_mask";
            case 1240L: return "bfk_ia32_divps";
            case 1241L: return "bfk_ia32_divps256";
            case 1242L: return "bfk_ia32_divps256_mask";
            case 1243L: return "bfk_ia32_divps512";
            case 1244L: return "bfk_ia32_divps512_mask";
            case 1245L: return "bfk_ia32_divps_mask";
            case 1246L: return "bfk_ia32_divsd";
            case 1247L: return "bfk_ia32_divsd_mask_round";
            case 1248L: return "bfk_ia32_divsd_round";
            case 1249L: return "bfk_ia32_divsd_round_mask";
            case 1250L: return "bfk_ia32_divss";
            case 1251L: return "bfk_ia32_divss_mask_round";
            case 1252L: return "bfk_ia32_divss_round";
            case 1253L: return "bfk_ia32_divss_round_mask";
            case 1254L: return "bfk_ia32_dpbf16ps_128";
            case 1255L: return "bfk_ia32_dpbf16ps_256";
            case 1256L: return "bfk_ia32_dpbf16ps_512";
            case 1257L: return "bfk_ia32_dpbf16ps_v16sf";
            case 1258L: return "bfk_ia32_dpbf16ps_v16sf_mask";
            case 1259L: return "bfk_ia32_dpbf16ps_v16sf_maskz";
            case 1260L: return "bfk_ia32_dpbf16ps_v4sf";
            case 1261L: return "bfk_ia32_dpbf16ps_v4sf_mask";
            case 1262L: return "bfk_ia32_dpbf16ps_v4sf_maskz";
            case 1263L: return "bfk_ia32_dpbf16ps_v8sf";
            case 1264L: return "bfk_ia32_dpbf16ps_v8sf_mask";
            case 1265L: return "bfk_ia32_dpbf16ps_v8sf_maskz";
            case 1266L: return "bfk_ia32_dppd";
            case 1267L: return "bfk_ia32_dpps";
            case 1268L: return "bfk_ia32_dpps256";
            case 1269L: return "bfk_ia32_emms";
            case 1270L: return "bfk_ia32_encodekey128_u32";
            case 1271L: return "bfk_ia32_encodekey256_u32";
            case 1272L: return "bfk_ia32_enqcmd";
            case 1273L: return "bfk_ia32_enqcmds";
            case 1274L: return "bfk_ia32_exp2pd_mask";
            case 1275L: return "bfk_ia32_exp2ps";
            case 1276L: return "bfk_ia32_exp2ps_mask";
            case 1277L: return "bfk_ia32_expanddf128_mask";
            case 1278L: return "bfk_ia32_expanddf128_maskz";
            case 1279L: return "bfk_ia32_expanddf256_mask";
            case 1280L: return "bfk_ia32_expanddf256_maskz";
            case 1281L: return "bfk_ia32_expanddf512_mask";
            case 1282L: return "bfk_ia32_expanddf512_maskz";
            case 1283L: return "bfk_ia32_expanddi128_mask";
            case 1284L: return "bfk_ia32_expanddi128_maskz";
            case 1285L: return "bfk_ia32_expanddi256_mask";
            case 1286L: return "bfk_ia32_expanddi256_maskz";
            case 1287L: return "bfk_ia32_expanddi512_mask";
            case 1288L: return "bfk_ia32_expanddi512_maskz";
            case 1289L: return "bfk_ia32_expandhi128_mask";
            case 1290L: return "bfk_ia32_expandhi128_maskz";
            case 1291L: return "bfk_ia32_expandhi256_mask";
            case 1292L: return "bfk_ia32_expandhi256_maskz";
            case 1293L: return "bfk_ia32_expandhi512_mask";
            case 1294L: return "bfk_ia32_expandhi512_maskz";
            case 1295L: return "bfk_ia32_expandloaddf128_mask";
            case 1296L: return "bfk_ia32_expandloaddf128_maskz";
            case 1297L: return "bfk_ia32_expandloaddf256_mask";
            case 1298L: return "bfk_ia32_expandloaddf256_maskz";
            case 1299L: return "bfk_ia32_expandloaddf512_mask";
            case 1300L: return "bfk_ia32_expandloaddf512_maskz";
            case 1301L: return "bfk_ia32_expandloaddi128_mask";
            case 1302L: return "bfk_ia32_expandloaddi128_maskz";
            case 1303L: return "bfk_ia32_expandloaddi256_mask";
            case 1304L: return "bfk_ia32_expandloaddi256_maskz";
            case 1305L: return "bfk_ia32_expandloaddi512_mask";
            case 1306L: return "bfk_ia32_expandloaddi512_maskz";
            case 1307L: return "bfk_ia32_expandloadhi128_mask";
            case 1308L: return "bfk_ia32_expandloadhi128_maskz";
            case 1309L: return "bfk_ia32_expandloadhi256_mask";
            case 1310L: return "bfk_ia32_expandloadhi256_maskz";
            case 1311L: return "bfk_ia32_expandloadhi512_mask";
            case 1312L: return "bfk_ia32_expandloadhi512_maskz";
            case 1313L: return "bfk_ia32_expandloadqi128_mask";
            case 1314L: return "bfk_ia32_expandloadqi128_maskz";
            case 1315L: return "bfk_ia32_expandloadqi256_mask";
            case 1316L: return "bfk_ia32_expandloadqi256_maskz";
            case 1317L: return "bfk_ia32_expandloadqi512_mask";
            case 1318L: return "bfk_ia32_expandloadqi512_maskz";
            case 1319L: return "bfk_ia32_expandloadsf128_mask";
            case 1320L: return "bfk_ia32_expandloadsf128_maskz";
            case 1321L: return "bfk_ia32_expandloadsf256_mask";
            case 1322L: return "bfk_ia32_expandloadsf256_maskz";
            case 1323L: return "bfk_ia32_expandloadsf512_mask";
            case 1324L: return "bfk_ia32_expandloadsf512_maskz";
            case 1325L: return "bfk_ia32_expandloadsi128_mask";
            case 1326L: return "bfk_ia32_expandloadsi128_maskz";
            case 1327L: return "bfk_ia32_expandloadsi256_mask";
            case 1328L: return "bfk_ia32_expandloadsi256_maskz";
            case 1329L: return "bfk_ia32_expandloadsi512_mask";
            case 1330L: return "bfk_ia32_expandloadsi512_maskz";
            case 1331L: return "bfk_ia32_expandqi128_mask";
            case 1332L: return "bfk_ia32_expandqi128_maskz";
            case 1333L: return "bfk_ia32_expandqi256_mask";
            case 1334L: return "bfk_ia32_expandqi256_maskz";
            case 1335L: return "bfk_ia32_expandqi512_mask";
            case 1336L: return "bfk_ia32_expandqi512_maskz";
            case 1337L: return "bfk_ia32_expandsf128_mask";
            case 1338L: return "bfk_ia32_expandsf128_maskz";
            case 1339L: return "bfk_ia32_expandsf256_mask";
            case 1340L: return "bfk_ia32_expandsf256_maskz";
            case 1341L: return "bfk_ia32_expandsf512_mask";
            case 1342L: return "bfk_ia32_expandsf512_maskz";
            case 1343L: return "bfk_ia32_expandsi128_mask";
            case 1344L: return "bfk_ia32_expandsi128_maskz";
            case 1345L: return "bfk_ia32_expandsi256_mask";
            case 1346L: return "bfk_ia32_expandsi256_maskz";
            case 1347L: return "bfk_ia32_expandsi512_mask";
            case 1348L: return "bfk_ia32_expandsi512_maskz";
            case 1349L: return "bfk_ia32_extract128i256";
            case 1350L: return "bfk_ia32_extractf32x4_256_mask";
            case 1351L: return "bfk_ia32_extractf32x4_mask";
            case 1352L: return "bfk_ia32_extractf32x8_mask";
            case 1353L: return "bfk_ia32_extractf64x2_256_mask";
            case 1354L: return "bfk_ia32_extractf64x2_512_mask";
            case 1355L: return "bfk_ia32_extractf64x4_mask";
            case 1356L: return "bfk_ia32_extracti32x4_256_mask";
            case 1357L: return "bfk_ia32_extracti32x4_mask";
            case 1358L: return "bfk_ia32_extracti32x8_mask";
            case 1359L: return "bfk_ia32_extracti64x2_256_mask";
            case 1360L: return "bfk_ia32_extracti64x2_512_mask";
            case 1361L: return "bfk_ia32_extracti64x4_mask";
            case 1362L: return "bfk_ia32_extrq";
            case 1363L: return "bfk_ia32_extrqi";
            case 1364L: return "bfk_ia32_femms";
            case 1365L: return "bfk_ia32_fixupimmpd128_mask";
            case 1366L: return "bfk_ia32_fixupimmpd128_maskz";
            case 1367L: return "bfk_ia32_fixupimmpd256_mask";
            case 1368L: return "bfk_ia32_fixupimmpd256_maskz";
            case 1369L: return "bfk_ia32_fixupimmpd512_mask";
            case 1370L: return "bfk_ia32_fixupimmpd512_maskz";
            case 1371L: return "bfk_ia32_fixupimmps128_mask";
            case 1372L: return "bfk_ia32_fixupimmps128_maskz";
            case 1373L: return "bfk_ia32_fixupimmps256_mask";
            case 1374L: return "bfk_ia32_fixupimmps256_maskz";
            case 1375L: return "bfk_ia32_fixupimmps512_mask";
            case 1376L: return "bfk_ia32_fixupimmps512_maskz";
            case 1377L: return "bfk_ia32_fixupimmsd_mask";
            case 1378L: return "bfk_ia32_fixupimmsd_maskz";
            case 1379L: return "bfk_ia32_fixupimmss_mask";
            case 1380L: return "bfk_ia32_fixupimmss_maskz";
            case 1381L: return "bfk_ia32_fldenv";
            case 1382L: return "bfk_ia32_floorpd";
            case 1383L: return "bfk_ia32_floorpd256";
            case 1384L: return "bfk_ia32_floorpd512";
            case 1385L: return "bfk_ia32_floorpd_vec_pack_sfix";
            case 1386L: return "bfk_ia32_floorpd_vec_pack_sfix256";
            case 1387L: return "bfk_ia32_floorpd_vec_pack_sfix512";
            case 1388L: return "bfk_ia32_floorps";
            case 1389L: return "bfk_ia32_floorps256";
            case 1390L: return "bfk_ia32_floorps512";
            case 1391L: return "bfk_ia32_floorps_sfix";
            case 1392L: return "bfk_ia32_floorps_sfix256";
            case 1393L: return "bfk_ia32_floorps_sfix512";
            case 1394L: return "bfk_ia32_fmaddpd";
            case 1395L: return "bfk_ia32_fmaddps";
            case 1396L: return "bfk_ia32_fmaddsd";
            case 1397L: return "bfk_ia32_fmaddss";
            case 1398L: return "bfk_ia32_fmsubpd";
            case 1399L: return "bfk_ia32_fmsubps";
            case 1400L: return "bfk_ia32_fmsubsd";
            case 1401L: return "bfk_ia32_fmsubss";
            case 1402L: return "bfk_ia32_fnclex";
            case 1403L: return "bfk_ia32_fnmaddpd";
            case 1404L: return "bfk_ia32_fnmaddps";
            case 1405L: return "bfk_ia32_fnmaddsd";
            case 1406L: return "bfk_ia32_fnmaddss";
            case 1407L: return "bfk_ia32_fnmsubpd";
            case 1408L: return "bfk_ia32_fnmsubps";
            case 1409L: return "bfk_ia32_fnmsubsd";
            case 1410L: return "bfk_ia32_fnmsubss";
            case 1411L: return "bfk_ia32_fnstenv";
            case 1412L: return "bfk_ia32_fnstsw";
            case 1413L: return "bfk_ia32_fpclasspd128_mask";
            case 1414L: return "bfk_ia32_fpclasspd256_mask";
            case 1415L: return "bfk_ia32_fpclasspd512_mask";
            case 1416L: return "bfk_ia32_fpclassps128_mask";
            case 1417L: return "bfk_ia32_fpclassps256_mask";
            case 1418L: return "bfk_ia32_fpclassps512_mask";
            case 1419L: return "bfk_ia32_fpclasssd";
            case 1420L: return "bfk_ia32_fpclasssd_mask";
            case 1421L: return "bfk_ia32_fpclassss";
            case 1422L: return "bfk_ia32_fpclassss_mask";
            case 1423L: return "bfk_ia32_frczpd";
            case 1424L: return "bfk_ia32_frczps";
            case 1425L: return "bfk_ia32_frczsd";
            case 1426L: return "bfk_ia32_frczss";
            case 1427L: return "bfk_ia32_fxrstor";
            case 1428L: return "bfk_ia32_fxrstor64";
            case 1429L: return "bfk_ia32_fxsave";
            case 1430L: return "bfk_ia32_fxsave64";
            case 1431L: return "bfk_ia32_gather3altdiv16sf";
            case 1432L: return "bfk_ia32_gather3altdiv16si";
            case 1433L: return "bfk_ia32_gather3altdiv8sf";
            case 1434L: return "bfk_ia32_gather3altdiv8si";
            case 1435L: return "bfk_ia32_gather3altsiv4df";
            case 1436L: return "bfk_ia32_gather3altsiv4di";
            case 1437L: return "bfk_ia32_gather3altsiv8df";
            case 1438L: return "bfk_ia32_gather3altsiv8di";
            case 1439L: return "bfk_ia32_gather3div2df";
            case 1440L: return "bfk_ia32_gather3div2di";
            case 1441L: return "bfk_ia32_gather3div4df";
            case 1442L: return "bfk_ia32_gather3div4di";
            case 1443L: return "bfk_ia32_gather3div4sf";
            case 1444L: return "bfk_ia32_gather3div4si";
            case 1445L: return "bfk_ia32_gather3div8sf";
            case 1446L: return "bfk_ia32_gather3div8si";
            case 1447L: return "bfk_ia32_gather3siv2df";
            case 1448L: return "bfk_ia32_gather3siv2di";
            case 1449L: return "bfk_ia32_gather3siv4df";
            case 1450L: return "bfk_ia32_gather3siv4di";
            case 1451L: return "bfk_ia32_gather3siv4sf";
            case 1452L: return "bfk_ia32_gather3siv4si";
            case 1453L: return "bfk_ia32_gather3siv8sf";
            case 1454L: return "bfk_ia32_gather3siv8si";
            case 1455L: return "bfk_ia32_gatheraltdiv4sf256";
            case 1456L: return "bfk_ia32_gatheraltdiv4si256";
            case 1457L: return "bfk_ia32_gatheraltdiv8sf";
            case 1458L: return "bfk_ia32_gatheraltdiv8si";
            case 1459L: return "bfk_ia32_gatheraltsiv4df";
            case 1460L: return "bfk_ia32_gatheraltsiv4di";
            case 1461L: return "bfk_ia32_gatheraltsiv8df";
            case 1462L: return "bfk_ia32_gatheraltsiv8di";
            case 1463L: return "bfk_ia32_gatherd_d";
            case 1464L: return "bfk_ia32_gatherd_d256";
            case 1465L: return "bfk_ia32_gatherd_pd";
            case 1466L: return "bfk_ia32_gatherd_pd256";
            case 1467L: return "bfk_ia32_gatherd_ps";
            case 1468L: return "bfk_ia32_gatherd_ps256";
            case 1469L: return "bfk_ia32_gatherd_q";
            case 1470L: return "bfk_ia32_gatherd_q256";
            case 1471L: return "bfk_ia32_gatherdiv16sf";
            case 1472L: return "bfk_ia32_gatherdiv16si";
            case 1473L: return "bfk_ia32_gatherdiv2df";
            case 1474L: return "bfk_ia32_gatherdiv2di";
            case 1475L: return "bfk_ia32_gatherdiv4df";
            case 1476L: return "bfk_ia32_gatherdiv4di";
            case 1477L: return "bfk_ia32_gatherdiv4sf";
            case 1478L: return "bfk_ia32_gatherdiv4sf256";
            case 1479L: return "bfk_ia32_gatherdiv4si";
            case 1480L: return "bfk_ia32_gatherdiv4si256";
            case 1481L: return "bfk_ia32_gatherdiv8df";
            case 1482L: return "bfk_ia32_gatherdiv8di";
            case 1483L: return "bfk_ia32_gatherpfdpd";
            case 1484L: return "bfk_ia32_gatherpfdps";
            case 1485L: return "bfk_ia32_gatherpfqpd";
            case 1486L: return "bfk_ia32_gatherpfqps";
            case 1487L: return "bfk_ia32_gatherq_d";
            case 1488L: return "bfk_ia32_gatherq_d256";
            case 1489L: return "bfk_ia32_gatherq_pd";
            case 1490L: return "bfk_ia32_gatherq_pd256";
            case 1491L: return "bfk_ia32_gatherq_ps";
            case 1492L: return "bfk_ia32_gatherq_ps256";
            case 1493L: return "bfk_ia32_gatherq_q";
            case 1494L: return "bfk_ia32_gatherq_q256";
            case 1495L: return "bfk_ia32_gathersiv16sf";
            case 1496L: return "bfk_ia32_gathersiv16si";
            case 1497L: return "bfk_ia32_gathersiv2df";
            case 1498L: return "bfk_ia32_gathersiv2di";
            case 1499L: return "bfk_ia32_gathersiv4df";
            case 1500L: return "bfk_ia32_gathersiv4di";
            case 1501L: return "bfk_ia32_gathersiv4sf";
            case 1502L: return "bfk_ia32_gathersiv4si";
            case 1503L: return "bfk_ia32_gathersiv8df";
            case 1504L: return "bfk_ia32_gathersiv8di";
            case 1505L: return "bfk_ia32_gathersiv8sf";
            case 1506L: return "bfk_ia32_gathersiv8si";
            case 1507L: return "bfk_ia32_getexppd128_mask";
            case 1508L: return "bfk_ia32_getexppd256_mask";
            case 1509L: return "bfk_ia32_getexppd512_mask";
            case 1510L: return "bfk_ia32_getexpps128_mask";
            case 1511L: return "bfk_ia32_getexpps256_mask";
            case 1512L: return "bfk_ia32_getexpps512_mask";
            case 1513L: return "bfk_ia32_getexpsd128_round";
            case 1514L: return "bfk_ia32_getexpsd128_round_mask";
            case 1515L: return "bfk_ia32_getexpsd_mask_round";
            case 1516L: return "bfk_ia32_getexpss128_round";
            case 1517L: return "bfk_ia32_getexpss128_round_mask";
            case 1518L: return "bfk_ia32_getexpss_mask_round";
            case 1519L: return "bfk_ia32_getmantpd128_mask";
            case 1520L: return "bfk_ia32_getmantpd256_mask";
            case 1521L: return "bfk_ia32_getmantpd512_mask";
            case 1522L: return "bfk_ia32_getmantps128_mask";
            case 1523L: return "bfk_ia32_getmantps256_mask";
            case 1524L: return "bfk_ia32_getmantps512_mask";
            case 1525L: return "bfk_ia32_getmantsd_mask_round";
            case 1526L: return "bfk_ia32_getmantsd_round";
            case 1527L: return "bfk_ia32_getmantsd_round_mask";
            case 1528L: return "bfk_ia32_getmantss_mask_round";
            case 1529L: return "bfk_ia32_getmantss_round";
            case 1530L: return "bfk_ia32_getmantss_round_mask";
            case 1531L: return "bfk_ia32_haddpd";
            case 1532L: return "bfk_ia32_haddpd256";
            case 1533L: return "bfk_ia32_haddps";
            case 1534L: return "bfk_ia32_haddps256";
            case 1535L: return "bfk_ia32_hreset";
            case 1536L: return "bfk_ia32_hsubpd";
            case 1537L: return "bfk_ia32_hsubpd256";
            case 1538L: return "bfk_ia32_hsubps";
            case 1539L: return "bfk_ia32_hsubps256";
            case 1540L: return "bfk_ia32_incsspd";
            case 1541L: return "bfk_ia32_incsspq";
            case 1542L: return "bfk_ia32_insert128i256";
            case 1543L: return "bfk_ia32_insertf32x4";
            case 1544L: return "bfk_ia32_insertf32x4_256";
            case 1545L: return "bfk_ia32_insertf32x4_256_mask";
            case 1546L: return "bfk_ia32_insertf32x4_mask";
            case 1547L: return "bfk_ia32_insertf32x8";
            case 1548L: return "bfk_ia32_insertf32x8_mask";
            case 1549L: return "bfk_ia32_insertf64x2_256";
            case 1550L: return "bfk_ia32_insertf64x2_256_mask";
            case 1551L: return "bfk_ia32_insertf64x2_512";
            case 1552L: return "bfk_ia32_insertf64x2_512_mask";
            case 1553L: return "bfk_ia32_insertf64x4";
            case 1554L: return "bfk_ia32_insertf64x4_mask";
            case 1555L: return "bfk_ia32_inserti32x4";
            case 1556L: return "bfk_ia32_inserti32x4_256";
            case 1557L: return "bfk_ia32_inserti32x4_256_mask";
            case 1558L: return "bfk_ia32_inserti32x4_mask";
            case 1559L: return "bfk_ia32_inserti32x8";
            case 1560L: return "bfk_ia32_inserti32x8_mask";
            case 1561L: return "bfk_ia32_inserti64x2_256";
            case 1562L: return "bfk_ia32_inserti64x2_256_mask";
            case 1563L: return "bfk_ia32_inserti64x2_512";
            case 1564L: return "bfk_ia32_inserti64x2_512_mask";
            case 1565L: return "bfk_ia32_inserti64x4";
            case 1566L: return "bfk_ia32_inserti64x4_mask";
            case 1567L: return "bfk_ia32_insertps128";
            case 1568L: return "bfk_ia32_insertq";
            case 1569L: return "bfk_ia32_insertqi";
            case 1570L: return "bfk_ia32_invpcid";
            case 1571L: return "bfk_ia32_kadddi";
            case 1572L: return "bfk_ia32_kaddhi";
            case 1573L: return "bfk_ia32_kaddqi";
            case 1574L: return "bfk_ia32_kaddsi";
            case 1575L: return "bfk_ia32_kanddi";
            case 1576L: return "bfk_ia32_kandhi";
            case 1577L: return "bfk_ia32_kandndi";
            case 1578L: return "bfk_ia32_kandnhi";
            case 1579L: return "bfk_ia32_kandnqi";
            case 1580L: return "bfk_ia32_kandnsi";
            case 1581L: return "bfk_ia32_kandqi";
            case 1582L: return "bfk_ia32_kandsi";
            case 1583L: return "bfk_ia32_kmov16";
            case 1584L: return "bfk_ia32_kmovb";
            case 1585L: return "bfk_ia32_kmovd";
            case 1586L: return "bfk_ia32_kmovq";
            case 1587L: return "bfk_ia32_kmovw";
            case 1588L: return "bfk_ia32_knotdi";
            case 1589L: return "bfk_ia32_knothi";
            case 1590L: return "bfk_ia32_knotqi";
            case 1591L: return "bfk_ia32_knotsi";
            case 1592L: return "bfk_ia32_kordi";
            case 1593L: return "bfk_ia32_korhi";
            case 1594L: return "bfk_ia32_korqi";
            case 1595L: return "bfk_ia32_korsi";
            case 1596L: return "bfk_ia32_kortestcdi";
            case 1597L: return "bfk_ia32_kortestchi";
            case 1598L: return "bfk_ia32_kortestcqi";
            case 1599L: return "bfk_ia32_kortestcsi";
            case 1600L: return "bfk_ia32_kortestzdi";
            case 1601L: return "bfk_ia32_kortestzhi";
            case 1602L: return "bfk_ia32_kortestzqi";
            case 1603L: return "bfk_ia32_kortestzsi";
            case 1604L: return "bfk_ia32_kshiftlidi";
            case 1605L: return "bfk_ia32_kshiftlihi";
            case 1606L: return "bfk_ia32_kshiftliqi";
            case 1607L: return "bfk_ia32_kshiftlisi";
            case 1608L: return "bfk_ia32_kshiftridi";
            case 1609L: return "bfk_ia32_kshiftrihi";
            case 1610L: return "bfk_ia32_kshiftriqi";
            case 1611L: return "bfk_ia32_kshiftrisi";
            case 1612L: return "bfk_ia32_ktestcdi";
            case 1613L: return "bfk_ia32_ktestchi";
            case 1614L: return "bfk_ia32_ktestcqi";
            case 1615L: return "bfk_ia32_ktestcsi";
            case 1616L: return "bfk_ia32_ktestzdi";
            case 1617L: return "bfk_ia32_ktestzhi";
            case 1618L: return "bfk_ia32_ktestzqi";
            case 1619L: return "bfk_ia32_ktestzsi";
            case 1620L: return "bfk_ia32_kunpckdi";
            case 1621L: return "bfk_ia32_kunpckhi";
            case 1622L: return "bfk_ia32_kunpcksi";
            case 1623L: return "bfk_ia32_kxnordi";
            case 1624L: return "bfk_ia32_kxnorhi";
            case 1625L: return "bfk_ia32_kxnorqi";
            case 1626L: return "bfk_ia32_kxnorsi";
            case 1627L: return "bfk_ia32_kxordi";
            case 1628L: return "bfk_ia32_kxorhi";
            case 1629L: return "bfk_ia32_kxorqi";
            case 1630L: return "bfk_ia32_kxorsi";
            case 1631L: return "bfk_ia32_lddqu";
            case 1632L: return "bfk_ia32_lddqu256";
            case 1633L: return "bfk_ia32_ldmxcsr";
            case 1634L: return "bfk_ia32_lfence";
            case 1635L: return "bfk_ia32_llwpcb";
            case 1636L: return "bfk_ia32_loadapd128_mask";
            case 1637L: return "bfk_ia32_loadapd256_mask";
            case 1638L: return "bfk_ia32_loadapd512_mask";
            case 1639L: return "bfk_ia32_loadaps";
            case 1640L: return "bfk_ia32_loadaps128_mask";
            case 1641L: return "bfk_ia32_loadaps256_mask";
            case 1642L: return "bfk_ia32_loadaps512_mask";
            case 1643L: return "bfk_ia32_loadddup";
            case 1644L: return "bfk_ia32_loaddqu";
            case 1645L: return "bfk_ia32_loaddqu256";
            case 1646L: return "bfk_ia32_loaddqudi128_mask";
            case 1647L: return "bfk_ia32_loaddqudi256_mask";
            case 1648L: return "bfk_ia32_loaddqudi512_mask";
            case 1649L: return "bfk_ia32_loaddquhi128_mask";
            case 1650L: return "bfk_ia32_loaddquhi256_mask";
            case 1651L: return "bfk_ia32_loaddquhi512_mask";
            case 1652L: return "bfk_ia32_loaddquqi128_mask";
            case 1653L: return "bfk_ia32_loaddquqi256_mask";
            case 1654L: return "bfk_ia32_loaddquqi512_mask";
            case 1655L: return "bfk_ia32_loaddqusi128_mask";
            case 1656L: return "bfk_ia32_loaddqusi256_mask";
            case 1657L: return "bfk_ia32_loaddqusi512_mask";
            case 1658L: return "bfk_ia32_loadhpd";
            case 1659L: return "bfk_ia32_loadhps";
            case 1660L: return "bfk_ia32_loadiwkey";
            case 1661L: return "bfk_ia32_loadlpd";
            case 1662L: return "bfk_ia32_loadlps";
            case 1663L: return "bfk_ia32_loadsd128_mask";
            case 1664L: return "bfk_ia32_loadsd_mask";
            case 1665L: return "bfk_ia32_loadss";
            case 1666L: return "bfk_ia32_loadss128_mask";
            case 1667L: return "bfk_ia32_loadss_mask";
            case 1668L: return "bfk_ia32_loadupd";
            case 1669L: return "bfk_ia32_loadupd128_mask";
            case 1670L: return "bfk_ia32_loadupd256";
            case 1671L: return "bfk_ia32_loadupd256_mask";
            case 1672L: return "bfk_ia32_loadupd512_mask";
            case 1673L: return "bfk_ia32_loadups";
            case 1674L: return "bfk_ia32_loadups128_mask";
            case 1675L: return "bfk_ia32_loadups256";
            case 1676L: return "bfk_ia32_loadups256_mask";
            case 1677L: return "bfk_ia32_loadups512_mask";
            case 1678L: return "bfk_ia32_lwpins32";
            case 1679L: return "bfk_ia32_lwpins64";
            case 1680L: return "bfk_ia32_lwpval32";
            case 1681L: return "bfk_ia32_lwpval64";
            case 1682L: return "bfk_ia32_lzcnt_u16";
            case 1683L: return "bfk_ia32_lzcnt_u32";
            case 1684L: return "bfk_ia32_lzcnt_u64";
            case 1685L: return "bfk_ia32_maskloadd";
            case 1686L: return "bfk_ia32_maskloadd256";
            case 1687L: return "bfk_ia32_maskloadpd";
            case 1688L: return "bfk_ia32_maskloadpd256";
            case 1689L: return "bfk_ia32_maskloadps";
            case 1690L: return "bfk_ia32_maskloadps256";
            case 1691L: return "bfk_ia32_maskloadq";
            case 1692L: return "bfk_ia32_maskloadq256";
            case 1693L: return "bfk_ia32_maskmovdqu";
            case 1694L: return "bfk_ia32_maskmovq";
            case 1695L: return "bfk_ia32_maskstored";
            case 1696L: return "bfk_ia32_maskstored256";
            case 1697L: return "bfk_ia32_maskstorepd";
            case 1698L: return "bfk_ia32_maskstorepd256";
            case 1699L: return "bfk_ia32_maskstoreps";
            case 1700L: return "bfk_ia32_maskstoreps256";
            case 1701L: return "bfk_ia32_maskstoreq";
            case 1702L: return "bfk_ia32_maskstoreq256";
            case 1703L: return "bfk_ia32_maxpd";
            case 1704L: return "bfk_ia32_maxpd256";
            case 1705L: return "bfk_ia32_maxpd256_mask";
            case 1706L: return "bfk_ia32_maxpd512";
            case 1707L: return "bfk_ia32_maxpd512_mask";
            case 1708L: return "bfk_ia32_maxpd_mask";
            case 1709L: return "bfk_ia32_maxps";
            case 1710L: return "bfk_ia32_maxps256";
            case 1711L: return "bfk_ia32_maxps256_mask";
            case 1712L: return "bfk_ia32_maxps512";
            case 1713L: return "bfk_ia32_maxps512_mask";
            case 1714L: return "bfk_ia32_maxps_mask";
            case 1715L: return "bfk_ia32_maxsd";
            case 1716L: return "bfk_ia32_maxsd_mask_round";
            case 1717L: return "bfk_ia32_maxsd_round";
            case 1718L: return "bfk_ia32_maxsd_round_mask";
            case 1719L: return "bfk_ia32_maxss";
            case 1720L: return "bfk_ia32_maxss_mask_round";
            case 1721L: return "bfk_ia32_maxss_round";
            case 1722L: return "bfk_ia32_maxss_round_mask";
            case 1723L: return "bfk_ia32_mfence";
            case 1724L: return "bfk_ia32_minpd";
            case 1725L: return "bfk_ia32_minpd256";
            case 1726L: return "bfk_ia32_minpd256_mask";
            case 1727L: return "bfk_ia32_minpd512";
            case 1728L: return "bfk_ia32_minpd512_mask";
            case 1729L: return "bfk_ia32_minpd_mask";
            case 1730L: return "bfk_ia32_minps";
            case 1731L: return "bfk_ia32_minps256";
            case 1732L: return "bfk_ia32_minps256_mask";
            case 1733L: return "bfk_ia32_minps512";
            case 1734L: return "bfk_ia32_minps512_mask";
            case 1735L: return "bfk_ia32_minps_mask";
            case 1736L: return "bfk_ia32_minsd";
            case 1737L: return "bfk_ia32_minsd_mask_round";
            case 1738L: return "bfk_ia32_minsd_round";
            case 1739L: return "bfk_ia32_minsd_round_mask";
            case 1740L: return "bfk_ia32_minss";
            case 1741L: return "bfk_ia32_minss_mask_round";
            case 1742L: return "bfk_ia32_minss_round";
            case 1743L: return "bfk_ia32_minss_round_mask";
            case 1744L: return "bfk_ia32_monitor";
            case 1745L: return "bfk_ia32_monitorx";
            case 1746L: return "bfk_ia32_movapd128_mask";
            case 1747L: return "bfk_ia32_movapd256_mask";
            case 1748L: return "bfk_ia32_movapd512_mask";
            case 1749L: return "bfk_ia32_movaps128_mask";
            case 1750L: return "bfk_ia32_movaps256_mask";
            case 1751L: return "bfk_ia32_movaps512_mask";
            case 1752L: return "bfk_ia32_movddup";
            case 1753L: return "bfk_ia32_movddup128_mask";
            case 1754L: return "bfk_ia32_movddup256";
            case 1755L: return "bfk_ia32_movddup256_mask";
            case 1756L: return "bfk_ia32_movddup512_mask";
            case 1757L: return "bfk_ia32_movdir64b";
            case 1758L: return "bfk_ia32_movdqa32_128_mask";
            case 1759L: return "bfk_ia32_movdqa32_256_mask";
            case 1760L: return "bfk_ia32_movdqa32_512_mask";
            case 1761L: return "bfk_ia32_movdqa32load128_mask";
            case 1762L: return "bfk_ia32_movdqa32load256_mask";
            case 1763L: return "bfk_ia32_movdqa32load512_mask";
            case 1764L: return "bfk_ia32_movdqa32store128_mask";
            case 1765L: return "bfk_ia32_movdqa32store256_mask";
            case 1766L: return "bfk_ia32_movdqa32store512_mask";
            case 1767L: return "bfk_ia32_movdqa64_128_mask";
            case 1768L: return "bfk_ia32_movdqa64_256_mask";
            case 1769L: return "bfk_ia32_movdqa64_512_mask";
            case 1770L: return "bfk_ia32_movdqa64load128_mask";
            case 1771L: return "bfk_ia32_movdqa64load256_mask";
            case 1772L: return "bfk_ia32_movdqa64load512_mask";
            case 1773L: return "bfk_ia32_movdqa64store128_mask";
            case 1774L: return "bfk_ia32_movdqa64store256_mask";
            case 1775L: return "bfk_ia32_movdqa64store512_mask";
            case 1776L: return "bfk_ia32_movdquhi128_mask";
            case 1777L: return "bfk_ia32_movdquhi256_mask";
            case 1778L: return "bfk_ia32_movdquhi512_mask";
            case 1779L: return "bfk_ia32_movdquqi128_mask";
            case 1780L: return "bfk_ia32_movdquqi256_mask";
            case 1781L: return "bfk_ia32_movdquqi512_mask";
            case 1782L: return "bfk_ia32_movesd_mask";
            case 1783L: return "bfk_ia32_movess_mask";
            case 1784L: return "bfk_ia32_movhlps";
            case 1785L: return "bfk_ia32_movlhps";
            case 1786L: return "bfk_ia32_movmskpd";
            case 1787L: return "bfk_ia32_movmskpd256";
            case 1788L: return "bfk_ia32_movmskps";
            case 1789L: return "bfk_ia32_movmskps256";
            case 1790L: return "bfk_ia32_movntdq";
            case 1791L: return "bfk_ia32_movntdq256";
            case 1792L: return "bfk_ia32_movntdq512";
            case 1793L: return "bfk_ia32_movntdqa";
            case 1794L: return "bfk_ia32_movntdqa256";
            case 1795L: return "bfk_ia32_movntdqa512";
            case 1796L: return "bfk_ia32_movnti";
            case 1797L: return "bfk_ia32_movnti64";
            case 1798L: return "bfk_ia32_movntpd";
            case 1799L: return "bfk_ia32_movntpd256";
            case 1800L: return "bfk_ia32_movntpd512";
            case 1801L: return "bfk_ia32_movntps";
            case 1802L: return "bfk_ia32_movntps256";
            case 1803L: return "bfk_ia32_movntps512";
            case 1804L: return "bfk_ia32_movntq";
            case 1805L: return "bfk_ia32_movntsd";
            case 1806L: return "bfk_ia32_movntss";
            case 1807L: return "bfk_ia32_movq128";
            case 1808L: return "bfk_ia32_movsd";
            case 1809L: return "bfk_ia32_movshdup";
            case 1810L: return "bfk_ia32_movshdup128_mask";
            case 1811L: return "bfk_ia32_movshdup256";
            case 1812L: return "bfk_ia32_movshdup256_mask";
            case 1813L: return "bfk_ia32_movshdup512_mask";
            case 1814L: return "bfk_ia32_movsldup";
            case 1815L: return "bfk_ia32_movsldup128_mask";
            case 1816L: return "bfk_ia32_movsldup256";
            case 1817L: return "bfk_ia32_movsldup256_mask";
            case 1818L: return "bfk_ia32_movsldup512_mask";
            case 1819L: return "bfk_ia32_movss";
            case 1820L: return "bfk_ia32_mpsadbw128";
            case 1821L: return "bfk_ia32_mpsadbw256";
            case 1822L: return "bfk_ia32_mulpd";
            case 1823L: return "bfk_ia32_mulpd256";
            case 1824L: return "bfk_ia32_mulpd256_mask";
            case 1825L: return "bfk_ia32_mulpd512";
            case 1826L: return "bfk_ia32_mulpd512_mask";
            case 1827L: return "bfk_ia32_mulpd_mask";
            case 1828L: return "bfk_ia32_mulps";
            case 1829L: return "bfk_ia32_mulps256";
            case 1830L: return "bfk_ia32_mulps256_mask";
            case 1831L: return "bfk_ia32_mulps512";
            case 1832L: return "bfk_ia32_mulps512_mask";
            case 1833L: return "bfk_ia32_mulps_mask";
            case 1834L: return "bfk_ia32_mulsd";
            case 1835L: return "bfk_ia32_mulsd_mask_round";
            case 1836L: return "bfk_ia32_mulsd_round";
            case 1837L: return "bfk_ia32_mulsd_round_mask";
            case 1838L: return "bfk_ia32_mulss";
            case 1839L: return "bfk_ia32_mulss_mask_round";
            case 1840L: return "bfk_ia32_mulss_round";
            case 1841L: return "bfk_ia32_mulss_round_mask";
            case 1842L: return "bfk_ia32_mwait";
            case 1843L: return "bfk_ia32_mwaitx";
            case 1844L: return "bfk_ia32_orpd";
            case 1845L: return "bfk_ia32_orpd128_mask";
            case 1846L: return "bfk_ia32_orpd256";
            case 1847L: return "bfk_ia32_orpd256_mask";
            case 1848L: return "bfk_ia32_orpd512_mask";
            case 1849L: return "bfk_ia32_orps";
            case 1850L: return "bfk_ia32_orps128_mask";
            case 1851L: return "bfk_ia32_orps256";
            case 1852L: return "bfk_ia32_orps256_mask";
            case 1853L: return "bfk_ia32_orps512_mask";
            case 1854L: return "bfk_ia32_pabsb";
            case 1855L: return "bfk_ia32_pabsb128";
            case 1856L: return "bfk_ia32_pabsb128_mask";
            case 1857L: return "bfk_ia32_pabsb256";
            case 1858L: return "bfk_ia32_pabsb256_mask";
            case 1859L: return "bfk_ia32_pabsb512";
            case 1860L: return "bfk_ia32_pabsb512_mask";
            case 1861L: return "bfk_ia32_pabsd";
            case 1862L: return "bfk_ia32_pabsd128";
            case 1863L: return "bfk_ia32_pabsd128_mask";
            case 1864L: return "bfk_ia32_pabsd256";
            case 1865L: return "bfk_ia32_pabsd256_mask";
            case 1866L: return "bfk_ia32_pabsd512";
            case 1867L: return "bfk_ia32_pabsd512_mask";
            case 1868L: return "bfk_ia32_pabsq128";
            case 1869L: return "bfk_ia32_pabsq128_mask";
            case 1870L: return "bfk_ia32_pabsq256";
            case 1871L: return "bfk_ia32_pabsq256_mask";
            case 1872L: return "bfk_ia32_pabsq512";
            case 1873L: return "bfk_ia32_pabsq512_mask";
            case 1874L: return "bfk_ia32_pabsw";
            case 1875L: return "bfk_ia32_pabsw128";
            case 1876L: return "bfk_ia32_pabsw128_mask";
            case 1877L: return "bfk_ia32_pabsw256";
            case 1878L: return "bfk_ia32_pabsw256_mask";
            case 1879L: return "bfk_ia32_pabsw512";
            case 1880L: return "bfk_ia32_pabsw512_mask";
            case 1881L: return "bfk_ia32_packssdw";
            case 1882L: return "bfk_ia32_packssdw128";
            case 1883L: return "bfk_ia32_packssdw128_mask";
            case 1884L: return "bfk_ia32_packssdw256";
            case 1885L: return "bfk_ia32_packssdw256_mask";
            case 1886L: return "bfk_ia32_packssdw512";
            case 1887L: return "bfk_ia32_packssdw512_mask";
            case 1888L: return "bfk_ia32_packsswb";
            case 1889L: return "bfk_ia32_packsswb128";
            case 1890L: return "bfk_ia32_packsswb128_mask";
            case 1891L: return "bfk_ia32_packsswb256";
            case 1892L: return "bfk_ia32_packsswb256_mask";
            case 1893L: return "bfk_ia32_packsswb512";
            case 1894L: return "bfk_ia32_packsswb512_mask";
            case 1895L: return "bfk_ia32_packusdw128";
            case 1896L: return "bfk_ia32_packusdw128_mask";
            case 1897L: return "bfk_ia32_packusdw256";
            case 1898L: return "bfk_ia32_packusdw256_mask";
            case 1899L: return "bfk_ia32_packusdw512";
            case 1900L: return "bfk_ia32_packusdw512_mask";
            case 1901L: return "bfk_ia32_packuswb";
            case 1902L: return "bfk_ia32_packuswb128";
            case 1903L: return "bfk_ia32_packuswb128_mask";
            case 1904L: return "bfk_ia32_packuswb256";
            case 1905L: return "bfk_ia32_packuswb256_mask";
            case 1906L: return "bfk_ia32_packuswb512";
            case 1907L: return "bfk_ia32_packuswb512_mask";
            case 1908L: return "bfk_ia32_paddb";
            case 1909L: return "bfk_ia32_paddb128";
            case 1910L: return "bfk_ia32_paddb128_mask";
            case 1911L: return "bfk_ia32_paddb256";
            case 1912L: return "bfk_ia32_paddb256_mask";
            case 1913L: return "bfk_ia32_paddb512_mask";
            case 1914L: return "bfk_ia32_paddd";
            case 1915L: return "bfk_ia32_paddd128";
            case 1916L: return "bfk_ia32_paddd128_mask";
            case 1917L: return "bfk_ia32_paddd256";
            case 1918L: return "bfk_ia32_paddd256_mask";
            case 1919L: return "bfk_ia32_paddd512_mask";
            case 1920L: return "bfk_ia32_paddq";
            case 1921L: return "bfk_ia32_paddq128";
            case 1922L: return "bfk_ia32_paddq128_mask";
            case 1923L: return "bfk_ia32_paddq256";
            case 1924L: return "bfk_ia32_paddq256_mask";
            case 1925L: return "bfk_ia32_paddq512_mask";
            case 1926L: return "bfk_ia32_paddsb";
            case 1927L: return "bfk_ia32_paddsb128";
            case 1928L: return "bfk_ia32_paddsb128_mask";
            case 1929L: return "bfk_ia32_paddsb256";
            case 1930L: return "bfk_ia32_paddsb256_mask";
            case 1931L: return "bfk_ia32_paddsb512";
            case 1932L: return "bfk_ia32_paddsb512_mask";
            case 1933L: return "bfk_ia32_paddsw";
            case 1934L: return "bfk_ia32_paddsw128";
            case 1935L: return "bfk_ia32_paddsw128_mask";
            case 1936L: return "bfk_ia32_paddsw256";
            case 1937L: return "bfk_ia32_paddsw256_mask";
            case 1938L: return "bfk_ia32_paddsw512";
            case 1939L: return "bfk_ia32_paddsw512_mask";
            case 1940L: return "bfk_ia32_paddusb";
            case 1941L: return "bfk_ia32_paddusb128";
            case 1942L: return "bfk_ia32_paddusb128_mask";
            case 1943L: return "bfk_ia32_paddusb256";
            case 1944L: return "bfk_ia32_paddusb256_mask";
            case 1945L: return "bfk_ia32_paddusb512";
            case 1946L: return "bfk_ia32_paddusb512_mask";
            case 1947L: return "bfk_ia32_paddusw";
            case 1948L: return "bfk_ia32_paddusw128";
            case 1949L: return "bfk_ia32_paddusw128_mask";
            case 1950L: return "bfk_ia32_paddusw256";
            case 1951L: return "bfk_ia32_paddusw256_mask";
            case 1952L: return "bfk_ia32_paddusw512";
            case 1953L: return "bfk_ia32_paddusw512_mask";
            case 1954L: return "bfk_ia32_paddw";
            case 1955L: return "bfk_ia32_paddw128";
            case 1956L: return "bfk_ia32_paddw128_mask";
            case 1957L: return "bfk_ia32_paddw256";
            case 1958L: return "bfk_ia32_paddw256_mask";
            case 1959L: return "bfk_ia32_paddw512_mask";
            case 1960L: return "bfk_ia32_palignr";
            case 1961L: return "bfk_ia32_palignr128";
            case 1962L: return "bfk_ia32_palignr128_mask";
            case 1963L: return "bfk_ia32_palignr256";
            case 1964L: return "bfk_ia32_palignr256_mask";
            case 1965L: return "bfk_ia32_palignr512";
            case 1966L: return "bfk_ia32_palignr512_mask";
            case 1967L: return "bfk_ia32_pand";
            case 1968L: return "bfk_ia32_pand128";
            case 1969L: return "bfk_ia32_pandd128_mask";
            case 1970L: return "bfk_ia32_pandd256_mask";
            case 1971L: return "bfk_ia32_pandd512_mask";
            case 1972L: return "bfk_ia32_pandn";
            case 1973L: return "bfk_ia32_pandn128";
            case 1974L: return "bfk_ia32_pandnd128_mask";
            case 1975L: return "bfk_ia32_pandnd256_mask";
            case 1976L: return "bfk_ia32_pandnd512_mask";
            case 1977L: return "bfk_ia32_pandnq128_mask";
            case 1978L: return "bfk_ia32_pandnq256_mask";
            case 1979L: return "bfk_ia32_pandnq512_mask";
            case 1980L: return "bfk_ia32_pandq128_mask";
            case 1981L: return "bfk_ia32_pandq256_mask";
            case 1982L: return "bfk_ia32_pandq512_mask";
            case 1983L: return "bfk_ia32_pause";
            case 1984L: return "bfk_ia32_pavgb";
            case 1985L: return "bfk_ia32_pavgb128";
            case 1986L: return "bfk_ia32_pavgb128_mask";
            case 1987L: return "bfk_ia32_pavgb256";
            case 1988L: return "bfk_ia32_pavgb256_mask";
            case 1989L: return "bfk_ia32_pavgb512";
            case 1990L: return "bfk_ia32_pavgb512_mask";
            case 1991L: return "bfk_ia32_pavgusb";
            case 1992L: return "bfk_ia32_pavgw";
            case 1993L: return "bfk_ia32_pavgw128";
            case 1994L: return "bfk_ia32_pavgw128_mask";
            case 1995L: return "bfk_ia32_pavgw256";
            case 1996L: return "bfk_ia32_pavgw256_mask";
            case 1997L: return "bfk_ia32_pavgw512";
            case 1998L: return "bfk_ia32_pavgw512_mask";
            case 1999L: return "bfk_ia32_pblendd128";
            case 2000L: return "bfk_ia32_pblendd256";
            case 2001L: return "bfk_ia32_pblendvb128";
            case 2002L: return "bfk_ia32_pblendvb256";
            case 2003L: return "bfk_ia32_pblendw128";
            case 2004L: return "bfk_ia32_pblendw256";
            case 2005L: return "bfk_ia32_pbroadcastb128";
            case 2006L: return "bfk_ia32_pbroadcastb128_gpr_mask";
            case 2007L: return "bfk_ia32_pbroadcastb128_mask";
            case 2008L: return "bfk_ia32_pbroadcastb256";
            case 2009L: return "bfk_ia32_pbroadcastb256_gpr_mask";
            case 2010L: return "bfk_ia32_pbroadcastb256_mask";
            case 2011L: return "bfk_ia32_pbroadcastb512_gpr_mask";
            case 2012L: return "bfk_ia32_pbroadcastb512_mask";
            case 2013L: return "bfk_ia32_pbroadcastd128";
            case 2014L: return "bfk_ia32_pbroadcastd128_gpr_mask";
            case 2015L: return "bfk_ia32_pbroadcastd128_mask";
            case 2016L: return "bfk_ia32_pbroadcastd256";
            case 2017L: return "bfk_ia32_pbroadcastd256_gpr_mask";
            case 2018L: return "bfk_ia32_pbroadcastd256_mask";
            case 2019L: return "bfk_ia32_pbroadcastd512";
            case 2020L: return "bfk_ia32_pbroadcastd512_gpr_mask";
            case 2021L: return "bfk_ia32_pbroadcastq128";
            case 2022L: return "bfk_ia32_pbroadcastq128_gpr_mask";
            case 2023L: return "bfk_ia32_pbroadcastq128_mask";
            case 2024L: return "bfk_ia32_pbroadcastq256";
            case 2025L: return "bfk_ia32_pbroadcastq256_gpr_mask";
            case 2026L: return "bfk_ia32_pbroadcastq256_mask";
            case 2027L: return "bfk_ia32_pbroadcastq512";
            case 2028L: return "bfk_ia32_pbroadcastq512_gpr_mask";
            case 2029L: return "bfk_ia32_pbroadcastq512_mem_mask";
            case 2030L: return "bfk_ia32_pbroadcastw128";
            case 2031L: return "bfk_ia32_pbroadcastw128_gpr_mask";
            case 2032L: return "bfk_ia32_pbroadcastw128_mask";
            case 2033L: return "bfk_ia32_pbroadcastw256";
            case 2034L: return "bfk_ia32_pbroadcastw256_gpr_mask";
            case 2035L: return "bfk_ia32_pbroadcastw256_mask";
            case 2036L: return "bfk_ia32_pbroadcastw512_gpr_mask";
            case 2037L: return "bfk_ia32_pbroadcastw512_mask";
            case 2038L: return "bfk_ia32_pclmulqdq128";
            case 2039L: return "bfk_ia32_pclmulqdq256";
            case 2040L: return "bfk_ia32_pclmulqdq512";
            case 2041L: return "bfk_ia32_pcmov";
            case 2042L: return "bfk_ia32_pcmov_v16qi";
            case 2043L: return "bfk_ia32_pcmov_v2df";
            case 2044L: return "bfk_ia32_pcmov_v2di";
            case 2045L: return "bfk_ia32_pcmov_v4sf";
            case 2046L: return "bfk_ia32_pcmov_v4si";
            case 2047L: return "bfk_ia32_pcmov_v8hi";
            case 2048L: return "bfk_ia32_pcmpeqb";
            case 2049L: return "bfk_ia32_pcmpeqb128";
            case 2050L: return "bfk_ia32_pcmpeqb128_mask";
            case 2051L: return "bfk_ia32_pcmpeqb256";
            case 2052L: return "bfk_ia32_pcmpeqb256_mask";
            case 2053L: return "bfk_ia32_pcmpeqb512_mask";
            case 2054L: return "bfk_ia32_pcmpeqd";
            case 2055L: return "bfk_ia32_pcmpeqd128";
            case 2056L: return "bfk_ia32_pcmpeqd128_mask";
            case 2057L: return "bfk_ia32_pcmpeqd256";
            case 2058L: return "bfk_ia32_pcmpeqd256_mask";
            case 2059L: return "bfk_ia32_pcmpeqd512_mask";
            case 2060L: return "bfk_ia32_pcmpeqq";
            case 2061L: return "bfk_ia32_pcmpeqq128_mask";
            case 2062L: return "bfk_ia32_pcmpeqq256";
            case 2063L: return "bfk_ia32_pcmpeqq256_mask";
            case 2064L: return "bfk_ia32_pcmpeqq512_mask";
            case 2065L: return "bfk_ia32_pcmpeqw";
            case 2066L: return "bfk_ia32_pcmpeqw128";
            case 2067L: return "bfk_ia32_pcmpeqw128_mask";
            case 2068L: return "bfk_ia32_pcmpeqw256";
            case 2069L: return "bfk_ia32_pcmpeqw256_mask";
            case 2070L: return "bfk_ia32_pcmpeqw512_mask";
            case 2071L: return "bfk_ia32_pcmpestri128";
            case 2072L: return "bfk_ia32_pcmpestria128";
            case 2073L: return "bfk_ia32_pcmpestric128";
            case 2074L: return "bfk_ia32_pcmpestrio128";
            case 2075L: return "bfk_ia32_pcmpestris128";
            case 2076L: return "bfk_ia32_pcmpestriz128";
            case 2077L: return "bfk_ia32_pcmpestrm128";
            case 2078L: return "bfk_ia32_pcmpgtb";
            case 2079L: return "bfk_ia32_pcmpgtb128";
            case 2080L: return "bfk_ia32_pcmpgtb128_mask";
            case 2081L: return "bfk_ia32_pcmpgtb256";
            case 2082L: return "bfk_ia32_pcmpgtb256_mask";
            case 2083L: return "bfk_ia32_pcmpgtb512_mask";
            case 2084L: return "bfk_ia32_pcmpgtd";
            case 2085L: return "bfk_ia32_pcmpgtd128";
            case 2086L: return "bfk_ia32_pcmpgtd128_mask";
            case 2087L: return "bfk_ia32_pcmpgtd256";
            case 2088L: return "bfk_ia32_pcmpgtd256_mask";
            case 2089L: return "bfk_ia32_pcmpgtd512_mask";
            case 2090L: return "bfk_ia32_pcmpgtq";
            case 2091L: return "bfk_ia32_pcmpgtq128_mask";
            case 2092L: return "bfk_ia32_pcmpgtq256";
            case 2093L: return "bfk_ia32_pcmpgtq256_mask";
            case 2094L: return "bfk_ia32_pcmpgtq512_mask";
            case 2095L: return "bfk_ia32_pcmpgtw";
            case 2096L: return "bfk_ia32_pcmpgtw128";
            case 2097L: return "bfk_ia32_pcmpgtw128_mask";
            case 2098L: return "bfk_ia32_pcmpgtw256";
            case 2099L: return "bfk_ia32_pcmpgtw256_mask";
            case 2100L: return "bfk_ia32_pcmpgtw512_mask";
            case 2101L: return "bfk_ia32_pcmpistri128";
            case 2102L: return "bfk_ia32_pcmpistria128";
            case 2103L: return "bfk_ia32_pcmpistric128";
            case 2104L: return "bfk_ia32_pcmpistrio128";
            case 2105L: return "bfk_ia32_pcmpistris128";
            case 2106L: return "bfk_ia32_pcmpistriz128";
            case 2107L: return "bfk_ia32_pcmpistrm128";
            case 2108L: return "bfk_ia32_pcomeqb";
            case 2109L: return "bfk_ia32_pcomeqd";
            case 2110L: return "bfk_ia32_pcomeqq";
            case 2111L: return "bfk_ia32_pcomequb";
            case 2112L: return "bfk_ia32_pcomequd";
            case 2113L: return "bfk_ia32_pcomequq";
            case 2114L: return "bfk_ia32_pcomequw";
            case 2115L: return "bfk_ia32_pcomeqw";
            case 2116L: return "bfk_ia32_pcomfalseb";
            case 2117L: return "bfk_ia32_pcomfalsed";
            case 2118L: return "bfk_ia32_pcomfalseq";
            case 2119L: return "bfk_ia32_pcomfalseub";
            case 2120L: return "bfk_ia32_pcomfalseud";
            case 2121L: return "bfk_ia32_pcomfalseuq";
            case 2122L: return "bfk_ia32_pcomfalseuw";
            case 2123L: return "bfk_ia32_pcomfalsew";
            case 2124L: return "bfk_ia32_pcomgeb";
            case 2125L: return "bfk_ia32_pcomged";
            case 2126L: return "bfk_ia32_pcomgeq";
            case 2127L: return "bfk_ia32_pcomgeub";
            case 2128L: return "bfk_ia32_pcomgeud";
            case 2129L: return "bfk_ia32_pcomgeuq";
            case 2130L: return "bfk_ia32_pcomgeuw";
            case 2131L: return "bfk_ia32_pcomgew";
            case 2132L: return "bfk_ia32_pcomgtb";
            case 2133L: return "bfk_ia32_pcomgtd";
            case 2134L: return "bfk_ia32_pcomgtq";
            case 2135L: return "bfk_ia32_pcomgtub";
            case 2136L: return "bfk_ia32_pcomgtud";
            case 2137L: return "bfk_ia32_pcomgtuq";
            case 2138L: return "bfk_ia32_pcomgtuw";
            case 2139L: return "bfk_ia32_pcomgtw";
            case 2140L: return "bfk_ia32_pcomleb";
            case 2141L: return "bfk_ia32_pcomled";
            case 2142L: return "bfk_ia32_pcomleq";
            case 2143L: return "bfk_ia32_pcomleub";
            case 2144L: return "bfk_ia32_pcomleud";
            case 2145L: return "bfk_ia32_pcomleuq";
            case 2146L: return "bfk_ia32_pcomleuw";
            case 2147L: return "bfk_ia32_pcomlew";
            case 2148L: return "bfk_ia32_pcomltb";
            case 2149L: return "bfk_ia32_pcomltd";
            case 2150L: return "bfk_ia32_pcomltq";
            case 2151L: return "bfk_ia32_pcomltub";
            case 2152L: return "bfk_ia32_pcomltud";
            case 2153L: return "bfk_ia32_pcomltuq";
            case 2154L: return "bfk_ia32_pcomltuw";
            case 2155L: return "bfk_ia32_pcomltw";
            case 2156L: return "bfk_ia32_pcommit";
            case 2157L: return "bfk_ia32_pcomneb";
            case 2158L: return "bfk_ia32_pcomned";
            case 2159L: return "bfk_ia32_pcomneq";
            case 2160L: return "bfk_ia32_pcomneub";
            case 2161L: return "bfk_ia32_pcomneud";
            case 2162L: return "bfk_ia32_pcomneuq";
            case 2163L: return "bfk_ia32_pcomneuw";
            case 2164L: return "bfk_ia32_pcomnew";
            case 2165L: return "bfk_ia32_pcomtrueb";
            case 2166L: return "bfk_ia32_pcomtrued";
            case 2167L: return "bfk_ia32_pcomtrueq";
            case 2168L: return "bfk_ia32_pcomtrueub";
            case 2169L: return "bfk_ia32_pcomtrueud";
            case 2170L: return "bfk_ia32_pcomtrueuq";
            case 2171L: return "bfk_ia32_pcomtrueuw";
            case 2172L: return "bfk_ia32_pcomtruew";
            case 2173L: return "bfk_ia32_pd256_pd";
            case 2174L: return "bfk_ia32_pd512_256pd";
            case 2175L: return "bfk_ia32_pd512_pd";
            case 2176L: return "bfk_ia32_pd_pd256";
            case 2177L: return "bfk_ia32_pdep_di";
            case 2178L: return "bfk_ia32_pdep_si";
            case 2179L: return "bfk_ia32_permdf256";
            case 2180L: return "bfk_ia32_permdf256_mask";
            case 2181L: return "bfk_ia32_permdf512";
            case 2182L: return "bfk_ia32_permdf512_mask";
            case 2183L: return "bfk_ia32_permdi256";
            case 2184L: return "bfk_ia32_permdi256_mask";
            case 2185L: return "bfk_ia32_permdi512";
            case 2186L: return "bfk_ia32_permdi512_mask";
            case 2187L: return "bfk_ia32_permpd";
            case 2188L: return "bfk_ia32_permps";
            case 2189L: return "bfk_ia32_permti256";
            case 2190L: return "bfk_ia32_permvardf256";
            case 2191L: return "bfk_ia32_permvardf256_mask";
            case 2192L: return "bfk_ia32_permvardf512";
            case 2193L: return "bfk_ia32_permvardf512_mask";
            case 2194L: return "bfk_ia32_permvardi256";
            case 2195L: return "bfk_ia32_permvardi256_mask";
            case 2196L: return "bfk_ia32_permvardi512";
            case 2197L: return "bfk_ia32_permvardi512_mask";
            case 2198L: return "bfk_ia32_permvarhi128";
            case 2199L: return "bfk_ia32_permvarhi128_mask";
            case 2200L: return "bfk_ia32_permvarhi256";
            case 2201L: return "bfk_ia32_permvarhi256_mask";
            case 2202L: return "bfk_ia32_permvarhi512";
            case 2203L: return "bfk_ia32_permvarhi512_mask";
            case 2204L: return "bfk_ia32_permvarqi128";
            case 2205L: return "bfk_ia32_permvarqi128_mask";
            case 2206L: return "bfk_ia32_permvarqi256";
            case 2207L: return "bfk_ia32_permvarqi256_mask";
            case 2208L: return "bfk_ia32_permvarqi512";
            case 2209L: return "bfk_ia32_permvarqi512_mask";
            case 2210L: return "bfk_ia32_permvarsf256";
            case 2211L: return "bfk_ia32_permvarsf256_mask";
            case 2212L: return "bfk_ia32_permvarsf512";
            case 2213L: return "bfk_ia32_permvarsf512_mask";
            case 2214L: return "bfk_ia32_permvarsi256";
            case 2215L: return "bfk_ia32_permvarsi256_mask";
            case 2216L: return "bfk_ia32_permvarsi512";
            case 2217L: return "bfk_ia32_permvarsi512_mask";
            case 2218L: return "bfk_ia32_pext_di";
            case 2219L: return "bfk_ia32_pext_si";
            case 2220L: return "bfk_ia32_pextrw";
            case 2221L: return "bfk_ia32_pf2id";
            case 2222L: return "bfk_ia32_pf2iw";
            case 2223L: return "bfk_ia32_pfacc";
            case 2224L: return "bfk_ia32_pfadd";
            case 2225L: return "bfk_ia32_pfcmpeq";
            case 2226L: return "bfk_ia32_pfcmpge";
            case 2227L: return "bfk_ia32_pfcmpgt";
            case 2228L: return "bfk_ia32_pfmax";
            case 2229L: return "bfk_ia32_pfmin";
            case 2230L: return "bfk_ia32_pfmul";
            case 2231L: return "bfk_ia32_pfnacc";
            case 2232L: return "bfk_ia32_pfpnacc";
            case 2233L: return "bfk_ia32_pfrcp";
            case 2234L: return "bfk_ia32_pfrcpit1";
            case 2235L: return "bfk_ia32_pfrcpit2";
            case 2236L: return "bfk_ia32_pfrsqit1";
            case 2237L: return "bfk_ia32_pfrsqrt";
            case 2238L: return "bfk_ia32_pfrsqrtit1";
            case 2239L: return "bfk_ia32_pfsub";
            case 2240L: return "bfk_ia32_pfsubr";
            case 2241L: return "bfk_ia32_phaddbd";
            case 2242L: return "bfk_ia32_phaddbq";
            case 2243L: return "bfk_ia32_phaddbw";
            case 2244L: return "bfk_ia32_phaddd";
            case 2245L: return "bfk_ia32_phaddd128";
            case 2246L: return "bfk_ia32_phaddd256";
            case 2247L: return "bfk_ia32_phadddq";
            case 2248L: return "bfk_ia32_phaddsw";
            case 2249L: return "bfk_ia32_phaddsw128";
            case 2250L: return "bfk_ia32_phaddsw256";
            case 2251L: return "bfk_ia32_phaddubd";
            case 2252L: return "bfk_ia32_phaddubq";
            case 2253L: return "bfk_ia32_phaddubw";
            case 2254L: return "bfk_ia32_phaddudq";
            case 2255L: return "bfk_ia32_phadduwd";
            case 2256L: return "bfk_ia32_phadduwq";
            case 2257L: return "bfk_ia32_phaddw";
            case 2258L: return "bfk_ia32_phaddw128";
            case 2259L: return "bfk_ia32_phaddw256";
            case 2260L: return "bfk_ia32_phaddwd";
            case 2261L: return "bfk_ia32_phaddwq";
            case 2262L: return "bfk_ia32_phminposuw128";
            case 2263L: return "bfk_ia32_phsubbw";
            case 2264L: return "bfk_ia32_phsubd";
            case 2265L: return "bfk_ia32_phsubd128";
            case 2266L: return "bfk_ia32_phsubd256";
            case 2267L: return "bfk_ia32_phsubdq";
            case 2268L: return "bfk_ia32_phsubsw";
            case 2269L: return "bfk_ia32_phsubsw128";
            case 2270L: return "bfk_ia32_phsubsw256";
            case 2271L: return "bfk_ia32_phsubw";
            case 2272L: return "bfk_ia32_phsubw128";
            case 2273L: return "bfk_ia32_phsubw256";
            case 2274L: return "bfk_ia32_phsubwd";
            case 2275L: return "bfk_ia32_pi2fd";
            case 2276L: return "bfk_ia32_pi2fw";
            case 2277L: return "bfk_ia32_pinsrw";
            case 2278L: return "bfk_ia32_pmacsdd";
            case 2279L: return "bfk_ia32_pmacsdqh";
            case 2280L: return "bfk_ia32_pmacsdql";
            case 2281L: return "bfk_ia32_pmacssdd";
            case 2282L: return "bfk_ia32_pmacssdqh";
            case 2283L: return "bfk_ia32_pmacssdql";
            case 2284L: return "bfk_ia32_pmacsswd";
            case 2285L: return "bfk_ia32_pmacssww";
            case 2286L: return "bfk_ia32_pmacswd";
            case 2287L: return "bfk_ia32_pmacsww";
            case 2288L: return "bfk_ia32_pmadcsswd";
            case 2289L: return "bfk_ia32_pmadcswd";
            case 2290L: return "bfk_ia32_pmaddubsw";
            case 2291L: return "bfk_ia32_pmaddubsw128";
            case 2292L: return "bfk_ia32_pmaddubsw128_mask";
            case 2293L: return "bfk_ia32_pmaddubsw256";
            case 2294L: return "bfk_ia32_pmaddubsw256_mask";
            case 2295L: return "bfk_ia32_pmaddubsw512";
            case 2296L: return "bfk_ia32_pmaddubsw512_mask";
            case 2297L: return "bfk_ia32_pmaddwd";
            case 2298L: return "bfk_ia32_pmaddwd128";
            case 2299L: return "bfk_ia32_pmaddwd128_mask";
            case 2300L: return "bfk_ia32_pmaddwd256";
            case 2301L: return "bfk_ia32_pmaddwd256_mask";
            case 2302L: return "bfk_ia32_pmaddwd512";
            case 2303L: return "bfk_ia32_pmaddwd512_mask";
            case 2304L: return "bfk_ia32_pmaxsb128";
            case 2305L: return "bfk_ia32_pmaxsb128_mask";
            case 2306L: return "bfk_ia32_pmaxsb256";
            case 2307L: return "bfk_ia32_pmaxsb256_mask";
            case 2308L: return "bfk_ia32_pmaxsb512";
            case 2309L: return "bfk_ia32_pmaxsb512_mask";
            case 2310L: return "bfk_ia32_pmaxsd128";
            case 2311L: return "bfk_ia32_pmaxsd128_mask";
            case 2312L: return "bfk_ia32_pmaxsd256";
            case 2313L: return "bfk_ia32_pmaxsd256_mask";
            case 2314L: return "bfk_ia32_pmaxsd512";
            case 2315L: return "bfk_ia32_pmaxsd512_mask";
            case 2316L: return "bfk_ia32_pmaxsq128";
            case 2317L: return "bfk_ia32_pmaxsq128_mask";
            case 2318L: return "bfk_ia32_pmaxsq256";
            case 2319L: return "bfk_ia32_pmaxsq256_mask";
            case 2320L: return "bfk_ia32_pmaxsq512";
            case 2321L: return "bfk_ia32_pmaxsq512_mask";
            case 2322L: return "bfk_ia32_pmaxsw";
            case 2323L: return "bfk_ia32_pmaxsw128";
            case 2324L: return "bfk_ia32_pmaxsw128_mask";
            case 2325L: return "bfk_ia32_pmaxsw256";
            case 2326L: return "bfk_ia32_pmaxsw256_mask";
            case 2327L: return "bfk_ia32_pmaxsw512";
            case 2328L: return "bfk_ia32_pmaxsw512_mask";
            case 2329L: return "bfk_ia32_pmaxub";
            case 2330L: return "bfk_ia32_pmaxub128";
            case 2331L: return "bfk_ia32_pmaxub128_mask";
            case 2332L: return "bfk_ia32_pmaxub256";
            case 2333L: return "bfk_ia32_pmaxub256_mask";
            case 2334L: return "bfk_ia32_pmaxub512";
            case 2335L: return "bfk_ia32_pmaxub512_mask";
            case 2336L: return "bfk_ia32_pmaxud128";
            case 2337L: return "bfk_ia32_pmaxud128_mask";
            case 2338L: return "bfk_ia32_pmaxud256";
            case 2339L: return "bfk_ia32_pmaxud256_mask";
            case 2340L: return "bfk_ia32_pmaxud512";
            case 2341L: return "bfk_ia32_pmaxud512_mask";
            case 2342L: return "bfk_ia32_pmaxuq128";
            case 2343L: return "bfk_ia32_pmaxuq128_mask";
            case 2344L: return "bfk_ia32_pmaxuq256";
            case 2345L: return "bfk_ia32_pmaxuq256_mask";
            case 2346L: return "bfk_ia32_pmaxuq512";
            case 2347L: return "bfk_ia32_pmaxuq512_mask";
            case 2348L: return "bfk_ia32_pmaxuw128";
            case 2349L: return "bfk_ia32_pmaxuw128_mask";
            case 2350L: return "bfk_ia32_pmaxuw256";
            case 2351L: return "bfk_ia32_pmaxuw256_mask";
            case 2352L: return "bfk_ia32_pmaxuw512";
            case 2353L: return "bfk_ia32_pmaxuw512_mask";
            case 2354L: return "bfk_ia32_pminsb128";
            case 2355L: return "bfk_ia32_pminsb128_mask";
            case 2356L: return "bfk_ia32_pminsb256";
            case 2357L: return "bfk_ia32_pminsb256_mask";
            case 2358L: return "bfk_ia32_pminsb512";
            case 2359L: return "bfk_ia32_pminsb512_mask";
            case 2360L: return "bfk_ia32_pminsd128";
            case 2361L: return "bfk_ia32_pminsd128_mask";
            case 2362L: return "bfk_ia32_pminsd256";
            case 2363L: return "bfk_ia32_pminsd256_mask";
            case 2364L: return "bfk_ia32_pminsd512";
            case 2365L: return "bfk_ia32_pminsd512_mask";
            case 2366L: return "bfk_ia32_pminsq128";
            case 2367L: return "bfk_ia32_pminsq128_mask";
            case 2368L: return "bfk_ia32_pminsq256";
            case 2369L: return "bfk_ia32_pminsq256_mask";
            case 2370L: return "bfk_ia32_pminsq512";
            case 2371L: return "bfk_ia32_pminsq512_mask";
            case 2372L: return "bfk_ia32_pminsw";
            case 2373L: return "bfk_ia32_pminsw128";
            case 2374L: return "bfk_ia32_pminsw128_mask";
            case 2375L: return "bfk_ia32_pminsw256";
            case 2376L: return "bfk_ia32_pminsw256_mask";
            case 2377L: return "bfk_ia32_pminsw512";
            case 2378L: return "bfk_ia32_pminsw512_mask";
            case 2379L: return "bfk_ia32_pminub";
            case 2380L: return "bfk_ia32_pminub128";
            case 2381L: return "bfk_ia32_pminub128_mask";
            case 2382L: return "bfk_ia32_pminub256";
            case 2383L: return "bfk_ia32_pminub256_mask";
            case 2384L: return "bfk_ia32_pminub512";
            case 2385L: return "bfk_ia32_pminub512_mask";
            case 2386L: return "bfk_ia32_pminud128";
            case 2387L: return "bfk_ia32_pminud128_mask";
            case 2388L: return "bfk_ia32_pminud256";
            case 2389L: return "bfk_ia32_pminud256_mask";
            case 2390L: return "bfk_ia32_pminud512";
            case 2391L: return "bfk_ia32_pminud512_mask";
            case 2392L: return "bfk_ia32_pminuq128";
            case 2393L: return "bfk_ia32_pminuq128_mask";
            case 2394L: return "bfk_ia32_pminuq256";
            case 2395L: return "bfk_ia32_pminuq256_mask";
            case 2396L: return "bfk_ia32_pminuq512";
            case 2397L: return "bfk_ia32_pminuq512_mask";
            case 2398L: return "bfk_ia32_pminuw128";
            case 2399L: return "bfk_ia32_pminuw128_mask";
            case 2400L: return "bfk_ia32_pminuw256";
            case 2401L: return "bfk_ia32_pminuw256_mask";
            case 2402L: return "bfk_ia32_pminuw512";
            case 2403L: return "bfk_ia32_pminuw512_mask";
            case 2404L: return "bfk_ia32_pmovdb128_mask";
            case 2405L: return "bfk_ia32_pmovdb128mem_mask";
            case 2406L: return "bfk_ia32_pmovdb256_mask";
            case 2407L: return "bfk_ia32_pmovdb256mem_mask";
            case 2408L: return "bfk_ia32_pmovdb512_mask";
            case 2409L: return "bfk_ia32_pmovdb512mem_mask";
            case 2410L: return "bfk_ia32_pmovdw128_mask";
            case 2411L: return "bfk_ia32_pmovdw128mem_mask";
            case 2412L: return "bfk_ia32_pmovdw256_mask";
            case 2413L: return "bfk_ia32_pmovdw256mem_mask";
            case 2414L: return "bfk_ia32_pmovdw512_mask";
            case 2415L: return "bfk_ia32_pmovdw512mem_mask";
            case 2416L: return "bfk_ia32_pmovmskb";
            case 2417L: return "bfk_ia32_pmovmskb128";
            case 2418L: return "bfk_ia32_pmovmskb256";
            case 2419L: return "bfk_ia32_pmovqb128_mask";
            case 2420L: return "bfk_ia32_pmovqb128mem_mask";
            case 2421L: return "bfk_ia32_pmovqb256_mask";
            case 2422L: return "bfk_ia32_pmovqb256mem_mask";
            case 2423L: return "bfk_ia32_pmovqb512_mask";
            case 2424L: return "bfk_ia32_pmovqb512mem_mask";
            case 2425L: return "bfk_ia32_pmovqd128_mask";
            case 2426L: return "bfk_ia32_pmovqd128mem_mask";
            case 2427L: return "bfk_ia32_pmovqd256_mask";
            case 2428L: return "bfk_ia32_pmovqd256mem_mask";
            case 2429L: return "bfk_ia32_pmovqd512_mask";
            case 2430L: return "bfk_ia32_pmovqd512mem_mask";
            case 2431L: return "bfk_ia32_pmovqw128_mask";
            case 2432L: return "bfk_ia32_pmovqw128mem_mask";
            case 2433L: return "bfk_ia32_pmovqw256_mask";
            case 2434L: return "bfk_ia32_pmovqw256mem_mask";
            case 2435L: return "bfk_ia32_pmovqw512_mask";
            case 2436L: return "bfk_ia32_pmovqw512mem_mask";
            case 2437L: return "bfk_ia32_pmovsdb128_mask";
            case 2438L: return "bfk_ia32_pmovsdb128mem_mask";
            case 2439L: return "bfk_ia32_pmovsdb256_mask";
            case 2440L: return "bfk_ia32_pmovsdb256mem_mask";
            case 2441L: return "bfk_ia32_pmovsdb512_mask";
            case 2442L: return "bfk_ia32_pmovsdb512mem_mask";
            case 2443L: return "bfk_ia32_pmovsdw128_mask";
            case 2444L: return "bfk_ia32_pmovsdw128mem_mask";
            case 2445L: return "bfk_ia32_pmovsdw256_mask";
            case 2446L: return "bfk_ia32_pmovsdw256mem_mask";
            case 2447L: return "bfk_ia32_pmovsdw512_mask";
            case 2448L: return "bfk_ia32_pmovsdw512mem_mask";
            case 2449L: return "bfk_ia32_pmovsqb128_mask";
            case 2450L: return "bfk_ia32_pmovsqb128mem_mask";
            case 2451L: return "bfk_ia32_pmovsqb256_mask";
            case 2452L: return "bfk_ia32_pmovsqb256mem_mask";
            case 2453L: return "bfk_ia32_pmovsqb512_mask";
            case 2454L: return "bfk_ia32_pmovsqb512mem_mask";
            case 2455L: return "bfk_ia32_pmovsqd128_mask";
            case 2456L: return "bfk_ia32_pmovsqd128mem_mask";
            case 2457L: return "bfk_ia32_pmovsqd256_mask";
            case 2458L: return "bfk_ia32_pmovsqd256mem_mask";
            case 2459L: return "bfk_ia32_pmovsqd512_mask";
            case 2460L: return "bfk_ia32_pmovsqd512mem_mask";
            case 2461L: return "bfk_ia32_pmovsqw128_mask";
            case 2462L: return "bfk_ia32_pmovsqw128mem_mask";
            case 2463L: return "bfk_ia32_pmovsqw256_mask";
            case 2464L: return "bfk_ia32_pmovsqw256mem_mask";
            case 2465L: return "bfk_ia32_pmovsqw512_mask";
            case 2466L: return "bfk_ia32_pmovsqw512mem_mask";
            case 2467L: return "bfk_ia32_pmovswb128_mask";
            case 2468L: return "bfk_ia32_pmovswb128mem_mask";
            case 2469L: return "bfk_ia32_pmovswb256_mask";
            case 2470L: return "bfk_ia32_pmovswb256mem_mask";
            case 2471L: return "bfk_ia32_pmovswb512_mask";
            case 2472L: return "bfk_ia32_pmovswb512mem_mask";
            case 2473L: return "bfk_ia32_pmovsxbd128";
            case 2474L: return "bfk_ia32_pmovsxbd128_mask";
            case 2475L: return "bfk_ia32_pmovsxbd256";
            case 2476L: return "bfk_ia32_pmovsxbd256_mask";
            case 2477L: return "bfk_ia32_pmovsxbd512_mask";
            case 2478L: return "bfk_ia32_pmovsxbq128";
            case 2479L: return "bfk_ia32_pmovsxbq128_mask";
            case 2480L: return "bfk_ia32_pmovsxbq256";
            case 2481L: return "bfk_ia32_pmovsxbq256_mask";
            case 2482L: return "bfk_ia32_pmovsxbq512_mask";
            case 2483L: return "bfk_ia32_pmovsxbw128";
            case 2484L: return "bfk_ia32_pmovsxbw128_mask";
            case 2485L: return "bfk_ia32_pmovsxbw256";
            case 2486L: return "bfk_ia32_pmovsxbw256_mask";
            case 2487L: return "bfk_ia32_pmovsxbw512_mask";
            case 2488L: return "bfk_ia32_pmovsxdq128";
            case 2489L: return "bfk_ia32_pmovsxdq128_mask";
            case 2490L: return "bfk_ia32_pmovsxdq256";
            case 2491L: return "bfk_ia32_pmovsxdq256_mask";
            case 2492L: return "bfk_ia32_pmovsxdq512_mask";
            case 2493L: return "bfk_ia32_pmovsxwd128";
            case 2494L: return "bfk_ia32_pmovsxwd128_mask";
            case 2495L: return "bfk_ia32_pmovsxwd256";
            case 2496L: return "bfk_ia32_pmovsxwd256_mask";
            case 2497L: return "bfk_ia32_pmovsxwd512_mask";
            case 2498L: return "bfk_ia32_pmovsxwq128";
            case 2499L: return "bfk_ia32_pmovsxwq128_mask";
            case 2500L: return "bfk_ia32_pmovsxwq256";
            case 2501L: return "bfk_ia32_pmovsxwq256_mask";
            case 2502L: return "bfk_ia32_pmovsxwq512_mask";
            case 2503L: return "bfk_ia32_pmovusdb128_mask";
            case 2504L: return "bfk_ia32_pmovusdb128mem_mask";
            case 2505L: return "bfk_ia32_pmovusdb256_mask";
            case 2506L: return "bfk_ia32_pmovusdb256mem_mask";
            case 2507L: return "bfk_ia32_pmovusdb512_mask";
            case 2508L: return "bfk_ia32_pmovusdb512mem_mask";
            case 2509L: return "bfk_ia32_pmovusdw128_mask";
            case 2510L: return "bfk_ia32_pmovusdw128mem_mask";
            case 2511L: return "bfk_ia32_pmovusdw256_mask";
            case 2512L: return "bfk_ia32_pmovusdw256mem_mask";
            case 2513L: return "bfk_ia32_pmovusdw512_mask";
            case 2514L: return "bfk_ia32_pmovusdw512mem_mask";
            case 2515L: return "bfk_ia32_pmovusqb128_mask";
            case 2516L: return "bfk_ia32_pmovusqb128mem_mask";
            case 2517L: return "bfk_ia32_pmovusqb256_mask";
            case 2518L: return "bfk_ia32_pmovusqb256mem_mask";
            case 2519L: return "bfk_ia32_pmovusqb512_mask";
            case 2520L: return "bfk_ia32_pmovusqb512mem_mask";
            case 2521L: return "bfk_ia32_pmovusqd128_mask";
            case 2522L: return "bfk_ia32_pmovusqd128mem_mask";
            case 2523L: return "bfk_ia32_pmovusqd256_mask";
            case 2524L: return "bfk_ia32_pmovusqd256mem_mask";
            case 2525L: return "bfk_ia32_pmovusqd512_mask";
            case 2526L: return "bfk_ia32_pmovusqd512mem_mask";
            case 2527L: return "bfk_ia32_pmovusqw128_mask";
            case 2528L: return "bfk_ia32_pmovusqw128mem_mask";
            case 2529L: return "bfk_ia32_pmovusqw256_mask";
            case 2530L: return "bfk_ia32_pmovusqw256mem_mask";
            case 2531L: return "bfk_ia32_pmovusqw512_mask";
            case 2532L: return "bfk_ia32_pmovusqw512mem_mask";
            case 2533L: return "bfk_ia32_pmovuswb128_mask";
            case 2534L: return "bfk_ia32_pmovuswb128mem_mask";
            case 2535L: return "bfk_ia32_pmovuswb256_mask";
            case 2536L: return "bfk_ia32_pmovuswb256mem_mask";
            case 2537L: return "bfk_ia32_pmovuswb512_mask";
            case 2538L: return "bfk_ia32_pmovuswb512mem_mask";
            case 2539L: return "bfk_ia32_pmovwb128_mask";
            case 2540L: return "bfk_ia32_pmovwb128mem_mask";
            case 2541L: return "bfk_ia32_pmovwb256_mask";
            case 2542L: return "bfk_ia32_pmovwb256mem_mask";
            case 2543L: return "bfk_ia32_pmovwb512_mask";
            case 2544L: return "bfk_ia32_pmovwb512mem_mask";
            case 2545L: return "bfk_ia32_pmovzxbd128";
            case 2546L: return "bfk_ia32_pmovzxbd128_mask";
            case 2547L: return "bfk_ia32_pmovzxbd256";
            case 2548L: return "bfk_ia32_pmovzxbd256_mask";
            case 2549L: return "bfk_ia32_pmovzxbd512_mask";
            case 2550L: return "bfk_ia32_pmovzxbq128";
            case 2551L: return "bfk_ia32_pmovzxbq128_mask";
            case 2552L: return "bfk_ia32_pmovzxbq256";
            case 2553L: return "bfk_ia32_pmovzxbq256_mask";
            case 2554L: return "bfk_ia32_pmovzxbq512_mask";
            case 2555L: return "bfk_ia32_pmovzxbw128";
            case 2556L: return "bfk_ia32_pmovzxbw128_mask";
            case 2557L: return "bfk_ia32_pmovzxbw256";
            case 2558L: return "bfk_ia32_pmovzxbw256_mask";
            case 2559L: return "bfk_ia32_pmovzxbw512_mask";
            case 2560L: return "bfk_ia32_pmovzxdq128";
            case 2561L: return "bfk_ia32_pmovzxdq128_mask";
            case 2562L: return "bfk_ia32_pmovzxdq256";
            case 2563L: return "bfk_ia32_pmovzxdq256_mask";
            case 2564L: return "bfk_ia32_pmovzxdq512_mask";
            case 2565L: return "bfk_ia32_pmovzxwd128";
            case 2566L: return "bfk_ia32_pmovzxwd128_mask";
            case 2567L: return "bfk_ia32_pmovzxwd256";
            case 2568L: return "bfk_ia32_pmovzxwd256_mask";
            case 2569L: return "bfk_ia32_pmovzxwd512_mask";
            case 2570L: return "bfk_ia32_pmovzxwq128";
            case 2571L: return "bfk_ia32_pmovzxwq128_mask";
            case 2572L: return "bfk_ia32_pmovzxwq256";
            case 2573L: return "bfk_ia32_pmovzxwq256_mask";
            case 2574L: return "bfk_ia32_pmovzxwq512_mask";
            case 2575L: return "bfk_ia32_pmuldq128";
            case 2576L: return "bfk_ia32_pmuldq128_mask";
            case 2577L: return "bfk_ia32_pmuldq256";
            case 2578L: return "bfk_ia32_pmuldq256_mask";
            case 2579L: return "bfk_ia32_pmuldq512";
            case 2580L: return "bfk_ia32_pmuldq512_mask";
            case 2581L: return "bfk_ia32_pmulhrsw";
            case 2582L: return "bfk_ia32_pmulhrsw128";
            case 2583L: return "bfk_ia32_pmulhrsw128_mask";
            case 2584L: return "bfk_ia32_pmulhrsw256";
            case 2585L: return "bfk_ia32_pmulhrsw256_mask";
            case 2586L: return "bfk_ia32_pmulhrsw512";
            case 2587L: return "bfk_ia32_pmulhrsw512_mask";
            case 2588L: return "bfk_ia32_pmulhrw";
            case 2589L: return "bfk_ia32_pmulhuw";
            case 2590L: return "bfk_ia32_pmulhuw128";
            case 2591L: return "bfk_ia32_pmulhuw128_mask";
            case 2592L: return "bfk_ia32_pmulhuw256";
            case 2593L: return "bfk_ia32_pmulhuw256_mask";
            case 2594L: return "bfk_ia32_pmulhuw512";
            case 2595L: return "bfk_ia32_pmulhuw512_mask";
            case 2596L: return "bfk_ia32_pmulhw";
            case 2597L: return "bfk_ia32_pmulhw128";
            case 2598L: return "bfk_ia32_pmulhw128_mask";
            case 2599L: return "bfk_ia32_pmulhw256";
            case 2600L: return "bfk_ia32_pmulhw256_mask";
            case 2601L: return "bfk_ia32_pmulhw512";
            case 2602L: return "bfk_ia32_pmulhw512_mask";
            case 2603L: return "bfk_ia32_pmulld128";
            case 2604L: return "bfk_ia32_pmulld128_mask";
            case 2605L: return "bfk_ia32_pmulld256";
            case 2606L: return "bfk_ia32_pmulld256_mask";
            case 2607L: return "bfk_ia32_pmulld512_mask";
            case 2608L: return "bfk_ia32_pmullq128_mask";
            case 2609L: return "bfk_ia32_pmullq256_mask";
            case 2610L: return "bfk_ia32_pmullq512_mask";
            case 2611L: return "bfk_ia32_pmullw";
            case 2612L: return "bfk_ia32_pmullw128";
            case 2613L: return "bfk_ia32_pmullw128_mask";
            case 2614L: return "bfk_ia32_pmullw256";
            case 2615L: return "bfk_ia32_pmullw256_mask";
            case 2616L: return "bfk_ia32_pmullw512_mask";
            case 2617L: return "bfk_ia32_pmuludq";
            case 2618L: return "bfk_ia32_pmuludq128";
            case 2619L: return "bfk_ia32_pmuludq128_mask";
            case 2620L: return "bfk_ia32_pmuludq256";
            case 2621L: return "bfk_ia32_pmuludq256_mask";
            case 2622L: return "bfk_ia32_pmuludq512";
            case 2623L: return "bfk_ia32_pmuludq512_mask";
            case 2624L: return "bfk_ia32_por";
            case 2625L: return "bfk_ia32_por128";
            case 2626L: return "bfk_ia32_por256";
            case 2627L: return "bfk_ia32_pord128_mask";
            case 2628L: return "bfk_ia32_pord256_mask";
            case 2629L: return "bfk_ia32_pord512_mask";
            case 2630L: return "bfk_ia32_porq128_mask";
            case 2631L: return "bfk_ia32_porq256_mask";
            case 2632L: return "bfk_ia32_porq512_mask";
            case 2633L: return "bfk_ia32_pperm";
            case 2634L: return "bfk_ia32_prold128";
            case 2635L: return "bfk_ia32_prold128_mask";
            case 2636L: return "bfk_ia32_prold256";
            case 2637L: return "bfk_ia32_prold256_mask";
            case 2638L: return "bfk_ia32_prold512";
            case 2639L: return "bfk_ia32_prold512_mask";
            case 2640L: return "bfk_ia32_prolq128";
            case 2641L: return "bfk_ia32_prolq128_mask";
            case 2642L: return "bfk_ia32_prolq256";
            case 2643L: return "bfk_ia32_prolq256_mask";
            case 2644L: return "bfk_ia32_prolq512";
            case 2645L: return "bfk_ia32_prolq512_mask";
            case 2646L: return "bfk_ia32_prolvd128";
            case 2647L: return "bfk_ia32_prolvd128_mask";
            case 2648L: return "bfk_ia32_prolvd256";
            case 2649L: return "bfk_ia32_prolvd256_mask";
            case 2650L: return "bfk_ia32_prolvd512";
            case 2651L: return "bfk_ia32_prolvd512_mask";
            case 2652L: return "bfk_ia32_prolvq128";
            case 2653L: return "bfk_ia32_prolvq128_mask";
            case 2654L: return "bfk_ia32_prolvq256";
            case 2655L: return "bfk_ia32_prolvq256_mask";
            case 2656L: return "bfk_ia32_prolvq512";
            case 2657L: return "bfk_ia32_prolvq512_mask";
            case 2658L: return "bfk_ia32_prord128";
            case 2659L: return "bfk_ia32_prord128_mask";
            case 2660L: return "bfk_ia32_prord256";
            case 2661L: return "bfk_ia32_prord256_mask";
            case 2662L: return "bfk_ia32_prord512";
            case 2663L: return "bfk_ia32_prord512_mask";
            case 2664L: return "bfk_ia32_prorq128";
            case 2665L: return "bfk_ia32_prorq128_mask";
            case 2666L: return "bfk_ia32_prorq256";
            case 2667L: return "bfk_ia32_prorq256_mask";
            case 2668L: return "bfk_ia32_prorq512";
            case 2669L: return "bfk_ia32_prorq512_mask";
            case 2670L: return "bfk_ia32_prorvd128";
            case 2671L: return "bfk_ia32_prorvd128_mask";
            case 2672L: return "bfk_ia32_prorvd256";
            case 2673L: return "bfk_ia32_prorvd256_mask";
            case 2674L: return "bfk_ia32_prorvd512";
            case 2675L: return "bfk_ia32_prorvd512_mask";
            case 2676L: return "bfk_ia32_prorvq128";
            case 2677L: return "bfk_ia32_prorvq128_mask";
            case 2678L: return "bfk_ia32_prorvq256";
            case 2679L: return "bfk_ia32_prorvq256_mask";
            case 2680L: return "bfk_ia32_prorvq512";
            case 2681L: return "bfk_ia32_prorvq512_mask";
            case 2682L: return "bfk_ia32_protb";
            case 2683L: return "bfk_ia32_protd";
            case 2684L: return "bfk_ia32_protq";
            case 2685L: return "bfk_ia32_protw";
            case 2686L: return "bfk_ia32_ps256_ps";
            case 2687L: return "bfk_ia32_ps512_256ps";
            case 2688L: return "bfk_ia32_ps512_ps";
            case 2689L: return "bfk_ia32_ps_ps256";
            case 2690L: return "bfk_ia32_psadbw";
            case 2691L: return "bfk_ia32_psadbw128";
            case 2692L: return "bfk_ia32_psadbw256";
            case 2693L: return "bfk_ia32_psadbw512";
            case 2694L: return "bfk_ia32_pshab";
            case 2695L: return "bfk_ia32_pshad";
            case 2696L: return "bfk_ia32_pshaq";
            case 2697L: return "bfk_ia32_pshaw";
            case 2698L: return "bfk_ia32_pshlb";
            case 2699L: return "bfk_ia32_pshld";
            case 2700L: return "bfk_ia32_pshlq";
            case 2701L: return "bfk_ia32_pshlw";
            case 2702L: return "bfk_ia32_pshufb";
            case 2703L: return "bfk_ia32_pshufb128";
            case 2704L: return "bfk_ia32_pshufb128_mask";
            case 2705L: return "bfk_ia32_pshufb256";
            case 2706L: return "bfk_ia32_pshufb256_mask";
            case 2707L: return "bfk_ia32_pshufb512";
            case 2708L: return "bfk_ia32_pshufb512_mask";
            case 2709L: return "bfk_ia32_pshufd";
            case 2710L: return "bfk_ia32_pshufd128_mask";
            case 2711L: return "bfk_ia32_pshufd256";
            case 2712L: return "bfk_ia32_pshufd256_mask";
            case 2713L: return "bfk_ia32_pshufd512";
            case 2714L: return "bfk_ia32_pshufd512_mask";
            case 2715L: return "bfk_ia32_pshufhw";
            case 2716L: return "bfk_ia32_pshufhw128_mask";
            case 2717L: return "bfk_ia32_pshufhw256";
            case 2718L: return "bfk_ia32_pshufhw256_mask";
            case 2719L: return "bfk_ia32_pshufhw512";
            case 2720L: return "bfk_ia32_pshufhw512_mask";
            case 2721L: return "bfk_ia32_pshuflw";
            case 2722L: return "bfk_ia32_pshuflw128_mask";
            case 2723L: return "bfk_ia32_pshuflw256";
            case 2724L: return "bfk_ia32_pshuflw256_mask";
            case 2725L: return "bfk_ia32_pshuflw512";
            case 2726L: return "bfk_ia32_pshuflw512_mask";
            case 2727L: return "bfk_ia32_pshufw";
            case 2728L: return "bfk_ia32_psignb";
            case 2729L: return "bfk_ia32_psignb128";
            case 2730L: return "bfk_ia32_psignb256";
            case 2731L: return "bfk_ia32_psignd";
            case 2732L: return "bfk_ia32_psignd128";
            case 2733L: return "bfk_ia32_psignd256";
            case 2734L: return "bfk_ia32_psignw";
            case 2735L: return "bfk_ia32_psignw128";
            case 2736L: return "bfk_ia32_psignw256";
            case 2737L: return "bfk_ia32_pslld";
            case 2738L: return "bfk_ia32_pslld128";
            case 2739L: return "bfk_ia32_pslld128_mask";
            case 2740L: return "bfk_ia32_pslld256";
            case 2741L: return "bfk_ia32_pslld256_mask";
            case 2742L: return "bfk_ia32_pslld512";
            case 2743L: return "bfk_ia32_pslld512_mask";
            case 2744L: return "bfk_ia32_pslldi";
            case 2745L: return "bfk_ia32_pslldi128";
            case 2746L: return "bfk_ia32_pslldi128_mask";
            case 2747L: return "bfk_ia32_pslldi256";
            case 2748L: return "bfk_ia32_pslldi256_mask";
            case 2749L: return "bfk_ia32_pslldi512";
            case 2750L: return "bfk_ia32_pslldi512_mask";
            case 2751L: return "bfk_ia32_pslldq512";
            case 2752L: return "bfk_ia32_pslldqi128";
            case 2753L: return "bfk_ia32_pslldqi128_byteshift";
            case 2754L: return "bfk_ia32_pslldqi256";
            case 2755L: return "bfk_ia32_pslldqi256_byteshift";
            case 2756L: return "bfk_ia32_pslldqi512_byteshift";
            case 2757L: return "bfk_ia32_psllq";
            case 2758L: return "bfk_ia32_psllq128";
            case 2759L: return "bfk_ia32_psllq128_mask";
            case 2760L: return "bfk_ia32_psllq256";
            case 2761L: return "bfk_ia32_psllq256_mask";
            case 2762L: return "bfk_ia32_psllq512";
            case 2763L: return "bfk_ia32_psllq512_mask";
            case 2764L: return "bfk_ia32_psllqi";
            case 2765L: return "bfk_ia32_psllqi128";
            case 2766L: return "bfk_ia32_psllqi128_mask";
            case 2767L: return "bfk_ia32_psllqi256";
            case 2768L: return "bfk_ia32_psllqi256_mask";
            case 2769L: return "bfk_ia32_psllqi512";
            case 2770L: return "bfk_ia32_psllqi512_mask";
            case 2771L: return "bfk_ia32_psllv16hi";
            case 2772L: return "bfk_ia32_psllv16hi_mask";
            case 2773L: return "bfk_ia32_psllv16si";
            case 2774L: return "bfk_ia32_psllv16si_mask";
            case 2775L: return "bfk_ia32_psllv2di";
            case 2776L: return "bfk_ia32_psllv2di_mask";
            case 2777L: return "bfk_ia32_psllv32hi";
            case 2778L: return "bfk_ia32_psllv32hi_mask";
            case 2779L: return "bfk_ia32_psllv4di";
            case 2780L: return "bfk_ia32_psllv4di_mask";
            case 2781L: return "bfk_ia32_psllv4si";
            case 2782L: return "bfk_ia32_psllv4si_mask";
            case 2783L: return "bfk_ia32_psllv8di";
            case 2784L: return "bfk_ia32_psllv8di_mask";
            case 2785L: return "bfk_ia32_psllv8hi";
            case 2786L: return "bfk_ia32_psllv8hi_mask";
            case 2787L: return "bfk_ia32_psllv8si";
            case 2788L: return "bfk_ia32_psllv8si_mask";
            case 2789L: return "bfk_ia32_psllw";
            case 2790L: return "bfk_ia32_psllw128";
            case 2791L: return "bfk_ia32_psllw128_mask";
            case 2792L: return "bfk_ia32_psllw256";
            case 2793L: return "bfk_ia32_psllw256_mask";
            case 2794L: return "bfk_ia32_psllw512";
            case 2795L: return "bfk_ia32_psllw512_mask";
            case 2796L: return "bfk_ia32_psllwi";
            case 2797L: return "bfk_ia32_psllwi128";
            case 2798L: return "bfk_ia32_psllwi128_mask";
            case 2799L: return "bfk_ia32_psllwi256";
            case 2800L: return "bfk_ia32_psllwi256_mask";
            case 2801L: return "bfk_ia32_psllwi512";
            case 2802L: return "bfk_ia32_psllwi512_mask";
            case 2803L: return "bfk_ia32_psrad";
            case 2804L: return "bfk_ia32_psrad128";
            case 2805L: return "bfk_ia32_psrad128_mask";
            case 2806L: return "bfk_ia32_psrad256";
            case 2807L: return "bfk_ia32_psrad256_mask";
            case 2808L: return "bfk_ia32_psrad512";
            case 2809L: return "bfk_ia32_psrad512_mask";
            case 2810L: return "bfk_ia32_psradi";
            case 2811L: return "bfk_ia32_psradi128";
            case 2812L: return "bfk_ia32_psradi128_mask";
            case 2813L: return "bfk_ia32_psradi256";
            case 2814L: return "bfk_ia32_psradi256_mask";
            case 2815L: return "bfk_ia32_psradi512";
            case 2816L: return "bfk_ia32_psradi512_mask";
            case 2817L: return "bfk_ia32_psraq128";
            case 2818L: return "bfk_ia32_psraq128_mask";
            case 2819L: return "bfk_ia32_psraq256";
            case 2820L: return "bfk_ia32_psraq256_mask";
            case 2821L: return "bfk_ia32_psraq512";
            case 2822L: return "bfk_ia32_psraq512_mask";
            case 2823L: return "bfk_ia32_psraqi128";
            case 2824L: return "bfk_ia32_psraqi128_mask";
            case 2825L: return "bfk_ia32_psraqi256";
            case 2826L: return "bfk_ia32_psraqi256_mask";
            case 2827L: return "bfk_ia32_psraqi512";
            case 2828L: return "bfk_ia32_psraqi512_mask";
            case 2829L: return "bfk_ia32_psrav16hi";
            case 2830L: return "bfk_ia32_psrav16hi_mask";
            case 2831L: return "bfk_ia32_psrav16si";
            case 2832L: return "bfk_ia32_psrav16si_mask";
            case 2833L: return "bfk_ia32_psrav32hi";
            case 2834L: return "bfk_ia32_psrav32hi_mask";
            case 2835L: return "bfk_ia32_psrav4si";
            case 2836L: return "bfk_ia32_psrav4si_mask";
            case 2837L: return "bfk_ia32_psrav8di";
            case 2838L: return "bfk_ia32_psrav8di_mask";
            case 2839L: return "bfk_ia32_psrav8hi";
            case 2840L: return "bfk_ia32_psrav8hi_mask";
            case 2841L: return "bfk_ia32_psrav8si";
            case 2842L: return "bfk_ia32_psrav8si_mask";
            case 2843L: return "bfk_ia32_psravq128";
            case 2844L: return "bfk_ia32_psravq128_mask";
            case 2845L: return "bfk_ia32_psravq256";
            case 2846L: return "bfk_ia32_psravq256_mask";
            case 2847L: return "bfk_ia32_psraw";
            case 2848L: return "bfk_ia32_psraw128";
            case 2849L: return "bfk_ia32_psraw128_mask";
            case 2850L: return "bfk_ia32_psraw256";
            case 2851L: return "bfk_ia32_psraw256_mask";
            case 2852L: return "bfk_ia32_psraw512";
            case 2853L: return "bfk_ia32_psraw512_mask";
            case 2854L: return "bfk_ia32_psrawi";
            case 2855L: return "bfk_ia32_psrawi128";
            case 2856L: return "bfk_ia32_psrawi128_mask";
            case 2857L: return "bfk_ia32_psrawi256";
            case 2858L: return "bfk_ia32_psrawi256_mask";
            case 2859L: return "bfk_ia32_psrawi512";
            case 2860L: return "bfk_ia32_psrawi512_mask";
            case 2861L: return "bfk_ia32_psrld";
            case 2862L: return "bfk_ia32_psrld128";
            case 2863L: return "bfk_ia32_psrld128_mask";
            case 2864L: return "bfk_ia32_psrld256";
            case 2865L: return "bfk_ia32_psrld256_mask";
            case 2866L: return "bfk_ia32_psrld512";
            case 2867L: return "bfk_ia32_psrld512_mask";
            case 2868L: return "bfk_ia32_psrldi";
            case 2869L: return "bfk_ia32_psrldi128";
            case 2870L: return "bfk_ia32_psrldi128_mask";
            case 2871L: return "bfk_ia32_psrldi256";
            case 2872L: return "bfk_ia32_psrldi256_mask";
            case 2873L: return "bfk_ia32_psrldi512";
            case 2874L: return "bfk_ia32_psrldi512_mask";
            case 2875L: return "bfk_ia32_psrldq512";
            case 2876L: return "bfk_ia32_psrldqi128";
            case 2877L: return "bfk_ia32_psrldqi128_byteshift";
            case 2878L: return "bfk_ia32_psrldqi256";
            case 2879L: return "bfk_ia32_psrldqi256_byteshift";
            case 2880L: return "bfk_ia32_psrldqi512_byteshift";
            case 2881L: return "bfk_ia32_psrlq";
            case 2882L: return "bfk_ia32_psrlq128";
            case 2883L: return "bfk_ia32_psrlq128_mask";
            case 2884L: return "bfk_ia32_psrlq256";
            case 2885L: return "bfk_ia32_psrlq256_mask";
            case 2886L: return "bfk_ia32_psrlq512";
            case 2887L: return "bfk_ia32_psrlq512_mask";
            case 2888L: return "bfk_ia32_psrlqi";
            case 2889L: return "bfk_ia32_psrlqi128";
            case 2890L: return "bfk_ia32_psrlqi128_mask";
            case 2891L: return "bfk_ia32_psrlqi256";
            case 2892L: return "bfk_ia32_psrlqi256_mask";
            case 2893L: return "bfk_ia32_psrlqi512";
            case 2894L: return "bfk_ia32_psrlqi512_mask";
            case 2895L: return "bfk_ia32_psrlv16hi";
            case 2896L: return "bfk_ia32_psrlv16hi_mask";
            case 2897L: return "bfk_ia32_psrlv16si";
            case 2898L: return "bfk_ia32_psrlv16si_mask";
            case 2899L: return "bfk_ia32_psrlv2di";
            case 2900L: return "bfk_ia32_psrlv2di_mask";
            case 2901L: return "bfk_ia32_psrlv32hi";
            case 2902L: return "bfk_ia32_psrlv32hi_mask";
            case 2903L: return "bfk_ia32_psrlv4di";
            case 2904L: return "bfk_ia32_psrlv4di_mask";
            case 2905L: return "bfk_ia32_psrlv4si";
            case 2906L: return "bfk_ia32_psrlv4si_mask";
            case 2907L: return "bfk_ia32_psrlv8di";
            case 2908L: return "bfk_ia32_psrlv8di_mask";
            case 2909L: return "bfk_ia32_psrlv8hi";
            case 2910L: return "bfk_ia32_psrlv8hi_mask";
            case 2911L: return "bfk_ia32_psrlv8si";
            case 2912L: return "bfk_ia32_psrlv8si_mask";
            case 2913L: return "bfk_ia32_psrlw";
            case 2914L: return "bfk_ia32_psrlw128";
            case 2915L: return "bfk_ia32_psrlw128_mask";
            case 2916L: return "bfk_ia32_psrlw256";
            case 2917L: return "bfk_ia32_psrlw256_mask";
            case 2918L: return "bfk_ia32_psrlw512";
            case 2919L: return "bfk_ia32_psrlw512_mask";
            case 2920L: return "bfk_ia32_psrlwi";
            case 2921L: return "bfk_ia32_psrlwi128";
            case 2922L: return "bfk_ia32_psrlwi128_mask";
            case 2923L: return "bfk_ia32_psrlwi256";
            case 2924L: return "bfk_ia32_psrlwi256_mask";
            case 2925L: return "bfk_ia32_psrlwi512";
            case 2926L: return "bfk_ia32_psrlwi512_mask";
            case 2927L: return "bfk_ia32_psubb";
            case 2928L: return "bfk_ia32_psubb128";
            case 2929L: return "bfk_ia32_psubb128_mask";
            case 2930L: return "bfk_ia32_psubb256";
            case 2931L: return "bfk_ia32_psubb256_mask";
            case 2932L: return "bfk_ia32_psubb512_mask";
            case 2933L: return "bfk_ia32_psubd";
            case 2934L: return "bfk_ia32_psubd128";
            case 2935L: return "bfk_ia32_psubd128_mask";
            case 2936L: return "bfk_ia32_psubd256";
            case 2937L: return "bfk_ia32_psubd256_mask";
            case 2938L: return "bfk_ia32_psubd512_mask";
            case 2939L: return "bfk_ia32_psubq";
            case 2940L: return "bfk_ia32_psubq128";
            case 2941L: return "bfk_ia32_psubq128_mask";
            case 2942L: return "bfk_ia32_psubq256";
            case 2943L: return "bfk_ia32_psubq256_mask";
            case 2944L: return "bfk_ia32_psubq512_mask";
            case 2945L: return "bfk_ia32_psubsb";
            case 2946L: return "bfk_ia32_psubsb128";
            case 2947L: return "bfk_ia32_psubsb128_mask";
            case 2948L: return "bfk_ia32_psubsb256";
            case 2949L: return "bfk_ia32_psubsb256_mask";
            case 2950L: return "bfk_ia32_psubsb512";
            case 2951L: return "bfk_ia32_psubsb512_mask";
            case 2952L: return "bfk_ia32_psubsw";
            case 2953L: return "bfk_ia32_psubsw128";
            case 2954L: return "bfk_ia32_psubsw128_mask";
            case 2955L: return "bfk_ia32_psubsw256";
            case 2956L: return "bfk_ia32_psubsw256_mask";
            case 2957L: return "bfk_ia32_psubsw512";
            case 2958L: return "bfk_ia32_psubsw512_mask";
            case 2959L: return "bfk_ia32_psubusb";
            case 2960L: return "bfk_ia32_psubusb128";
            case 2961L: return "bfk_ia32_psubusb128_mask";
            case 2962L: return "bfk_ia32_psubusb256";
            case 2963L: return "bfk_ia32_psubusb256_mask";
            case 2964L: return "bfk_ia32_psubusb512";
            case 2965L: return "bfk_ia32_psubusb512_mask";
            case 2966L: return "bfk_ia32_psubusw";
            case 2967L: return "bfk_ia32_psubusw128";
            case 2968L: return "bfk_ia32_psubusw128_mask";
            case 2969L: return "bfk_ia32_psubusw256";
            case 2970L: return "bfk_ia32_psubusw256_mask";
            case 2971L: return "bfk_ia32_psubusw512";
            case 2972L: return "bfk_ia32_psubusw512_mask";
            case 2973L: return "bfk_ia32_psubw";
            case 2974L: return "bfk_ia32_psubw128";
            case 2975L: return "bfk_ia32_psubw128_mask";
            case 2976L: return "bfk_ia32_psubw256";
            case 2977L: return "bfk_ia32_psubw256_mask";
            case 2978L: return "bfk_ia32_psubw512_mask";
            case 2979L: return "bfk_ia32_pswapdsf";
            case 2980L: return "bfk_ia32_pswapdsi";
            case 2981L: return "bfk_ia32_pternlogd128_mask";
            case 2982L: return "bfk_ia32_pternlogd128_maskz";
            case 2983L: return "bfk_ia32_pternlogd256_mask";
            case 2984L: return "bfk_ia32_pternlogd256_maskz";
            case 2985L: return "bfk_ia32_pternlogd512_mask";
            case 2986L: return "bfk_ia32_pternlogd512_maskz";
            case 2987L: return "bfk_ia32_pternlogq128_mask";
            case 2988L: return "bfk_ia32_pternlogq128_maskz";
            case 2989L: return "bfk_ia32_pternlogq256_mask";
            case 2990L: return "bfk_ia32_pternlogq256_maskz";
            case 2991L: return "bfk_ia32_pternlogq512_mask";
            case 2992L: return "bfk_ia32_pternlogq512_maskz";
            case 2993L: return "bfk_ia32_ptestc128";
            case 2994L: return "bfk_ia32_ptestc256";
            case 2995L: return "bfk_ia32_ptestmb128";
            case 2996L: return "bfk_ia32_ptestmb256";
            case 2997L: return "bfk_ia32_ptestmb512";
            case 2998L: return "bfk_ia32_ptestmd128";
            case 2999L: return "bfk_ia32_ptestmd256";
            case 3000L: return "bfk_ia32_ptestmd512";
            case 3001L: return "bfk_ia32_ptestmq128";
            case 3002L: return "bfk_ia32_ptestmq256";
            case 3003L: return "bfk_ia32_ptestmq512";
            case 3004L: return "bfk_ia32_ptestmw128";
            case 3005L: return "bfk_ia32_ptestmw256";
            case 3006L: return "bfk_ia32_ptestmw512";
            case 3007L: return "bfk_ia32_ptestnmb128";
            case 3008L: return "bfk_ia32_ptestnmb256";
            case 3009L: return "bfk_ia32_ptestnmb512";
            case 3010L: return "bfk_ia32_ptestnmd128";
            case 3011L: return "bfk_ia32_ptestnmd256";
            case 3012L: return "bfk_ia32_ptestnmd512";
            case 3013L: return "bfk_ia32_ptestnmq128";
            case 3014L: return "bfk_ia32_ptestnmq256";
            case 3015L: return "bfk_ia32_ptestnmq512";
            case 3016L: return "bfk_ia32_ptestnmw128";
            case 3017L: return "bfk_ia32_ptestnmw256";
            case 3018L: return "bfk_ia32_ptestnmw512";
            case 3019L: return "bfk_ia32_ptestnzc128";
            case 3020L: return "bfk_ia32_ptestnzc256";
            case 3021L: return "bfk_ia32_ptestz128";
            case 3022L: return "bfk_ia32_ptestz256";
            case 3023L: return "bfk_ia32_ptwrite32";
            case 3024L: return "bfk_ia32_ptwrite64";
            case 3025L: return "bfk_ia32_punpckhbw";
            case 3026L: return "bfk_ia32_punpckhbw128";
            case 3027L: return "bfk_ia32_punpckhbw128_mask";
            case 3028L: return "bfk_ia32_punpckhbw256";
            case 3029L: return "bfk_ia32_punpckhbw256_mask";
            case 3030L: return "bfk_ia32_punpckhbw512_mask";
            case 3031L: return "bfk_ia32_punpckhdq";
            case 3032L: return "bfk_ia32_punpckhdq128";
            case 3033L: return "bfk_ia32_punpckhdq128_mask";
            case 3034L: return "bfk_ia32_punpckhdq256";
            case 3035L: return "bfk_ia32_punpckhdq256_mask";
            case 3036L: return "bfk_ia32_punpckhdq512_mask";
            case 3037L: return "bfk_ia32_punpckhqdq128";
            case 3038L: return "bfk_ia32_punpckhqdq128_mask";
            case 3039L: return "bfk_ia32_punpckhqdq256";
            case 3040L: return "bfk_ia32_punpckhqdq256_mask";
            case 3041L: return "bfk_ia32_punpckhqdq512_mask";
            case 3042L: return "bfk_ia32_punpckhwd";
            case 3043L: return "bfk_ia32_punpckhwd128";
            case 3044L: return "bfk_ia32_punpckhwd128_mask";
            case 3045L: return "bfk_ia32_punpckhwd256";
            case 3046L: return "bfk_ia32_punpckhwd256_mask";
            case 3047L: return "bfk_ia32_punpckhwd512_mask";
            case 3048L: return "bfk_ia32_punpcklbw";
            case 3049L: return "bfk_ia32_punpcklbw128";
            case 3050L: return "bfk_ia32_punpcklbw128_mask";
            case 3051L: return "bfk_ia32_punpcklbw256";
            case 3052L: return "bfk_ia32_punpcklbw256_mask";
            case 3053L: return "bfk_ia32_punpcklbw512_mask";
            case 3054L: return "bfk_ia32_punpckldq";
            case 3055L: return "bfk_ia32_punpckldq128";
            case 3056L: return "bfk_ia32_punpckldq128_mask";
            case 3057L: return "bfk_ia32_punpckldq256";
            case 3058L: return "bfk_ia32_punpckldq256_mask";
            case 3059L: return "bfk_ia32_punpckldq512_mask";
            case 3060L: return "bfk_ia32_punpcklqdq128";
            case 3061L: return "bfk_ia32_punpcklqdq128_mask";
            case 3062L: return "bfk_ia32_punpcklqdq256";
            case 3063L: return "bfk_ia32_punpcklqdq256_mask";
            case 3064L: return "bfk_ia32_punpcklqdq512_mask";
            case 3065L: return "bfk_ia32_punpcklwd";
            case 3066L: return "bfk_ia32_punpcklwd128";
            case 3067L: return "bfk_ia32_punpcklwd128_mask";
            case 3068L: return "bfk_ia32_punpcklwd256";
            case 3069L: return "bfk_ia32_punpcklwd256_mask";
            case 3070L: return "bfk_ia32_punpcklwd512_mask";
            case 3071L: return "bfk_ia32_pxor";
            case 3072L: return "bfk_ia32_pxor128";
            case 3073L: return "bfk_ia32_pxor256";
            case 3074L: return "bfk_ia32_pxord128_mask";
            case 3075L: return "bfk_ia32_pxord256_mask";
            case 3076L: return "bfk_ia32_pxord512_mask";
            case 3077L: return "bfk_ia32_pxorq128_mask";
            case 3078L: return "bfk_ia32_pxorq256_mask";
            case 3079L: return "bfk_ia32_pxorq512_mask";
            case 3080L: return "bfk_ia32_rangepd128_mask";
            case 3081L: return "bfk_ia32_rangepd256_mask";
            case 3082L: return "bfk_ia32_rangepd512_mask";
            case 3083L: return "bfk_ia32_rangeps128_mask";
            case 3084L: return "bfk_ia32_rangeps256_mask";
            case 3085L: return "bfk_ia32_rangeps512_mask";
            case 3086L: return "bfk_ia32_rangesd128_mask_round";
            case 3087L: return "bfk_ia32_rangesd128_round";
            case 3088L: return "bfk_ia32_rangesd128_round_mask";
            case 3089L: return "bfk_ia32_rangess128_mask_round";
            case 3090L: return "bfk_ia32_rangess128_round";
            case 3091L: return "bfk_ia32_rangess128_round_mask";
            case 3092L: return "bfk_ia32_rcp14pd128_mask";
            case 3093L: return "bfk_ia32_rcp14pd256_mask";
            case 3094L: return "bfk_ia32_rcp14pd512_mask";
            case 3095L: return "bfk_ia32_rcp14ps128_mask";
            case 3096L: return "bfk_ia32_rcp14ps256_mask";
            case 3097L: return "bfk_ia32_rcp14ps512_mask";
            case 3098L: return "bfk_ia32_rcp14sd";
            case 3099L: return "bfk_ia32_rcp14sd_mask";
            case 3100L: return "bfk_ia32_rcp14ss";
            case 3101L: return "bfk_ia32_rcp14ss_mask";
            case 3102L: return "bfk_ia32_rcp28pd_mask";
            case 3103L: return "bfk_ia32_rcp28ps_mask";
            case 3104L: return "bfk_ia32_rcp28sd_mask";
            case 3105L: return "bfk_ia32_rcp28sd_mask_round";
            case 3106L: return "bfk_ia32_rcp28sd_round";
            case 3107L: return "bfk_ia32_rcp28sd_round_mask";
            case 3108L: return "bfk_ia32_rcp28ss_mask";
            case 3109L: return "bfk_ia32_rcp28ss_mask_round";
            case 3110L: return "bfk_ia32_rcp28ss_round";
            case 3111L: return "bfk_ia32_rcp28ss_round_mask";
            case 3112L: return "bfk_ia32_rcpps";
            case 3113L: return "bfk_ia32_rcpps256";
            case 3114L: return "bfk_ia32_rcpss";
            case 3115L: return "bfk_ia32_rdfsbase32";
            case 3116L: return "bfk_ia32_rdfsbase64";
            case 3117L: return "bfk_ia32_rdgsbase32";
            case 3118L: return "bfk_ia32_rdgsbase64";
            case 3119L: return "bfk_ia32_rdpid";
            case 3120L: return "bfk_ia32_rdpkru";
            case 3121L: return "bfk_ia32_rdpmc";
            case 3122L: return "bfk_ia32_rdrand16_step";
            case 3123L: return "bfk_ia32_rdrand32_step";
            case 3124L: return "bfk_ia32_rdrand64_step";
            case 3125L: return "bfk_ia32_rdseed16_step";
            case 3126L: return "bfk_ia32_rdseed32_step";
            case 3127L: return "bfk_ia32_rdseed64_step";
            case 3128L: return "bfk_ia32_rdseed_di_step";
            case 3129L: return "bfk_ia32_rdseed_hi_step";
            case 3130L: return "bfk_ia32_rdseed_si_step";
            case 3131L: return "bfk_ia32_rdsspd";
            case 3132L: return "bfk_ia32_rdsspq";
            case 3133L: return "bfk_ia32_rdtsc";
            case 3134L: return "bfk_ia32_rdtscp";
            case 3135L: return "bfk_ia32_readeflags_u32";
            case 3136L: return "bfk_ia32_readeflags_u64";
            case 3137L: return "bfk_ia32_reduce_add_d512";
            case 3138L: return "bfk_ia32_reduce_add_q512";
            case 3139L: return "bfk_ia32_reduce_and_d512";
            case 3140L: return "bfk_ia32_reduce_and_q512";
            case 3141L: return "bfk_ia32_reduce_fadd_pd512";
            case 3142L: return "bfk_ia32_reduce_fadd_ps512";
            case 3143L: return "bfk_ia32_reduce_fmax_pd512";
            case 3144L: return "bfk_ia32_reduce_fmax_ps512";
            case 3145L: return "bfk_ia32_reduce_fmin_pd512";
            case 3146L: return "bfk_ia32_reduce_fmin_ps512";
            case 3147L: return "bfk_ia32_reduce_fmul_pd512";
            case 3148L: return "bfk_ia32_reduce_fmul_ps512";
            case 3149L: return "bfk_ia32_reduce_mul_d512";
            case 3150L: return "bfk_ia32_reduce_mul_q512";
            case 3151L: return "bfk_ia32_reduce_or_d512";
            case 3152L: return "bfk_ia32_reduce_or_q512";
            case 3153L: return "bfk_ia32_reduce_smax_d512";
            case 3154L: return "bfk_ia32_reduce_smax_q512";
            case 3155L: return "bfk_ia32_reduce_smin_d512";
            case 3156L: return "bfk_ia32_reduce_smin_q512";
            case 3157L: return "bfk_ia32_reduce_umax_d512";
            case 3158L: return "bfk_ia32_reduce_umax_q512";
            case 3159L: return "bfk_ia32_reduce_umin_d512";
            case 3160L: return "bfk_ia32_reduce_umin_q512";
            case 3161L: return "bfk_ia32_reducepd128_mask";
            case 3162L: return "bfk_ia32_reducepd256_mask";
            case 3163L: return "bfk_ia32_reducepd512_mask";
            case 3164L: return "bfk_ia32_reducepd512_mask_round";
            case 3165L: return "bfk_ia32_reduceps128_mask";
            case 3166L: return "bfk_ia32_reduceps256_mask";
            case 3167L: return "bfk_ia32_reduceps512_mask";
            case 3168L: return "bfk_ia32_reduceps512_mask_round";
            case 3169L: return "bfk_ia32_reducesd";
            case 3170L: return "bfk_ia32_reducesd_mask";
            case 3171L: return "bfk_ia32_reducesd_mask_round";
            case 3172L: return "bfk_ia32_reducess";
            case 3173L: return "bfk_ia32_reducess_mask";
            case 3174L: return "bfk_ia32_reducess_mask_round";
            case 3175L: return "bfk_ia32_rintpd";
            case 3176L: return "bfk_ia32_rintpd256";
            case 3177L: return "bfk_ia32_rintps";
            case 3178L: return "bfk_ia32_rintps256";
            case 3179L: return "bfk_ia32_rndscalepd_128_mask";
            case 3180L: return "bfk_ia32_rndscalepd_256_mask";
            case 3181L: return "bfk_ia32_rndscalepd_mask";
            case 3182L: return "bfk_ia32_rndscaleps_128_mask";
            case 3183L: return "bfk_ia32_rndscaleps_256_mask";
            case 3184L: return "bfk_ia32_rndscaleps_mask";
            case 3185L: return "bfk_ia32_rndscalesd_mask_round";
            case 3186L: return "bfk_ia32_rndscalesd_round";
            case 3187L: return "bfk_ia32_rndscalesd_round_mask";
            case 3188L: return "bfk_ia32_rndscaless_mask_round";
            case 3189L: return "bfk_ia32_rndscaless_round";
            case 3190L: return "bfk_ia32_rndscaless_round_mask";
            case 3191L: return "bfk_ia32_rolhi";
            case 3192L: return "bfk_ia32_rolqi";
            case 3193L: return "bfk_ia32_rorhi";
            case 3194L: return "bfk_ia32_rorqi";
            case 3195L: return "bfk_ia32_roundpd";
            case 3196L: return "bfk_ia32_roundpd256";
            case 3197L: return "bfk_ia32_roundpd_az";
            case 3198L: return "bfk_ia32_roundpd_az256";
            case 3199L: return "bfk_ia32_roundpd_az_vec_pack_sfix";
            case 3200L: return "bfk_ia32_roundpd_az_vec_pack_sfix256";
            case 3201L: return "bfk_ia32_roundpd_az_vec_pack_sfix512";
            case 3202L: return "bfk_ia32_roundps";
            case 3203L: return "bfk_ia32_roundps256";
            case 3204L: return "bfk_ia32_roundps_az";
            case 3205L: return "bfk_ia32_roundps_az256";
            case 3206L: return "bfk_ia32_roundps_az_sfix";
            case 3207L: return "bfk_ia32_roundps_az_sfix256";
            case 3208L: return "bfk_ia32_roundps_az_sfix512";
            case 3209L: return "bfk_ia32_roundsd";
            case 3210L: return "bfk_ia32_roundss";
            case 3211L: return "bfk_ia32_rsqrt14pd128_mask";
            case 3212L: return "bfk_ia32_rsqrt14pd256_mask";
            case 3213L: return "bfk_ia32_rsqrt14pd512_mask";
            case 3214L: return "bfk_ia32_rsqrt14ps128_mask";
            case 3215L: return "bfk_ia32_rsqrt14ps256_mask";
            case 3216L: return "bfk_ia32_rsqrt14ps512_mask";
            case 3217L: return "bfk_ia32_rsqrt14sd";
            case 3218L: return "bfk_ia32_rsqrt14sd_mask";
            case 3219L: return "bfk_ia32_rsqrt14ss";
            case 3220L: return "bfk_ia32_rsqrt14ss_mask";
            case 3221L: return "bfk_ia32_rsqrt28pd_mask";
            case 3222L: return "bfk_ia32_rsqrt28ps_mask";
            case 3223L: return "bfk_ia32_rsqrt28sd_mask";
            case 3224L: return "bfk_ia32_rsqrt28sd_mask_round";
            case 3225L: return "bfk_ia32_rsqrt28sd_round";
            case 3226L: return "bfk_ia32_rsqrt28sd_round_mask";
            case 3227L: return "bfk_ia32_rsqrt28ss_mask";
            case 3228L: return "bfk_ia32_rsqrt28ss_mask_round";
            case 3229L: return "bfk_ia32_rsqrt28ss_round";
            case 3230L: return "bfk_ia32_rsqrt28ss_round_mask";
            case 3231L: return "bfk_ia32_rsqrtf";
            case 3232L: return "bfk_ia32_rsqrtps";
            case 3233L: return "bfk_ia32_rsqrtps256";
            case 3234L: return "bfk_ia32_rsqrtps_nr";
            case 3235L: return "bfk_ia32_rsqrtps_nr256";
            case 3236L: return "bfk_ia32_rsqrtss";
            case 3237L: return "bfk_ia32_rstorssp";
            case 3238L: return "bfk_ia32_saveprevssp";
            case 3239L: return "bfk_ia32_sbb_u32";
            case 3240L: return "bfk_ia32_sbb_u64";
            case 3241L: return "bfk_ia32_scalefpd128_mask";
            case 3242L: return "bfk_ia32_scalefpd256_mask";
            case 3243L: return "bfk_ia32_scalefpd512_mask";
            case 3244L: return "bfk_ia32_scalefps128_mask";
            case 3245L: return "bfk_ia32_scalefps256_mask";
            case 3246L: return "bfk_ia32_scalefps512_mask";
            case 3247L: return "bfk_ia32_scalefsd_mask_round";
            case 3248L: return "bfk_ia32_scalefsd_round";
            case 3249L: return "bfk_ia32_scalefsd_round_mask";
            case 3250L: return "bfk_ia32_scalefss_mask_round";
            case 3251L: return "bfk_ia32_scalefss_round";
            case 3252L: return "bfk_ia32_scalefss_round_mask";
            case 3253L: return "bfk_ia32_scatteraltdiv16sf";
            case 3254L: return "bfk_ia32_scatteraltdiv16si";
            case 3255L: return "bfk_ia32_scatteraltdiv4sf";
            case 3256L: return "bfk_ia32_scatteraltdiv4si";
            case 3257L: return "bfk_ia32_scatteraltdiv8sf";
            case 3258L: return "bfk_ia32_scatteraltdiv8si";
            case 3259L: return "bfk_ia32_scatteraltsiv2df";
            case 3260L: return "bfk_ia32_scatteraltsiv2di";
            case 3261L: return "bfk_ia32_scatteraltsiv4df";
            case 3262L: return "bfk_ia32_scatteraltsiv4di";
            case 3263L: return "bfk_ia32_scatteraltsiv8df";
            case 3264L: return "bfk_ia32_scatteraltsiv8di";
            case 3265L: return "bfk_ia32_scatterdiv16sf";
            case 3266L: return "bfk_ia32_scatterdiv16si";
            case 3267L: return "bfk_ia32_scatterdiv2df";
            case 3268L: return "bfk_ia32_scatterdiv2di";
            case 3269L: return "bfk_ia32_scatterdiv4df";
            case 3270L: return "bfk_ia32_scatterdiv4di";
            case 3271L: return "bfk_ia32_scatterdiv4sf";
            case 3272L: return "bfk_ia32_scatterdiv4si";
            case 3273L: return "bfk_ia32_scatterdiv8df";
            case 3274L: return "bfk_ia32_scatterdiv8di";
            case 3275L: return "bfk_ia32_scatterdiv8sf";
            case 3276L: return "bfk_ia32_scatterdiv8si";
            case 3277L: return "bfk_ia32_scatterpfdpd";
            case 3278L: return "bfk_ia32_scatterpfdps";
            case 3279L: return "bfk_ia32_scatterpfqpd";
            case 3280L: return "bfk_ia32_scatterpfqps";
            case 3281L: return "bfk_ia32_scattersiv16sf";
            case 3282L: return "bfk_ia32_scattersiv16si";
            case 3283L: return "bfk_ia32_scattersiv2df";
            case 3284L: return "bfk_ia32_scattersiv2di";
            case 3285L: return "bfk_ia32_scattersiv4df";
            case 3286L: return "bfk_ia32_scattersiv4di";
            case 3287L: return "bfk_ia32_scattersiv4sf";
            case 3288L: return "bfk_ia32_scattersiv4si";
            case 3289L: return "bfk_ia32_scattersiv8df";
            case 3290L: return "bfk_ia32_scattersiv8di";
            case 3291L: return "bfk_ia32_scattersiv8sf";
            case 3292L: return "bfk_ia32_scattersiv8si";
            case 3293L: return "bfk_ia32_selectb_128";
            case 3294L: return "bfk_ia32_selectb_256";
            case 3295L: return "bfk_ia32_selectb_512";
            case 3296L: return "bfk_ia32_selectd_128";
            case 3297L: return "bfk_ia32_selectd_256";
            case 3298L: return "bfk_ia32_selectd_512";
            case 3299L: return "bfk_ia32_selectpd_128";
            case 3300L: return "bfk_ia32_selectpd_256";
            case 3301L: return "bfk_ia32_selectpd_512";
            case 3302L: return "bfk_ia32_selectps_128";
            case 3303L: return "bfk_ia32_selectps_256";
            case 3304L: return "bfk_ia32_selectps_512";
            case 3305L: return "bfk_ia32_selectq_128";
            case 3306L: return "bfk_ia32_selectq_256";
            case 3307L: return "bfk_ia32_selectq_512";
            case 3308L: return "bfk_ia32_selectsd_128";
            case 3309L: return "bfk_ia32_selectss_128";
            case 3310L: return "bfk_ia32_selectw_128";
            case 3311L: return "bfk_ia32_selectw_256";
            case 3312L: return "bfk_ia32_selectw_512";
            case 3313L: return "bfk_ia32_senduipi";
            case 3314L: return "bfk_ia32_serialize";
            case 3315L: return "bfk_ia32_setssbsy";
            case 3316L: return "bfk_ia32_sfence";
            case 3317L: return "bfk_ia32_sha1msg1";
            case 3318L: return "bfk_ia32_sha1msg2";
            case 3319L: return "bfk_ia32_sha1nexte";
            case 3320L: return "bfk_ia32_sha1rnds4";
            case 3321L: return "bfk_ia32_sha256msg1";
            case 3322L: return "bfk_ia32_sha256msg2";
            case 3323L: return "bfk_ia32_sha256rnds2";
            case 3324L: return "bfk_ia32_shuf_f32x4";
            case 3325L: return "bfk_ia32_shuf_f32x4_256";
            case 3326L: return "bfk_ia32_shuf_f32x4_256_mask";
            case 3327L: return "bfk_ia32_shuf_f32x4_mask";
            case 3328L: return "bfk_ia32_shuf_f64x2";
            case 3329L: return "bfk_ia32_shuf_f64x2_256";
            case 3330L: return "bfk_ia32_shuf_f64x2_256_mask";
            case 3331L: return "bfk_ia32_shuf_f64x2_mask";
            case 3332L: return "bfk_ia32_shuf_i32x4";
            case 3333L: return "bfk_ia32_shuf_i32x4_256";
            case 3334L: return "bfk_ia32_shuf_i32x4_256_mask";
            case 3335L: return "bfk_ia32_shuf_i32x4_mask";
            case 3336L: return "bfk_ia32_shuf_i64x2";
            case 3337L: return "bfk_ia32_shuf_i64x2_256";
            case 3338L: return "bfk_ia32_shuf_i64x2_256_mask";
            case 3339L: return "bfk_ia32_shuf_i64x2_mask";
            case 3340L: return "bfk_ia32_shufpd";
            case 3341L: return "bfk_ia32_shufpd128_mask";
            case 3342L: return "bfk_ia32_shufpd256";
            case 3343L: return "bfk_ia32_shufpd256_mask";
            case 3344L: return "bfk_ia32_shufpd512";
            case 3345L: return "bfk_ia32_shufpd512_mask";
            case 3346L: return "bfk_ia32_shufps";
            case 3347L: return "bfk_ia32_shufps128_mask";
            case 3348L: return "bfk_ia32_shufps256";
            case 3349L: return "bfk_ia32_shufps256_mask";
            case 3350L: return "bfk_ia32_shufps512";
            case 3351L: return "bfk_ia32_shufps512_mask";
            case 3352L: return "bfk_ia32_si256_si";
            case 3353L: return "bfk_ia32_si512_256si";
            case 3354L: return "bfk_ia32_si512_si";
            case 3355L: return "bfk_ia32_si_si256";
            case 3356L: return "bfk_ia32_slwpcb";
            case 3357L: return "bfk_ia32_sqrtpd";
            case 3358L: return "bfk_ia32_sqrtpd128_mask";
            case 3359L: return "bfk_ia32_sqrtpd256";
            case 3360L: return "bfk_ia32_sqrtpd256_mask";
            case 3361L: return "bfk_ia32_sqrtpd512";
            case 3362L: return "bfk_ia32_sqrtpd512_mask";
            case 3363L: return "bfk_ia32_sqrtps";
            case 3364L: return "bfk_ia32_sqrtps128_mask";
            case 3365L: return "bfk_ia32_sqrtps256";
            case 3366L: return "bfk_ia32_sqrtps256_mask";
            case 3367L: return "bfk_ia32_sqrtps512";
            case 3368L: return "bfk_ia32_sqrtps512_mask";
            case 3369L: return "bfk_ia32_sqrtps_nr";
            case 3370L: return "bfk_ia32_sqrtps_nr256";
            case 3371L: return "bfk_ia32_sqrtsd";
            case 3372L: return "bfk_ia32_sqrtsd_mask_round";
            case 3373L: return "bfk_ia32_sqrtsd_round";
            case 3374L: return "bfk_ia32_sqrtsd_round_mask";
            case 3375L: return "bfk_ia32_sqrtss";
            case 3376L: return "bfk_ia32_sqrtss_mask_round";
            case 3377L: return "bfk_ia32_sqrtss_round";
            case 3378L: return "bfk_ia32_sqrtss_round_mask";
            case 3379L: return "bfk_ia32_stmxcsr";
            case 3380L: return "bfk_ia32_storeapd128_mask";
            case 3381L: return "bfk_ia32_storeapd256_mask";
            case 3382L: return "bfk_ia32_storeapd512_mask";
            case 3383L: return "bfk_ia32_storeaps";
            case 3384L: return "bfk_ia32_storeaps128_mask";
            case 3385L: return "bfk_ia32_storeaps256_mask";
            case 3386L: return "bfk_ia32_storeaps512_mask";
            case 3387L: return "bfk_ia32_storedqu";
            case 3388L: return "bfk_ia32_storedqu256";
            case 3389L: return "bfk_ia32_storedqudi128_mask";
            case 3390L: return "bfk_ia32_storedqudi256_mask";
            case 3391L: return "bfk_ia32_storedqudi512_mask";
            case 3392L: return "bfk_ia32_storedquhi128_mask";
            case 3393L: return "bfk_ia32_storedquhi256_mask";
            case 3394L: return "bfk_ia32_storedquhi512_mask";
            case 3395L: return "bfk_ia32_storedquqi128_mask";
            case 3396L: return "bfk_ia32_storedquqi256_mask";
            case 3397L: return "bfk_ia32_storedquqi512_mask";
            case 3398L: return "bfk_ia32_storedqusi128_mask";
            case 3399L: return "bfk_ia32_storedqusi256_mask";
            case 3400L: return "bfk_ia32_storedqusi512_mask";
            case 3401L: return "bfk_ia32_storehps";
            case 3402L: return "bfk_ia32_storelps";
            case 3403L: return "bfk_ia32_storesd128_mask";
            case 3404L: return "bfk_ia32_storesd_mask";
            case 3405L: return "bfk_ia32_storess";
            case 3406L: return "bfk_ia32_storess128_mask";
            case 3407L: return "bfk_ia32_storess_mask";
            case 3408L: return "bfk_ia32_storeupd";
            case 3409L: return "bfk_ia32_storeupd128_mask";
            case 3410L: return "bfk_ia32_storeupd256";
            case 3411L: return "bfk_ia32_storeupd256_mask";
            case 3412L: return "bfk_ia32_storeupd512_mask";
            case 3413L: return "bfk_ia32_storeups";
            case 3414L: return "bfk_ia32_storeups128_mask";
            case 3415L: return "bfk_ia32_storeups256";
            case 3416L: return "bfk_ia32_storeups256_mask";
            case 3417L: return "bfk_ia32_storeups512_mask";
            case 3418L: return "bfk_ia32_stui";
            case 3419L: return "bfk_ia32_subborrow_u32";
            case 3420L: return "bfk_ia32_subborrow_u64";
            case 3421L: return "bfk_ia32_subpd";
            case 3422L: return "bfk_ia32_subpd128_mask";
            case 3423L: return "bfk_ia32_subpd256";
            case 3424L: return "bfk_ia32_subpd256_mask";
            case 3425L: return "bfk_ia32_subpd512";
            case 3426L: return "bfk_ia32_subpd512_mask";
            case 3427L: return "bfk_ia32_subps";
            case 3428L: return "bfk_ia32_subps128_mask";
            case 3429L: return "bfk_ia32_subps256";
            case 3430L: return "bfk_ia32_subps256_mask";
            case 3431L: return "bfk_ia32_subps512";
            case 3432L: return "bfk_ia32_subps512_mask";
            case 3433L: return "bfk_ia32_subsd";
            case 3434L: return "bfk_ia32_subsd_mask_round";
            case 3435L: return "bfk_ia32_subsd_round";
            case 3436L: return "bfk_ia32_subsd_round_mask";
            case 3437L: return "bfk_ia32_subss";
            case 3438L: return "bfk_ia32_subss_mask_round";
            case 3439L: return "bfk_ia32_subss_round";
            case 3440L: return "bfk_ia32_subss_round_mask";
            case 3441L: return "bfk_ia32_tdpbf16ps";
            case 3442L: return "bfk_ia32_tdpbf16ps_internal";
            case 3443L: return "bfk_ia32_tdpbssd";
            case 3444L: return "bfk_ia32_tdpbssd_internal";
            case 3445L: return "bfk_ia32_tdpbsud";
            case 3446L: return "bfk_ia32_tdpbsud_internal";
            case 3447L: return "bfk_ia32_tdpbusd";
            case 3448L: return "bfk_ia32_tdpbusd_internal";
            case 3449L: return "bfk_ia32_tdpbuud";
            case 3450L: return "bfk_ia32_tdpbuud_internal";
            case 3451L: return "bfk_ia32_testui";
            case 3452L: return "bfk_ia32_tile_loadconfig";
            case 3453L: return "bfk_ia32_tile_loadconfig_internal";
            case 3454L: return "bfk_ia32_tile_storeconfig";
            case 3455L: return "bfk_ia32_tileloadd64";
            case 3456L: return "bfk_ia32_tileloadd64_internal";
            case 3457L: return "bfk_ia32_tileloaddt164";
            case 3458L: return "bfk_ia32_tileloaddt164_internal";
            case 3459L: return "bfk_ia32_tilerelease";
            case 3460L: return "bfk_ia32_tilestored64";
            case 3461L: return "bfk_ia32_tilestored64_internal";
            case 3462L: return "bfk_ia32_tilezero";
            case 3463L: return "bfk_ia32_tilezero_internal";
            case 3464L: return "bfk_ia32_tpause";
            case 3465L: return "bfk_ia32_truncpd";
            case 3466L: return "bfk_ia32_truncpd256";
            case 3467L: return "bfk_ia32_truncpd512";
            case 3468L: return "bfk_ia32_truncps";
            case 3469L: return "bfk_ia32_truncps256";
            case 3470L: return "bfk_ia32_truncps512";
            case 3471L: return "bfk_ia32_tzcnt_u16";
            case 3472L: return "bfk_ia32_tzcnt_u32";
            case 3473L: return "bfk_ia32_tzcnt_u64";
            case 3474L: return "bfk_ia32_ucmpb128_mask";
            case 3475L: return "bfk_ia32_ucmpb256_mask";
            case 3476L: return "bfk_ia32_ucmpb512_mask";
            case 3477L: return "bfk_ia32_ucmpd128_mask";
            case 3478L: return "bfk_ia32_ucmpd256_mask";
            case 3479L: return "bfk_ia32_ucmpd512_mask";
            case 3480L: return "bfk_ia32_ucmpq128_mask";
            case 3481L: return "bfk_ia32_ucmpq256_mask";
            case 3482L: return "bfk_ia32_ucmpq512_mask";
            case 3483L: return "bfk_ia32_ucmpw128_mask";
            case 3484L: return "bfk_ia32_ucmpw256_mask";
            case 3485L: return "bfk_ia32_ucmpw512_mask";
            case 3486L: return "bfk_ia32_ucomieq";
            case 3487L: return "bfk_ia32_ucomige";
            case 3488L: return "bfk_ia32_ucomigt";
            case 3489L: return "bfk_ia32_ucomile";
            case 3490L: return "bfk_ia32_ucomilt";
            case 3491L: return "bfk_ia32_ucomineq";
            case 3492L: return "bfk_ia32_ucomisdeq";
            case 3493L: return "bfk_ia32_ucomisdge";
            case 3494L: return "bfk_ia32_ucomisdgt";
            case 3495L: return "bfk_ia32_ucomisdle";
            case 3496L: return "bfk_ia32_ucomisdlt";
            case 3497L: return "bfk_ia32_ucomisdneq";
            case 3498L: return "bfk_ia32_umonitor";
            case 3499L: return "bfk_ia32_umwait";
            case 3500L: return "bfk_ia32_undef128";
            case 3501L: return "bfk_ia32_undef256";
            case 3502L: return "bfk_ia32_undef512";
            case 3503L: return "bfk_ia32_unpckhpd";
            case 3504L: return "bfk_ia32_unpckhpd128_mask";
            case 3505L: return "bfk_ia32_unpckhpd256";
            case 3506L: return "bfk_ia32_unpckhpd256_mask";
            case 3507L: return "bfk_ia32_unpckhpd512_mask";
            case 3508L: return "bfk_ia32_unpckhps";
            case 3509L: return "bfk_ia32_unpckhps128_mask";
            case 3510L: return "bfk_ia32_unpckhps256";
            case 3511L: return "bfk_ia32_unpckhps256_mask";
            case 3512L: return "bfk_ia32_unpckhps512_mask";
            case 3513L: return "bfk_ia32_unpcklpd";
            case 3514L: return "bfk_ia32_unpcklpd128_mask";
            case 3515L: return "bfk_ia32_unpcklpd256";
            case 3516L: return "bfk_ia32_unpcklpd256_mask";
            case 3517L: return "bfk_ia32_unpcklpd512_mask";
            case 3518L: return "bfk_ia32_unpcklps";
            case 3519L: return "bfk_ia32_unpcklps128_mask";
            case 3520L: return "bfk_ia32_unpcklps256";
            case 3521L: return "bfk_ia32_unpcklps256_mask";
            case 3522L: return "bfk_ia32_unpcklps512_mask";
            case 3523L: return "bfk_ia32_vaesdec_v16qi";
            case 3524L: return "bfk_ia32_vaesdec_v32qi";
            case 3525L: return "bfk_ia32_vaesdec_v64qi";
            case 3526L: return "bfk_ia32_vaesdeclast_v16qi";
            case 3527L: return "bfk_ia32_vaesdeclast_v32qi";
            case 3528L: return "bfk_ia32_vaesdeclast_v64qi";
            case 3529L: return "bfk_ia32_vaesenc_v16qi";
            case 3530L: return "bfk_ia32_vaesenc_v32qi";
            case 3531L: return "bfk_ia32_vaesenc_v64qi";
            case 3532L: return "bfk_ia32_vaesenclast_v16qi";
            case 3533L: return "bfk_ia32_vaesenclast_v32qi";
            case 3534L: return "bfk_ia32_vaesenclast_v64qi";
            case 3535L: return "bfk_ia32_vbroadcastf128_pd256";
            case 3536L: return "bfk_ia32_vbroadcastf128_ps256";
            case 3537L: return "bfk_ia32_vbroadcastsd256";
            case 3538L: return "bfk_ia32_vbroadcastsd_pd256";
            case 3539L: return "bfk_ia32_vbroadcastsi256";
            case 3540L: return "bfk_ia32_vbroadcastss";
            case 3541L: return "bfk_ia32_vbroadcastss256";
            case 3542L: return "bfk_ia32_vbroadcastss_ps";
            case 3543L: return "bfk_ia32_vbroadcastss_ps256";
            case 3544L: return "bfk_ia32_vcomisd";
            case 3545L: return "bfk_ia32_vcomiss";
            case 3546L: return "bfk_ia32_vcvtph2ps";
            case 3547L: return "bfk_ia32_vcvtph2ps256";
            case 3548L: return "bfk_ia32_vcvtph2ps256_mask";
            case 3549L: return "bfk_ia32_vcvtph2ps512";
            case 3550L: return "bfk_ia32_vcvtph2ps512_mask";
            case 3551L: return "bfk_ia32_vcvtph2ps_mask";
            case 3552L: return "bfk_ia32_vcvtps2ph";
            case 3553L: return "bfk_ia32_vcvtps2ph256";
            case 3554L: return "bfk_ia32_vcvtps2ph256_mask";
            case 3555L: return "bfk_ia32_vcvtps2ph512";
            case 3556L: return "bfk_ia32_vcvtps2ph512_mask";
            case 3557L: return "bfk_ia32_vcvtps2ph_mask";
            case 3558L: return "bfk_ia32_vcvtsd2si32";
            case 3559L: return "bfk_ia32_vcvtsd2si64";
            case 3560L: return "bfk_ia32_vcvtsd2usi32";
            case 3561L: return "bfk_ia32_vcvtsd2usi64";
            case 3562L: return "bfk_ia32_vcvtss2si32";
            case 3563L: return "bfk_ia32_vcvtss2si64";
            case 3564L: return "bfk_ia32_vcvtss2usi32";
            case 3565L: return "bfk_ia32_vcvtss2usi64";
            case 3566L: return "bfk_ia32_vcvttsd2si32";
            case 3567L: return "bfk_ia32_vcvttsd2si64";
            case 3568L: return "bfk_ia32_vcvttsd2usi32";
            case 3569L: return "bfk_ia32_vcvttsd2usi64";
            case 3570L: return "bfk_ia32_vcvttss2si32";
            case 3571L: return "bfk_ia32_vcvttss2si64";
            case 3572L: return "bfk_ia32_vcvttss2usi32";
            case 3573L: return "bfk_ia32_vcvttss2usi64";
            case 3574L: return "bfk_ia32_vec_ext_v16hi";
            case 3575L: return "bfk_ia32_vec_ext_v16qi";
            case 3576L: return "bfk_ia32_vec_ext_v2df";
            case 3577L: return "bfk_ia32_vec_ext_v2di";
            case 3578L: return "bfk_ia32_vec_ext_v2si";
            case 3579L: return "bfk_ia32_vec_ext_v32qi";
            case 3580L: return "bfk_ia32_vec_ext_v4di";
            case 3581L: return "bfk_ia32_vec_ext_v4hi";
            case 3582L: return "bfk_ia32_vec_ext_v4sf";
            case 3583L: return "bfk_ia32_vec_ext_v4si";
            case 3584L: return "bfk_ia32_vec_ext_v8hi";
            case 3585L: return "bfk_ia32_vec_ext_v8si";
            case 3586L: return "bfk_ia32_vec_init_v2si";
            case 3587L: return "bfk_ia32_vec_init_v4hi";
            case 3588L: return "bfk_ia32_vec_init_v8qi";
            case 3589L: return "bfk_ia32_vec_pack_sfix";
            case 3590L: return "bfk_ia32_vec_pack_sfix256";
            case 3591L: return "bfk_ia32_vec_pack_sfix512";
            case 3592L: return "bfk_ia32_vec_perm_v16qi";
            case 3593L: return "bfk_ia32_vec_perm_v16qi_u";
            case 3594L: return "bfk_ia32_vec_perm_v2df";
            case 3595L: return "bfk_ia32_vec_perm_v2di";
            case 3596L: return "bfk_ia32_vec_perm_v2di_u";
            case 3597L: return "bfk_ia32_vec_perm_v4df";
            case 3598L: return "bfk_ia32_vec_perm_v4sf";
            case 3599L: return "bfk_ia32_vec_perm_v4si";
            case 3600L: return "bfk_ia32_vec_perm_v4si_u";
            case 3601L: return "bfk_ia32_vec_perm_v8hi";
            case 3602L: return "bfk_ia32_vec_perm_v8hi_u";
            case 3603L: return "bfk_ia32_vec_perm_v8sf";
            case 3604L: return "bfk_ia32_vec_set_v16hi";
            case 3605L: return "bfk_ia32_vec_set_v16qi";
            case 3606L: return "bfk_ia32_vec_set_v2di";
            case 3607L: return "bfk_ia32_vec_set_v32qi";
            case 3608L: return "bfk_ia32_vec_set_v4di";
            case 3609L: return "bfk_ia32_vec_set_v4hi";
            case 3610L: return "bfk_ia32_vec_set_v4sf";
            case 3611L: return "bfk_ia32_vec_set_v4si";
            case 3612L: return "bfk_ia32_vec_set_v8hi";
            case 3613L: return "bfk_ia32_vec_set_v8si";
            case 3614L: return "bfk_ia32_vextractf128_pd256";
            case 3615L: return "bfk_ia32_vextractf128_ps256";
            case 3616L: return "bfk_ia32_vextractf128_si256";
            case 3617L: return "bfk_ia32_vfmaddpd";
            case 3618L: return "bfk_ia32_vfmaddpd128_mask";
            case 3619L: return "bfk_ia32_vfmaddpd128_mask3";
            case 3620L: return "bfk_ia32_vfmaddpd128_maskz";
            case 3621L: return "bfk_ia32_vfmaddpd256";
            case 3622L: return "bfk_ia32_vfmaddpd256_mask";
            case 3623L: return "bfk_ia32_vfmaddpd256_mask3";
            case 3624L: return "bfk_ia32_vfmaddpd256_maskz";
            case 3625L: return "bfk_ia32_vfmaddpd512_mask";
            case 3626L: return "bfk_ia32_vfmaddpd512_mask3";
            case 3627L: return "bfk_ia32_vfmaddpd512_maskz";
            case 3628L: return "bfk_ia32_vfmaddps";
            case 3629L: return "bfk_ia32_vfmaddps128_mask";
            case 3630L: return "bfk_ia32_vfmaddps128_mask3";
            case 3631L: return "bfk_ia32_vfmaddps128_maskz";
            case 3632L: return "bfk_ia32_vfmaddps256";
            case 3633L: return "bfk_ia32_vfmaddps256_mask";
            case 3634L: return "bfk_ia32_vfmaddps256_mask3";
            case 3635L: return "bfk_ia32_vfmaddps256_maskz";
            case 3636L: return "bfk_ia32_vfmaddps512_mask";
            case 3637L: return "bfk_ia32_vfmaddps512_mask3";
            case 3638L: return "bfk_ia32_vfmaddps512_maskz";
            case 3639L: return "bfk_ia32_vfmaddsd";
            case 3640L: return "bfk_ia32_vfmaddsd3";
            case 3641L: return "bfk_ia32_vfmaddsd3_mask";
            case 3642L: return "bfk_ia32_vfmaddsd3_mask3";
            case 3643L: return "bfk_ia32_vfmaddsd3_maskz";
            case 3644L: return "bfk_ia32_vfmaddsd3_round";
            case 3645L: return "bfk_ia32_vfmaddss";
            case 3646L: return "bfk_ia32_vfmaddss3";
            case 3647L: return "bfk_ia32_vfmaddss3_mask";
            case 3648L: return "bfk_ia32_vfmaddss3_mask3";
            case 3649L: return "bfk_ia32_vfmaddss3_maskz";
            case 3650L: return "bfk_ia32_vfmaddss3_round";
            case 3651L: return "bfk_ia32_vfmaddsubpd";
            case 3652L: return "bfk_ia32_vfmaddsubpd128_mask";
            case 3653L: return "bfk_ia32_vfmaddsubpd128_mask3";
            case 3654L: return "bfk_ia32_vfmaddsubpd128_maskz";
            case 3655L: return "bfk_ia32_vfmaddsubpd256";
            case 3656L: return "bfk_ia32_vfmaddsubpd256_mask";
            case 3657L: return "bfk_ia32_vfmaddsubpd256_mask3";
            case 3658L: return "bfk_ia32_vfmaddsubpd256_maskz";
            case 3659L: return "bfk_ia32_vfmaddsubpd512_mask";
            case 3660L: return "bfk_ia32_vfmaddsubpd512_mask3";
            case 3661L: return "bfk_ia32_vfmaddsubpd512_maskz";
            case 3662L: return "bfk_ia32_vfmaddsubps";
            case 3663L: return "bfk_ia32_vfmaddsubps128_mask";
            case 3664L: return "bfk_ia32_vfmaddsubps128_mask3";
            case 3665L: return "bfk_ia32_vfmaddsubps128_maskz";
            case 3666L: return "bfk_ia32_vfmaddsubps256";
            case 3667L: return "bfk_ia32_vfmaddsubps256_mask";
            case 3668L: return "bfk_ia32_vfmaddsubps256_mask3";
            case 3669L: return "bfk_ia32_vfmaddsubps256_maskz";
            case 3670L: return "bfk_ia32_vfmaddsubps512_mask";
            case 3671L: return "bfk_ia32_vfmaddsubps512_mask3";
            case 3672L: return "bfk_ia32_vfmaddsubps512_maskz";
            case 3673L: return "bfk_ia32_vfmsubaddpd";
            case 3674L: return "bfk_ia32_vfmsubaddpd128_mask3";
            case 3675L: return "bfk_ia32_vfmsubaddpd256";
            case 3676L: return "bfk_ia32_vfmsubaddpd256_mask3";
            case 3677L: return "bfk_ia32_vfmsubaddpd512_mask3";
            case 3678L: return "bfk_ia32_vfmsubaddps";
            case 3679L: return "bfk_ia32_vfmsubaddps128_mask3";
            case 3680L: return "bfk_ia32_vfmsubaddps256";
            case 3681L: return "bfk_ia32_vfmsubaddps256_mask3";
            case 3682L: return "bfk_ia32_vfmsubaddps512_mask3";
            case 3683L: return "bfk_ia32_vfmsubpd";
            case 3684L: return "bfk_ia32_vfmsubpd128_mask";
            case 3685L: return "bfk_ia32_vfmsubpd128_mask3";
            case 3686L: return "bfk_ia32_vfmsubpd128_maskz";
            case 3687L: return "bfk_ia32_vfmsubpd256";
            case 3688L: return "bfk_ia32_vfmsubpd256_mask";
            case 3689L: return "bfk_ia32_vfmsubpd256_mask3";
            case 3690L: return "bfk_ia32_vfmsubpd256_maskz";
            case 3691L: return "bfk_ia32_vfmsubpd512_mask";
            case 3692L: return "bfk_ia32_vfmsubpd512_mask3";
            case 3693L: return "bfk_ia32_vfmsubpd512_maskz";
            case 3694L: return "bfk_ia32_vfmsubps";
            case 3695L: return "bfk_ia32_vfmsubps128_mask";
            case 3696L: return "bfk_ia32_vfmsubps128_mask3";
            case 3697L: return "bfk_ia32_vfmsubps128_maskz";
            case 3698L: return "bfk_ia32_vfmsubps256";
            case 3699L: return "bfk_ia32_vfmsubps256_mask";
            case 3700L: return "bfk_ia32_vfmsubps256_mask3";
            case 3701L: return "bfk_ia32_vfmsubps256_maskz";
            case 3702L: return "bfk_ia32_vfmsubps512_mask";
            case 3703L: return "bfk_ia32_vfmsubps512_mask3";
            case 3704L: return "bfk_ia32_vfmsubps512_maskz";
            case 3705L: return "bfk_ia32_vfmsubsd";
            case 3706L: return "bfk_ia32_vfmsubsd3";
            case 3707L: return "bfk_ia32_vfmsubsd3_mask3";
            case 3708L: return "bfk_ia32_vfmsubss";
            case 3709L: return "bfk_ia32_vfmsubss3";
            case 3710L: return "bfk_ia32_vfmsubss3_mask3";
            case 3711L: return "bfk_ia32_vfnmaddpd";
            case 3712L: return "bfk_ia32_vfnmaddpd128_mask";
            case 3713L: return "bfk_ia32_vfnmaddpd128_mask3";
            case 3714L: return "bfk_ia32_vfnmaddpd128_maskz";
            case 3715L: return "bfk_ia32_vfnmaddpd256";
            case 3716L: return "bfk_ia32_vfnmaddpd256_mask";
            case 3717L: return "bfk_ia32_vfnmaddpd256_mask3";
            case 3718L: return "bfk_ia32_vfnmaddpd256_maskz";
            case 3719L: return "bfk_ia32_vfnmaddpd512_mask";
            case 3720L: return "bfk_ia32_vfnmaddpd512_mask3";
            case 3721L: return "bfk_ia32_vfnmaddpd512_maskz";
            case 3722L: return "bfk_ia32_vfnmaddps";
            case 3723L: return "bfk_ia32_vfnmaddps128_mask";
            case 3724L: return "bfk_ia32_vfnmaddps128_mask3";
            case 3725L: return "bfk_ia32_vfnmaddps128_maskz";
            case 3726L: return "bfk_ia32_vfnmaddps256";
            case 3727L: return "bfk_ia32_vfnmaddps256_mask";
            case 3728L: return "bfk_ia32_vfnmaddps256_mask3";
            case 3729L: return "bfk_ia32_vfnmaddps256_maskz";
            case 3730L: return "bfk_ia32_vfnmaddps512_mask";
            case 3731L: return "bfk_ia32_vfnmaddps512_mask3";
            case 3732L: return "bfk_ia32_vfnmaddps512_maskz";
            case 3733L: return "bfk_ia32_vfnmaddsd";
            case 3734L: return "bfk_ia32_vfnmaddsd3";
            case 3735L: return "bfk_ia32_vfnmaddss";
            case 3736L: return "bfk_ia32_vfnmaddss3";
            case 3737L: return "bfk_ia32_vfnmsubpd";
            case 3738L: return "bfk_ia32_vfnmsubpd128_mask";
            case 3739L: return "bfk_ia32_vfnmsubpd128_mask3";
            case 3740L: return "bfk_ia32_vfnmsubpd128_maskz";
            case 3741L: return "bfk_ia32_vfnmsubpd256";
            case 3742L: return "bfk_ia32_vfnmsubpd256_mask";
            case 3743L: return "bfk_ia32_vfnmsubpd256_mask3";
            case 3744L: return "bfk_ia32_vfnmsubpd256_maskz";
            case 3745L: return "bfk_ia32_vfnmsubpd512_mask";
            case 3746L: return "bfk_ia32_vfnmsubpd512_mask3";
            case 3747L: return "bfk_ia32_vfnmsubpd512_maskz";
            case 3748L: return "bfk_ia32_vfnmsubps";
            case 3749L: return "bfk_ia32_vfnmsubps128_mask";
            case 3750L: return "bfk_ia32_vfnmsubps128_mask3";
            case 3751L: return "bfk_ia32_vfnmsubps128_maskz";
            case 3752L: return "bfk_ia32_vfnmsubps256";
            case 3753L: return "bfk_ia32_vfnmsubps256_mask";
            case 3754L: return "bfk_ia32_vfnmsubps256_mask3";
            case 3755L: return "bfk_ia32_vfnmsubps256_maskz";
            case 3756L: return "bfk_ia32_vfnmsubps512_mask";
            case 3757L: return "bfk_ia32_vfnmsubps512_mask3";
            case 3758L: return "bfk_ia32_vfnmsubps512_maskz";
            case 3759L: return "bfk_ia32_vfnmsubsd";
            case 3760L: return "bfk_ia32_vfnmsubsd3";
            case 3761L: return "bfk_ia32_vfnmsubsd3_mask3";
            case 3762L: return "bfk_ia32_vfnmsubss";
            case 3763L: return "bfk_ia32_vfnmsubss3";
            case 3764L: return "bfk_ia32_vfnmsubss3_mask3";
            case 3765L: return "bfk_ia32_vfrczpd";
            case 3766L: return "bfk_ia32_vfrczpd256";
            case 3767L: return "bfk_ia32_vfrczps";
            case 3768L: return "bfk_ia32_vfrczps256";
            case 3769L: return "bfk_ia32_vfrczsd";
            case 3770L: return "bfk_ia32_vfrczss";
            case 3771L: return "bfk_ia32_vgf2p8affineinvqb_v16qi";
            case 3772L: return "bfk_ia32_vgf2p8affineinvqb_v16qi_mask";
            case 3773L: return "bfk_ia32_vgf2p8affineinvqb_v32qi";
            case 3774L: return "bfk_ia32_vgf2p8affineinvqb_v32qi_mask";
            case 3775L: return "bfk_ia32_vgf2p8affineinvqb_v64qi";
            case 3776L: return "bfk_ia32_vgf2p8affineinvqb_v64qi_mask";
            case 3777L: return "bfk_ia32_vgf2p8affineqb_v16qi";
            case 3778L: return "bfk_ia32_vgf2p8affineqb_v16qi_mask";
            case 3779L: return "bfk_ia32_vgf2p8affineqb_v32qi";
            case 3780L: return "bfk_ia32_vgf2p8affineqb_v32qi_mask";
            case 3781L: return "bfk_ia32_vgf2p8affineqb_v64qi";
            case 3782L: return "bfk_ia32_vgf2p8affineqb_v64qi_mask";
            case 3783L: return "bfk_ia32_vgf2p8mulb_v16qi";
            case 3784L: return "bfk_ia32_vgf2p8mulb_v16qi_mask";
            case 3785L: return "bfk_ia32_vgf2p8mulb_v32qi";
            case 3786L: return "bfk_ia32_vgf2p8mulb_v32qi_mask";
            case 3787L: return "bfk_ia32_vgf2p8mulb_v64qi";
            case 3788L: return "bfk_ia32_vgf2p8mulb_v64qi_mask";
            case 3789L: return "bfk_ia32_vinsertf128_pd256";
            case 3790L: return "bfk_ia32_vinsertf128_ps256";
            case 3791L: return "bfk_ia32_vinsertf128_si256";
            case 3792L: return "bfk_ia32_vp2intersect_d_128";
            case 3793L: return "bfk_ia32_vp2intersect_d_256";
            case 3794L: return "bfk_ia32_vp2intersect_d_512";
            case 3795L: return "bfk_ia32_vp2intersect_q_128";
            case 3796L: return "bfk_ia32_vp2intersect_q_256";
            case 3797L: return "bfk_ia32_vp2intersect_q_512";
            case 3798L: return "bfk_ia32_vp4dpwssd";
            case 3799L: return "bfk_ia32_vp4dpwssd_mask";
            case 3800L: return "bfk_ia32_vp4dpwssds";
            case 3801L: return "bfk_ia32_vp4dpwssds_mask";
            case 3802L: return "bfk_ia32_vpclmulqdq_v2di";
            case 3803L: return "bfk_ia32_vpclmulqdq_v4di";
            case 3804L: return "bfk_ia32_vpclmulqdq_v8di";
            case 3805L: return "bfk_ia32_vpcmov";
            case 3806L: return "bfk_ia32_vpcmov256";
            case 3807L: return "bfk_ia32_vpcmov_256";
            case 3808L: return "bfk_ia32_vpcmov_v16hi256";
            case 3809L: return "bfk_ia32_vpcmov_v16qi";
            case 3810L: return "bfk_ia32_vpcmov_v2df";
            case 3811L: return "bfk_ia32_vpcmov_v2di";
            case 3812L: return "bfk_ia32_vpcmov_v32qi256";
            case 3813L: return "bfk_ia32_vpcmov_v4df256";
            case 3814L: return "bfk_ia32_vpcmov_v4di256";
            case 3815L: return "bfk_ia32_vpcmov_v4sf";
            case 3816L: return "bfk_ia32_vpcmov_v4si";
            case 3817L: return "bfk_ia32_vpcmov_v8hi";
            case 3818L: return "bfk_ia32_vpcmov_v8sf256";
            case 3819L: return "bfk_ia32_vpcmov_v8si256";
            case 3820L: return "bfk_ia32_vpcomb";
            case 3821L: return "bfk_ia32_vpcomd";
            case 3822L: return "bfk_ia32_vpcomeqb";
            case 3823L: return "bfk_ia32_vpcomeqd";
            case 3824L: return "bfk_ia32_vpcomeqq";
            case 3825L: return "bfk_ia32_vpcomequb";
            case 3826L: return "bfk_ia32_vpcomequd";
            case 3827L: return "bfk_ia32_vpcomequq";
            case 3828L: return "bfk_ia32_vpcomequw";
            case 3829L: return "bfk_ia32_vpcomeqw";
            case 3830L: return "bfk_ia32_vpcomfalseb";
            case 3831L: return "bfk_ia32_vpcomfalsed";
            case 3832L: return "bfk_ia32_vpcomfalseq";
            case 3833L: return "bfk_ia32_vpcomfalseub";
            case 3834L: return "bfk_ia32_vpcomfalseud";
            case 3835L: return "bfk_ia32_vpcomfalseuq";
            case 3836L: return "bfk_ia32_vpcomfalseuw";
            case 3837L: return "bfk_ia32_vpcomfalsew";
            case 3838L: return "bfk_ia32_vpcomgeb";
            case 3839L: return "bfk_ia32_vpcomged";
            case 3840L: return "bfk_ia32_vpcomgeq";
            case 3841L: return "bfk_ia32_vpcomgeub";
            case 3842L: return "bfk_ia32_vpcomgeud";
            case 3843L: return "bfk_ia32_vpcomgeuq";
            case 3844L: return "bfk_ia32_vpcomgeuw";
            case 3845L: return "bfk_ia32_vpcomgew";
            case 3846L: return "bfk_ia32_vpcomgtb";
            case 3847L: return "bfk_ia32_vpcomgtd";
            case 3848L: return "bfk_ia32_vpcomgtq";
            case 3849L: return "bfk_ia32_vpcomgtub";
            case 3850L: return "bfk_ia32_vpcomgtud";
            case 3851L: return "bfk_ia32_vpcomgtuq";
            case 3852L: return "bfk_ia32_vpcomgtuw";
            case 3853L: return "bfk_ia32_vpcomgtw";
            case 3854L: return "bfk_ia32_vpcomleb";
            case 3855L: return "bfk_ia32_vpcomled";
            case 3856L: return "bfk_ia32_vpcomleq";
            case 3857L: return "bfk_ia32_vpcomleub";
            case 3858L: return "bfk_ia32_vpcomleud";
            case 3859L: return "bfk_ia32_vpcomleuq";
            case 3860L: return "bfk_ia32_vpcomleuw";
            case 3861L: return "bfk_ia32_vpcomlew";
            case 3862L: return "bfk_ia32_vpcomltb";
            case 3863L: return "bfk_ia32_vpcomltd";
            case 3864L: return "bfk_ia32_vpcomltq";
            case 3865L: return "bfk_ia32_vpcomltub";
            case 3866L: return "bfk_ia32_vpcomltud";
            case 3867L: return "bfk_ia32_vpcomltuq";
            case 3868L: return "bfk_ia32_vpcomltuw";
            case 3869L: return "bfk_ia32_vpcomltw";
            case 3870L: return "bfk_ia32_vpcomneb";
            case 3871L: return "bfk_ia32_vpcomned";
            case 3872L: return "bfk_ia32_vpcomneq";
            case 3873L: return "bfk_ia32_vpcomneqb";
            case 3874L: return "bfk_ia32_vpcomneqd";
            case 3875L: return "bfk_ia32_vpcomneqq";
            case 3876L: return "bfk_ia32_vpcomnequb";
            case 3877L: return "bfk_ia32_vpcomnequd";
            case 3878L: return "bfk_ia32_vpcomnequq";
            case 3879L: return "bfk_ia32_vpcomnequw";
            case 3880L: return "bfk_ia32_vpcomneqw";
            case 3881L: return "bfk_ia32_vpcomneub";
            case 3882L: return "bfk_ia32_vpcomneud";
            case 3883L: return "bfk_ia32_vpcomneuq";
            case 3884L: return "bfk_ia32_vpcomneuw";
            case 3885L: return "bfk_ia32_vpcomnew";
            case 3886L: return "bfk_ia32_vpcomq";
            case 3887L: return "bfk_ia32_vpcomtrueb";
            case 3888L: return "bfk_ia32_vpcomtrued";
            case 3889L: return "bfk_ia32_vpcomtrueq";
            case 3890L: return "bfk_ia32_vpcomtrueub";
            case 3891L: return "bfk_ia32_vpcomtrueud";
            case 3892L: return "bfk_ia32_vpcomtrueuq";
            case 3893L: return "bfk_ia32_vpcomtrueuw";
            case 3894L: return "bfk_ia32_vpcomtruew";
            case 3895L: return "bfk_ia32_vpcomub";
            case 3896L: return "bfk_ia32_vpcomud";
            case 3897L: return "bfk_ia32_vpcomuq";
            case 3898L: return "bfk_ia32_vpcomuw";
            case 3899L: return "bfk_ia32_vpcomw";
            case 3900L: return "bfk_ia32_vpconflictdi_128";
            case 3901L: return "bfk_ia32_vpconflictdi_128_mask";
            case 3902L: return "bfk_ia32_vpconflictdi_256";
            case 3903L: return "bfk_ia32_vpconflictdi_256_mask";
            case 3904L: return "bfk_ia32_vpconflictdi_512";
            case 3905L: return "bfk_ia32_vpconflictdi_512_mask";
            case 3906L: return "bfk_ia32_vpconflictsi_128";
            case 3907L: return "bfk_ia32_vpconflictsi_128_mask";
            case 3908L: return "bfk_ia32_vpconflictsi_256";
            case 3909L: return "bfk_ia32_vpconflictsi_256_mask";
            case 3910L: return "bfk_ia32_vpconflictsi_512";
            case 3911L: return "bfk_ia32_vpconflictsi_512_mask";
            case 3912L: return "bfk_ia32_vpdpbusd128";
            case 3913L: return "bfk_ia32_vpdpbusd128_mask";
            case 3914L: return "bfk_ia32_vpdpbusd128_maskz";
            case 3915L: return "bfk_ia32_vpdpbusd256";
            case 3916L: return "bfk_ia32_vpdpbusd256_mask";
            case 3917L: return "bfk_ia32_vpdpbusd256_maskz";
            case 3918L: return "bfk_ia32_vpdpbusd512";
            case 3919L: return "bfk_ia32_vpdpbusd512_mask";
            case 3920L: return "bfk_ia32_vpdpbusd512_maskz";
            case 3921L: return "bfk_ia32_vpdpbusd_v16si";
            case 3922L: return "bfk_ia32_vpdpbusd_v16si_mask";
            case 3923L: return "bfk_ia32_vpdpbusd_v16si_maskz";
            case 3924L: return "bfk_ia32_vpdpbusd_v4si";
            case 3925L: return "bfk_ia32_vpdpbusd_v4si_mask";
            case 3926L: return "bfk_ia32_vpdpbusd_v4si_maskz";
            case 3927L: return "bfk_ia32_vpdpbusd_v8si";
            case 3928L: return "bfk_ia32_vpdpbusd_v8si_mask";
            case 3929L: return "bfk_ia32_vpdpbusd_v8si_maskz";
            case 3930L: return "bfk_ia32_vpdpbusds128";
            case 3931L: return "bfk_ia32_vpdpbusds128_mask";
            case 3932L: return "bfk_ia32_vpdpbusds128_maskz";
            case 3933L: return "bfk_ia32_vpdpbusds256";
            case 3934L: return "bfk_ia32_vpdpbusds256_mask";
            case 3935L: return "bfk_ia32_vpdpbusds256_maskz";
            case 3936L: return "bfk_ia32_vpdpbusds512";
            case 3937L: return "bfk_ia32_vpdpbusds512_mask";
            case 3938L: return "bfk_ia32_vpdpbusds512_maskz";
            case 3939L: return "bfk_ia32_vpdpbusds_v16si";
            case 3940L: return "bfk_ia32_vpdpbusds_v16si_mask";
            case 3941L: return "bfk_ia32_vpdpbusds_v16si_maskz";
            case 3942L: return "bfk_ia32_vpdpbusds_v4si";
            case 3943L: return "bfk_ia32_vpdpbusds_v4si_mask";
            case 3944L: return "bfk_ia32_vpdpbusds_v4si_maskz";
            case 3945L: return "bfk_ia32_vpdpbusds_v8si";
            case 3946L: return "bfk_ia32_vpdpbusds_v8si_mask";
            case 3947L: return "bfk_ia32_vpdpbusds_v8si_maskz";
            case 3948L: return "bfk_ia32_vpdpwssd128";
            case 3949L: return "bfk_ia32_vpdpwssd128_mask";
            case 3950L: return "bfk_ia32_vpdpwssd128_maskz";
            case 3951L: return "bfk_ia32_vpdpwssd256";
            case 3952L: return "bfk_ia32_vpdpwssd256_mask";
            case 3953L: return "bfk_ia32_vpdpwssd256_maskz";
            case 3954L: return "bfk_ia32_vpdpwssd512";
            case 3955L: return "bfk_ia32_vpdpwssd512_mask";
            case 3956L: return "bfk_ia32_vpdpwssd512_maskz";
            case 3957L: return "bfk_ia32_vpdpwssd_v16si";
            case 3958L: return "bfk_ia32_vpdpwssd_v16si_mask";
            case 3959L: return "bfk_ia32_vpdpwssd_v16si_maskz";
            case 3960L: return "bfk_ia32_vpdpwssd_v4si";
            case 3961L: return "bfk_ia32_vpdpwssd_v4si_mask";
            case 3962L: return "bfk_ia32_vpdpwssd_v4si_maskz";
            case 3963L: return "bfk_ia32_vpdpwssd_v8si";
            case 3964L: return "bfk_ia32_vpdpwssd_v8si_mask";
            case 3965L: return "bfk_ia32_vpdpwssd_v8si_maskz";
            case 3966L: return "bfk_ia32_vpdpwssds128";
            case 3967L: return "bfk_ia32_vpdpwssds128_mask";
            case 3968L: return "bfk_ia32_vpdpwssds128_maskz";
            case 3969L: return "bfk_ia32_vpdpwssds256";
            case 3970L: return "bfk_ia32_vpdpwssds256_mask";
            case 3971L: return "bfk_ia32_vpdpwssds256_maskz";
            case 3972L: return "bfk_ia32_vpdpwssds512";
            case 3973L: return "bfk_ia32_vpdpwssds512_mask";
            case 3974L: return "bfk_ia32_vpdpwssds512_maskz";
            case 3975L: return "bfk_ia32_vpdpwssds_v16si";
            case 3976L: return "bfk_ia32_vpdpwssds_v16si_mask";
            case 3977L: return "bfk_ia32_vpdpwssds_v16si_maskz";
            case 3978L: return "bfk_ia32_vpdpwssds_v4si";
            case 3979L: return "bfk_ia32_vpdpwssds_v4si_mask";
            case 3980L: return "bfk_ia32_vpdpwssds_v4si_maskz";
            case 3981L: return "bfk_ia32_vpdpwssds_v8si";
            case 3982L: return "bfk_ia32_vpdpwssds_v8si_mask";
            case 3983L: return "bfk_ia32_vpdpwssds_v8si_maskz";
            case 3984L: return "bfk_ia32_vperm2f128_pd256";
            case 3985L: return "bfk_ia32_vperm2f128_ps256";
            case 3986L: return "bfk_ia32_vperm2f128_si256";
            case 3987L: return "bfk_ia32_vpermi2vard128";
            case 3988L: return "bfk_ia32_vpermi2vard128_mask";
            case 3989L: return "bfk_ia32_vpermi2vard256";
            case 3990L: return "bfk_ia32_vpermi2vard256_mask";
            case 3991L: return "bfk_ia32_vpermi2vard512";
            case 3992L: return "bfk_ia32_vpermi2vard512_mask";
            case 3993L: return "bfk_ia32_vpermi2varhi128";
            case 3994L: return "bfk_ia32_vpermi2varhi128_mask";
            case 3995L: return "bfk_ia32_vpermi2varhi256";
            case 3996L: return "bfk_ia32_vpermi2varhi256_mask";
            case 3997L: return "bfk_ia32_vpermi2varhi512";
            case 3998L: return "bfk_ia32_vpermi2varhi512_mask";
            case 3999L: return "bfk_ia32_vpermi2varpd128";
            case 4000L: return "bfk_ia32_vpermi2varpd128_mask";
            case 4001L: return "bfk_ia32_vpermi2varpd256";
            case 4002L: return "bfk_ia32_vpermi2varpd256_mask";
            case 4003L: return "bfk_ia32_vpermi2varpd512";
            case 4004L: return "bfk_ia32_vpermi2varpd512_mask";
            case 4005L: return "bfk_ia32_vpermi2varps128";
            case 4006L: return "bfk_ia32_vpermi2varps128_mask";
            case 4007L: return "bfk_ia32_vpermi2varps256";
            case 4008L: return "bfk_ia32_vpermi2varps256_mask";
            case 4009L: return "bfk_ia32_vpermi2varps512";
            case 4010L: return "bfk_ia32_vpermi2varps512_mask";
            case 4011L: return "bfk_ia32_vpermi2varq128";
            case 4012L: return "bfk_ia32_vpermi2varq128_mask";
            case 4013L: return "bfk_ia32_vpermi2varq256";
            case 4014L: return "bfk_ia32_vpermi2varq256_mask";
            case 4015L: return "bfk_ia32_vpermi2varq512";
            case 4016L: return "bfk_ia32_vpermi2varq512_mask";
            case 4017L: return "bfk_ia32_vpermi2varqi128";
            case 4018L: return "bfk_ia32_vpermi2varqi128_mask";
            case 4019L: return "bfk_ia32_vpermi2varqi256";
            case 4020L: return "bfk_ia32_vpermi2varqi256_mask";
            case 4021L: return "bfk_ia32_vpermi2varqi512";
            case 4022L: return "bfk_ia32_vpermi2varqi512_mask";
            case 4023L: return "bfk_ia32_vpermil2pd";
            case 4024L: return "bfk_ia32_vpermil2pd256";
            case 4025L: return "bfk_ia32_vpermil2ps";
            case 4026L: return "bfk_ia32_vpermil2ps256";
            case 4027L: return "bfk_ia32_vpermilpd";
            case 4028L: return "bfk_ia32_vpermilpd256";
            case 4029L: return "bfk_ia32_vpermilpd256_mask";
            case 4030L: return "bfk_ia32_vpermilpd512";
            case 4031L: return "bfk_ia32_vpermilpd512_mask";
            case 4032L: return "bfk_ia32_vpermilpd_mask";
            case 4033L: return "bfk_ia32_vpermilps";
            case 4034L: return "bfk_ia32_vpermilps256";
            case 4035L: return "bfk_ia32_vpermilps256_mask";
            case 4036L: return "bfk_ia32_vpermilps512";
            case 4037L: return "bfk_ia32_vpermilps512_mask";
            case 4038L: return "bfk_ia32_vpermilps_mask";
            case 4039L: return "bfk_ia32_vpermilvarpd";
            case 4040L: return "bfk_ia32_vpermilvarpd256";
            case 4041L: return "bfk_ia32_vpermilvarpd256_mask";
            case 4042L: return "bfk_ia32_vpermilvarpd512";
            case 4043L: return "bfk_ia32_vpermilvarpd512_mask";
            case 4044L: return "bfk_ia32_vpermilvarpd_mask";
            case 4045L: return "bfk_ia32_vpermilvarps";
            case 4046L: return "bfk_ia32_vpermilvarps256";
            case 4047L: return "bfk_ia32_vpermilvarps256_mask";
            case 4048L: return "bfk_ia32_vpermilvarps512";
            case 4049L: return "bfk_ia32_vpermilvarps512_mask";
            case 4050L: return "bfk_ia32_vpermilvarps_mask";
            case 4051L: return "bfk_ia32_vpermt2vard128_mask";
            case 4052L: return "bfk_ia32_vpermt2vard128_maskz";
            case 4053L: return "bfk_ia32_vpermt2vard256_mask";
            case 4054L: return "bfk_ia32_vpermt2vard256_maskz";
            case 4055L: return "bfk_ia32_vpermt2vard512_mask";
            case 4056L: return "bfk_ia32_vpermt2vard512_maskz";
            case 4057L: return "bfk_ia32_vpermt2varhi128_mask";
            case 4058L: return "bfk_ia32_vpermt2varhi128_maskz";
            case 4059L: return "bfk_ia32_vpermt2varhi256_mask";
            case 4060L: return "bfk_ia32_vpermt2varhi256_maskz";
            case 4061L: return "bfk_ia32_vpermt2varhi512_mask";
            case 4062L: return "bfk_ia32_vpermt2varhi512_maskz";
            case 4063L: return "bfk_ia32_vpermt2varpd128_mask";
            case 4064L: return "bfk_ia32_vpermt2varpd128_maskz";
            case 4065L: return "bfk_ia32_vpermt2varpd256_mask";
            case 4066L: return "bfk_ia32_vpermt2varpd256_maskz";
            case 4067L: return "bfk_ia32_vpermt2varpd512_mask";
            case 4068L: return "bfk_ia32_vpermt2varpd512_maskz";
            case 4069L: return "bfk_ia32_vpermt2varps128_mask";
            case 4070L: return "bfk_ia32_vpermt2varps128_maskz";
            case 4071L: return "bfk_ia32_vpermt2varps256_mask";
            case 4072L: return "bfk_ia32_vpermt2varps256_maskz";
            case 4073L: return "bfk_ia32_vpermt2varps512_mask";
            case 4074L: return "bfk_ia32_vpermt2varps512_maskz";
            case 4075L: return "bfk_ia32_vpermt2varq128_mask";
            case 4076L: return "bfk_ia32_vpermt2varq128_maskz";
            case 4077L: return "bfk_ia32_vpermt2varq256_mask";
            case 4078L: return "bfk_ia32_vpermt2varq256_maskz";
            case 4079L: return "bfk_ia32_vpermt2varq512_mask";
            case 4080L: return "bfk_ia32_vpermt2varq512_maskz";
            case 4081L: return "bfk_ia32_vpermt2varqi128_mask";
            case 4082L: return "bfk_ia32_vpermt2varqi128_maskz";
            case 4083L: return "bfk_ia32_vpermt2varqi256_mask";
            case 4084L: return "bfk_ia32_vpermt2varqi256_maskz";
            case 4085L: return "bfk_ia32_vpermt2varqi512_mask";
            case 4086L: return "bfk_ia32_vpermt2varqi512_maskz";
            case 4087L: return "bfk_ia32_vphaddbd";
            case 4088L: return "bfk_ia32_vphaddbq";
            case 4089L: return "bfk_ia32_vphaddbw";
            case 4090L: return "bfk_ia32_vphadddq";
            case 4091L: return "bfk_ia32_vphaddubd";
            case 4092L: return "bfk_ia32_vphaddubq";
            case 4093L: return "bfk_ia32_vphaddubw";
            case 4094L: return "bfk_ia32_vphaddudq";
            case 4095L: return "bfk_ia32_vphadduwd";
            case 4096L: return "bfk_ia32_vphadduwq";
            case 4097L: return "bfk_ia32_vphaddwd";
            case 4098L: return "bfk_ia32_vphaddwq";
            case 4099L: return "bfk_ia32_vphsubbw";
            case 4100L: return "bfk_ia32_vphsubdq";
            case 4101L: return "bfk_ia32_vphsubwd";
            case 4102L: return "bfk_ia32_vplzcntd_128";
            case 4103L: return "bfk_ia32_vplzcntd_128_mask";
            case 4104L: return "bfk_ia32_vplzcntd_256";
            case 4105L: return "bfk_ia32_vplzcntd_256_mask";
            case 4106L: return "bfk_ia32_vplzcntd_512";
            case 4107L: return "bfk_ia32_vplzcntd_512_mask";
            case 4108L: return "bfk_ia32_vplzcntq_128";
            case 4109L: return "bfk_ia32_vplzcntq_128_mask";
            case 4110L: return "bfk_ia32_vplzcntq_256";
            case 4111L: return "bfk_ia32_vplzcntq_256_mask";
            case 4112L: return "bfk_ia32_vplzcntq_512";
            case 4113L: return "bfk_ia32_vplzcntq_512_mask";
            case 4114L: return "bfk_ia32_vpmacsdd";
            case 4115L: return "bfk_ia32_vpmacsdqh";
            case 4116L: return "bfk_ia32_vpmacsdql";
            case 4117L: return "bfk_ia32_vpmacssdd";
            case 4118L: return "bfk_ia32_vpmacssdqh";
            case 4119L: return "bfk_ia32_vpmacssdql";
            case 4120L: return "bfk_ia32_vpmacsswd";
            case 4121L: return "bfk_ia32_vpmacssww";
            case 4122L: return "bfk_ia32_vpmacswd";
            case 4123L: return "bfk_ia32_vpmacsww";
            case 4124L: return "bfk_ia32_vpmadcsswd";
            case 4125L: return "bfk_ia32_vpmadcswd";
            case 4126L: return "bfk_ia32_vpmadd52huq128";
            case 4127L: return "bfk_ia32_vpmadd52huq128_mask";
            case 4128L: return "bfk_ia32_vpmadd52huq128_maskz";
            case 4129L: return "bfk_ia32_vpmadd52huq256";
            case 4130L: return "bfk_ia32_vpmadd52huq256_mask";
            case 4131L: return "bfk_ia32_vpmadd52huq256_maskz";
            case 4132L: return "bfk_ia32_vpmadd52huq512";
            case 4133L: return "bfk_ia32_vpmadd52huq512_mask";
            case 4134L: return "bfk_ia32_vpmadd52huq512_maskz";
            case 4135L: return "bfk_ia32_vpmadd52luq128";
            case 4136L: return "bfk_ia32_vpmadd52luq128_mask";
            case 4137L: return "bfk_ia32_vpmadd52luq128_maskz";
            case 4138L: return "bfk_ia32_vpmadd52luq256";
            case 4139L: return "bfk_ia32_vpmadd52luq256_mask";
            case 4140L: return "bfk_ia32_vpmadd52luq256_maskz";
            case 4141L: return "bfk_ia32_vpmadd52luq512";
            case 4142L: return "bfk_ia32_vpmadd52luq512_mask";
            case 4143L: return "bfk_ia32_vpmadd52luq512_maskz";
            case 4144L: return "bfk_ia32_vpmultishiftqb128";
            case 4145L: return "bfk_ia32_vpmultishiftqb128_mask";
            case 4146L: return "bfk_ia32_vpmultishiftqb256";
            case 4147L: return "bfk_ia32_vpmultishiftqb256_mask";
            case 4148L: return "bfk_ia32_vpmultishiftqb512";
            case 4149L: return "bfk_ia32_vpmultishiftqb512_mask";
            case 4150L: return "bfk_ia32_vpopcntb_128";
            case 4151L: return "bfk_ia32_vpopcntb_256";
            case 4152L: return "bfk_ia32_vpopcntb_512";
            case 4153L: return "bfk_ia32_vpopcntd_128";
            case 4154L: return "bfk_ia32_vpopcntd_256";
            case 4155L: return "bfk_ia32_vpopcntd_512";
            case 4156L: return "bfk_ia32_vpopcntq_128";
            case 4157L: return "bfk_ia32_vpopcntq_256";
            case 4158L: return "bfk_ia32_vpopcntq_512";
            case 4159L: return "bfk_ia32_vpopcntw_128";
            case 4160L: return "bfk_ia32_vpopcntw_256";
            case 4161L: return "bfk_ia32_vpopcntw_512";
            case 4162L: return "bfk_ia32_vpopcountb_v16qi";
            case 4163L: return "bfk_ia32_vpopcountb_v16qi_mask";
            case 4164L: return "bfk_ia32_vpopcountb_v32qi";
            case 4165L: return "bfk_ia32_vpopcountb_v32qi_mask";
            case 4166L: return "bfk_ia32_vpopcountb_v64qi";
            case 4167L: return "bfk_ia32_vpopcountb_v64qi_mask";
            case 4168L: return "bfk_ia32_vpopcountd_v16si";
            case 4169L: return "bfk_ia32_vpopcountd_v16si_mask";
            case 4170L: return "bfk_ia32_vpopcountd_v4si";
            case 4171L: return "bfk_ia32_vpopcountd_v4si_mask";
            case 4172L: return "bfk_ia32_vpopcountd_v8si";
            case 4173L: return "bfk_ia32_vpopcountd_v8si_mask";
            case 4174L: return "bfk_ia32_vpopcountq_v2di";
            case 4175L: return "bfk_ia32_vpopcountq_v2di_mask";
            case 4176L: return "bfk_ia32_vpopcountq_v4di";
            case 4177L: return "bfk_ia32_vpopcountq_v4di_mask";
            case 4178L: return "bfk_ia32_vpopcountq_v8di";
            case 4179L: return "bfk_ia32_vpopcountq_v8di_mask";
            case 4180L: return "bfk_ia32_vpopcountw_v16hi";
            case 4181L: return "bfk_ia32_vpopcountw_v16hi_mask";
            case 4182L: return "bfk_ia32_vpopcountw_v32hi";
            case 4183L: return "bfk_ia32_vpopcountw_v32hi_mask";
            case 4184L: return "bfk_ia32_vpopcountw_v8hi";
            case 4185L: return "bfk_ia32_vpopcountw_v8hi_mask";
            case 4186L: return "bfk_ia32_vpperm";
            case 4187L: return "bfk_ia32_vprotb";
            case 4188L: return "bfk_ia32_vprotbi";
            case 4189L: return "bfk_ia32_vprotd";
            case 4190L: return "bfk_ia32_vprotdi";
            case 4191L: return "bfk_ia32_vprotq";
            case 4192L: return "bfk_ia32_vprotqi";
            case 4193L: return "bfk_ia32_vprotw";
            case 4194L: return "bfk_ia32_vprotwi";
            case 4195L: return "bfk_ia32_vpshab";
            case 4196L: return "bfk_ia32_vpshad";
            case 4197L: return "bfk_ia32_vpshaq";
            case 4198L: return "bfk_ia32_vpshaw";
            case 4199L: return "bfk_ia32_vpshlb";
            case 4200L: return "bfk_ia32_vpshld";
            case 4201L: return "bfk_ia32_vpshld_v16hi";
            case 4202L: return "bfk_ia32_vpshld_v16hi_mask";
            case 4203L: return "bfk_ia32_vpshld_v16si";
            case 4204L: return "bfk_ia32_vpshld_v16si_mask";
            case 4205L: return "bfk_ia32_vpshld_v2di";
            case 4206L: return "bfk_ia32_vpshld_v2di_mask";
            case 4207L: return "bfk_ia32_vpshld_v32hi";
            case 4208L: return "bfk_ia32_vpshld_v32hi_mask";
            case 4209L: return "bfk_ia32_vpshld_v4di";
            case 4210L: return "bfk_ia32_vpshld_v4di_mask";
            case 4211L: return "bfk_ia32_vpshld_v4si";
            case 4212L: return "bfk_ia32_vpshld_v4si_mask";
            case 4213L: return "bfk_ia32_vpshld_v8di";
            case 4214L: return "bfk_ia32_vpshld_v8di_mask";
            case 4215L: return "bfk_ia32_vpshld_v8hi";
            case 4216L: return "bfk_ia32_vpshld_v8hi_mask";
            case 4217L: return "bfk_ia32_vpshld_v8si";
            case 4218L: return "bfk_ia32_vpshld_v8si_mask";
            case 4219L: return "bfk_ia32_vpshldd128";
            case 4220L: return "bfk_ia32_vpshldd128_mask";
            case 4221L: return "bfk_ia32_vpshldd256";
            case 4222L: return "bfk_ia32_vpshldd256_mask";
            case 4223L: return "bfk_ia32_vpshldd512";
            case 4224L: return "bfk_ia32_vpshldd512_mask";
            case 4225L: return "bfk_ia32_vpshldq128";
            case 4226L: return "bfk_ia32_vpshldq128_mask";
            case 4227L: return "bfk_ia32_vpshldq256";
            case 4228L: return "bfk_ia32_vpshldq256_mask";
            case 4229L: return "bfk_ia32_vpshldq512";
            case 4230L: return "bfk_ia32_vpshldq512_mask";
            case 4231L: return "bfk_ia32_vpshldv_v16hi";
            case 4232L: return "bfk_ia32_vpshldv_v16hi_mask";
            case 4233L: return "bfk_ia32_vpshldv_v16hi_maskz";
            case 4234L: return "bfk_ia32_vpshldv_v16si";
            case 4235L: return "bfk_ia32_vpshldv_v16si_mask";
            case 4236L: return "bfk_ia32_vpshldv_v16si_maskz";
            case 4237L: return "bfk_ia32_vpshldv_v2di";
            case 4238L: return "bfk_ia32_vpshldv_v2di_mask";
            case 4239L: return "bfk_ia32_vpshldv_v2di_maskz";
            case 4240L: return "bfk_ia32_vpshldv_v32hi";
            case 4241L: return "bfk_ia32_vpshldv_v32hi_mask";
            case 4242L: return "bfk_ia32_vpshldv_v32hi_maskz";
            case 4243L: return "bfk_ia32_vpshldv_v4di";
            case 4244L: return "bfk_ia32_vpshldv_v4di_mask";
            case 4245L: return "bfk_ia32_vpshldv_v4di_maskz";
            case 4246L: return "bfk_ia32_vpshldv_v4si";
            case 4247L: return "bfk_ia32_vpshldv_v4si_mask";
            case 4248L: return "bfk_ia32_vpshldv_v4si_maskz";
            case 4249L: return "bfk_ia32_vpshldv_v8di";
            case 4250L: return "bfk_ia32_vpshldv_v8di_mask";
            case 4251L: return "bfk_ia32_vpshldv_v8di_maskz";
            case 4252L: return "bfk_ia32_vpshldv_v8hi";
            case 4253L: return "bfk_ia32_vpshldv_v8hi_mask";
            case 4254L: return "bfk_ia32_vpshldv_v8hi_maskz";
            case 4255L: return "bfk_ia32_vpshldv_v8si";
            case 4256L: return "bfk_ia32_vpshldv_v8si_mask";
            case 4257L: return "bfk_ia32_vpshldv_v8si_maskz";
            case 4258L: return "bfk_ia32_vpshldvd128";
            case 4259L: return "bfk_ia32_vpshldvd128_mask";
            case 4260L: return "bfk_ia32_vpshldvd128_maskz";
            case 4261L: return "bfk_ia32_vpshldvd256";
            case 4262L: return "bfk_ia32_vpshldvd256_mask";
            case 4263L: return "bfk_ia32_vpshldvd256_maskz";
            case 4264L: return "bfk_ia32_vpshldvd512";
            case 4265L: return "bfk_ia32_vpshldvd512_mask";
            case 4266L: return "bfk_ia32_vpshldvd512_maskz";
            case 4267L: return "bfk_ia32_vpshldvq128";
            case 4268L: return "bfk_ia32_vpshldvq128_mask";
            case 4269L: return "bfk_ia32_vpshldvq128_maskz";
            case 4270L: return "bfk_ia32_vpshldvq256";
            case 4271L: return "bfk_ia32_vpshldvq256_mask";
            case 4272L: return "bfk_ia32_vpshldvq256_maskz";
            case 4273L: return "bfk_ia32_vpshldvq512";
            case 4274L: return "bfk_ia32_vpshldvq512_mask";
            case 4275L: return "bfk_ia32_vpshldvq512_maskz";
            case 4276L: return "bfk_ia32_vpshldvw128";
            case 4277L: return "bfk_ia32_vpshldvw128_mask";
            case 4278L: return "bfk_ia32_vpshldvw128_maskz";
            case 4279L: return "bfk_ia32_vpshldvw256";
            case 4280L: return "bfk_ia32_vpshldvw256_mask";
            case 4281L: return "bfk_ia32_vpshldvw256_maskz";
            case 4282L: return "bfk_ia32_vpshldvw512";
            case 4283L: return "bfk_ia32_vpshldvw512_mask";
            case 4284L: return "bfk_ia32_vpshldvw512_maskz";
            case 4285L: return "bfk_ia32_vpshldw128";
            case 4286L: return "bfk_ia32_vpshldw128_mask";
            case 4287L: return "bfk_ia32_vpshldw256";
            case 4288L: return "bfk_ia32_vpshldw256_mask";
            case 4289L: return "bfk_ia32_vpshldw512";
            case 4290L: return "bfk_ia32_vpshldw512_mask";
            case 4291L: return "bfk_ia32_vpshlq";
            case 4292L: return "bfk_ia32_vpshlw";
            case 4293L: return "bfk_ia32_vpshrd_v16hi";
            case 4294L: return "bfk_ia32_vpshrd_v16hi_mask";
            case 4295L: return "bfk_ia32_vpshrd_v16si";
            case 4296L: return "bfk_ia32_vpshrd_v16si_mask";
            case 4297L: return "bfk_ia32_vpshrd_v2di";
            case 4298L: return "bfk_ia32_vpshrd_v2di_mask";
            case 4299L: return "bfk_ia32_vpshrd_v32hi";
            case 4300L: return "bfk_ia32_vpshrd_v32hi_mask";
            case 4301L: return "bfk_ia32_vpshrd_v4di";
            case 4302L: return "bfk_ia32_vpshrd_v4di_mask";
            case 4303L: return "bfk_ia32_vpshrd_v4si";
            case 4304L: return "bfk_ia32_vpshrd_v4si_mask";
            case 4305L: return "bfk_ia32_vpshrd_v8di";
            case 4306L: return "bfk_ia32_vpshrd_v8di_mask";
            case 4307L: return "bfk_ia32_vpshrd_v8hi";
            case 4308L: return "bfk_ia32_vpshrd_v8hi_mask";
            case 4309L: return "bfk_ia32_vpshrd_v8si";
            case 4310L: return "bfk_ia32_vpshrd_v8si_mask";
            case 4311L: return "bfk_ia32_vpshrdd128";
            case 4312L: return "bfk_ia32_vpshrdd128_mask";
            case 4313L: return "bfk_ia32_vpshrdd256";
            case 4314L: return "bfk_ia32_vpshrdd256_mask";
            case 4315L: return "bfk_ia32_vpshrdd512";
            case 4316L: return "bfk_ia32_vpshrdd512_mask";
            case 4317L: return "bfk_ia32_vpshrdq128";
            case 4318L: return "bfk_ia32_vpshrdq128_mask";
            case 4319L: return "bfk_ia32_vpshrdq256";
            case 4320L: return "bfk_ia32_vpshrdq256_mask";
            case 4321L: return "bfk_ia32_vpshrdq512";
            case 4322L: return "bfk_ia32_vpshrdq512_mask";
            case 4323L: return "bfk_ia32_vpshrdv_v16hi";
            case 4324L: return "bfk_ia32_vpshrdv_v16hi_mask";
            case 4325L: return "bfk_ia32_vpshrdv_v16hi_maskz";
            case 4326L: return "bfk_ia32_vpshrdv_v16si";
            case 4327L: return "bfk_ia32_vpshrdv_v16si_mask";
            case 4328L: return "bfk_ia32_vpshrdv_v16si_maskz";
            case 4329L: return "bfk_ia32_vpshrdv_v2di";
            case 4330L: return "bfk_ia32_vpshrdv_v2di_mask";
            case 4331L: return "bfk_ia32_vpshrdv_v2di_maskz";
            case 4332L: return "bfk_ia32_vpshrdv_v32hi";
            case 4333L: return "bfk_ia32_vpshrdv_v32hi_mask";
            case 4334L: return "bfk_ia32_vpshrdv_v32hi_maskz";
            case 4335L: return "bfk_ia32_vpshrdv_v4di";
            case 4336L: return "bfk_ia32_vpshrdv_v4di_mask";
            case 4337L: return "bfk_ia32_vpshrdv_v4di_maskz";
            case 4338L: return "bfk_ia32_vpshrdv_v4si";
            case 4339L: return "bfk_ia32_vpshrdv_v4si_mask";
            case 4340L: return "bfk_ia32_vpshrdv_v4si_maskz";
            case 4341L: return "bfk_ia32_vpshrdv_v8di";
            case 4342L: return "bfk_ia32_vpshrdv_v8di_mask";
            case 4343L: return "bfk_ia32_vpshrdv_v8di_maskz";
            case 4344L: return "bfk_ia32_vpshrdv_v8hi";
            case 4345L: return "bfk_ia32_vpshrdv_v8hi_mask";
            case 4346L: return "bfk_ia32_vpshrdv_v8hi_maskz";
            case 4347L: return "bfk_ia32_vpshrdv_v8si";
            case 4348L: return "bfk_ia32_vpshrdv_v8si_mask";
            case 4349L: return "bfk_ia32_vpshrdv_v8si_maskz";
            case 4350L: return "bfk_ia32_vpshrdvd128";
            case 4351L: return "bfk_ia32_vpshrdvd128_mask";
            case 4352L: return "bfk_ia32_vpshrdvd128_maskz";
            case 4353L: return "bfk_ia32_vpshrdvd256";
            case 4354L: return "bfk_ia32_vpshrdvd256_mask";
            case 4355L: return "bfk_ia32_vpshrdvd256_maskz";
            case 4356L: return "bfk_ia32_vpshrdvd512";
            case 4357L: return "bfk_ia32_vpshrdvd512_mask";
            case 4358L: return "bfk_ia32_vpshrdvd512_maskz";
            case 4359L: return "bfk_ia32_vpshrdvq128";
            case 4360L: return "bfk_ia32_vpshrdvq128_mask";
            case 4361L: return "bfk_ia32_vpshrdvq128_maskz";
            case 4362L: return "bfk_ia32_vpshrdvq256";
            case 4363L: return "bfk_ia32_vpshrdvq256_mask";
            case 4364L: return "bfk_ia32_vpshrdvq256_maskz";
            case 4365L: return "bfk_ia32_vpshrdvq512";
            case 4366L: return "bfk_ia32_vpshrdvq512_mask";
            case 4367L: return "bfk_ia32_vpshrdvq512_maskz";
            case 4368L: return "bfk_ia32_vpshrdvw128";
            case 4369L: return "bfk_ia32_vpshrdvw128_mask";
            case 4370L: return "bfk_ia32_vpshrdvw128_maskz";
            case 4371L: return "bfk_ia32_vpshrdvw256";
            case 4372L: return "bfk_ia32_vpshrdvw256_mask";
            case 4373L: return "bfk_ia32_vpshrdvw256_maskz";
            case 4374L: return "bfk_ia32_vpshrdvw512";
            case 4375L: return "bfk_ia32_vpshrdvw512_mask";
            case 4376L: return "bfk_ia32_vpshrdvw512_maskz";
            case 4377L: return "bfk_ia32_vpshrdw128";
            case 4378L: return "bfk_ia32_vpshrdw128_mask";
            case 4379L: return "bfk_ia32_vpshrdw256";
            case 4380L: return "bfk_ia32_vpshrdw256_mask";
            case 4381L: return "bfk_ia32_vpshrdw512";
            case 4382L: return "bfk_ia32_vpshrdw512_mask";
            case 4383L: return "bfk_ia32_vpshufbitqmb128_mask";
            case 4384L: return "bfk_ia32_vpshufbitqmb256_mask";
            case 4385L: return "bfk_ia32_vpshufbitqmb512_mask";
            case 4386L: return "bfk_ia32_vtestcpd";
            case 4387L: return "bfk_ia32_vtestcpd256";
            case 4388L: return "bfk_ia32_vtestcps";
            case 4389L: return "bfk_ia32_vtestcps256";
            case 4390L: return "bfk_ia32_vtestnzcpd";
            case 4391L: return "bfk_ia32_vtestnzcpd256";
            case 4392L: return "bfk_ia32_vtestnzcps";
            case 4393L: return "bfk_ia32_vtestnzcps256";
            case 4394L: return "bfk_ia32_vtestzpd";
            case 4395L: return "bfk_ia32_vtestzpd256";
            case 4396L: return "bfk_ia32_vtestzps";
            case 4397L: return "bfk_ia32_vtestzps256";
            case 4398L: return "bfk_ia32_vzeroall";
            case 4399L: return "bfk_ia32_vzeroupper";
            case 4400L: return "bfk_ia32_wbinvd";
            case 4401L: return "bfk_ia32_wbnoinvd";
            case 4402L: return "bfk_ia32_wrfsbase32";
            case 4403L: return "bfk_ia32_wrfsbase64";
            case 4404L: return "bfk_ia32_wrgsbase32";
            case 4405L: return "bfk_ia32_wrgsbase64";
            case 4406L: return "bfk_ia32_writeeflags_u32";
            case 4407L: return "bfk_ia32_writeeflags_u64";
            case 4408L: return "bfk_ia32_wrpkru";
            case 4409L: return "bfk_ia32_wrssd";
            case 4410L: return "bfk_ia32_wrssq";
            case 4411L: return "bfk_ia32_wrussd";
            case 4412L: return "bfk_ia32_wrussq";
            case 4413L: return "bfk_ia32_xabort";
            case 4414L: return "bfk_ia32_xbegin";
            case 4415L: return "bfk_ia32_xend";
            case 4416L: return "bfk_ia32_xgetbv";
            case 4417L: return "bfk_ia32_xorpd";
            case 4418L: return "bfk_ia32_xorpd128_mask";
            case 4419L: return "bfk_ia32_xorpd256";
            case 4420L: return "bfk_ia32_xorpd256_mask";
            case 4421L: return "bfk_ia32_xorpd512_mask";
            case 4422L: return "bfk_ia32_xorps";
            case 4423L: return "bfk_ia32_xorps128_mask";
            case 4424L: return "bfk_ia32_xorps256";
            case 4425L: return "bfk_ia32_xorps256_mask";
            case 4426L: return "bfk_ia32_xorps512_mask";
            case 4427L: return "bfk_ia32_xresldtrk";
            case 4428L: return "bfk_ia32_xrstor";
            case 4429L: return "bfk_ia32_xrstor64";
            case 4430L: return "bfk_ia32_xrstors";
            case 4431L: return "bfk_ia32_xrstors64";
            case 4432L: return "bfk_ia32_xsave";
            case 4433L: return "bfk_ia32_xsave64";
            case 4434L: return "bfk_ia32_xsavec";
            case 4435L: return "bfk_ia32_xsavec64";
            case 4436L: return "bfk_ia32_xsaveopt";
            case 4437L: return "bfk_ia32_xsaveopt64";
            case 4438L: return "bfk_ia32_xsaves";
            case 4439L: return "bfk_ia32_xsaves64";
            case 4440L: return "bfk_ia32_xsetbv";
            case 4441L: return "bfk_ia32_xsusldtrk";
            case 4442L: return "bfk_ia32_xtest";
            case 4443L: return "bfk_iceil";
            case 4444L: return "bfk_iceilf";
            case 4445L: return "bfk_iceill";
            case 4446L: return "bfk_ifloor";
            case 4447L: return "bfk_ifloorf";
            case 4448L: return "bfk_ifloorl";
            case 4449L: return "bfk_ilogb";
            case 4450L: return "bfk_ilogbf";
            case 4451L: return "bfk_ilogbf128";
            case 4452L: return "bfk_ilogbl";
            case 4453L: return "bfk_imaxabs";
            case 4454L: return "bfk_index";
            case 4455L: return "bfk_inf";
            case 4456L: return "bfk_inff";
            case 4457L: return "bfk_inff128";
            case 4458L: return "bfk_inff32";
            case 4459L: return "bfk_inff32x";
            case 4460L: return "bfk_inff64";
            case 4461L: return "bfk_inff64x";
            case 4462L: return "bfk_infl";
            case 4463L: return "bfk_init_descriptor";
            case 4464L: return "bfk_init_dwarf_reg_size_table";
            case 4465L: return "bfk_init_heap_trampoline";
            case 4466L: return "bfk_init_trampoline";
            case 4467L: return "bfk_irint";
            case 4468L: return "bfk_irintf";
            case 4469L: return "bfk_irintl";
            case 4470L: return "bfk_iround";
            case 4471L: return "bfk_iroundf";
            case 4472L: return "bfk_iroundl";
            case 4473L: return "bfk_is_aligned";
            case 4474L: return "bfk_is_constant_evaluated";
            case 4475L: return "bfk_isalnum";
            case 4476L: return "bfk_isalpha";
            case 4477L: return "bfk_isascii";
            case 4478L: return "bfk_isblank";
            case 4479L: return "bfk_iscntrl";
            case 4480L: return "bfk_isdigit";
            case 4481L: return "bfk_isfinite";
            case 4482L: return "bfk_isgraph";
            case 4483L: return "bfk_isgreater";
            case 4484L: return "bfk_isgreaterequal";
            case 4485L: return "bfk_isinf";
            case 4486L: return "bfk_isinf_sign";
            case 4487L: return "bfk_isinff";
            case 4488L: return "bfk_isinfl";
            case 4489L: return "bfk_isless";
            case 4490L: return "bfk_islessequal";
            case 4491L: return "bfk_islessgreater";
            case 4492L: return "bfk_islower";
            case 4493L: return "bfk_isnan";
            case 4494L: return "bfk_isnanf";
            case 4495L: return "bfk_isnanl";
            case 4496L: return "bfk_isnormal";
            case 4497L: return "bfk_isprint";
            case 4498L: return "bfk_ispunct";
            case 4499L: return "bfk_isspace";
            case 4500L: return "bfk_isunordered";
            case 4501L: return "bfk_isupper";
            case 4502L: return "bfk_iswalnum";
            case 4503L: return "bfk_iswalpha";
            case 4504L: return "bfk_iswblank";
            case 4505L: return "bfk_iswcntrl";
            case 4506L: return "bfk_iswdigit";
            case 4507L: return "bfk_iswgraph";
            case 4508L: return "bfk_iswlower";
            case 4509L: return "bfk_iswprint";
            case 4510L: return "bfk_iswpunct";
            case 4511L: return "bfk_iswspace";
            case 4512L: return "bfk_iswupper";
            case 4513L: return "bfk_iswxdigit";
            case 4514L: return "bfk_isxdigit";
            case 4515L: return "bfk_j0";
            case 4516L: return "bfk_j0f";
            case 4517L: return "bfk_j0l";
            case 4518L: return "bfk_j1";
            case 4519L: return "bfk_j1f";
            case 4520L: return "bfk_j1l";
            case 4521L: return "bfk_jn";
            case 4522L: return "bfk_jnf";
            case 4523L: return "bfk_jnl";
            case 4524L: return "bfk_labs";
            case 4525L: return "bfk_launder";
            case 4526L: return "bfk_lceil";
            case 4527L: return "bfk_lceilf";
            case 4528L: return "bfk_lceill";
            case 4529L: return "bfk_ldexp";
            case 4530L: return "bfk_ldexpf";
            case 4531L: return "bfk_ldexpf128";
            case 4532L: return "bfk_ldexpl";
            case 4533L: return "bfk_lfloor";
            case 4534L: return "bfk_lfloorf";
            case 4535L: return "bfk_lfloorl";
            case 4536L: return "bfk_lgamma";
            case 4537L: return "bfk_lgamma_r";
            case 4538L: return "bfk_lgammaf";
            case 4539L: return "bfk_lgammaf128";
            case 4540L: return "bfk_lgammaf_r";
            case 4541L: return "bfk_lgammal";
            case 4542L: return "bfk_lgammal_r";
            case 4543L: return "bfk_llabs";
            case 4544L: return "bfk_llceil";
            case 4545L: return "bfk_llceilf";
            case 4546L: return "bfk_llceill";
            case 4547L: return "bfk_llfloor";
            case 4548L: return "bfk_llfloorf";
            case 4549L: return "bfk_llfloorl";
            case 4550L: return "bfk_llrint";
            case 4551L: return "bfk_llrintf";
            case 4552L: return "bfk_llrintf128";
            case 4553L: return "bfk_llrintl";
            case 4554L: return "bfk_llround";
            case 4555L: return "bfk_llroundf";
            case 4556L: return "bfk_llroundf128";
            case 4557L: return "bfk_llroundl";
            case 4558L: return "bfk_log";
            case 4559L: return "bfk_log10";
            case 4560L: return "bfk_log10f";
            case 4561L: return "bfk_log10f128";
            case 4562L: return "bfk_log10f16";
            case 4563L: return "bfk_log10l";
            case 4564L: return "bfk_log1p";
            case 4565L: return "bfk_log1pf";
            case 4566L: return "bfk_log1pf128";
            case 4567L: return "bfk_log1pl";
            case 4568L: return "bfk_log2";
            case 4569L: return "bfk_log2f";
            case 4570L: return "bfk_log2f128";
            case 4571L: return "bfk_log2f16";
            case 4572L: return "bfk_log2l";
            case 4573L: return "bfk_logb";
            case 4574L: return "bfk_logbf";
            case 4575L: return "bfk_logbf128";
            case 4576L: return "bfk_logbl";
            case 4577L: return "bfk_logf";
            case 4578L: return "bfk_logf128";
            case 4579L: return "bfk_logf16";
            case 4580L: return "bfk_logl";
            case 4581L: return "bfk_longjmp";
            case 4582L: return "bfk_lrint";
            case 4583L: return "bfk_lrintf";
            case 4584L: return "bfk_lrintf128";
            case 4585L: return "bfk_lrintl";
            case 4586L: return "bfk_lround";
            case 4587L: return "bfk_lroundf";
            case 4588L: return "bfk_lroundf128";
            case 4589L: return "bfk_lroundl";
            case 4590L: return "bfk_malloc";
            case 4591L: return "bfk_matrix_column_major_load";
            case 4592L: return "bfk_matrix_column_major_store";
            case 4593L: return "bfk_matrix_transpose";
            case 4594L: return "bfk_memalign";
            case 4595L: return "bfk_memccpy";
            case 4596L: return "bfk_memchr";
            case 4597L: return "bfk_memcmp";
            case 4598L: return "bfk_memcmp_eq";
            case 4599L: return "bfk_memcpy";
            case 4600L: return "bfk_memcpy_inline";
            case 4601L: return "bfk_memmove";
            case 4602L: return "bfk_mempcpy";
            case 4603L: return "bfk_memset";
            case 4604L: return "bfk_modf";
            case 4605L: return "bfk_modff";
            case 4606L: return "bfk_modff128";
            case 4607L: return "bfk_modfl";
            case 4608L: return "bfk_ms_va_copy";
            case 4609L: return "bfk_ms_va_end";
            case 4610L: return "bfk_ms_va_start";
            case 4611L: return "bfk_mul_overflow";
            case 4612L: return "bfk_mul_overflow_p";
            case 4613L: return "bfk_nan";
            case 4614L: return "bfk_nanf";
            case 4615L: return "bfk_nanf128";
            case 4616L: return "bfk_nanf32";
            case 4617L: return "bfk_nanf32x";
            case 4618L: return "bfk_nanf64";
            case 4619L: return "bfk_nanf64x";
            case 4620L: return "bfk_nanl";
            case 4621L: return "bfk_nans";
            case 4622L: return "bfk_nansf";
            case 4623L: return "bfk_nansf128";
            case 4624L: return "bfk_nansf32";
            case 4625L: return "bfk_nansf32x";
            case 4626L: return "bfk_nansf64";
            case 4627L: return "bfk_nansf64x";
            case 4628L: return "bfk_nansl";
            case 4629L: return "bfk_nearbyint";
            case 4630L: return "bfk_nearbyintf";
            case 4631L: return "bfk_nearbyintf128";
            case 4632L: return "bfk_nearbyintf32";
            case 4633L: return "bfk_nearbyintf32x";
            case 4634L: return "bfk_nearbyintf64";
            case 4635L: return "bfk_nearbyintf64x";
            case 4636L: return "bfk_nearbyintl";
            case 4637L: return "bfk_next_arg";
            case 4638L: return "bfk_nextafter";
            case 4639L: return "bfk_nextafterf";
            case 4640L: return "bfk_nextafterf128";
            case 4641L: return "bfk_nextafterl";
            case 4642L: return "bfk_nexttoward";
            case 4643L: return "bfk_nexttowardf";
            case 4644L: return "bfk_nexttowardf128";
            case 4645L: return "bfk_nexttowardl";
            case 4646L: return "bfk_nonlocal_goto";
            case 4647L: return "bfk_nontemporal_load";
            case 4648L: return "bfk_nontemporal_store";
            case 4649L: return "bfk_objc_memmove_collectable";
            case 4650L: return "bfk_object_size";
            case 4651L: return "bfk_omp_get_num_teams";
            case 4652L: return "bfk_omp_get_num_threads";
            case 4653L: return "bfk_omp_get_team_num";
            case 4654L: return "bfk_omp_get_thread_num";
            case 4655L: return "bfk_operator_delete";
            case 4656L: return "bfk_operator_new";
            case 4657L: return "bfk_os_log_format";
            case 4658L: return "bfk_os_log_format_buffer_size";
            case 4659L: return "bfk_parity";
            case 4660L: return "bfk_parityimax";
            case 4661L: return "bfk_parityl";
            case 4662L: return "bfk_parityll";
            case 4663L: return "bfk_popcount";
            case 4664L: return "bfk_popcountimax";
            case 4665L: return "bfk_popcountl";
            case 4666L: return "bfk_popcountll";
            case 4667L: return "bfk_posix_memalign";
            case 4668L: return "bfk_pow";
            case 4669L: return "bfk_pow10";
            case 4670L: return "bfk_pow10f";
            case 4671L: return "bfk_pow10l";
            case 4672L: return "bfk_powf";
            case 4673L: return "bfk_powf128";
            case 4674L: return "bfk_powf16";
            case 4675L: return "bfk_powi";
            case 4676L: return "bfk_powif";
            case 4677L: return "bfk_powil";
            case 4678L: return "bfk_powl";
            case 4679L: return "bfk_prefetch";
            case 4680L: return "bfk_preserve_access_index";
            case 4681L: return "bfk_printf";
            case 4682L: return "bfk_printf_unlocked";
            case 4683L: return "bfk_profile_func_enter";
            case 4684L: return "bfk_profile_func_exit";
            case 4685L: return "bfk_putc";
            case 4686L: return "bfk_putc_unlocked";
            case 4687L: return "bfk_putchar";
            case 4688L: return "bfk_putchar_unlocked";
            case 4689L: return "bfk_puts";
            case 4690L: return "bfk_puts_unlocked";
            case 4691L: return "bfk_readcyclecounter";
            case 4692L: return "bfk_realloc";
            case 4693L: return "bfk_remainder";
            case 4694L: return "bfk_remainderf";
            case 4695L: return "bfk_remainderf128";
            case 4696L: return "bfk_remainderl";
            case 4697L: return "bfk_remquo";
            case 4698L: return "bfk_remquof";
            case 4699L: return "bfk_remquof128";
            case 4700L: return "bfk_remquol";
            case 4701L: return "bfk_return";
            case 4702L: return "bfk_return_address";
            case 4703L: return "bfk_rindex";
            case 4704L: return "bfk_rint";
            case 4705L: return "bfk_rintf";
            case 4706L: return "bfk_rintf128";
            case 4707L: return "bfk_rintf16";
            case 4708L: return "bfk_rintf32";
            case 4709L: return "bfk_rintf32x";
            case 4710L: return "bfk_rintf64";
            case 4711L: return "bfk_rintf64x";
            case 4712L: return "bfk_rintl";
            case 4713L: return "bfk_rotateleft16";
            case 4714L: return "bfk_rotateleft32";
            case 4715L: return "bfk_rotateleft64";
            case 4716L: return "bfk_rotateleft8";
            case 4717L: return "bfk_rotateright16";
            case 4718L: return "bfk_rotateright32";
            case 4719L: return "bfk_rotateright64";
            case 4720L: return "bfk_rotateright8";
            case 4721L: return "bfk_round";
            case 4722L: return "bfk_roundeven";
            case 4723L: return "bfk_roundevenf";
            case 4724L: return "bfk_roundevenf32";
            case 4725L: return "bfk_roundevenf32x";
            case 4726L: return "bfk_roundevenf64";
            case 4727L: return "bfk_roundevenf64x";
            case 4728L: return "bfk_roundevenl";
            case 4729L: return "bfk_roundf";
            case 4730L: return "bfk_roundf128";
            case 4731L: return "bfk_roundf16";
            case 4732L: return "bfk_roundf32";
            case 4733L: return "bfk_roundf32x";
            case 4734L: return "bfk_roundf64";
            case 4735L: return "bfk_roundf64x";
            case 4736L: return "bfk_roundl";
            case 4737L: return "bfk_sadd_overflow";
            case 4738L: return "bfk_saddl_overflow";
            case 4739L: return "bfk_saddll_overflow";
            case 4740L: return "bfk_saveregs";
            case 4741L: return "bfk_scalb";
            case 4742L: return "bfk_scalbf";
            case 4743L: return "bfk_scalbl";
            case 4744L: return "bfk_scalbln";
            case 4745L: return "bfk_scalblnf";
            case 4746L: return "bfk_scalblnf128";
            case 4747L: return "bfk_scalblnl";
            case 4748L: return "bfk_scalbn";
            case 4749L: return "bfk_scalbnf";
            case 4750L: return "bfk_scalbnf128";
            case 4751L: return "bfk_scalbnl";
            case 4752L: return "bfk_scanf";
            case 4753L: return "bfk_set_thread_pointer";
            case 4754L: return "bfk_setjmp";
            case 4755L: return "bfk_setjmp_dispatcher";
            case 4756L: return "bfk_setjmp_receiver";
            case 4757L: return "bfk_setjmp_setup";
            case 4758L: return "bfk_shufflevector";
            case 4759L: return "bfk_signbit";
            case 4760L: return "bfk_signbitf";
            case 4761L: return "bfk_signbitl";
            case 4762L: return "bfk_significand";
            case 4763L: return "bfk_significandf";
            case 4764L: return "bfk_significandl";
            case 4765L: return "bfk_sin";
            case 4766L: return "bfk_sincos";
            case 4767L: return "bfk_sincosf";
            case 4768L: return "bfk_sincosl";
            case 4769L: return "bfk_sinf";
            case 4770L: return "bfk_sinf128";
            case 4771L: return "bfk_sinf16";
            case 4772L: return "bfk_sinh";
            case 4773L: return "bfk_sinhf";
            case 4774L: return "bfk_sinhf128";
            case 4775L: return "bfk_sinhl";
            case 4776L: return "bfk_sinl";
            case 4777L: return "bfk_smul_overflow";
            case 4778L: return "bfk_smull_overflow";
            case 4779L: return "bfk_smulll_overflow";
            case 4780L: return "bfk_snprintf";
            case 4781L: return "bfk_source_location";
            case 4782L: return "bfk_speculation_safe_value";
            case 4783L: return "bfk_speculation_safe_value_1";
            case 4784L: return "bfk_speculation_safe_value_16";
            case 4785L: return "bfk_speculation_safe_value_2";
            case 4786L: return "bfk_speculation_safe_value_4";
            case 4787L: return "bfk_speculation_safe_value_8";
            case 4788L: return "bfk_speculation_safe_value_ptr";
            case 4789L: return "bfk_sprintf";
            case 4790L: return "bfk_sqrt";
            case 4791L: return "bfk_sqrtf";
            case 4792L: return "bfk_sqrtf128";
            case 4793L: return "bfk_sqrtf16";
            case 4794L: return "bfk_sqrtf32";
            case 4795L: return "bfk_sqrtf32x";
            case 4796L: return "bfk_sqrtf64";
            case 4797L: return "bfk_sqrtf64x";
            case 4798L: return "bfk_sqrtl";
            case 4799L: return "bfk_sscanf";
            case 4800L: return "bfk_ssub_overflow";
            case 4801L: return "bfk_ssubl_overflow";
            case 4802L: return "bfk_ssubll_overflow";
            case 4803L: return "bfk_stack_restore";
            case 4804L: return "bfk_stack_save";
            case 4805L: return "bfk_stdarg_start";
            case 4806L: return "bfk_stpcpy";
            case 4807L: return "bfk_stpncpy";
            case 4808L: return "bfk_strcasecmp";
            case 4809L: return "bfk_strcat";
            case 4810L: return "bfk_strchr";
            case 4811L: return "bfk_strcmp";
            case 4812L: return "bfk_strcmp_eq";
            case 4813L: return "bfk_strcpy";
            case 4814L: return "bfk_strcspn";
            case 4815L: return "bfk_strdup";
            case 4816L: return "bfk_strerror";
            case 4817L: return "bfk_strfmon";
            case 4818L: return "bfk_strftime";
            case 4819L: return "bfk_strlcat";
            case 4820L: return "bfk_strlcpy";
            case 4821L: return "bfk_strlen";
            case 4822L: return "bfk_strncasecmp";
            case 4823L: return "bfk_strncat";
            case 4824L: return "bfk_strncmp";
            case 4825L: return "bfk_strncmp_eq";
            case 4826L: return "bfk_strncpy";
            case 4827L: return "bfk_strndup";
            case 4828L: return "bfk_strnlen";
            case 4829L: return "bfk_strpbrk";
            case 4830L: return "bfk_strrchr";
            case 4831L: return "bfk_strspn";
            case 4832L: return "bfk_strstr";
            case 4833L: return "bfk_strtod";
            case 4834L: return "bfk_strtof";
            case 4835L: return "bfk_strtok";
            case 4836L: return "bfk_strtol";
            case 4837L: return "bfk_strtold";
            case 4838L: return "bfk_strtoll";
            case 4839L: return "bfk_strtoul";
            case 4840L: return "bfk_strtoull";
            case 4841L: return "bfk_strxfrm";
            case 4842L: return "bfk_sub_overflow";
            case 4843L: return "bfk_sub_overflow_p";
            case 4844L: return "bfk_subc";
            case 4845L: return "bfk_subcb";
            case 4846L: return "bfk_subcl";
            case 4847L: return "bfk_subcll";
            case 4848L: return "bfk_subcs";
            case 4849L: return "bfk_sync_add_and_fetch";
            case 4850L: return "bfk_sync_add_and_fetch_1";
            case 4851L: return "bfk_sync_add_and_fetch_16";
            case 4852L: return "bfk_sync_add_and_fetch_2";
            case 4853L: return "bfk_sync_add_and_fetch_4";
            case 4854L: return "bfk_sync_add_and_fetch_8";
            case 4855L: return "bfk_sync_and_and_fetch";
            case 4856L: return "bfk_sync_and_and_fetch_1";
            case 4857L: return "bfk_sync_and_and_fetch_16";
            case 4858L: return "bfk_sync_and_and_fetch_2";
            case 4859L: return "bfk_sync_and_and_fetch_4";
            case 4860L: return "bfk_sync_and_and_fetch_8";
            case 4861L: return "bfk_sync_bool_compare_and_swap";
            case 4862L: return "bfk_sync_bool_compare_and_swap_1";
            case 4863L: return "bfk_sync_bool_compare_and_swap_16";
            case 4864L: return "bfk_sync_bool_compare_and_swap_2";
            case 4865L: return "bfk_sync_bool_compare_and_swap_4";
            case 4866L: return "bfk_sync_bool_compare_and_swap_8";
            case 4867L: return "bfk_sync_fetch_and_add";
            case 4868L: return "bfk_sync_fetch_and_add_1";
            case 4869L: return "bfk_sync_fetch_and_add_16";
            case 4870L: return "bfk_sync_fetch_and_add_2";
            case 4871L: return "bfk_sync_fetch_and_add_4";
            case 4872L: return "bfk_sync_fetch_and_add_8";
            case 4873L: return "bfk_sync_fetch_and_and";
            case 4874L: return "bfk_sync_fetch_and_and_1";
            case 4875L: return "bfk_sync_fetch_and_and_16";
            case 4876L: return "bfk_sync_fetch_and_and_2";
            case 4877L: return "bfk_sync_fetch_and_and_4";
            case 4878L: return "bfk_sync_fetch_and_and_8";
            case 4879L: return "bfk_sync_fetch_and_max";
            case 4880L: return "bfk_sync_fetch_and_min";
            case 4881L: return "bfk_sync_fetch_and_nand";
            case 4882L: return "bfk_sync_fetch_and_nand_1";
            case 4883L: return "bfk_sync_fetch_and_nand_16";
            case 4884L: return "bfk_sync_fetch_and_nand_2";
            case 4885L: return "bfk_sync_fetch_and_nand_4";
            case 4886L: return "bfk_sync_fetch_and_nand_8";
            case 4887L: return "bfk_sync_fetch_and_or";
            case 4888L: return "bfk_sync_fetch_and_or_1";
            case 4889L: return "bfk_sync_fetch_and_or_16";
            case 4890L: return "bfk_sync_fetch_and_or_2";
            case 4891L: return "bfk_sync_fetch_and_or_4";
            case 4892L: return "bfk_sync_fetch_and_or_8";
            case 4893L: return "bfk_sync_fetch_and_sub";
            case 4894L: return "bfk_sync_fetch_and_sub_1";
            case 4895L: return "bfk_sync_fetch_and_sub_16";
            case 4896L: return "bfk_sync_fetch_and_sub_2";
            case 4897L: return "bfk_sync_fetch_and_sub_4";
            case 4898L: return "bfk_sync_fetch_and_sub_8";
            case 4899L: return "bfk_sync_fetch_and_umax";
            case 4900L: return "bfk_sync_fetch_and_umin";
            case 4901L: return "bfk_sync_fetch_and_xor";
            case 4902L: return "bfk_sync_fetch_and_xor_1";
            case 4903L: return "bfk_sync_fetch_and_xor_16";
            case 4904L: return "bfk_sync_fetch_and_xor_2";
            case 4905L: return "bfk_sync_fetch_and_xor_4";
            case 4906L: return "bfk_sync_fetch_and_xor_8";
            case 4907L: return "bfk_sync_lock_release";
            case 4908L: return "bfk_sync_lock_release_1";
            case 4909L: return "bfk_sync_lock_release_16";
            case 4910L: return "bfk_sync_lock_release_2";
            case 4911L: return "bfk_sync_lock_release_4";
            case 4912L: return "bfk_sync_lock_release_8";
            case 4913L: return "bfk_sync_lock_test_and_set";
            case 4914L: return "bfk_sync_lock_test_and_set_1";
            case 4915L: return "bfk_sync_lock_test_and_set_16";
            case 4916L: return "bfk_sync_lock_test_and_set_2";
            case 4917L: return "bfk_sync_lock_test_and_set_4";
            case 4918L: return "bfk_sync_lock_test_and_set_8";
            case 4919L: return "bfk_sync_nand_and_fetch";
            case 4920L: return "bfk_sync_nand_and_fetch_1";
            case 4921L: return "bfk_sync_nand_and_fetch_16";
            case 4922L: return "bfk_sync_nand_and_fetch_2";
            case 4923L: return "bfk_sync_nand_and_fetch_4";
            case 4924L: return "bfk_sync_nand_and_fetch_8";
            case 4925L: return "bfk_sync_or_and_fetch";
            case 4926L: return "bfk_sync_or_and_fetch_1";
            case 4927L: return "bfk_sync_or_and_fetch_16";
            case 4928L: return "bfk_sync_or_and_fetch_2";
            case 4929L: return "bfk_sync_or_and_fetch_4";
            case 4930L: return "bfk_sync_or_and_fetch_8";
            case 4931L: return "bfk_sync_sub_and_fetch";
            case 4932L: return "bfk_sync_sub_and_fetch_1";
            case 4933L: return "bfk_sync_sub_and_fetch_16";
            case 4934L: return "bfk_sync_sub_and_fetch_2";
            case 4935L: return "bfk_sync_sub_and_fetch_4";
            case 4936L: return "bfk_sync_sub_and_fetch_8";
            case 4937L: return "bfk_sync_swap";
            case 4938L: return "bfk_sync_swap_1";
            case 4939L: return "bfk_sync_swap_16";
            case 4940L: return "bfk_sync_swap_2";
            case 4941L: return "bfk_sync_swap_4";
            case 4942L: return "bfk_sync_swap_8";
            case 4943L: return "bfk_sync_synchronize";
            case 4944L: return "bfk_sync_val_compare_and_swap";
            case 4945L: return "bfk_sync_val_compare_and_swap_1";
            case 4946L: return "bfk_sync_val_compare_and_swap_16";
            case 4947L: return "bfk_sync_val_compare_and_swap_2";
            case 4948L: return "bfk_sync_val_compare_and_swap_4";
            case 4949L: return "bfk_sync_val_compare_and_swap_8";
            case 4950L: return "bfk_sync_xor_and_fetch";
            case 4951L: return "bfk_sync_xor_and_fetch_1";
            case 4952L: return "bfk_sync_xor_and_fetch_16";
            case 4953L: return "bfk_sync_xor_and_fetch_2";
            case 4954L: return "bfk_sync_xor_and_fetch_4";
            case 4955L: return "bfk_sync_xor_and_fetch_8";
            case 4956L: return "bfk_sysv_va_copy";
            case 4957L: return "bfk_sysv_va_end";
            case 4958L: return "bfk_sysv_va_start";
            case 4959L: return "bfk_tan";
            case 4960L: return "bfk_tanf";
            case 4961L: return "bfk_tanf128";
            case 4962L: return "bfk_tanh";
            case 4963L: return "bfk_tanhf";
            case 4964L: return "bfk_tanhf128";
            case 4965L: return "bfk_tanhl";
            case 4966L: return "bfk_tanl";
            case 4967L: return "bfk_tgamma";
            case 4968L: return "bfk_tgammaf";
            case 4969L: return "bfk_tgammaf128";
            case 4970L: return "bfk_tgammal";
            case 4971L: return "bfk_thread_pointer";
            case 4972L: return "bfk_toascii";
            case 4973L: return "bfk_tolower";
            case 4974L: return "bfk_toupper";
            case 4975L: return "bfk_towlower";
            case 4976L: return "bfk_towupper";
            case 4977L: return "bfk_trap";
            case 4978L: return "bfk_trunc";
            case 4979L: return "bfk_truncf";
            case 4980L: return "bfk_truncf128";
            case 4981L: return "bfk_truncf16";
            case 4982L: return "bfk_truncf32";
            case 4983L: return "bfk_truncf32x";
            case 4984L: return "bfk_truncf64";
            case 4985L: return "bfk_truncf64x";
            case 4986L: return "bfk_truncl";
            case 4987L: return "bfk_uadd_overflow";
            case 4988L: return "bfk_uaddl_overflow";
            case 4989L: return "bfk_uaddll_overflow";
            case 4990L: return "bfk_umul_overflow";
            case 4991L: return "bfk_umull_overflow";
            case 4992L: return "bfk_umulll_overflow";
            case 4993L: return "bfk_unpredictable";
            case 4994L: return "bfk_unreachable";
            case 4995L: return "bfk_unwind_init";
            case 4996L: return "bfk_unwind_resume";
            case 4997L: return "bfk_update_setjmp_buf";
            case 4998L: return "bfk_usub_overflow";
            case 4999L: return "bfk_usubl_overflow";
            case 5000L: return "bfk_usubll_overflow";
            case 5001L: return "bfk_va_arg";
            case 5002L: return "bfk_va_arg_pack";
            case 5003L: return "bfk_va_arg_pack_len";
            case 5004L: return "bfk_va_copy";
            case 5005L: return "bfk_va_end";
            case 5006L: return "bfk_va_start";
            case 5007L: return "bfk_varargs_start";
            case 5008L: return "bfk_vfork";
            case 5009L: return "bfk_vfprintf";
            case 5010L: return "bfk_vfscanf";
            case 5011L: return "bfk_vprintf";
            case 5012L: return "bfk_vscanf";
            case 5013L: return "bfk_vsnprintf";
            case 5014L: return "bfk_vsprintf";
            case 5015L: return "bfk_vsscanf";
            case 5016L: return "bfk_wcschr";
            case 5017L: return "bfk_wcscmp";
            case 5018L: return "bfk_wcslen";
            case 5019L: return "bfk_wcsncmp";
            case 5020L: return "bfk_wmemchr";
            case 5021L: return "bfk_wmemcmp";
            case 5022L: return "bfk_wmemcpy";
            case 5023L: return "bfk_wmemmove";
            case 5024L: return "bfk_y0";
            case 5025L: return "bfk_y0f";
            case 5026L: return "bfk_y0l";
            case 5027L: return "bfk_y1";
            case 5028L: return "bfk_y1f";
            case 5029L: return "bfk_y1l";
            case 5030L: return "bfk_yn";
            case 5031L: return "bfk_ynf";
            case 5032L: return "bfk_ynl";
            case 5033L: return "bfk_zero_non_value_bits";
            case 5034L: return "bfk_last";
            default: return "";
        }
    }

    std::string a_builtin_function_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_builtin_function_kind_tag(i);
        if (s.empty())
            s = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_builtin_function_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            810L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            879L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            894L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1058L,
            1059L,
            1060L,
            1061L,
            1062L,
            1063L,
            1064L,
            1065L,
            1066L,
            1067L,
            1068L,
            1069L,
            1070L,
            1071L,
            1072L,
            1073L,
            1074L,
            1075L,
            1076L,
            1077L,
            1078L,
            1079L,
            1080L,
            1081L,
            1082L,
            1083L,
            1084L,
            1085L,
            1086L,
            1087L,
            1088L,
            1089L,
            1090L,
            1091L,
            1092L,
            1093L,
            1094L,
            1095L,
            1096L,
            1097L,
            1098L,
            1099L,
            1100L,
            1101L,
            1102L,
            1103L,
            1104L,
            1105L,
            1106L,
            1107L,
            1108L,
            1109L,
            1110L,
            1111L,
            1112L,
            1113L,
            1114L,
            1115L,
            1116L,
            1117L,
            1118L,
            1119L,
            1120L,
            1121L,
            1122L,
            1123L,
            1124L,
            1125L,
            1126L,
            1127L,
            1128L,
            1129L,
            1130L,
            1131L,
            1132L,
            1133L,
            1134L,
            1135L,
            1136L,
            1137L,
            1138L,
            1139L,
            1140L,
            1141L,
            1142L,
            1143L,
            1144L,
            1145L,
            1146L,
            1147L,
            1148L,
            1149L,
            1150L,
            1151L,
            1152L,
            1153L,
            1154L,
            1155L,
            1156L,
            1157L,
            1158L,
            1159L,
            1160L,
            1161L,
            1162L,
            1163L,
            1164L,
            1165L,
            1166L,
            1167L,
            1168L,
            1169L,
            1170L,
            1171L,
            1172L,
            1173L,
            1174L,
            1175L,
            1176L,
            1177L,
            1178L,
            1179L,
            1180L,
            1181L,
            1182L,
            1183L,
            1184L,
            1185L,
            1186L,
            1187L,
            1188L,
            1189L,
            1190L,
            1191L,
            1192L,
            1193L,
            1194L,
            1195L,
            1196L,
            1197L,
            1198L,
            1199L,
            1200L,
            1201L,
            1202L,
            1203L,
            1204L,
            1205L,
            1206L,
            1207L,
            1208L,
            1209L,
            1210L,
            1211L,
            1212L,
            1213L,
            1214L,
            1215L,
            1216L,
            1217L,
            1218L,
            1219L,
            1220L,
            1221L,
            1222L,
            1223L,
            1224L,
            1225L,
            1226L,
            1227L,
            1228L,
            1229L,
            1230L,
            1231L,
            1232L,
            1233L,
            1234L,
            1235L,
            1236L,
            1237L,
            1238L,
            1239L,
            1240L,
            1241L,
            1242L,
            1243L,
            1244L,
            1245L,
            1246L,
            1247L,
            1248L,
            1249L,
            1250L,
            1251L,
            1252L,
            1253L,
            1254L,
            1255L,
            1256L,
            1257L,
            1258L,
            1259L,
            1260L,
            1261L,
            1262L,
            1263L,
            1264L,
            1265L,
            1266L,
            1267L,
            1268L,
            1269L,
            1270L,
            1271L,
            1272L,
            1273L,
            1274L,
            1275L,
            1276L,
            1277L,
            1278L,
            1279L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1285L,
            1286L,
            1287L,
            1288L,
            1289L,
            1290L,
            1291L,
            1292L,
            1293L,
            1294L,
            1295L,
            1296L,
            1297L,
            1298L,
            1299L,
            1300L,
            1301L,
            1302L,
            1303L,
            1304L,
            1305L,
            1306L,
            1307L,
            1308L,
            1309L,
            1310L,
            1311L,
            1312L,
            1313L,
            1314L,
            1315L,
            1316L,
            1317L,
            1318L,
            1319L,
            1320L,
            1321L,
            1322L,
            1323L,
            1324L,
            1325L,
            1326L,
            1327L,
            1328L,
            1329L,
            1330L,
            1331L,
            1332L,
            1333L,
            1334L,
            1335L,
            1336L,
            1337L,
            1338L,
            1339L,
            1340L,
            1341L,
            1342L,
            1343L,
            1344L,
            1345L,
            1346L,
            1347L,
            1348L,
            1349L,
            1350L,
            1351L,
            1352L,
            1353L,
            1354L,
            1355L,
            1356L,
            1357L,
            1358L,
            1359L,
            1360L,
            1361L,
            1362L,
            1363L,
            1364L,
            1365L,
            1366L,
            1367L,
            1368L,
            1369L,
            1370L,
            1371L,
            1372L,
            1373L,
            1374L,
            1375L,
            1376L,
            1377L,
            1378L,
            1379L,
            1380L,
            1381L,
            1382L,
            1383L,
            1384L,
            1385L,
            1386L,
            1387L,
            1388L,
            1389L,
            1390L,
            1391L,
            1392L,
            1393L,
            1394L,
            1395L,
            1396L,
            1397L,
            1398L,
            1399L,
            1400L,
            1401L,
            1402L,
            1403L,
            1404L,
            1405L,
            1406L,
            1407L,
            1408L,
            1409L,
            1410L,
            1411L,
            1412L,
            1413L,
            1414L,
            1415L,
            1416L,
            1417L,
            1418L,
            1419L,
            1420L,
            1421L,
            1422L,
            1423L,
            1424L,
            1425L,
            1426L,
            1427L,
            1428L,
            1429L,
            1430L,
            1431L,
            1432L,
            1433L,
            1434L,
            1435L,
            1436L,
            1437L,
            1438L,
            1439L,
            1440L,
            1441L,
            1442L,
            1443L,
            1444L,
            1445L,
            1446L,
            1447L,
            1448L,
            1449L,
            1450L,
            1451L,
            1452L,
            1453L,
            1454L,
            1455L,
            1456L,
            1457L,
            1458L,
            1459L,
            1460L,
            1461L,
            1462L,
            1463L,
            1464L,
            1465L,
            1466L,
            1467L,
            1468L,
            1469L,
            1470L,
            1471L,
            1472L,
            1473L,
            1474L,
            1475L,
            1476L,
            1477L,
            1478L,
            1479L,
            1480L,
            1481L,
            1482L,
            1483L,
            1484L,
            1485L,
            1486L,
            1487L,
            1488L,
            1489L,
            1490L,
            1491L,
            1492L,
            1493L,
            1494L,
            1495L,
            1496L,
            1497L,
            1498L,
            1499L,
            1500L,
            1501L,
            1502L,
            1503L,
            1504L,
            1505L,
            1506L,
            1507L,
            1508L,
            1509L,
            1510L,
            1511L,
            1512L,
            1513L,
            1514L,
            1515L,
            1516L,
            1517L,
            1518L,
            1519L,
            1520L,
            1521L,
            1522L,
            1523L,
            1524L,
            1525L,
            1526L,
            1527L,
            1528L,
            1529L,
            1530L,
            1531L,
            1532L,
            1533L,
            1534L,
            1535L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1559L,
            1560L,
            1561L,
            1562L,
            1563L,
            1564L,
            1565L,
            1566L,
            1567L,
            1568L,
            1569L,
            1570L,
            1571L,
            1572L,
            1573L,
            1574L,
            1575L,
            1576L,
            1577L,
            1578L,
            1579L,
            1580L,
            1581L,
            1582L,
            1583L,
            1584L,
            1585L,
            1586L,
            1587L,
            1588L,
            1589L,
            1590L,
            1591L,
            1592L,
            1593L,
            1594L,
            1595L,
            1596L,
            1597L,
            1598L,
            1599L,
            1600L,
            1601L,
            1602L,
            1603L,
            1604L,
            1605L,
            1606L,
            1607L,
            1608L,
            1609L,
            1610L,
            1611L,
            1612L,
            1613L,
            1614L,
            1615L,
            1616L,
            1617L,
            1618L,
            1619L,
            1620L,
            1621L,
            1622L,
            1623L,
            1624L,
            1625L,
            1626L,
            1627L,
            1628L,
            1629L,
            1630L,
            1631L,
            1632L,
            1633L,
            1634L,
            1635L,
            1636L,
            1637L,
            1638L,
            1639L,
            1640L,
            1641L,
            1642L,
            1643L,
            1644L,
            1645L,
            1646L,
            1647L,
            1648L,
            1649L,
            1650L,
            1651L,
            1652L,
            1653L,
            1654L,
            1655L,
            1656L,
            1657L,
            1658L,
            1659L,
            1660L,
            1661L,
            1662L,
            1663L,
            1664L,
            1665L,
            1666L,
            1667L,
            1668L,
            1669L,
            1670L,
            1671L,
            1672L,
            1673L,
            1674L,
            1675L,
            1676L,
            1677L,
            1678L,
            1679L,
            1680L,
            1681L,
            1682L,
            1683L,
            1684L,
            1685L,
            1686L,
            1687L,
            1688L,
            1689L,
            1690L,
            1691L,
            1692L,
            1693L,
            1694L,
            1695L,
            1696L,
            1697L,
            1698L,
            1699L,
            1700L,
            1701L,
            1702L,
            1703L,
            1704L,
            1705L,
            1706L,
            1707L,
            1708L,
            1709L,
            1710L,
            1711L,
            1712L,
            1713L,
            1714L,
            1715L,
            1716L,
            1717L,
            1718L,
            1719L,
            1720L,
            1721L,
            1722L,
            1723L,
            1724L,
            1725L,
            1726L,
            1727L,
            1728L,
            1729L,
            1730L,
            1731L,
            1732L,
            1733L,
            1734L,
            1735L,
            1736L,
            1737L,
            1738L,
            1739L,
            1740L,
            1741L,
            1742L,
            1743L,
            1744L,
            1745L,
            1746L,
            1747L,
            1748L,
            1749L,
            1750L,
            1751L,
            1752L,
            1753L,
            1754L,
            1755L,
            1756L,
            1757L,
            1758L,
            1759L,
            1760L,
            1761L,
            1762L,
            1763L,
            1764L,
            1765L,
            1766L,
            1767L,
            1768L,
            1769L,
            1770L,
            1771L,
            1772L,
            1773L,
            1774L,
            1775L,
            1776L,
            1777L,
            1778L,
            1779L,
            1780L,
            1781L,
            1782L,
            1783L,
            1784L,
            1785L,
            1786L,
            1787L,
            1788L,
            1789L,
            1790L,
            1791L,
            1792L,
            1793L,
            1794L,
            1795L,
            1796L,
            1797L,
            1798L,
            1799L,
            1800L,
            1801L,
            1802L,
            1803L,
            1804L,
            1805L,
            1806L,
            1807L,
            1808L,
            1809L,
            1810L,
            1811L,
            1812L,
            1813L,
            1814L,
            1815L,
            1816L,
            1817L,
            1818L,
            1819L,
            1820L,
            1821L,
            1822L,
            1823L,
            1824L,
            1825L,
            1826L,
            1827L,
            1828L,
            1829L,
            1830L,
            1831L,
            1832L,
            1833L,
            1834L,
            1835L,
            1836L,
            1837L,
            1838L,
            1839L,
            1840L,
            1841L,
            1842L,
            1843L,
            1844L,
            1845L,
            1846L,
            1847L,
            1848L,
            1849L,
            1850L,
            1851L,
            1852L,
            1853L,
            1854L,
            1855L,
            1856L,
            1857L,
            1858L,
            1859L,
            1860L,
            1861L,
            1862L,
            1863L,
            1864L,
            1865L,
            1866L,
            1867L,
            1868L,
            1869L,
            1870L,
            1871L,
            1872L,
            1873L,
            1874L,
            1875L,
            1876L,
            1877L,
            1878L,
            1879L,
            1880L,
            1881L,
            1882L,
            1883L,
            1884L,
            1885L,
            1886L,
            1887L,
            1888L,
            1889L,
            1890L,
            1891L,
            1892L,
            1893L,
            1894L,
            1895L,
            1896L,
            1897L,
            1898L,
            1899L,
            1900L,
            1901L,
            1902L,
            1903L,
            1904L,
            1905L,
            1906L,
            1907L,
            1908L,
            1909L,
            1910L,
            1911L,
            1912L,
            1913L,
            1914L,
            1915L,
            1916L,
            1917L,
            1918L,
            1919L,
            1920L,
            1921L,
            1922L,
            1923L,
            1924L,
            1925L,
            1926L,
            1927L,
            1928L,
            1929L,
            1930L,
            1931L,
            1932L,
            1933L,
            1934L,
            1935L,
            1936L,
            1937L,
            1938L,
            1939L,
            1940L,
            1941L,
            1942L,
            1943L,
            1944L,
            1945L,
            1946L,
            1947L,
            1948L,
            1949L,
            1950L,
            1951L,
            1952L,
            1953L,
            1954L,
            1955L,
            1956L,
            1957L,
            1958L,
            1959L,
            1960L,
            1961L,
            1962L,
            1963L,
            1964L,
            1965L,
            1966L,
            1967L,
            1968L,
            1969L,
            1970L,
            1971L,
            1972L,
            1973L,
            1974L,
            1975L,
            1976L,
            1977L,
            1978L,
            1979L,
            1980L,
            1981L,
            1982L,
            1983L,
            1984L,
            1985L,
            1986L,
            1987L,
            1988L,
            1989L,
            1990L,
            1991L,
            1992L,
            1993L,
            1994L,
            1995L,
            1996L,
            1997L,
            1998L,
            1999L,
            2000L,
            2001L,
            2002L,
            2003L,
            2004L,
            2005L,
            2006L,
            2007L,
            2008L,
            2009L,
            2010L,
            2011L,
            2012L,
            2013L,
            2014L,
            2015L,
            2016L,
            2017L,
            2018L,
            2019L,
            2020L,
            2021L,
            2022L,
            2023L,
            2024L,
            2025L,
            2026L,
            2027L,
            2028L,
            2029L,
            2030L,
            2031L,
            2032L,
            2033L,
            2034L,
            2035L,
            2036L,
            2037L,
            2038L,
            2039L,
            2040L,
            2041L,
            2042L,
            2043L,
            2044L,
            2045L,
            2046L,
            2047L,
            2048L,
            2049L,
            2050L,
            2051L,
            2052L,
            2053L,
            2054L,
            2055L,
            2056L,
            2057L,
            2058L,
            2059L,
            2060L,
            2061L,
            2062L,
            2063L,
            2064L,
            2065L,
            2066L,
            2067L,
            2068L,
            2069L,
            2070L,
            2071L,
            2072L,
            2073L,
            2074L,
            2075L,
            2076L,
            2077L,
            2078L,
            2079L,
            2080L,
            2081L,
            2082L,
            2083L,
            2084L,
            2085L,
            2086L,
            2087L,
            2088L,
            2089L,
            2090L,
            2091L,
            2092L,
            2093L,
            2094L,
            2095L,
            2096L,
            2097L,
            2098L,
            2099L,
            2100L,
            2101L,
            2102L,
            2103L,
            2104L,
            2105L,
            2106L,
            2107L,
            2108L,
            2109L,
            2110L,
            2111L,
            2112L,
            2113L,
            2114L,
            2115L,
            2116L,
            2117L,
            2118L,
            2119L,
            2120L,
            2121L,
            2122L,
            2123L,
            2124L,
            2125L,
            2126L,
            2127L,
            2128L,
            2129L,
            2130L,
            2131L,
            2132L,
            2133L,
            2134L,
            2135L,
            2136L,
            2137L,
            2138L,
            2139L,
            2140L,
            2141L,
            2142L,
            2143L,
            2144L,
            2145L,
            2146L,
            2147L,
            2148L,
            2149L,
            2150L,
            2151L,
            2152L,
            2153L,
            2154L,
            2155L,
            2156L,
            2157L,
            2158L,
            2159L,
            2160L,
            2161L,
            2162L,
            2163L,
            2164L,
            2165L,
            2166L,
            2167L,
            2168L,
            2169L,
            2170L,
            2171L,
            2172L,
            2173L,
            2174L,
            2175L,
            2176L,
            2177L,
            2178L,
            2179L,
            2180L,
            2181L,
            2182L,
            2183L,
            2184L,
            2185L,
            2186L,
            2187L,
            2188L,
            2189L,
            2190L,
            2191L,
            2192L,
            2193L,
            2194L,
            2195L,
            2196L,
            2197L,
            2198L,
            2199L,
            2200L,
            2201L,
            2202L,
            2203L,
            2204L,
            2205L,
            2206L,
            2207L,
            2208L,
            2209L,
            2210L,
            2211L,
            2212L,
            2213L,
            2214L,
            2215L,
            2216L,
            2217L,
            2218L,
            2219L,
            2220L,
            2221L,
            2222L,
            2223L,
            2224L,
            2225L,
            2226L,
            2227L,
            2228L,
            2229L,
            2230L,
            2231L,
            2232L,
            2233L,
            2234L,
            2235L,
            2236L,
            2237L,
            2238L,
            2239L,
            2240L,
            2241L,
            2242L,
            2243L,
            2244L,
            2245L,
            2246L,
            2247L,
            2248L,
            2249L,
            2250L,
            2251L,
            2252L,
            2253L,
            2254L,
            2255L,
            2256L,
            2257L,
            2258L,
            2259L,
            2260L,
            2261L,
            2262L,
            2263L,
            2264L,
            2265L,
            2266L,
            2267L,
            2268L,
            2269L,
            2270L,
            2271L,
            2272L,
            2273L,
            2274L,
            2275L,
            2276L,
            2277L,
            2278L,
            2279L,
            2280L,
            2281L,
            2282L,
            2283L,
            2284L,
            2285L,
            2286L,
            2287L,
            2288L,
            2289L,
            2290L,
            2291L,
            2292L,
            2293L,
            2294L,
            2295L,
            2296L,
            2297L,
            2298L,
            2299L,
            2300L,
            2301L,
            2302L,
            2303L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2320L,
            2321L,
            2322L,
            2323L,
            2324L,
            2325L,
            2326L,
            2327L,
            2328L,
            2329L,
            2330L,
            2331L,
            2332L,
            2333L,
            2334L,
            2335L,
            2336L,
            2337L,
            2338L,
            2339L,
            2340L,
            2341L,
            2342L,
            2343L,
            2344L,
            2345L,
            2346L,
            2347L,
            2348L,
            2349L,
            2350L,
            2351L,
            2352L,
            2353L,
            2354L,
            2355L,
            2356L,
            2357L,
            2358L,
            2359L,
            2360L,
            2361L,
            2362L,
            2363L,
            2364L,
            2365L,
            2366L,
            2367L,
            2368L,
            2369L,
            2370L,
            2371L,
            2372L,
            2373L,
            2374L,
            2375L,
            2376L,
            2377L,
            2378L,
            2379L,
            2380L,
            2381L,
            2382L,
            2383L,
            2384L,
            2385L,
            2386L,
            2387L,
            2388L,
            2389L,
            2390L,
            2391L,
            2392L,
            2393L,
            2394L,
            2395L,
            2396L,
            2397L,
            2398L,
            2399L,
            2400L,
            2401L,
            2402L,
            2403L,
            2404L,
            2405L,
            2406L,
            2407L,
            2408L,
            2409L,
            2410L,
            2411L,
            2412L,
            2413L,
            2414L,
            2415L,
            2416L,
            2417L,
            2418L,
            2419L,
            2420L,
            2421L,
            2422L,
            2423L,
            2424L,
            2425L,
            2426L,
            2427L,
            2428L,
            2429L,
            2430L,
            2431L,
            2432L,
            2433L,
            2434L,
            2435L,
            2436L,
            2437L,
            2438L,
            2439L,
            2440L,
            2441L,
            2442L,
            2443L,
            2444L,
            2445L,
            2446L,
            2447L,
            2448L,
            2449L,
            2450L,
            2451L,
            2452L,
            2453L,
            2454L,
            2455L,
            2456L,
            2457L,
            2458L,
            2459L,
            2460L,
            2461L,
            2462L,
            2463L,
            2464L,
            2465L,
            2466L,
            2467L,
            2468L,
            2469L,
            2470L,
            2471L,
            2472L,
            2473L,
            2474L,
            2475L,
            2476L,
            2477L,
            2478L,
            2479L,
            2480L,
            2481L,
            2482L,
            2483L,
            2484L,
            2485L,
            2486L,
            2487L,
            2488L,
            2489L,
            2490L,
            2491L,
            2492L,
            2493L,
            2494L,
            2495L,
            2496L,
            2497L,
            2498L,
            2499L,
            2500L,
            2501L,
            2502L,
            2503L,
            2504L,
            2505L,
            2506L,
            2507L,
            2508L,
            2509L,
            2510L,
            2511L,
            2512L,
            2513L,
            2514L,
            2515L,
            2516L,
            2517L,
            2518L,
            2519L,
            2520L,
            2521L,
            2522L,
            2523L,
            2524L,
            2525L,
            2526L,
            2527L,
            2528L,
            2529L,
            2530L,
            2531L,
            2532L,
            2533L,
            2534L,
            2535L,
            2536L,
            2537L,
            2538L,
            2539L,
            2540L,
            2541L,
            2542L,
            2543L,
            2544L,
            2545L,
            2546L,
            2547L,
            2548L,
            2549L,
            2550L,
            2551L,
            2552L,
            2553L,
            2554L,
            2555L,
            2556L,
            2557L,
            2558L,
            2559L,
            2560L,
            2561L,
            2562L,
            2563L,
            2564L,
            2565L,
            2566L,
            2567L,
            2568L,
            2569L,
            2570L,
            2571L,
            2572L,
            2573L,
            2574L,
            2575L,
            2576L,
            2577L,
            2578L,
            2579L,
            2580L,
            2581L,
            2582L,
            2583L,
            2584L,
            2585L,
            2586L,
            2587L,
            2588L,
            2589L,
            2590L,
            2591L,
            2592L,
            2593L,
            2594L,
            2595L,
            2596L,
            2597L,
            2598L,
            2599L,
            2600L,
            2601L,
            2602L,
            2603L,
            2604L,
            2605L,
            2606L,
            2607L,
            2608L,
            2609L,
            2610L,
            2611L,
            2612L,
            2613L,
            2614L,
            2615L,
            2616L,
            2617L,
            2618L,
            2619L,
            2620L,
            2621L,
            2622L,
            2623L,
            2624L,
            2625L,
            2626L,
            2627L,
            2628L,
            2629L,
            2630L,
            2631L,
            2632L,
            2633L,
            2634L,
            2635L,
            2636L,
            2637L,
            2638L,
            2639L,
            2640L,
            2641L,
            2642L,
            2643L,
            2644L,
            2645L,
            2646L,
            2647L,
            2648L,
            2649L,
            2650L,
            2651L,
            2652L,
            2653L,
            2654L,
            2655L,
            2656L,
            2657L,
            2658L,
            2659L,
            2660L,
            2661L,
            2662L,
            2663L,
            2664L,
            2665L,
            2666L,
            2667L,
            2668L,
            2669L,
            2670L,
            2671L,
            2672L,
            2673L,
            2674L,
            2675L,
            2676L,
            2677L,
            2678L,
            2679L,
            2680L,
            2681L,
            2682L,
            2683L,
            2684L,
            2685L,
            2686L,
            2687L,
            2688L,
            2689L,
            2690L,
            2691L,
            2692L,
            2693L,
            2694L,
            2695L,
            2696L,
            2697L,
            2698L,
            2699L,
            2700L,
            2701L,
            2702L,
            2703L,
            2704L,
            2705L,
            2706L,
            2707L,
            2708L,
            2709L,
            2710L,
            2711L,
            2712L,
            2713L,
            2714L,
            2715L,
            2716L,
            2717L,
            2718L,
            2719L,
            2720L,
            2721L,
            2722L,
            2723L,
            2724L,
            2725L,
            2726L,
            2727L,
            2728L,
            2729L,
            2730L,
            2731L,
            2732L,
            2733L,
            2734L,
            2735L,
            2736L,
            2737L,
            2738L,
            2739L,
            2740L,
            2741L,
            2742L,
            2743L,
            2744L,
            2745L,
            2746L,
            2747L,
            2748L,
            2749L,
            2750L,
            2751L,
            2752L,
            2753L,
            2754L,
            2755L,
            2756L,
            2757L,
            2758L,
            2759L,
            2760L,
            2761L,
            2762L,
            2763L,
            2764L,
            2765L,
            2766L,
            2767L,
            2768L,
            2769L,
            2770L,
            2771L,
            2772L,
            2773L,
            2774L,
            2775L,
            2776L,
            2777L,
            2778L,
            2779L,
            2780L,
            2781L,
            2782L,
            2783L,
            2784L,
            2785L,
            2786L,
            2787L,
            2788L,
            2789L,
            2790L,
            2791L,
            2792L,
            2793L,
            2794L,
            2795L,
            2796L,
            2797L,
            2798L,
            2799L,
            2800L,
            2801L,
            2802L,
            2803L,
            2804L,
            2805L,
            2806L,
            2807L,
            2808L,
            2809L,
            2810L,
            2811L,
            2812L,
            2813L,
            2814L,
            2815L,
            2816L,
            2817L,
            2818L,
            2819L,
            2820L,
            2821L,
            2822L,
            2823L,
            2824L,
            2825L,
            2826L,
            2827L,
            2828L,
            2829L,
            2830L,
            2831L,
            2832L,
            2833L,
            2834L,
            2835L,
            2836L,
            2837L,
            2838L,
            2839L,
            2840L,
            2841L,
            2842L,
            2843L,
            2844L,
            2845L,
            2846L,
            2847L,
            2848L,
            2849L,
            2850L,
            2851L,
            2852L,
            2853L,
            2854L,
            2855L,
            2856L,
            2857L,
            2858L,
            2859L,
            2860L,
            2861L,
            2862L,
            2863L,
            2864L,
            2865L,
            2866L,
            2867L,
            2868L,
            2869L,
            2870L,
            2871L,
            2872L,
            2873L,
            2874L,
            2875L,
            2876L,
            2877L,
            2878L,
            2879L,
            2880L,
            2881L,
            2882L,
            2883L,
            2884L,
            2885L,
            2886L,
            2887L,
            2888L,
            2889L,
            2890L,
            2891L,
            2892L,
            2893L,
            2894L,
            2895L,
            2896L,
            2897L,
            2898L,
            2899L,
            2900L,
            2901L,
            2902L,
            2903L,
            2904L,
            2905L,
            2906L,
            2907L,
            2908L,
            2909L,
            2910L,
            2911L,
            2912L,
            2913L,
            2914L,
            2915L,
            2916L,
            2917L,
            2918L,
            2919L,
            2920L,
            2921L,
            2922L,
            2923L,
            2924L,
            2925L,
            2926L,
            2927L,
            2928L,
            2929L,
            2930L,
            2931L,
            2932L,
            2933L,
            2934L,
            2935L,
            2936L,
            2937L,
            2938L,
            2939L,
            2940L,
            2941L,
            2942L,
            2943L,
            2944L,
            2945L,
            2946L,
            2947L,
            2948L,
            2949L,
            2950L,
            2951L,
            2952L,
            2953L,
            2954L,
            2955L,
            2956L,
            2957L,
            2958L,
            2959L,
            2960L,
            2961L,
            2962L,
            2963L,
            2964L,
            2965L,
            2966L,
            2967L,
            2968L,
            2969L,
            2970L,
            2971L,
            2972L,
            2973L,
            2974L,
            2975L,
            2976L,
            2977L,
            2978L,
            2979L,
            2980L,
            2981L,
            2982L,
            2983L,
            2984L,
            2985L,
            2986L,
            2987L,
            2988L,
            2989L,
            2990L,
            2991L,
            2992L,
            2993L,
            2994L,
            2995L,
            2996L,
            2997L,
            2998L,
            2999L,
            3000L,
            3001L,
            3002L,
            3003L,
            3004L,
            3005L,
            3006L,
            3007L,
            3008L,
            3009L,
            3010L,
            3011L,
            3012L,
            3013L,
            3014L,
            3015L,
            3016L,
            3017L,
            3018L,
            3019L,
            3020L,
            3021L,
            3022L,
            3023L,
            3024L,
            3025L,
            3026L,
            3027L,
            3028L,
            3029L,
            3030L,
            3031L,
            3032L,
            3033L,
            3034L,
            3035L,
            3036L,
            3037L,
            3038L,
            3039L,
            3040L,
            3041L,
            3042L,
            3043L,
            3044L,
            3045L,
            3046L,
            3047L,
            3048L,
            3049L,
            3050L,
            3051L,
            3052L,
            3053L,
            3054L,
            3055L,
            3056L,
            3057L,
            3058L,
            3059L,
            3060L,
            3061L,
            3062L,
            3063L,
            3064L,
            3065L,
            3066L,
            3067L,
            3068L,
            3069L,
            3070L,
            3071L,
            3072L,
            3073L,
            3074L,
            3075L,
            3076L,
            3077L,
            3078L,
            3079L,
            3080L,
            3081L,
            3082L,
            3083L,
            3084L,
            3085L,
            3086L,
            3087L,
            3088L,
            3089L,
            3090L,
            3091L,
            3092L,
            3093L,
            3094L,
            3095L,
            3096L,
            3097L,
            3098L,
            3099L,
            3100L,
            3101L,
            3102L,
            3103L,
            3104L,
            3105L,
            3106L,
            3107L,
            3108L,
            3109L,
            3110L,
            3111L,
            3112L,
            3113L,
            3114L,
            3115L,
            3116L,
            3117L,
            3118L,
            3119L,
            3120L,
            3121L,
            3122L,
            3123L,
            3124L,
            3125L,
            3126L,
            3127L,
            3128L,
            3129L,
            3130L,
            3131L,
            3132L,
            3133L,
            3134L,
            3135L,
            3136L,
            3137L,
            3138L,
            3139L,
            3140L,
            3141L,
            3142L,
            3143L,
            3144L,
            3145L,
            3146L,
            3147L,
            3148L,
            3149L,
            3150L,
            3151L,
            3152L,
            3153L,
            3154L,
            3155L,
            3156L,
            3157L,
            3158L,
            3159L,
            3160L,
            3161L,
            3162L,
            3163L,
            3164L,
            3165L,
            3166L,
            3167L,
            3168L,
            3169L,
            3170L,
            3171L,
            3172L,
            3173L,
            3174L,
            3175L,
            3176L,
            3177L,
            3178L,
            3179L,
            3180L,
            3181L,
            3182L,
            3183L,
            3184L,
            3185L,
            3186L,
            3187L,
            3188L,
            3189L,
            3190L,
            3191L,
            3192L,
            3193L,
            3194L,
            3195L,
            3196L,
            3197L,
            3198L,
            3199L,
            3200L,
            3201L,
            3202L,
            3203L,
            3204L,
            3205L,
            3206L,
            3207L,
            3208L,
            3209L,
            3210L,
            3211L,
            3212L,
            3213L,
            3214L,
            3215L,
            3216L,
            3217L,
            3218L,
            3219L,
            3220L,
            3221L,
            3222L,
            3223L,
            3224L,
            3225L,
            3226L,
            3227L,
            3228L,
            3229L,
            3230L,
            3231L,
            3232L,
            3233L,
            3234L,
            3235L,
            3236L,
            3237L,
            3238L,
            3239L,
            3240L,
            3241L,
            3242L,
            3243L,
            3244L,
            3245L,
            3246L,
            3247L,
            3248L,
            3249L,
            3250L,
            3251L,
            3252L,
            3253L,
            3254L,
            3255L,
            3256L,
            3257L,
            3258L,
            3259L,
            3260L,
            3261L,
            3262L,
            3263L,
            3264L,
            3265L,
            3266L,
            3267L,
            3268L,
            3269L,
            3270L,
            3271L,
            3272L,
            3273L,
            3274L,
            3275L,
            3276L,
            3277L,
            3278L,
            3279L,
            3280L,
            3281L,
            3282L,
            3283L,
            3284L,
            3285L,
            3286L,
            3287L,
            3288L,
            3289L,
            3290L,
            3291L,
            3292L,
            3293L,
            3294L,
            3295L,
            3296L,
            3297L,
            3298L,
            3299L,
            3300L,
            3301L,
            3302L,
            3303L,
            3304L,
            3305L,
            3306L,
            3307L,
            3308L,
            3309L,
            3310L,
            3311L,
            3312L,
            3313L,
            3314L,
            3315L,
            3316L,
            3317L,
            3318L,
            3319L,
            3320L,
            3321L,
            3322L,
            3323L,
            3324L,
            3325L,
            3326L,
            3327L,
            3328L,
            3329L,
            3330L,
            3331L,
            3332L,
            3333L,
            3334L,
            3335L,
            3336L,
            3337L,
            3338L,
            3339L,
            3340L,
            3341L,
            3342L,
            3343L,
            3344L,
            3345L,
            3346L,
            3347L,
            3348L,
            3349L,
            3350L,
            3351L,
            3352L,
            3353L,
            3354L,
            3355L,
            3356L,
            3357L,
            3358L,
            3359L,
            3360L,
            3361L,
            3362L,
            3363L,
            3364L,
            3365L,
            3366L,
            3367L,
            3368L,
            3369L,
            3370L,
            3371L,
            3372L,
            3373L,
            3374L,
            3375L,
            3376L,
            3377L,
            3378L,
            3379L,
            3380L,
            3381L,
            3382L,
            3383L,
            3384L,
            3385L,
            3386L,
            3387L,
            3388L,
            3389L,
            3390L,
            3391L,
            3392L,
            3393L,
            3394L,
            3395L,
            3396L,
            3397L,
            3398L,
            3399L,
            3400L,
            3401L,
            3402L,
            3403L,
            3404L,
            3405L,
            3406L,
            3407L,
            3408L,
            3409L,
            3410L,
            3411L,
            3412L,
            3413L,
            3414L,
            3415L,
            3416L,
            3417L,
            3418L,
            3419L,
            3420L,
            3421L,
            3422L,
            3423L,
            3424L,
            3425L,
            3426L,
            3427L,
            3428L,
            3429L,
            3430L,
            3431L,
            3432L,
            3433L,
            3434L,
            3435L,
            3436L,
            3437L,
            3438L,
            3439L,
            3440L,
            3441L,
            3442L,
            3443L,
            3444L,
            3445L,
            3446L,
            3447L,
            3448L,
            3449L,
            3450L,
            3451L,
            3452L,
            3453L,
            3454L,
            3455L,
            3456L,
            3457L,
            3458L,
            3459L,
            3460L,
            3461L,
            3462L,
            3463L,
            3464L,
            3465L,
            3466L,
            3467L,
            3468L,
            3469L,
            3470L,
            3471L,
            3472L,
            3473L,
            3474L,
            3475L,
            3476L,
            3477L,
            3478L,
            3479L,
            3480L,
            3481L,
            3482L,
            3483L,
            3484L,
            3485L,
            3486L,
            3487L,
            3488L,
            3489L,
            3490L,
            3491L,
            3492L,
            3493L,
            3494L,
            3495L,
            3496L,
            3497L,
            3498L,
            3499L,
            3500L,
            3501L,
            3502L,
            3503L,
            3504L,
            3505L,
            3506L,
            3507L,
            3508L,
            3509L,
            3510L,
            3511L,
            3512L,
            3513L,
            3514L,
            3515L,
            3516L,
            3517L,
            3518L,
            3519L,
            3520L,
            3521L,
            3522L,
            3523L,
            3524L,
            3525L,
            3526L,
            3527L,
            3528L,
            3529L,
            3530L,
            3531L,
            3532L,
            3533L,
            3534L,
            3535L,
            3536L,
            3537L,
            3538L,
            3539L,
            3540L,
            3541L,
            3542L,
            3543L,
            3544L,
            3545L,
            3546L,
            3547L,
            3548L,
            3549L,
            3550L,
            3551L,
            3552L,
            3553L,
            3554L,
            3555L,
            3556L,
            3557L,
            3558L,
            3559L,
            3560L,
            3561L,
            3562L,
            3563L,
            3564L,
            3565L,
            3566L,
            3567L,
            3568L,
            3569L,
            3570L,
            3571L,
            3572L,
            3573L,
            3574L,
            3575L,
            3576L,
            3577L,
            3578L,
            3579L,
            3580L,
            3581L,
            3582L,
            3583L,
            3584L,
            3585L,
            3586L,
            3587L,
            3588L,
            3589L,
            3590L,
            3591L,
            3592L,
            3593L,
            3594L,
            3595L,
            3596L,
            3597L,
            3598L,
            3599L,
            3600L,
            3601L,
            3602L,
            3603L,
            3604L,
            3605L,
            3606L,
            3607L,
            3608L,
            3609L,
            3610L,
            3611L,
            3612L,
            3613L,
            3614L,
            3615L,
            3616L,
            3617L,
            3618L,
            3619L,
            3620L,
            3621L,
            3622L,
            3623L,
            3624L,
            3625L,
            3626L,
            3627L,
            3628L,
            3629L,
            3630L,
            3631L,
            3632L,
            3633L,
            3634L,
            3635L,
            3636L,
            3637L,
            3638L,
            3639L,
            3640L,
            3641L,
            3642L,
            3643L,
            3644L,
            3645L,
            3646L,
            3647L,
            3648L,
            3649L,
            3650L,
            3651L,
            3652L,
            3653L,
            3654L,
            3655L,
            3656L,
            3657L,
            3658L,
            3659L,
            3660L,
            3661L,
            3662L,
            3663L,
            3664L,
            3665L,
            3666L,
            3667L,
            3668L,
            3669L,
            3670L,
            3671L,
            3672L,
            3673L,
            3674L,
            3675L,
            3676L,
            3677L,
            3678L,
            3679L,
            3680L,
            3681L,
            3682L,
            3683L,
            3684L,
            3685L,
            3686L,
            3687L,
            3688L,
            3689L,
            3690L,
            3691L,
            3692L,
            3693L,
            3694L,
            3695L,
            3696L,
            3697L,
            3698L,
            3699L,
            3700L,
            3701L,
            3702L,
            3703L,
            3704L,
            3705L,
            3706L,
            3707L,
            3708L,
            3709L,
            3710L,
            3711L,
            3712L,
            3713L,
            3714L,
            3715L,
            3716L,
            3717L,
            3718L,
            3719L,
            3720L,
            3721L,
            3722L,
            3723L,
            3724L,
            3725L,
            3726L,
            3727L,
            3728L,
            3729L,
            3730L,
            3731L,
            3732L,
            3733L,
            3734L,
            3735L,
            3736L,
            3737L,
            3738L,
            3739L,
            3740L,
            3741L,
            3742L,
            3743L,
            3744L,
            3745L,
            3746L,
            3747L,
            3748L,
            3749L,
            3750L,
            3751L,
            3752L,
            3753L,
            3754L,
            3755L,
            3756L,
            3757L,
            3758L,
            3759L,
            3760L,
            3761L,
            3762L,
            3763L,
            3764L,
            3765L,
            3766L,
            3767L,
            3768L,
            3769L,
            3770L,
            3771L,
            3772L,
            3773L,
            3774L,
            3775L,
            3776L,
            3777L,
            3778L,
            3779L,
            3780L,
            3781L,
            3782L,
            3783L,
            3784L,
            3785L,
            3786L,
            3787L,
            3788L,
            3789L,
            3790L,
            3791L,
            3792L,
            3793L,
            3794L,
            3795L,
            3796L,
            3797L,
            3798L,
            3799L,
            3800L,
            3801L,
            3802L,
            3803L,
            3804L,
            3805L,
            3806L,
            3807L,
            3808L,
            3809L,
            3810L,
            3811L,
            3812L,
            3813L,
            3814L,
            3815L,
            3816L,
            3817L,
            3818L,
            3819L,
            3820L,
            3821L,
            3822L,
            3823L,
            3824L,
            3825L,
            3826L,
            3827L,
            3828L,
            3829L,
            3830L,
            3831L,
            3832L,
            3833L,
            3834L,
            3835L,
            3836L,
            3837L,
            3838L,
            3839L,
            3840L,
            3841L,
            3842L,
            3843L,
            3844L,
            3845L,
            3846L,
            3847L,
            3848L,
            3849L,
            3850L,
            3851L,
            3852L,
            3853L,
            3854L,
            3855L,
            3856L,
            3857L,
            3858L,
            3859L,
            3860L,
            3861L,
            3862L,
            3863L,
            3864L,
            3865L,
            3866L,
            3867L,
            3868L,
            3869L,
            3870L,
            3871L,
            3872L,
            3873L,
            3874L,
            3875L,
            3876L,
            3877L,
            3878L,
            3879L,
            3880L,
            3881L,
            3882L,
            3883L,
            3884L,
            3885L,
            3886L,
            3887L,
            3888L,
            3889L,
            3890L,
            3891L,
            3892L,
            3893L,
            3894L,
            3895L,
            3896L,
            3897L,
            3898L,
            3899L,
            3900L,
            3901L,
            3902L,
            3903L,
            3904L,
            3905L,
            3906L,
            3907L,
            3908L,
            3909L,
            3910L,
            3911L,
            3912L,
            3913L,
            3914L,
            3915L,
            3916L,
            3917L,
            3918L,
            3919L,
            3920L,
            3921L,
            3922L,
            3923L,
            3924L,
            3925L,
            3926L,
            3927L,
            3928L,
            3929L,
            3930L,
            3931L,
            3932L,
            3933L,
            3934L,
            3935L,
            3936L,
            3937L,
            3938L,
            3939L,
            3940L,
            3941L,
            3942L,
            3943L,
            3944L,
            3945L,
            3946L,
            3947L,
            3948L,
            3949L,
            3950L,
            3951L,
            3952L,
            3953L,
            3954L,
            3955L,
            3956L,
            3957L,
            3958L,
            3959L,
            3960L,
            3961L,
            3962L,
            3963L,
            3964L,
            3965L,
            3966L,
            3967L,
            3968L,
            3969L,
            3970L,
            3971L,
            3972L,
            3973L,
            3974L,
            3975L,
            3976L,
            3977L,
            3978L,
            3979L,
            3980L,
            3981L,
            3982L,
            3983L,
            3984L,
            3985L,
            3986L,
            3987L,
            3988L,
            3989L,
            3990L,
            3991L,
            3992L,
            3993L,
            3994L,
            3995L,
            3996L,
            3997L,
            3998L,
            3999L,
            4000L,
            4001L,
            4002L,
            4003L,
            4004L,
            4005L,
            4006L,
            4007L,
            4008L,
            4009L,
            4010L,
            4011L,
            4012L,
            4013L,
            4014L,
            4015L,
            4016L,
            4017L,
            4018L,
            4019L,
            4020L,
            4021L,
            4022L,
            4023L,
            4024L,
            4025L,
            4026L,
            4027L,
            4028L,
            4029L,
            4030L,
            4031L,
            4032L,
            4033L,
            4034L,
            4035L,
            4036L,
            4037L,
            4038L,
            4039L,
            4040L,
            4041L,
            4042L,
            4043L,
            4044L,
            4045L,
            4046L,
            4047L,
            4048L,
            4049L,
            4050L,
            4051L,
            4052L,
            4053L,
            4054L,
            4055L,
            4056L,
            4057L,
            4058L,
            4059L,
            4060L,
            4061L,
            4062L,
            4063L,
            4064L,
            4065L,
            4066L,
            4067L,
            4068L,
            4069L,
            4070L,
            4071L,
            4072L,
            4073L,
            4074L,
            4075L,
            4076L,
            4077L,
            4078L,
            4079L,
            4080L,
            4081L,
            4082L,
            4083L,
            4084L,
            4085L,
            4086L,
            4087L,
            4088L,
            4089L,
            4090L,
            4091L,
            4092L,
            4093L,
            4094L,
            4095L,
            4096L,
            4097L,
            4098L,
            4099L,
            4100L,
            4101L,
            4102L,
            4103L,
            4104L,
            4105L,
            4106L,
            4107L,
            4108L,
            4109L,
            4110L,
            4111L,
            4112L,
            4113L,
            4114L,
            4115L,
            4116L,
            4117L,
            4118L,
            4119L,
            4120L,
            4121L,
            4122L,
            4123L,
            4124L,
            4125L,
            4126L,
            4127L,
            4128L,
            4129L,
            4130L,
            4131L,
            4132L,
            4133L,
            4134L,
            4135L,
            4136L,
            4137L,
            4138L,
            4139L,
            4140L,
            4141L,
            4142L,
            4143L,
            4144L,
            4145L,
            4146L,
            4147L,
            4148L,
            4149L,
            4150L,
            4151L,
            4152L,
            4153L,
            4154L,
            4155L,
            4156L,
            4157L,
            4158L,
            4159L,
            4160L,
            4161L,
            4162L,
            4163L,
            4164L,
            4165L,
            4166L,
            4167L,
            4168L,
            4169L,
            4170L,
            4171L,
            4172L,
            4173L,
            4174L,
            4175L,
            4176L,
            4177L,
            4178L,
            4179L,
            4180L,
            4181L,
            4182L,
            4183L,
            4184L,
            4185L,
            4186L,
            4187L,
            4188L,
            4189L,
            4190L,
            4191L,
            4192L,
            4193L,
            4194L,
            4195L,
            4196L,
            4197L,
            4198L,
            4199L,
            4200L,
            4201L,
            4202L,
            4203L,
            4204L,
            4205L,
            4206L,
            4207L,
            4208L,
            4209L,
            4210L,
            4211L,
            4212L,
            4213L,
            4214L,
            4215L,
            4216L,
            4217L,
            4218L,
            4219L,
            4220L,
            4221L,
            4222L,
            4223L,
            4224L,
            4225L,
            4226L,
            4227L,
            4228L,
            4229L,
            4230L,
            4231L,
            4232L,
            4233L,
            4234L,
            4235L,
            4236L,
            4237L,
            4238L,
            4239L,
            4240L,
            4241L,
            4242L,
            4243L,
            4244L,
            4245L,
            4246L,
            4247L,
            4248L,
            4249L,
            4250L,
            4251L,
            4252L,
            4253L,
            4254L,
            4255L,
            4256L,
            4257L,
            4258L,
            4259L,
            4260L,
            4261L,
            4262L,
            4263L,
            4264L,
            4265L,
            4266L,
            4267L,
            4268L,
            4269L,
            4270L,
            4271L,
            4272L,
            4273L,
            4274L,
            4275L,
            4276L,
            4277L,
            4278L,
            4279L,
            4280L,
            4281L,
            4282L,
            4283L,
            4284L,
            4285L,
            4286L,
            4287L,
            4288L,
            4289L,
            4290L,
            4291L,
            4292L,
            4293L,
            4294L,
            4295L,
            4296L,
            4297L,
            4298L,
            4299L,
            4300L,
            4301L,
            4302L,
            4303L,
            4304L,
            4305L,
            4306L,
            4307L,
            4308L,
            4309L,
            4310L,
            4311L,
            4312L,
            4313L,
            4314L,
            4315L,
            4316L,
            4317L,
            4318L,
            4319L,
            4320L,
            4321L,
            4322L,
            4323L,
            4324L,
            4325L,
            4326L,
            4327L,
            4328L,
            4329L,
            4330L,
            4331L,
            4332L,
            4333L,
            4334L,
            4335L,
            4336L,
            4337L,
            4338L,
            4339L,
            4340L,
            4341L,
            4342L,
            4343L,
            4344L,
            4345L,
            4346L,
            4347L,
            4348L,
            4349L,
            4350L,
            4351L,
            4352L,
            4353L,
            4354L,
            4355L,
            4356L,
            4357L,
            4358L,
            4359L,
            4360L,
            4361L,
            4362L,
            4363L,
            4364L,
            4365L,
            4366L,
            4367L,
            4368L,
            4369L,
            4370L,
            4371L,
            4372L,
            4373L,
            4374L,
            4375L,
            4376L,
            4377L,
            4378L,
            4379L,
            4380L,
            4381L,
            4382L,
            4383L,
            4384L,
            4385L,
            4386L,
            4387L,
            4388L,
            4389L,
            4390L,
            4391L,
            4392L,
            4393L,
            4394L,
            4395L,
            4396L,
            4397L,
            4398L,
            4399L,
            4400L,
            4401L,
            4402L,
            4403L,
            4404L,
            4405L,
            4406L,
            4407L,
            4408L,
            4409L,
            4410L,
            4411L,
            4412L,
            4413L,
            4414L,
            4415L,
            4416L,
            4417L,
            4418L,
            4419L,
            4420L,
            4421L,
            4422L,
            4423L,
            4424L,
            4425L,
            4426L,
            4427L,
            4428L,
            4429L,
            4430L,
            4431L,
            4432L,
            4433L,
            4434L,
            4435L,
            4436L,
            4437L,
            4438L,
            4439L,
            4440L,
            4441L,
            4442L,
            4443L,
            4444L,
            4445L,
            4446L,
            4447L,
            4448L,
            4449L,
            4450L,
            4451L,
            4452L,
            4453L,
            4454L,
            4455L,
            4456L,
            4457L,
            4458L,
            4459L,
            4460L,
            4461L,
            4462L,
            4463L,
            4464L,
            4465L,
            4466L,
            4467L,
            4468L,
            4469L,
            4470L,
            4471L,
            4472L,
            4473L,
            4474L,
            4475L,
            4476L,
            4477L,
            4478L,
            4479L,
            4480L,
            4481L,
            4482L,
            4483L,
            4484L,
            4485L,
            4486L,
            4487L,
            4488L,
            4489L,
            4490L,
            4491L,
            4492L,
            4493L,
            4494L,
            4495L,
            4496L,
            4497L,
            4498L,
            4499L,
            4500L,
            4501L,
            4502L,
            4503L,
            4504L,
            4505L,
            4506L,
            4507L,
            4508L,
            4509L,
            4510L,
            4511L,
            4512L,
            4513L,
            4514L,
            4515L,
            4516L,
            4517L,
            4518L,
            4519L,
            4520L,
            4521L,
            4522L,
            4523L,
            4524L,
            4525L,
            4526L,
            4527L,
            4528L,
            4529L,
            4530L,
            4531L,
            4532L,
            4533L,
            4534L,
            4535L,
            4536L,
            4537L,
            4538L,
            4539L,
            4540L,
            4541L,
            4542L,
            4543L,
            4544L,
            4545L,
            4546L,
            4547L,
            4548L,
            4549L,
            4550L,
            4551L,
            4552L,
            4553L,
            4554L,
            4555L,
            4556L,
            4557L,
            4558L,
            4559L,
            4560L,
            4561L,
            4562L,
            4563L,
            4564L,
            4565L,
            4566L,
            4567L,
            4568L,
            4569L,
            4570L,
            4571L,
            4572L,
            4573L,
            4574L,
            4575L,
            4576L,
            4577L,
            4578L,
            4579L,
            4580L,
            4581L,
            4582L,
            4583L,
            4584L,
            4585L,
            4586L,
            4587L,
            4588L,
            4589L,
            4590L,
            4591L,
            4592L,
            4593L,
            4594L,
            4595L,
            4596L,
            4597L,
            4598L,
            4599L,
            4600L,
            4601L,
            4602L,
            4603L,
            4604L,
            4605L,
            4606L,
            4607L,
            4608L,
            4609L,
            4610L,
            4611L,
            4612L,
            4613L,
            4614L,
            4615L,
            4616L,
            4617L,
            4618L,
            4619L,
            4620L,
            4621L,
            4622L,
            4623L,
            4624L,
            4625L,
            4626L,
            4627L,
            4628L,
            4629L,
            4630L,
            4631L,
            4632L,
            4633L,
            4634L,
            4635L,
            4636L,
            4637L,
            4638L,
            4639L,
            4640L,
            4641L,
            4642L,
            4643L,
            4644L,
            4645L,
            4646L,
            4647L,
            4648L,
            4649L,
            4650L,
            4651L,
            4652L,
            4653L,
            4654L,
            4655L,
            4656L,
            4657L,
            4658L,
            4659L,
            4660L,
            4661L,
            4662L,
            4663L,
            4664L,
            4665L,
            4666L,
            4667L,
            4668L,
            4669L,
            4670L,
            4671L,
            4672L,
            4673L,
            4674L,
            4675L,
            4676L,
            4677L,
            4678L,
            4679L,
            4680L,
            4681L,
            4682L,
            4683L,
            4684L,
            4685L,
            4686L,
            4687L,
            4688L,
            4689L,
            4690L,
            4691L,
            4692L,
            4693L,
            4694L,
            4695L,
            4696L,
            4697L,
            4698L,
            4699L,
            4700L,
            4701L,
            4702L,
            4703L,
            4704L,
            4705L,
            4706L,
            4707L,
            4708L,
            4709L,
            4710L,
            4711L,
            4712L,
            4713L,
            4714L,
            4715L,
            4716L,
            4717L,
            4718L,
            4719L,
            4720L,
            4721L,
            4722L,
            4723L,
            4724L,
            4725L,
            4726L,
            4727L,
            4728L,
            4729L,
            4730L,
            4731L,
            4732L,
            4733L,
            4734L,
            4735L,
            4736L,
            4737L,
            4738L,
            4739L,
            4740L,
            4741L,
            4742L,
            4743L,
            4744L,
            4745L,
            4746L,
            4747L,
            4748L,
            4749L,
            4750L,
            4751L,
            4752L,
            4753L,
            4754L,
            4755L,
            4756L,
            4757L,
            4758L,
            4759L,
            4760L,
            4761L,
            4762L,
            4763L,
            4764L,
            4765L,
            4766L,
            4767L,
            4768L,
            4769L,
            4770L,
            4771L,
            4772L,
            4773L,
            4774L,
            4775L,
            4776L,
            4777L,
            4778L,
            4779L,
            4780L,
            4781L,
            4782L,
            4783L,
            4784L,
            4785L,
            4786L,
            4787L,
            4788L,
            4789L,
            4790L,
            4791L,
            4792L,
            4793L,
            4794L,
            4795L,
            4796L,
            4797L,
            4798L,
            4799L,
            4800L,
            4801L,
            4802L,
            4803L,
            4804L,
            4805L,
            4806L,
            4807L,
            4808L,
            4809L,
            4810L,
            4811L,
            4812L,
            4813L,
            4814L,
            4815L,
            4816L,
            4817L,
            4818L,
            4819L,
            4820L,
            4821L,
            4822L,
            4823L,
            4824L,
            4825L,
            4826L,
            4827L,
            4828L,
            4829L,
            4830L,
            4831L,
            4832L,
            4833L,
            4834L,
            4835L,
            4836L,
            4837L,
            4838L,
            4839L,
            4840L,
            4841L,
            4842L,
            4843L,
            4844L,
            4845L,
            4846L,
            4847L,
            4848L,
            4849L,
            4850L,
            4851L,
            4852L,
            4853L,
            4854L,
            4855L,
            4856L,
            4857L,
            4858L,
            4859L,
            4860L,
            4861L,
            4862L,
            4863L,
            4864L,
            4865L,
            4866L,
            4867L,
            4868L,
            4869L,
            4870L,
            4871L,
            4872L,
            4873L,
            4874L,
            4875L,
            4876L,
            4877L,
            4878L,
            4879L,
            4880L,
            4881L,
            4882L,
            4883L,
            4884L,
            4885L,
            4886L,
            4887L,
            4888L,
            4889L,
            4890L,
            4891L,
            4892L,
            4893L,
            4894L,
            4895L,
            4896L,
            4897L,
            4898L,
            4899L,
            4900L,
            4901L,
            4902L,
            4903L,
            4904L,
            4905L,
            4906L,
            4907L,
            4908L,
            4909L,
            4910L,
            4911L,
            4912L,
            4913L,
            4914L,
            4915L,
            4916L,
            4917L,
            4918L,
            4919L,
            4920L,
            4921L,
            4922L,
            4923L,
            4924L,
            4925L,
            4926L,
            4927L,
            4928L,
            4929L,
            4930L,
            4931L,
            4932L,
            4933L,
            4934L,
            4935L,
            4936L,
            4937L,
            4938L,
            4939L,
            4940L,
            4941L,
            4942L,
            4943L,
            4944L,
            4945L,
            4946L,
            4947L,
            4948L,
            4949L,
            4950L,
            4951L,
            4952L,
            4953L,
            4954L,
            4955L,
            4956L,
            4957L,
            4958L,
            4959L,
            4960L,
            4961L,
            4962L,
            4963L,
            4964L,
            4965L,
            4966L,
            4967L,
            4968L,
            4969L,
            4970L,
            4971L,
            4972L,
            4973L,
            4974L,
            4975L,
            4976L,
            4977L,
            4978L,
            4979L,
            4980L,
            4981L,
            4982L,
            4983L,
            4984L,
            4985L,
            4986L,
            4987L,
            4988L,
            4989L,
            4990L,
            4991L,
            4992L,
            4993L,
            4994L,
            4995L,
            4996L,
            4997L,
            4998L,
            4999L,
            5000L,
            5001L,
            5002L,
            5003L,
            5004L,
            5005L,
            5006L,
            5007L,
            5008L,
            5009L,
            5010L,
            5011L,
            5012L,
            5013L,
            5014L,
            5015L,
            5016L,
            5017L,
            5018L,
            5019L,
            5020L,
            5021L,
            5022L,
            5023L,
            5024L,
            5025L,
            5026L,
            5027L,
            5028L,
            5029L,
            5030L,
            5031L,
            5032L,
            5033L,
            5034L
        };
        static const std::vector<int64_t> retval(values, values + 5035);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_builtin_function_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_builtin_function_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_builtin_function_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_builtin_function_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_builtin_function_kind_tag() {
        return stringify::a_builtin_function_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/interpret.h line 66
namespace stringify {
    const char* a_constexpr_intrinsic_tag(int64_t i) {
        switch (i) {
            case 0L: return "cit_error";
            case 1L: return "cit_std_is_constant_evaluated";
            case 2L: return "cit_std_allocator_allocate";
            case 3L: return "cit_std_allocator_deallocate";
            case 4L: return "cit_std_construct_at";
            case 5L: return "cit_std_destroy_at";
            case 6L: return "cit_std_report_constexpr_value";
            case 7L: return "cit_last";
            default: return "";
        }
    }

    std::string a_constexpr_intrinsic_tag(int64_t i, const std::string &strip) {
        std::string s = a_constexpr_intrinsic_tag(i);
        if (s.empty())
            s = "(a_constexpr_intrinsic_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_constexpr_intrinsic_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_constexpr_intrinsic_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_constexpr_intrinsic_tag(i);
        if (retval.empty()) {
            retval = "(a_constexpr_intrinsic_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_constexpr_intrinsic_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_constexpr_intrinsic_tag() {
        return stringify::a_constexpr_intrinsic_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/il.h line 83
namespace stringify {
    const char* a_type_info_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "tik_user";
            case 1L: return "tik_fundamental";
            case 2L: return "tik_enum";
            case 3L: return "tik_array";
            case 4L: return "tik_function";
            case 5L: return "tik_class";
            case 6L: return "tik_si_class";
            case 7L: return "tik_vmi_class";
            case 8L: return "tik_pbase";
            case 9L: return "tik_pointer";
            case 10L: return "tik_ptr_to_member";
            case 11L: return "tik_implementation";
            case 12L: return "tik_last";
            default: return "";
        }
    }

    std::string a_type_info_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_type_info_kind_tag(i);
        if (s.empty())
            s = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_type_info_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_type_info_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_type_info_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_type_info_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_type_info_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_type_info_kind_tag() {
        return stringify::a_type_info_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ifc_modules.h line 2968
namespace stringify { namespace an_ifc_module {
    const char* a_cache_expr_option(int64_t i) {
        switch (i) {
            case 0L: return "ceo_none";
            case 1L: return "ceo_qualified_name";
            case 2L: return "ceo_skip_assign";
            case 4L: return "ceo_possible_temporary_decl";
            default: return "";
        }
    }

    std::string a_cache_expr_option(int64_t i, const std::string &strip) {
        std::string s = a_cache_expr_option(i);
        if (s.empty())
            s = "(an_ifc_module::a_cache_expr_option)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cache_expr_option() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_ifc_module_a_cache_expr_option(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ifc_module::a_cache_expr_option(i);
        if (retval.empty()) {
            retval = "(an_ifc_module::a_cache_expr_option)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ifc_module::a_cache_expr_option::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ifc_module_a_cache_expr_option() {
        return stringify::an_ifc_module::a_cache_expr_option();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/ifc_modules.h line 2977
namespace stringify { namespace an_ifc_module {
    const char* a_cache_statement_option(int64_t i) {
        switch (i) {
            case 0L: return "cso_none";
            case 1L: return "cso_func_body";
            case 2L: return "cso_no_final_semicolon";
            default: return "";
        }
    }

    std::string a_cache_statement_option(int64_t i, const std::string &strip) {
        std::string s = a_cache_statement_option(i);
        if (s.empty())
            s = "(an_ifc_module::a_cache_statement_option)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cache_statement_option() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringify_an_ifc_module_a_cache_statement_option(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_ifc_module::a_cache_statement_option(i);
        if (retval.empty()) {
            retval = "(an_ifc_module::a_cache_statement_option)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_ifc_module::a_cache_statement_option::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_ifc_module_a_cache_statement_option() {
        return stringify::an_ifc_module::a_cache_statement_option();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/symbol_tbl.h line 464
namespace stringify {
    const char* a_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "sk_keyword";
            case 1L: return "sk_macro";
            case 2L: return "sk_constant";
            case 3L: return "sk_type";
            case 4L: return "sk_class_or_struct_tag";
            case 5L: return "sk_union_tag";
            case 6L: return "sk_enum_tag";
            case 7L: return "sk_variable";
            case 8L: return "sk_field";
            case 9L: return "sk_static_data_member";
            case 10L: return "sk_member_function";
            case 11L: return "sk_routine";
            case 12L: return "sk_label";
            case 13L: return "sk_undefined";
            case 14L: return "sk_extern_variable";
            case 15L: return "sk_extern_routine";
            case 16L: return "sk_projection";
            case 17L: return "sk_overloaded_function";
            case 18L: return "sk_parameter";
            case 19L: return "sk_class_template";
            case 20L: return "sk_function_template";
            case 21L: return "sk_variable_template";
            case 22L: return "sk_concept_template";
            case 23L: return "sk_namespace";
            case 24L: return "sk_namespace_projection";
            case 25L: return "sk_module";
            case 26L: return "sk_named_address_space";
            case 27L: return "sk_named_register";
            case 28L: return "sk_property_set";
            case 29L: return "sk_last";
            default: return "";
        }
    }

    std::string a_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_symbol_kind_tag() {
        return stringify::a_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/symbol_tbl.h line 765
namespace stringify {
    const char* a_dependent_type_fixup_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "dtfk_arg_transfer_method";
            case 1L: return "dtfk_routine_calling_method";
            case 2L: return "dtfk_array_type_size";
            case 3L: return "dtfk_array_of_abstract_class_check";
            default: return "";
        }
    }

    std::string a_dependent_type_fixup_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_dependent_type_fixup_kind_tag(i);
        if (s.empty())
            s = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_dependent_type_fixup_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_dependent_type_fixup_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_dependent_type_fixup_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_dependent_type_fixup_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_dependent_type_fixup_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_dependent_type_fixup_kind_tag() {
        return stringify::a_dependent_type_fixup_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/symbol_tbl.h line 4096
namespace stringify {
    const char* a_cli_operator_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "cok_none";
            case 1L: return "cok_first";
            case 2L: return "cok_addition_assignment";
            case 3L: return "cok_address_of";
            case 4L: return "cok_assign";
            case 5L: return "cok_bitwise_and";
            case 6L: return "cok_bitwise_and_assignment";
            case 7L: return "cok_bitwise_or";
            case 8L: return "cok_bitwise_or_assignment";
            case 9L: return "cok_comma";
            case 10L: return "cok_decrement";
            case 11L: return "cok_division";
            case 12L: return "cok_division_assignment";
            case 13L: return "cok_equality";
            case 14L: return "cok_exclusive_or";
            case 15L: return "cok_exclusive_or_assignment";
            case 16L: return "cok_explicit";
            case 17L: return "cok_false";
            case 18L: return "cok_function_call";
            case 19L: return "cok_greater_than";
            case 20L: return "cok_greater_than_or_equal";
            case 21L: return "cok_implicit";
            case 22L: return "cok_increment";
            case 23L: return "cok_inequality";
            case 24L: return "cok_left_shift";
            case 25L: return "cok_left_shift_assignment";
            case 26L: return "cok_less_than";
            case 27L: return "cok_less_than_or_equal";
            case 28L: return "cok_logical_and";
            case 29L: return "cok_logical_not";
            case 30L: return "cok_logical_or";
            case 31L: return "cok_member_selection";
            case 32L: return "cok_modulus";
            case 33L: return "cok_modulus_assignment";
            case 34L: return "cok_multiply";
            case 35L: return "cok_multiplication_assignment";
            case 36L: return "cok_ones_complement";
            case 37L: return "cok_pointer_dereference";
            case 38L: return "cok_pointer_to_member_selection";
            case 39L: return "cok_right_shift";
            case 40L: return "cok_right_shift_assignment";
            case 41L: return "cok_signed_right_shift";
            case 42L: return "cok_subscript";
            case 43L: return "cok_subtraction";
            case 44L: return "cok_subtraction_assignment";
            case 45L: return "cok_true";
            case 46L: return "cok_unary_negation";
            case 47L: return "cok_unary_plus";
            case 48L: return "cok_unsigned_right_shift";
            case 49L: return "cok_unsigned_right_shift_assignment";
            case 50L: return "cok_last";
            default: return "";
        }
    }

    std::string a_cli_operator_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_operator_kind_tag(i);
        if (s.empty())
            s = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_operator_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L
        };
        static const std::vector<int64_t> retval(values, values + 51);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_operator_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_operator_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_operator_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_operator_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_operator_kind_tag() {
        return stringify::a_cli_operator_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/symbol_tbl.h line 5040
namespace stringify {
    const char* a_cli_symbol_kind_tag(int64_t i) {
        switch (i) {
            case 0L: return "csk_none";
            case 1L: return "csk_first_namespace";
            case 2L: return "csk_system_namespace";
            case 3L: return "csk_system_collections_namespace";
            case 4L: return "csk_system_collections_generic_namespace";
            case 5L: return "csk_platform_details_namespace";
            case 6L: return "csk_platform_metadata_namespace";
            case 7L: return "csk_windows_namespace";
            case 8L: return "csk_windows_foundation_namespace";
            case 9L: return "csk_windows_foundation_metadata_namespace";
            case 10L: return "csk_windows_foundation_collections_namespace";
            case 11L: return "csk_first_type";
            default: return "";
        }
    }

    std::string a_cli_symbol_kind_tag(int64_t i, const std::string &strip) {
        std::string s = a_cli_symbol_kind_tag(i);
        if (s.empty())
            s = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_cli_symbol_kind_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_cli_symbol_kind_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_cli_symbol_kind_tag(i);
        if (retval.empty()) {
            retval = "(a_cli_symbol_kind_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_cli_symbol_kind_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_cli_symbol_kind_tag() {
        return stringify::a_cli_symbol_kind_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/floating.h line 425
namespace stringify {
    const char* an_fp_type(int64_t i) {
        switch (i) {
            case 0L: return "fpt_invalid";
            case 1L: return "fpt_approx";
            case 2L: return "fpt_number";
            case 3L: return "fpt_nan";
            case 4L: return "fpt_infinity";
            case 5L: return "fpt_overflow";
            case 6L: return "fpt_zero";
            case 7L: return "fpt_underflow";
            default: return "";
        }
    }

    std::string an_fp_type(int64_t i, const std::string &strip) {
        std::string s = an_fp_type(i);
        if (s.empty())
            s = "(an_fp_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_fp_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_fp_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_fp_type(i);
        if (retval.empty()) {
            retval = "(an_fp_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_fp_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_fp_type() {
        return stringify::an_fp_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_6.3/src/floating.h line 524
namespace stringify {
    const char* an_fp_return_type(int64_t i) {
        switch (i) {
            case -3L: return "fp_ret_invalid";
            case -2L: return "fp_ret_too_small";
            case -1L: return "fp_ret_not_formatted";
            case 0L: return "fp_ret_valid";
            case 1L: return "fp_ret_nan";
            case 2L: return "fp_ret_pos_infinity";
            case 3L: return "fp_ret_neg_infinity";
            case 4L: return "fp_ret_overflow";
            case 5L: return "fp_ret_underflow";
            default: return "";
        }
    }

    std::string an_fp_return_type(int64_t i, const std::string &strip) {
        std::string s = an_fp_return_type(i);
        if (s.empty())
            s = "(an_fp_return_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_fp_return_type() {
        static const int64_t values[] = {
            -3L,
            -2L,
            -1L,
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_fp_return_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_fp_return_type(i);
        if (retval.empty()) {
            retval = "(an_fp_return_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_fp_return_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_fp_return_type() {
        return stringify::an_fp_return_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/util/decode.c line 4297
namespace stringify {
    const char* a_substitution_kind(int64_t i) {
        switch (i) {
            case 0L: return "subk_unscoped_template_name";
            case 1L: return "subk_prefix";
            case 2L: return "subk_template_prefix";
            case 3L: return "subk_type";
            case 4L: return "subk_template_template_param";
            default: return "";
        }
    }

    std::string a_substitution_kind(int64_t i, const std::string &strip) {
        std::string s = a_substitution_kind(i);
        if (s.empty())
            s = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_substitution_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_substitution_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_substitution_kind(i);
        if (retval.empty()) {
            retval = "(a_substitution_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_substitution_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_substitution_kind() {
        return stringify::a_substitution_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/lib_src/rtti.c line 120
namespace stringify {
    const char* a_result_virtuality(int64_t i) {
        switch (i) {
            case 0L: return "rv_unknown";
            case 1L: return "rv_nonvirtual";
            case 2L: return "rv_directvirtual";
            default: return "";
        }
    }

    std::string a_result_virtuality(int64_t i, const std::string &strip) {
        std::string s = a_result_virtuality(i);
        if (s.empty())
            s = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_result_virtuality() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_result_virtuality(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_result_virtuality(i);
        if (retval.empty()) {
            retval = "(a_result_virtuality)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_result_virtuality::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_result_virtuality() {
        return stringify::a_result_virtuality();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/decls.c line 16203
namespace stringify {
    const char* an_end_of_decl_action(int64_t i) {
        switch (i) {
            case 0L: return "eoda_not_at_end";
            case 1L: return "eoda_deferred_actions";
            case 2L: return "eoda_check_semicolon";
            case 3L: return "eoda_skip_final_token";
            case 4L: return "eoda_done";
            default: return "";
        }
    }

    std::string an_end_of_decl_action(int64_t i, const std::string &strip) {
        std::string s = an_end_of_decl_action(i);
        if (s.empty())
            s = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& an_end_of_decl_action() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_an_end_of_decl_action(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::an_end_of_decl_action(i);
        if (retval.empty()) {
            retval = "(an_end_of_decl_action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "an_end_of_decl_action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_an_end_of_decl_action() {
        return stringify::an_end_of_decl_action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 91
namespace stringify {
    const char* a_diag_fill_in_kind(int64_t i) {
        switch (i) {
            case 0L: return "dfk_number";
            case 1L: return "dfk_position";
            case 2L: return "dfk_string";
            case 3L: return "dfk_symbol";
            case 4L: return "dfk_type";
            case 5L: return "dfk_last";
            default: return "";
        }
    }

    std::string a_diag_fill_in_kind(int64_t i, const std::string &strip) {
        std::string s = a_diag_fill_in_kind(i);
        if (s.empty())
            s = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diag_fill_in_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diag_fill_in_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diag_fill_in_kind(i);
        if (retval.empty()) {
            retval = "(a_diag_fill_in_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diag_fill_in_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diag_fill_in_kind() {
        return stringify::a_diag_fill_in_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/EDG/EDG_5.0/src/error.c line 196
namespace stringify {
    const char* a_diagnostic_kind(int64_t i) {
        switch (i) {
            case 0L: return "dck_primary";
            case 1L: return "dck_sub_message";
            case 2L: return "dck_context";
            case 3L: return "dck_macro_context";
            default: return "";
        }
    }

    std::string a_diagnostic_kind(int64_t i, const std::string &strip) {
        std::string s = a_diagnostic_kind(i);
        if (s.empty())
            s = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& a_diagnostic_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_a_diagnostic_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::a_diagnostic_kind(i);
        if (retval.empty()) {
            retval = "(a_diagnostic_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "a_diagnostic_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_a_diagnostic_kind() {
        return stringify::a_diagnostic_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp line 156
namespace stringify { namespace ClangToSageTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToSageTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToSageTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToSageTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToSageTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToSageTranslatorLanguage() {
        return stringify::ClangToSageTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 156
namespace stringify { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/CxxFrontend/Clang/clang-to-dot-private.hpp line 228
namespace stringify { namespace ClangToDotTranslator { namespace ClangToDotTranslator {
    const char* Language(int64_t i) {
        switch (i) {
            case 0L: return "C";
            case 1L: return "CPLUSPLUS";
            case 2L: return "OBJC";
            case 3L: return "CUDA";
            case 4L: return "OPENCL";
            case 5L: return "unknown";
            default: return "";
        }
    }

    std::string Language(int64_t i, const std::string &strip) {
        std::string s = Language(i);
        if (s.empty())
            s = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Language() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyClangToDotTranslatorClangToDotTranslatorLanguage(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ClangToDotTranslator::ClangToDotTranslator::Language(i);
        if (retval.empty()) {
            retval = "(ClangToDotTranslator::ClangToDotTranslator::Language)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ClangToDotTranslator::ClangToDotTranslator::Language::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClangToDotTranslatorClangToDotTranslatorLanguage() {
        return stringify::ClangToDotTranslator::ClangToDotTranslator::Language();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 133
namespace stringify { namespace PreprocessingInfo {
    const char* RelativePositionType(int64_t i) {
        switch (i) {
            case 0L: return "defaultValue";
            case 1L: return "undef";
            case 2L: return "before";
            case 3L: return "after";
            case 4L: return "inside";
            case 5L: return "end_of";
            case 6L: return "before_syntax";
            case 7L: return "after_syntax";
            default: return "";
        }
    }

    std::string RelativePositionType(int64_t i, const std::string &strip) {
        std::string s = RelativePositionType(i);
        if (s.empty())
            s = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelativePositionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoRelativePositionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::RelativePositionType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::RelativePositionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::RelativePositionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoRelativePositionType() {
        return stringify::PreprocessingInfo::RelativePositionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 155
namespace stringify { namespace PreprocessingInfo {
    const char* DirectiveType(int64_t i) {
        switch (i) {
            case 0L: return "CpreprocessorUnknownDeclaration";
            case 1L: return "C_StyleComment";
            case 2L: return "CplusplusStyleComment";
            case 3L: return "FortranStyleComment";
            case 4L: return "F90StyleComment";
            case 5L: return "AdaStyleComment";
            case 6L: return "JovialStyleComment";
            case 7L: return "CpreprocessorBlankLine";
            case 8L: return "CpreprocessorIncludeDeclaration";
            case 9L: return "CpreprocessorIncludeNextDeclaration";
            case 10L: return "CpreprocessorDefineDeclaration";
            case 11L: return "CpreprocessorUndefDeclaration";
            case 12L: return "CpreprocessorIfdefDeclaration";
            case 13L: return "CpreprocessorIfndefDeclaration";
            case 14L: return "CpreprocessorIfDeclaration";
            case 15L: return "CpreprocessorDeadIfDeclaration";
            case 16L: return "CpreprocessorElseDeclaration";
            case 17L: return "CpreprocessorElifDeclaration";
            case 18L: return "CpreprocessorEndifDeclaration";
            case 19L: return "CpreprocessorElsifDeclaration";
            case 20L: return "CpreprocessorEnd_ifDeclaration";
            case 21L: return "CpreprocessorLineDeclaration";
            case 22L: return "CpreprocessorErrorDeclaration";
            case 23L: return "CpreprocessorWarningDeclaration";
            case 24L: return "CpreprocessorEmptyDeclaration";
            case 25L: return "CSkippedToken";
            case 26L: return "CMacroCall";
            case 27L: return "CMacroCallStatement";
            case 28L: return "LineReplacement";
            case 29L: return "ClinkageSpecificationStart";
            case 30L: return "ClinkageSpecificationEnd";
            case 31L: return "CpreprocessorIdentDeclaration";
            case 32L: return "CpreprocessorCompilerGeneratedLinemarker";
            case 33L: return "RawText";
            case 34L: return "LastDirectiveType";
            default: return "";
        }
    }

    std::string DirectiveType(int64_t i, const std::string &strip) {
        std::string s = DirectiveType(i);
        if (s.empty())
            s = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DirectiveType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L
        };
        static const std::vector<int64_t> retval(values, values + 35);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyPreprocessingInfoDirectiveType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::PreprocessingInfo::DirectiveType(i);
        if (retval.empty()) {
            retval = "(PreprocessingInfo::DirectiveType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "PreprocessingInfo::DirectiveType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPreprocessingInfoDirectiveType() {
        return stringify::PreprocessingInfo::DirectiveType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/rose_attributes_list.h line 537
namespace stringify { namespace ROSEAttributesList {
    const char* languageTypeEnum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_language";
            case 1L: return "e_C_language";
            case 2L: return "e_Cxx_language";
            case 3L: return "e_Fortran77_language";
            case 4L: return "e_Fortran9x_language";
            case 5L: return "e_Ada_language";
            case 6L: return "e_lastLanguage";
            default: return "";
        }
    }

    std::string languageTypeEnum(int64_t i, const std::string &strip) {
        std::string s = languageTypeEnum(i);
        if (s.empty())
            s = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageTypeEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSEAttributesList_languageTypeEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSEAttributesList::languageTypeEnum(i);
        if (retval.empty()) {
            retval = "(ROSEAttributesList::languageTypeEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSEAttributesList::languageTypeEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSEAttributesList_languageTypeEnum() {
        return stringify::ROSEAttributesList::languageTypeEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualCFG.h line 47
namespace stringify { namespace VirtualCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            case 5L: return "eckDoConditionPassed";
            case 6L: return "eckDoConditionFailed";
            case 7L: return "eckForallIndicesInRange";
            case 8L: return "eckForallIndicesNotInRange";
            case 9L: return "eckComputedGotoCaseLabel";
            case 10L: return "eckArithmeticIfLess";
            case 11L: return "eckArithmeticIfEqual";
            case 12L: return "eckArithmeticIfGreater";
            case 13L: return "eckInterprocedural";
            case 14L: return "eckError";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualCFG_EdgeConditionKind() {
        return stringify::VirtualCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/virtualCFG/virtualBinCFG.h line 17
namespace stringify { namespace VirtualBinCFG {
    const char* EdgeConditionKind(int64_t i) {
        switch (i) {
            case 0L: return "eckUnconditional";
            case 1L: return "eckTrue";
            case 2L: return "eckFalse";
            case 3L: return "eckCaseLabel";
            case 4L: return "eckDefault";
            default: return "";
        }
    }

    std::string EdgeConditionKind(int64_t i, const std::string &strip) {
        std::string s = EdgeConditionKind(i);
        if (s.empty())
            s = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeConditionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyVirtualBinCFG_EdgeConditionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VirtualBinCFG::EdgeConditionKind(i);
        if (retval.empty()) {
            retval = "(VirtualBinCFG::EdgeConditionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVirtualBinCFG_EdgeConditionKind() {
        return stringify::VirtualBinCFG::EdgeConditionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageBuilder.h line 138
namespace stringify { namespace SageBuilder {
    const char* SourcePositionClassification(int64_t i) {
        switch (i) {
            case 0L: return "e_sourcePositionError";
            case 1L: return "e_sourcePositionDefault";
            case 2L: return "e_sourcePositionTransformation";
            case 3L: return "e_sourcePositionCompilerGenerated";
            case 4L: return "e_sourcePositionNullPointers";
            case 5L: return "e_sourcePositionFrontendConstruction";
            case 6L: return "e_sourcePosition_last";
            default: return "";
        }
    }

    std::string SourcePositionClassification(int64_t i, const std::string &strip) {
        std::string s = SourcePositionClassification(i);
        if (s.empty())
            s = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SourcePositionClassification() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySageBuilderSourcePositionClassification(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageBuilder::SourcePositionClassification(i);
        if (retval.empty()) {
            retval = "(SageBuilder::SourcePositionClassification)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageBuilder::SourcePositionClassification::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageBuilderSourcePositionClassification() {
        return stringify::SageBuilder::SourcePositionClassification();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/sageInterface/sageInterface.h line 1965
namespace stringify { namespace SageInterface { namespace DeferredTransformation {
    const char* TransformationKind(int64_t i) {
        switch (i) {
            case 0L: return "e_error";
            case 1L: return "e_default";
            case 2L: return "e_outliner";
            case 3L: return "e_replaceStatement";
            case 4L: return "e_removeStatement";
            case 5L: return "e_replaceDefiningFunctionDeclarationWithFunctionPrototype";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string TransformationKind(int64_t i, const std::string &strip) {
        std::string s = TransformationKind(i);
        if (s.empty())
            s = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TransformationKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySageInterfaceDeferredTransformationTransformationKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SageInterface::DeferredTransformation::TransformationKind(i);
        if (retval.empty()) {
            retval = "(SageInterface::DeferredTransformation::TransformationKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SageInterface::DeferredTransformation::TransformationKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySageInterfaceDeferredTransformationTransformationKind() {
        return stringify::SageInterface::DeferredTransformation::TransformationKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 12
namespace stringify { namespace ROSE_token_ids {
    const char* whitespace(int64_t i) {
        switch (i) {
            case 0L: return "T_NOTKNOWN";
            default: return "";
        }
    }

    std::string whitespace(int64_t i, const std::string &strip) {
        std::string s = whitespace(i);
        if (s.empty())
            s = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& whitespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_ids_whitespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::whitespace(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::whitespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::whitespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_ids_whitespace() {
        return stringify::ROSE_token_ids::whitespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 21
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const std::vector<int64_t> retval;
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_keywords() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 159
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_alternate_tok(int64_t i) {
        switch (i) {
            case 0L: return "C_CXX_LEFT_CURLY_ALT";
            case 1L: return "C_CXX_RIGHT_CURLY_ALT";
            case 2L: return "C_CXX_LEFT_SQUARE_ALT";
            case 3L: return "C_CXX_RIGHT_SQUARE_ALT";
            case 4L: return "C_CXX_HASH_ALT";
            case 5L: return "C_CXX_HASH_HASH_ALT";
            case 6L: return "C_CXX_and_ALT";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_alternate_tok(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_alternate_tok(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_alternate_tok() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_alternate_tok(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_alternate_tok() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_alternate_tok();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/general_token_defs.h line 171
namespace stringify { namespace ROSE_token_ids {
    const char* ROSE_C_CXX_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "C_CXX_COMMENTS";
            case 100001L: return "C_CXX_STRING_LITERALS";
            case 100002L: return "C_CXX_IDENTIFIER";
            case 100003L: return "C_CXX_PREPROCESSING_INFO";
            case 100004L: return "C_CXX_UNIDENTIFIED_TOKEN";
            case 100005L: return "C_CXX_SYNTAX";
            case 100006L: return "C_CXX_WHITESPACE";
            case 100007L: return "C_CXX_PRAGMA";
            case 100008L: return "C_CXX_ERROR";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Additional_Info(i);
        if (s.empty())
            s = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L,
            100005L,
            100006L,
            100007L,
            100008L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyROSE_token_idsROSE_C_CXX_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info(i);
        if (retval.empty()) {
            retval = "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyROSE_token_idsROSE_C_CXX_Additional_Info() {
        return stringify::ROSE_token_ids::ROSE_C_CXX_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 30
namespace stringify {
    const char* omp_lock_hint_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_lock_hint_none";
            case 1L: return "omp_lock_hint_uncontended";
            case 2L: return "omp_lock_hint_contended";
            case 4L: return "omp_lock_hint_nonspeculative";
            case 8L: return "omp_lock_hint_speculative";
            default: return "";
        }
    }

    std::string omp_lock_hint_t(int64_t i, const std::string &strip) {
        std::string s = omp_lock_hint_t(i);
        if (s.empty())
            s = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_lock_hint_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_lock_hint_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_lock_hint_t(i);
        if (retval.empty()) {
            retval = "(omp_lock_hint_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_lock_hint_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_lock_hint_t() {
        return stringify::omp_lock_hint_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 46
namespace stringify {
    const char* omp_sched_t(int64_t i) {
        switch (i) {
            case 1L: return "omp_sched_static";
            case 2L: return "omp_sched_dynamic";
            case 3L: return "omp_sched_guided";
            case 4L: return "omp_sched_auto";
            default: return "";
        }
    }

    std::string omp_sched_t(int64_t i, const std::string &strip) {
        std::string s = omp_sched_t(i);
        if (s.empty())
            s = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_sched_t() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_sched_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_sched_t(i);
        if (retval.empty()) {
            retval = "(omp_sched_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_sched_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_sched_t() {
        return stringify::omp_sched_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/omp.h line 57
namespace stringify {
    const char* omp_proc_bind_t(int64_t i) {
        switch (i) {
            case 0L: return "omp_proc_bind_false";
            case 1L: return "omp_proc_bind_true";
            case 2L: return "omp_proc_bind_master";
            case 3L: return "omp_proc_bind_close";
            case 4L: return "omp_proc_bind_spread";
            default: return "";
        }
    }

    std::string omp_proc_bind_t(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_t(i);
        if (s.empty())
            s = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_t() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_omp_proc_bind_t(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::omp_proc_bind_t(i);
        if (retval.empty()) {
            retval = "(omp_proc_bind_t)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "omp_proc_bind_t::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_omp_proc_bind_t() {
        return stringify::omp_proc_bind_t();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 25
namespace stringify { namespace AstAttributeDOT {
    const char* DOTStyles(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTStyles";
            case 1L: return "filled";
            case 2L: return "not_filled";
            case 3L: return "END_OF_NODE_TYPE_LIST_DOTStyles";
            default: return "";
        }
    }

    std::string DOTStyles(int64_t i, const std::string &strip) {
        std::string s = DOTStyles(i);
        if (s.empty())
            s = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTStyles() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstAttributeDOT_DOTStyles(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstAttributeDOT::DOTStyles(i);
        if (retval.empty()) {
            retval = "(AstAttributeDOT::DOTStyles)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstAttributeDOT::DOTStyles::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstAttributeDOT_DOTStyles() {
        return stringify::AstAttributeDOT::DOTStyles();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 90
namespace stringify { namespace DOTGraphNode {
    const char* DOTShapeTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementDOTShapeTypes";
            case 1L: return "polygon";
            case 2L: return "ellipse";
            case 3L: return "record";
            case 4L: return "mrecord";
            case 5L: return "END_OF_NODE_TYPE_LIST_DOTShapeTypes";
            default: return "";
        }
    }

    std::string DOTShapeTypes(int64_t i, const std::string &strip) {
        std::string s = DOTShapeTypes(i);
        if (s.empty())
            s = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTShapeTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphNodeDOTShapeTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphNode::DOTShapeTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphNode::DOTShapeTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphNode::DOTShapeTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphNodeDOTShapeTypes() {
        return stringify::DOTGraphNode::DOTShapeTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/AstAttributeDOT.h line 137
namespace stringify { namespace DOTGraphEdge {
    const char* DOTArrowTypes(int64_t i) {
        switch (i) {
            case 0L: return "UnknownListElementArrowTypes";
            case 1L: return "normal";
            case 2L: return "inv";
            case 3L: return "dot";
            case 4L: return "invdot";
            case 5L: return "odot";
            case 6L: return "invodot";
            case 7L: return "none";
            case 8L: return "tee";
            case 9L: return "empty";
            case 10L: return "invempty";
            case 11L: return "diamond";
            case 12L: return "odiamond";
            case 13L: return "ediamond";
            case 14L: return "crow";
            case 15L: return "box";
            case 16L: return "obox";
            case 17L: return "open";
            case 18L: return "halfopen";
            case 19L: return "vee";
            case 20L: return "END_OF_NODE_TYPE_LIST_DOTArrowTypes";
            default: return "";
        }
    }

    std::string DOTArrowTypes(int64_t i, const std::string &strip) {
        std::string s = DOTArrowTypes(i);
        if (s.empty())
            s = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DOTArrowTypes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyDOTGraphEdgeDOTArrowTypes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DOTGraphEdge::DOTArrowTypes(i);
        if (retval.empty()) {
            retval = "(DOTGraphEdge::DOTArrowTypes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDOTGraphEdgeDOTArrowTypes() {
        return stringify::DOTGraphEdge::DOTArrowTypes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 12
namespace stringify { namespace AST_Graph {
    const char* pointerHandling(int64_t i) {
        switch (i) {
            case 0L: return "graph_NULL";
            case 1L: return "do_not_graph_NULL";
            default: return "";
        }
    }

    std::string pointerHandling(int64_t i, const std::string &strip) {
        std::string s = pointerHandling(i);
        if (s.empty())
            s = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& pointerHandling() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_pointerHandling(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::pointerHandling(i);
        if (retval.empty()) {
            retval = "(AST_Graph::pointerHandling)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::pointerHandling::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_pointerHandling() {
        return stringify::AST_Graph::pointerHandling();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/astVisualization/astGraph.h line 19
namespace stringify { namespace AST_Graph {
    const char* traversalType(int64_t i) {
        switch (i) {
            case 0L: return "memory_pool_traversal";
            case 1L: return "whole_graph_AST";
            default: return "";
        }
    }

    std::string traversalType(int64_t i, const std::string &strip) {
        std::string s = traversalType(i);
        if (s.empty())
            s = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& traversalType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAST_Graph_traversalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AST_Graph::traversalType(i);
        if (retval.empty()) {
            retval = "(AST_Graph::traversalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AST_Graph::traversalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_Graph_traversalType() {
        return stringify::AST_Graph::traversalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/SageIII/OmpAttribute.h line 31
namespace stringify { namespace OmpSupport {
    const char* omp_construct_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_parallel";
            case 2L: return "e_for";
            case 3L: return "e_for_simd";
            case 4L: return "e_do";
            case 5L: return "e_workshare";
            case 6L: return "e_sections";
            case 7L: return "e_section";
            case 8L: return "e_single";
            case 9L: return "e_master";
            case 10L: return "e_critical";
            case 11L: return "e_barrier";
            case 12L: return "e_atomic";
            case 13L: return "e_flush";
            case 14L: return "e_target";
            case 15L: return "e_target_declare";
            case 16L: return "e_target_data";
            case 17L: return "e_target_update";
            case 18L: return "e_map";
            case 19L: return "e_device";
            case 20L: return "e_begin";
            case 21L: return "e_end";
            case 22L: return "e_threadprivate";
            case 23L: return "e_parallel_for";
            case 24L: return "e_parallel_for_simd";
            case 25L: return "e_parallel_do";
            case 26L: return "e_parallel_sections";
            case 27L: return "e_parallel_workshare";
            case 28L: return "e_task";
            case 29L: return "e_taskwait";
            case 30L: return "e_ordered_directive";
            case 31L: return "e_end_critical";
            case 32L: return "e_end_do";
            case 33L: return "e_end_master";
            case 34L: return "e_end_ordered";
            case 35L: return "e_end_parallel_do";
            case 36L: return "e_end_parallel_sections";
            case 37L: return "e_end_parallel_workshare";
            case 38L: return "e_end_parallel";
            case 39L: return "e_end_sections";
            case 40L: return "e_end_single";
            case 41L: return "e_end_task";
            case 42L: return "e_end_workshare";
            case 43L: return "e_default";
            case 44L: return "e_shared";
            case 45L: return "e_private";
            case 46L: return "e_firstprivate";
            case 47L: return "e_lastprivate";
            case 48L: return "e_copyin";
            case 49L: return "e_copyprivate";
            case 50L: return "e_proc_bind";
            case 51L: return "e_if";
            case 52L: return "e_num_threads";
            case 53L: return "e_nowait";
            case 54L: return "e_ordered_clause";
            case 55L: return "e_reduction";
            case 56L: return "e_schedule";
            case 57L: return "e_collapse";
            case 58L: return "e_untied";
            case 59L: return "e_mergeable";
            case 60L: return "e_final";
            case 61L: return "e_priority";
            case 62L: return "e_atomic_clause";
            case 63L: return "e_inbranch";
            case 64L: return "e_notinbranch";
            case 65L: return "e_depend";
            case 66L: return "e_default_none";
            case 67L: return "e_default_shared";
            case 68L: return "e_default_private";
            case 69L: return "e_default_firstprivate";
            case 70L: return "e_proc_bind_master";
            case 71L: return "e_proc_bind_close";
            case 72L: return "e_proc_bind_spread";
            case 73L: return "e_atomic_read";
            case 74L: return "e_atomic_write";
            case 75L: return "e_atomic_update";
            case 76L: return "e_atomic_capture";
            case 77L: return "e_reduction_plus";
            case 78L: return "e_reduction_mul";
            case 79L: return "e_reduction_minus";
            case 80L: return "e_reduction_bitand";
            case 81L: return "e_reduction_bitor";
            case 82L: return "e_reduction_bitxor";
            case 83L: return "e_reduction_logand";
            case 84L: return "e_reduction_logor";
            case 85L: return "e_reduction_and";
            case 86L: return "e_reduction_or";
            case 87L: return "e_reduction_eqv";
            case 88L: return "e_reduction_neqv";
            case 89L: return "e_reduction_max";
            case 90L: return "e_reduction_min";
            case 91L: return "e_reduction_iand";
            case 92L: return "e_reduction_ior";
            case 93L: return "e_reduction_ieor";
            case 94L: return "e_schedule_none";
            case 95L: return "e_schedule_static";
            case 96L: return "e_schedule_dynamic";
            case 97L: return "e_schedule_guided";
            case 98L: return "e_schedule_auto";
            case 99L: return "e_schedule_runtime";
            case 100L: return "e_map_alloc";
            case 101L: return "e_map_to";
            case 102L: return "e_map_from";
            case 103L: return "e_map_tofrom";
            case 104L: return "e_dist_data";
            case 105L: return "e_duplicate";
            case 106L: return "e_block";
            case 107L: return "e_cyclic";
            case 108L: return "e_simd";
            case 109L: return "e_declare_simd";
            case 110L: return "e_safelen";
            case 111L: return "e_simdlen";
            case 112L: return "e_uniform";
            case 113L: return "e_aligned";
            case 114L: return "e_linear";
            case 115L: return "e_depend_in";
            case 116L: return "e_depend_out";
            case 117L: return "e_depend_inout";
            case 118L: return "e_not_omp";
            default: return "";
        }
    }

    std::string omp_construct_enum(int64_t i, const std::string &strip) {
        std::string s = omp_construct_enum(i);
        if (s.empty())
            s = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_construct_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L
        };
        static const std::vector<int64_t> retval(values, values + 119);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyOmpSupport_omp_construct_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::OmpSupport::omp_construct_enum(i);
        if (retval.empty()) {
            retval = "(OmpSupport::omp_construct_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "OmpSupport::omp_construct_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOmpSupport_omp_construct_enum() {
        return stringify::OmpSupport::omp_construct_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Flang_ROSE_Connection/sage-build.C line 72
namespace stringify {
    const char* Order(int64_t i) {
        switch (i) {
            case 0L: return "begin";
            case 1L: return "end";
            default: return "";
        }
    }

    std::string Order(int64_t i, const std::string &strip) {
        std::string s = Order(i);
        if (s.empty())
            s = "(Order)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Order() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Order(i);
        if (retval.empty()) {
            retval = "(Order)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Order::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOrder() {
        return stringify::Order();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 47
namespace stringify {
    const char* Element_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Element";
            case 1L: return "A_Pragma";
            case 2L: return "A_Defining_Name";
            case 3L: return "A_Declaration";
            case 4L: return "A_Definition";
            case 5L: return "An_Expression";
            case 6L: return "An_Association";
            case 7L: return "A_Statement";
            case 8L: return "A_Path";
            case 9L: return "A_Clause";
            case 10L: return "An_Exception_Handler";
            default: return "";
        }
    }

    std::string Element_Kinds(int64_t i, const std::string &strip) {
        std::string s = Element_Kinds(i);
        if (s.empty())
            s = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Element_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}

namespace Rose {
    std::string stringifyElement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Element_Kinds(i);
        if (retval.empty()) {
            retval = "(Element_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Element_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyElement_Kinds() {
        return stringify::Element_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 142
namespace stringify {
    const char* Operator_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Operator";
            case 1L: return "An_And_Operator";
            case 2L: return "An_Or_Operator";
            case 3L: return "An_Xor_Operator";
            case 4L: return "An_Equal_Operator";
            case 5L: return "A_Not_Equal_Operator";
            case 6L: return "A_Less_Than_Operator";
            case 7L: return "A_Less_Than_Or_Equal_Operator";
            case 8L: return "A_Greater_Than_Operator";
            case 9L: return "A_Greater_Than_Or_Equal_Operator";
            case 10L: return "A_Plus_Operator";
            case 11L: return "A_Minus_Operator";
            case 12L: return "A_Concatenate_Operator";
            case 13L: return "A_Unary_Plus_Operator";
            case 14L: return "A_Unary_Minus_Operator";
            case 15L: return "A_Multiply_Operator";
            case 16L: return "A_Divide_Operator";
            case 17L: return "A_Mod_Operator";
            case 18L: return "A_Rem_Operator";
            case 19L: return "An_Exponentiate_Operator";
            case 20L: return "An_Abs_Operator";
            case 21L: return "A_Not_Operator";
            default: return "";
        }
    }

    std::string Operator_Kinds(int64_t i, const std::string &strip) {
        std::string s = Operator_Kinds(i);
        if (s.empty())
            s = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}

namespace Rose {
    std::string stringifyOperator_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Operator_Kinds(i);
        if (retval.empty()) {
            retval = "(Operator_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Operator_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyOperator_Kinds() {
        return stringify::Operator_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 172
namespace stringify {
    const char* Pragma_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Pragma";
            case 1L: return "An_All_Calls_Remote_Pragma";
            case 2L: return "An_Assert_Pragma";
            case 3L: return "An_Assertion_Policy_Pragma";
            case 4L: return "An_Asynchronous_Pragma";
            case 5L: return "An_Atomic_Pragma";
            case 6L: return "An_Atomic_Components_Pragma";
            case 7L: return "An_Attach_Handler_Pragma";
            case 8L: return "A_Controlled_Pragma";
            case 9L: return "A_Convention_Pragma";
            case 10L: return "A_CPU_Pragma";
            case 11L: return "A_Default_Storage_Pool_Pragma";
            case 12L: return "A_Detect_Blocking_Pragma";
            case 13L: return "A_Discard_Names_Pragma";
            case 14L: return "A_Dispatching_Domain_Pragma";
            case 15L: return "An_Elaborate_Pragma";
            case 16L: return "An_Elaborate_All_Pragma";
            case 17L: return "An_Elaborate_Body_Pragma";
            case 18L: return "An_Export_Pragma";
            case 19L: return "An_Independent_Pragma";
            case 20L: return "A_Independent_Components_Pragma";
            case 21L: return "An_Import_Pragma";
            case 22L: return "An_Inline_Pragma";
            case 23L: return "An_Inspection_Point_Pragma";
            case 24L: return "An_Interrupt_Handler_Pragma";
            case 25L: return "An_Interrupt_Priority_Pragma";
            case 26L: return "A_Linker_Options_Pragma";
            case 27L: return "A_List_Pragma";
            case 28L: return "A_Locking_Policy_Pragma";
            case 29L: return "A_No_Return_Pragma";
            case 30L: return "A_Normalize_Scalars_Pragma";
            case 31L: return "An_Optimize_Pragma";
            case 32L: return "A_Pack_Pragma";
            case 33L: return "A_Page_Pragma";
            case 34L: return "A_Partition_Elaboration_Policy_Pragma";
            case 35L: return "A_Preelaborable_Initialization_Pragma";
            case 36L: return "A_Preelaborate_Pragma";
            case 37L: return "A_Priority_Pragma";
            case 38L: return "A_Priority_Specific_Dispatching_Pragma";
            case 39L: return "A_Profile_Pragma";
            case 40L: return "A_Pure_Pragma";
            case 41L: return "A_Queuing_Policy_Pragma";
            case 42L: return "A_Relative_Deadline_Pragma";
            case 43L: return "A_Remote_Call_Interface_Pragma";
            case 44L: return "A_Remote_Types_Pragma";
            case 45L: return "A_Restrictions_Pragma";
            case 46L: return "A_Reviewable_Pragma";
            case 47L: return "A_Shared_Passive_Pragma";
            case 48L: return "A_Storage_Size_Pragma";
            case 49L: return "A_Suppress_Pragma";
            case 50L: return "A_Task_Dispatching_Policy_Pragma";
            case 51L: return "An_Unchecked_Union_Pragma";
            case 52L: return "An_Unsuppress_Pragma";
            case 53L: return "A_Volatile_Pragma";
            case 54L: return "A_Volatile_Components_Pragma";
            case 55L: return "An_Implementation_Defined_Pragma";
            default: return "";
        }
    }

    std::string Pragma_Kinds(int64_t i, const std::string &strip) {
        std::string s = Pragma_Kinds(i);
        if (s.empty())
            s = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Pragma_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L
        };
        static const std::vector<int64_t> retval(values, values + 56);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPragma_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Pragma_Kinds(i);
        if (retval.empty()) {
            retval = "(Pragma_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Pragma_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPragma_Kinds() {
        return stringify::Pragma_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 246
namespace stringify {
    const char* Defining_Name_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Defining_Name";
            case 1L: return "A_Defining_Identifier";
            case 2L: return "A_Defining_Character_Literal";
            case 3L: return "A_Defining_Enumeration_Literal";
            case 4L: return "A_Defining_Operator_Symbol";
            case 5L: return "A_Defining_Expanded_Name";
            default: return "";
        }
    }

    std::string Defining_Name_Kinds(int64_t i, const std::string &strip) {
        std::string s = Defining_Name_Kinds(i);
        if (s.empty())
            s = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Defining_Name_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefining_Name_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Defining_Name_Kinds(i);
        if (retval.empty()) {
            retval = "(Defining_Name_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Defining_Name_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefining_Name_Kinds() {
        return stringify::Defining_Name_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 287
namespace stringify {
    const char* Declaration_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration";
            case 1L: return "An_Ordinary_Type_Declaration";
            case 2L: return "A_Task_Type_Declaration";
            case 3L: return "A_Protected_Type_Declaration";
            case 4L: return "An_Incomplete_Type_Declaration";
            case 5L: return "A_Tagged_Incomplete_Type_Declaration";
            case 6L: return "A_Private_Type_Declaration";
            case 7L: return "A_Private_Extension_Declaration";
            case 8L: return "A_Subtype_Declaration";
            case 9L: return "A_Variable_Declaration";
            case 10L: return "A_Constant_Declaration";
            case 11L: return "A_Deferred_Constant_Declaration";
            case 12L: return "A_Single_Task_Declaration";
            case 13L: return "A_Single_Protected_Declaration";
            case 14L: return "An_Integer_Number_Declaration";
            case 15L: return "A_Real_Number_Declaration";
            case 16L: return "An_Enumeration_Literal_Specification";
            case 17L: return "A_Discriminant_Specification";
            case 18L: return "A_Component_Declaration";
            case 19L: return "A_Loop_Parameter_Specification";
            case 20L: return "A_Generalized_Iterator_Specification";
            case 21L: return "An_Element_Iterator_Specification";
            case 22L: return "A_Procedure_Declaration";
            case 23L: return "A_Function_Declaration";
            case 24L: return "A_Parameter_Specification";
            case 25L: return "A_Procedure_Body_Declaration";
            case 26L: return "A_Function_Body_Declaration";
            case 27L: return "A_Return_Variable_Specification";
            case 28L: return "A_Return_Constant_Specification";
            case 29L: return "A_Null_Procedure_Declaration";
            case 30L: return "An_Expression_Function_Declaration";
            case 31L: return "A_Package_Declaration";
            case 32L: return "A_Package_Body_Declaration";
            case 33L: return "An_Object_Renaming_Declaration";
            case 34L: return "An_Exception_Renaming_Declaration";
            case 35L: return "A_Package_Renaming_Declaration";
            case 36L: return "A_Procedure_Renaming_Declaration";
            case 37L: return "A_Function_Renaming_Declaration";
            case 38L: return "A_Generic_Package_Renaming_Declaration";
            case 39L: return "A_Generic_Procedure_Renaming_Declaration";
            case 40L: return "A_Generic_Function_Renaming_Declaration";
            case 41L: return "A_Task_Body_Declaration";
            case 42L: return "A_Protected_Body_Declaration";
            case 43L: return "An_Entry_Declaration";
            case 44L: return "An_Entry_Body_Declaration";
            case 45L: return "An_Entry_Index_Specification";
            case 46L: return "A_Procedure_Body_Stub";
            case 47L: return "A_Function_Body_Stub";
            case 48L: return "A_Package_Body_Stub";
            case 49L: return "A_Task_Body_Stub";
            case 50L: return "A_Protected_Body_Stub";
            case 51L: return "An_Exception_Declaration";
            case 52L: return "A_Choice_Parameter_Specification";
            case 53L: return "A_Generic_Procedure_Declaration";
            case 54L: return "A_Generic_Function_Declaration";
            case 55L: return "A_Generic_Package_Declaration";
            case 56L: return "A_Package_Instantiation";
            case 57L: return "A_Procedure_Instantiation";
            case 58L: return "A_Function_Instantiation";
            case 59L: return "A_Formal_Object_Declaration";
            case 60L: return "A_Formal_Type_Declaration";
            case 61L: return "A_Formal_Incomplete_Type_Declaration";
            case 62L: return "A_Formal_Procedure_Declaration";
            case 63L: return "A_Formal_Function_Declaration";
            case 64L: return "A_Formal_Package_Declaration";
            case 65L: return "A_Formal_Package_Declaration_With_Box";
            default: return "";
        }
    }

    std::string Declaration_Kinds(int64_t i, const std::string &strip) {
        std::string s = Declaration_Kinds(i);
        if (s.empty())
            s = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Kinds(i);
        if (retval.empty()) {
            retval = "(Declaration_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Kinds() {
        return stringify::Declaration_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 391
namespace stringify {
    const char* Declaration_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Declaration_Origin";
            case 1L: return "An_Explicit_Declaration";
            case 2L: return "An_Implicit_Predefined_Declaration";
            case 3L: return "An_Implicit_Inherited_Declaration";
            default: return "";
        }
    }

    std::string Declaration_Origins(int64_t i, const std::string &strip) {
        std::string s = Declaration_Origins(i);
        if (s.empty())
            s = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Declaration_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeclaration_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Declaration_Origins(i);
        if (retval.empty()) {
            retval = "(Declaration_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Declaration_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeclaration_Origins() {
        return stringify::Declaration_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 407
namespace stringify {
    const char* Mode_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Mode";
            case 1L: return "A_Default_In_Mode";
            case 2L: return "An_In_Mode";
            case 3L: return "An_Out_Mode";
            case 4L: return "An_In_Out_Mode";
            default: return "";
        }
    }

    std::string Mode_Kinds(int64_t i, const std::string &strip) {
        std::string s = Mode_Kinds(i);
        if (s.empty())
            s = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyMode_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Mode_Kinds(i);
        if (retval.empty()) {
            retval = "(Mode_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Mode_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyMode_Kinds() {
        return stringify::Mode_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 417
namespace stringify {
    const char* Subprogram_Default_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Default";
            case 1L: return "A_Name_Default";
            case 2L: return "A_Box_Default";
            case 3L: return "A_Null_Default";
            case 4L: return "A_Nil_Default";
            default: return "";
        }
    }

    std::string Subprogram_Default_Kinds(int64_t i, const std::string &strip) {
        std::string s = Subprogram_Default_Kinds(i);
        if (s.empty())
            s = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subprogram_Default_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifySubprogram_Default_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Subprogram_Default_Kinds(i);
        if (retval.empty()) {
            retval = "(Subprogram_Default_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Subprogram_Default_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySubprogram_Default_Kinds() {
        return stringify::Subprogram_Default_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 814
namespace stringify {
    const char* Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Definition";
            case 1L: return "A_Type_Definition";
            case 2L: return "A_Subtype_Indication";
            case 3L: return "A_Constraint";
            case 4L: return "A_Component_Definition";
            case 5L: return "A_Discrete_Subtype_Definition";
            case 6L: return "A_Discrete_Range";
            case 7L: return "An_Unknown_Discriminant_Part";
            case 8L: return "A_Known_Discriminant_Part";
            case 9L: return "A_Record_Definition";
            case 10L: return "A_Null_Record_Definition";
            case 11L: return "A_Null_Component";
            case 12L: return "A_Variant_Part";
            case 13L: return "A_Variant";
            case 14L: return "An_Others_Choice";
            case 15L: return "An_Access_Definition";
            case 16L: return "A_Private_Type_Definition";
            case 17L: return "A_Tagged_Private_Type_Definition";
            case 18L: return "A_Private_Extension_Definition";
            case 19L: return "A_Task_Definition";
            case 20L: return "A_Protected_Definition";
            case 21L: return "A_Formal_Type_Definition";
            case 22L: return "An_Aspect_Specification";
            default: return "";
        }
    }

    std::string Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = Definition_Kinds(i);
        if (s.empty())
            s = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDefinition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDefinition_Kinds() {
        return stringify::Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 847
namespace stringify {
    const char* _Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Type_Definition";
            case 1L: return "A_Derived_Type_Definition";
            case 2L: return "A_Derived_Record_Extension_Definition";
            case 3L: return "An_Enumeration_Type_Definition";
            case 4L: return "A_Signed_Integer_Type_Definition";
            case 5L: return "A_Modular_Type_Definition";
            case 6L: return "A_Root_Type_Definition";
            case 7L: return "A_Floating_Point_Definition";
            case 8L: return "An_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Decimal_Fixed_Point_Definition";
            case 10L: return "An_Unconstrained_Array_Definition";
            case 11L: return "A_Constrained_Array_Definition";
            case 12L: return "A_Record_Type_Definition";
            case 13L: return "A_Tagged_Record_Type_Definition";
            case 14L: return "An_Interface_Type_Definition";
            case 15L: return "An_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Type_Kinds(i);
        if (s.empty())
            s = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Type_Kinds() {
        return stringify::_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 871
namespace stringify {
    const char* _Constraint_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Constraint";
            case 1L: return "A_Range_Attribute_Reference";
            case 2L: return "A_Simple_Expression_Range";
            case 3L: return "A_Digits_Constraint";
            case 4L: return "A_Delta_Constraint";
            case 5L: return "An_Index_Constraint";
            case 6L: return "A_Discriminant_Constraint";
            default: return "";
        }
    }

    std::string _Constraint_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Constraint_Kinds(i);
        if (s.empty())
            s = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Constraint_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Constraint_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Constraint_Kinds(i);
        if (retval.empty()) {
            retval = "(_Constraint_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Constraint_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Constraint_Kinds() {
        return stringify::_Constraint_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 881
namespace stringify {
    const char* _Interface_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Interface";
            case 1L: return "An_Ordinary_Interface";
            case 2L: return "A_Limited_Interface";
            case 3L: return "A_Task_Interface";
            case 4L: return "A_Protected_Interface";
            case 5L: return "A_Synchronized_Interface";
            default: return "";
        }
    }

    std::string _Interface_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Interface_Kinds(i);
        if (s.empty())
            s = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Interface_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Interface_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Interface_Kinds(i);
        if (retval.empty()) {
            retval = "(_Interface_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Interface_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Interface_Kinds() {
        return stringify::_Interface_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 890
namespace stringify {
    const char* _Root_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Root_Type_Definition";
            case 1L: return "A_Root_Integer_Definition";
            case 2L: return "A_Root_Real_Definition";
            case 3L: return "A_Universal_Integer_Definition";
            case 4L: return "A_Universal_Real_Definition";
            case 5L: return "A_Universal_Fixed_Definition";
            default: return "";
        }
    }

    std::string _Root_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Root_Type_Kinds(i);
        if (s.empty())
            s = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Root_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Root_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Root_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Root_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Root_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Root_Type_Kinds() {
        return stringify::_Root_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 899
namespace stringify {
    const char* _Discrete_Range_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Discrete_Range";
            case 1L: return "A_Discrete_Subtype_Indication";
            case 2L: return "A_Discrete_Range_Attribute_Reference";
            case 3L: return "A_Discrete_Simple_Expression_Range";
            default: return "";
        }
    }

    std::string _Discrete_Range_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Discrete_Range_Kinds(i);
        if (s.empty())
            s = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Discrete_Range_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Discrete_Range_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Discrete_Range_Kinds(i);
        if (retval.empty()) {
            retval = "(_Discrete_Range_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Discrete_Range_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Discrete_Range_Kinds() {
        return stringify::_Discrete_Range_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 906
namespace stringify {
    const char* _Formal_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Formal_Type_Definition";
            case 1L: return "A_Formal_Private_Type_Definition";
            case 2L: return "A_Formal_Tagged_Private_Type_Definition";
            case 3L: return "A_Formal_Derived_Type_Definition";
            case 4L: return "A_Formal_Discrete_Type_Definition";
            case 5L: return "A_Formal_Signed_Integer_Type_Definition";
            case 6L: return "A_Formal_Modular_Type_Definition";
            case 7L: return "A_Formal_Floating_Point_Definition";
            case 8L: return "A_Formal_Ordinary_Fixed_Point_Definition";
            case 9L: return "A_Formal_Decimal_Fixed_Point_Definition";
            case 10L: return "A_Formal_Interface_Type_Definition";
            case 11L: return "A_Formal_Unconstrained_Array_Definition";
            case 12L: return "A_Formal_Constrained_Array_Definition";
            case 13L: return "A_Formal_Access_Type_Definition";
            default: return "";
        }
    }

    std::string _Formal_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Formal_Type_Kinds(i);
        if (s.empty())
            s = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Formal_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Formal_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Formal_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Formal_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Formal_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Formal_Type_Kinds() {
        return stringify::_Formal_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 928
namespace stringify {
    const char* _Access_Type_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Type_Definition";
            case 1L: return "A_Pool_Specific_Access_To_Variable";
            case 2L: return "An_Access_To_Variable";
            case 3L: return "An_Access_To_Constant";
            case 4L: return "An_Access_To_Procedure";
            case 5L: return "An_Access_To_Protected_Procedure";
            case 6L: return "An_Access_To_Function";
            case 7L: return "An_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Type_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Type_Kinds(i);
        if (s.empty())
            s = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Type_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Type_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Type_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Type_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Type_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Type_Kinds() {
        return stringify::_Access_Type_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 939
namespace stringify {
    const char* _Access_Definition_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Access_Definition";
            case 1L: return "An_Anonymous_Access_To_Variable";
            case 2L: return "An_Anonymous_Access_To_Constant";
            case 3L: return "An_Anonymous_Access_To_Procedure";
            case 4L: return "An_Anonymous_Access_To_Protected_Procedure";
            case 5L: return "An_Anonymous_Access_To_Function";
            case 6L: return "An_Anonymous_Access_To_Protected_Function";
            default: return "";
        }
    }

    std::string _Access_Definition_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Access_Definition_Kinds(i);
        if (s.empty())
            s = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Access_Definition_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Access_Definition_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Access_Definition_Kinds(i);
        if (retval.empty()) {
            retval = "(_Access_Definition_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Access_Definition_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Access_Definition_Kinds() {
        return stringify::_Access_Definition_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1273
namespace stringify {
    const char* Expression_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Expression";
            case 1L: return "A_Box_Expression";
            case 2L: return "An_Integer_Literal";
            case 3L: return "A_Real_Literal";
            case 4L: return "A_String_Literal";
            case 5L: return "An_Identifier";
            case 6L: return "An_Operator_Symbol";
            case 7L: return "A_Character_Literal";
            case 8L: return "An_Enumeration_Literal";
            case 9L: return "An_Explicit_Dereference";
            case 10L: return "A_Function_Call";
            case 11L: return "An_Indexed_Component";
            case 12L: return "A_Slice";
            case 13L: return "A_Selected_Component";
            case 14L: return "An_Attribute_Reference";
            case 15L: return "A_Record_Aggregate";
            case 16L: return "An_Extension_Aggregate";
            case 17L: return "A_Positional_Array_Aggregate";
            case 18L: return "A_Named_Array_Aggregate";
            case 19L: return "An_And_Then_Short_Circuit";
            case 20L: return "An_Or_Else_Short_Circuit";
            case 21L: return "An_In_Membership_Test";
            case 22L: return "A_Not_In_Membership_Test";
            case 23L: return "A_Null_Literal";
            case 24L: return "A_Parenthesized_Expression";
            case 25L: return "A_Raise_Expression";
            case 26L: return "A_Type_Conversion";
            case 27L: return "A_Qualified_Expression";
            case 28L: return "An_Allocation_From_Subtype";
            case 29L: return "An_Allocation_From_Qualified_Expression";
            case 30L: return "A_Case_Expression";
            case 31L: return "An_If_Expression";
            case 32L: return "A_For_All_Quantified_Expression";
            case 33L: return "A_For_Some_Quantified_Expression";
            default: return "";
        }
    }

    std::string Expression_Kinds(int64_t i, const std::string &strip) {
        std::string s = Expression_Kinds(i);
        if (s.empty())
            s = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Expression_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}

namespace Rose {
    std::string stringifyExpression_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Expression_Kinds(i);
        if (retval.empty()) {
            retval = "(Expression_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Expression_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyExpression_Kinds() {
        return stringify::Expression_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1318
namespace stringify {
    const char* Attribute_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Attribute";
            case 1L: return "An_Access_Attribute";
            case 2L: return "An_Address_Attribute";
            case 3L: return "An_Adjacent_Attribute";
            case 4L: return "An_Aft_Attribute";
            case 5L: return "An_Alignment_Attribute";
            case 6L: return "A_Base_Attribute";
            case 7L: return "A_Bit_Order_Attribute";
            case 8L: return "A_Body_Version_Attribute";
            case 9L: return "A_Callable_Attribute";
            case 10L: return "A_Caller_Attribute";
            case 11L: return "A_Ceiling_Attribute";
            case 12L: return "A_Class_Attribute";
            case 13L: return "A_Component_Size_Attribute";
            case 14L: return "A_Compose_Attribute";
            case 15L: return "A_Constrained_Attribute";
            case 16L: return "A_Copy_Sign_Attribute";
            case 17L: return "A_Count_Attribute";
            case 18L: return "A_Definite_Attribute";
            case 19L: return "A_Delta_Attribute";
            case 20L: return "A_Denorm_Attribute";
            case 21L: return "A_Digits_Attribute";
            case 22L: return "An_Exponent_Attribute";
            case 23L: return "An_External_Tag_Attribute";
            case 24L: return "A_First_Attribute";
            case 25L: return "A_First_Bit_Attribute";
            case 26L: return "A_Floor_Attribute";
            case 27L: return "A_Fore_Attribute";
            case 28L: return "A_Fraction_Attribute";
            case 29L: return "An_Identity_Attribute";
            case 30L: return "An_Image_Attribute";
            case 31L: return "An_Input_Attribute";
            case 32L: return "A_Last_Attribute";
            case 33L: return "A_Last_Bit_Attribute";
            case 34L: return "A_Leading_Part_Attribute";
            case 35L: return "A_Length_Attribute";
            case 36L: return "A_Machine_Attribute";
            case 37L: return "A_Machine_Emax_Attribute";
            case 38L: return "A_Machine_Emin_Attribute";
            case 39L: return "A_Machine_Mantissa_Attribute";
            case 40L: return "A_Machine_Overflows_Attribute";
            case 41L: return "A_Machine_Radix_Attribute";
            case 42L: return "A_Machine_Rounds_Attribute";
            case 43L: return "A_Max_Attribute";
            case 44L: return "A_Max_Size_In_Storage_Elements_Attribute";
            case 45L: return "A_Min_Attribute";
            case 46L: return "A_Model_Attribute";
            case 47L: return "A_Model_Emin_Attribute";
            case 48L: return "A_Model_Epsilon_Attribute";
            case 49L: return "A_Model_Mantissa_Attribute";
            case 50L: return "A_Model_Small_Attribute";
            case 51L: return "A_Modulus_Attribute";
            case 52L: return "An_Output_Attribute";
            case 53L: return "A_Partition_ID_Attribute";
            case 54L: return "A_Pos_Attribute";
            case 55L: return "A_Position_Attribute";
            case 56L: return "A_Pred_Attribute";
            case 57L: return "A_Range_Attribute";
            case 58L: return "A_Read_Attribute";
            case 59L: return "A_Remainder_Attribute";
            case 60L: return "A_Round_Attribute";
            case 61L: return "A_Rounding_Attribute";
            case 62L: return "A_Safe_First_Attribute";
            case 63L: return "A_Safe_Last_Attribute";
            case 64L: return "A_Scale_Attribute";
            case 65L: return "A_Scaling_Attribute";
            case 66L: return "A_Signed_Zeros_Attribute";
            case 67L: return "A_Size_Attribute";
            case 68L: return "A_Small_Attribute";
            case 69L: return "A_Storage_Pool_Attribute";
            case 70L: return "A_Storage_Size_Attribute";
            case 71L: return "A_Succ_Attribute";
            case 72L: return "A_Tag_Attribute";
            case 73L: return "A_Terminated_Attribute";
            case 74L: return "A_Truncation_Attribute";
            case 75L: return "An_Unbiased_Rounding_Attribute";
            case 76L: return "An_Unchecked_Access_Attribute";
            case 77L: return "A_Val_Attribute";
            case 78L: return "A_Valid_Attribute";
            case 79L: return "A_Value_Attribute";
            case 80L: return "A_Version_Attribute";
            case 81L: return "A_Wide_Image_Attribute";
            case 82L: return "A_Wide_Value_Attribute";
            case 83L: return "A_Wide_Width_Attribute";
            case 84L: return "A_Width_Attribute";
            case 85L: return "A_Write_Attribute";
            case 86L: return "A_Machine_Rounding_Attribute";
            case 87L: return "A_Mod_Attribute";
            case 88L: return "A_Priority_Attribute";
            case 89L: return "A_Stream_Size_Attribute";
            case 90L: return "A_Wide_Wide_Image_Attribute";
            case 91L: return "A_Wide_Wide_Value_Attribute";
            case 92L: return "A_Wide_Wide_Width_Attribute";
            case 93L: return "A_Max_Alignment_For_Allocation_Attribute";
            case 94L: return "An_Overlaps_Storage_Attribute";
            case 95L: return "An_Implementation_Defined_Attribute";
            case 96L: return "An_Unknown_Attribute";
            default: return "";
        }
    }

    std::string Attribute_Kinds(int64_t i, const std::string &strip) {
        std::string s = Attribute_Kinds(i);
        if (s.empty())
            s = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Attribute_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L
        };
        static const std::vector<int64_t> retval(values, values + 97);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAttribute_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Attribute_Kinds(i);
        if (retval.empty()) {
            retval = "(Attribute_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Attribute_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAttribute_Kinds() {
        return stringify::Attribute_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1544
namespace stringify {
    const char* Association_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Association";
            case 1L: return "A_Pragma_Argument_Association";
            case 2L: return "A_Discriminant_Association";
            case 3L: return "A_Record_Component_Association";
            case 4L: return "An_Array_Component_Association";
            case 5L: return "A_Parameter_Association";
            case 6L: return "A_Generic_Association";
            default: return "";
        }
    }

    std::string Association_Kinds(int64_t i, const std::string &strip) {
        std::string s = Association_Kinds(i);
        if (s.empty())
            s = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Association_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociation_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Association_Kinds(i);
        if (retval.empty()) {
            retval = "(Association_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Association_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociation_Kinds() {
        return stringify::Association_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1593
namespace stringify {
    const char* Statement_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Statement";
            case 1L: return "A_Null_Statement";
            case 2L: return "An_Assignment_Statement";
            case 3L: return "An_If_Statement";
            case 4L: return "A_Case_Statement";
            case 5L: return "A_Loop_Statement";
            case 6L: return "A_While_Loop_Statement";
            case 7L: return "A_For_Loop_Statement";
            case 8L: return "A_Block_Statement";
            case 9L: return "An_Exit_Statement";
            case 10L: return "A_Goto_Statement";
            case 11L: return "A_Procedure_Call_Statement";
            case 12L: return "A_Return_Statement";
            case 13L: return "An_Extended_Return_Statement";
            case 14L: return "An_Accept_Statement";
            case 15L: return "An_Entry_Call_Statement";
            case 16L: return "A_Requeue_Statement";
            case 17L: return "A_Requeue_Statement_With_Abort";
            case 18L: return "A_Delay_Until_Statement";
            case 19L: return "A_Delay_Relative_Statement";
            case 20L: return "A_Terminate_Alternative_Statement";
            case 21L: return "A_Selective_Accept_Statement";
            case 22L: return "A_Timed_Entry_Call_Statement";
            case 23L: return "A_Conditional_Entry_Call_Statement";
            case 24L: return "An_Asynchronous_Select_Statement";
            case 25L: return "An_Abort_Statement";
            case 26L: return "A_Raise_Statement";
            case 27L: return "A_Code_Statement";
            default: return "";
        }
    }

    std::string Statement_Kinds(int64_t i, const std::string &strip) {
        std::string s = Statement_Kinds(i);
        if (s.empty())
            s = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statement_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyStatement_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Statement_Kinds(i);
        if (retval.empty()) {
            retval = "(Statement_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Statement_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStatement_Kinds() {
        return stringify::Statement_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1741
namespace stringify {
    const char* Path_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Path";
            case 1L: return "An_If_Path";
            case 2L: return "An_Elsif_Path";
            case 3L: return "An_Else_Path";
            case 4L: return "A_Case_Path";
            case 5L: return "A_Select_Path";
            case 6L: return "An_Or_Path";
            case 7L: return "A_Then_Abort_Path";
            case 8L: return "A_Case_Expression_Path";
            case 9L: return "An_If_Expression_Path";
            case 10L: return "An_Elsif_Expression_Path";
            case 11L: return "An_Else_Expression_Path";
            default: return "";
        }
    }

    std::string Path_Kinds(int64_t i, const std::string &strip) {
        std::string s = Path_Kinds(i);
        if (s.empty())
            s = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Path_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}

namespace Rose {
    std::string stringifyPath_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Path_Kinds(i);
        if (retval.empty()) {
            retval = "(Path_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Path_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyPath_Kinds() {
        return stringify::Path_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1821
namespace stringify {
    const char* Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Clause";
            case 1L: return "A_Use_Package_Clause";
            case 2L: return "A_Use_Type_Clause";
            case 3L: return "A_Use_All_Type_Clause";
            case 4L: return "A_With_Clause";
            case 5L: return "A_Representation_Clause";
            case 6L: return "A_Component_Clause";
            default: return "";
        }
    }

    std::string Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = Clause_Kinds(i);
        if (s.empty())
            s = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyClause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyClause_Kinds() {
        return stringify::Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1833
namespace stringify {
    const char* _Representation_Clause_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Representation_Clause";
            case 1L: return "An_Attribute_Definition_Clause";
            case 2L: return "An_Enumeration_Representation_Clause";
            case 3L: return "A_Record_Representation_Clause";
            case 4L: return "An_At_Clause";
            default: return "";
        }
    }

    std::string _Representation_Clause_Kinds(int64_t i, const std::string &strip) {
        std::string s = _Representation_Clause_Kinds(i);
        if (s.empty())
            s = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& _Representation_Clause_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_Representation_Clause_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::_Representation_Clause_Kinds(i);
        if (retval.empty()) {
            retval = "(_Representation_Clause_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "_Representation_Clause_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_Representation_Clause_Kinds() {
        return stringify::_Representation_Clause_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1918
namespace stringify {
    const char* Enclosing_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_Enclosing";
            case 1L: return "Enclosing_Element";
            case 2L: return "Enclosing_Unit";
            default: return "";
        }
    }

    std::string Enclosing_Kinds(int64_t i, const std::string &strip) {
        std::string s = Enclosing_Kinds(i);
        if (s.empty())
            s = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Enclosing_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyEnclosing_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Enclosing_Kinds(i);
        if (retval.empty()) {
            retval = "(Enclosing_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Enclosing_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyEnclosing_Kinds() {
        return stringify::Enclosing_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 1970
namespace stringify {
    const char* Unit_Kinds(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Unit";
            case 1L: return "A_Procedure";
            case 2L: return "A_Function";
            case 3L: return "A_Package";
            case 4L: return "A_Generic_Procedure";
            case 5L: return "A_Generic_Function";
            case 6L: return "A_Generic_Package";
            case 7L: return "A_Procedure_Instance";
            case 8L: return "A_Function_Instance";
            case 9L: return "A_Package_Instance";
            case 10L: return "A_Procedure_Renaming";
            case 11L: return "A_Function_Renaming";
            case 12L: return "A_Package_Renaming";
            case 13L: return "A_Generic_Procedure_Renaming";
            case 14L: return "A_Generic_Function_Renaming";
            case 15L: return "A_Generic_Package_Renaming";
            case 16L: return "A_Procedure_Body";
            case 17L: return "A_Function_Body";
            case 18L: return "A_Package_Body";
            case 19L: return "A_Procedure_Body_Subunit";
            case 20L: return "A_Function_Body_Subunit";
            case 21L: return "A_Package_Body_Subunit";
            case 22L: return "A_Task_Body_Subunit";
            case 23L: return "A_Protected_Body_Subunit";
            case 24L: return "A_Nonexistent_Declaration";
            case 25L: return "A_Nonexistent_Body";
            case 26L: return "A_Configuration_Compilation";
            case 27L: return "An_Unknown_Unit";
            default: return "";
        }
    }

    std::string Unit_Kinds(int64_t i, const std::string &strip) {
        std::string s = Unit_Kinds(i);
        if (s.empty())
            s = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Kinds() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Kinds(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Kinds(i);
        if (retval.empty()) {
            retval = "(Unit_Kinds)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Kinds::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Kinds() {
        return stringify::Unit_Kinds();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 2037
namespace stringify {
    const char* Unit_Classes(int64_t i) {
        switch (i) {
            case 0L: return "Not_A_Class";
            case 1L: return "A_Public_Declaration";
            case 2L: return "A_Public_Body";
            case 3L: return "A_Public_Declaration_And_Body";
            case 4L: return "A_Private_Declaration";
            case 5L: return "A_Private_Body";
            case 6L: return "A_Separate_Body";
            default: return "";
        }
    }

    std::string Unit_Classes(int64_t i, const std::string &strip) {
        std::string s = Unit_Classes(i);
        if (s.empty())
            s = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Classes() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Classes(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Classes(i);
        if (retval.empty()) {
            retval = "(Unit_Classes)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Classes::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Classes() {
        return stringify::Unit_Classes();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_Ada_ROSE_Connection/parser/a_nodes/include/a_nodes.h line 2058
namespace stringify {
    const char* Unit_Origins(int64_t i) {
        switch (i) {
            case 0L: return "Not_An_Origin";
            case 1L: return "A_Predefined_Unit";
            case 2L: return "An_Implementation_Unit";
            case 3L: return "An_Application_Unit";
            default: return "";
        }
    }

    std::string Unit_Origins(int64_t i, const std::string &strip) {
        std::string s = Unit_Origins(i);
        if (s.empty())
            s = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Unit_Origins() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyUnit_Origins(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Unit_Origins(i);
        if (retval.empty()) {
            retval = "(Unit_Origins)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Unit_Origins::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnit_Origins() {
        return stringify::Unit_Origins();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 14
namespace stringify { namespace LanguageTranslation {
    const char* FunctionModifier(int64_t i) {
        switch (i) {
            case 0L: return "e_function_modifier_none";
            case 1L: return "e_function_modifier_reentrant";
            case 2L: return "e_function_modifier_recursive";
            case 3L: return "e_function_modifier_definition";
            case 4L: return "e_function_modifier_reference";
            case 5L: return "e_function_modifier_elemental";
            case 6L: return "e_function_modifier_impure";
            case 7L: return "e_function_modifier_module";
            case 8L: return "e_function_modifier_non_recursive";
            case 9L: return "e_function_modifier_pure";
            case 10L: return "e_function_modifier_cuda_host";
            case 11L: return "e_function_modifier_cuda_device";
            case 12L: return "e_function_modifier_cuda_host_device";
            case 13L: return "e_function_modifier_cuda_global";
            case 14L: return "e_function_modifier_cuda_grid_global";
            case 15L: return "e_function_modifier_last";
            default: return "";
        }
    }

    std::string FunctionModifier(int64_t i, const std::string &strip) {
        std::string s = FunctionModifier(i);
        if (s.empty())
            s = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionModifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationFunctionModifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::FunctionModifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::FunctionModifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::FunctionModifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationFunctionModifier() {
        return stringify::LanguageTranslation::FunctionModifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 42
namespace stringify { namespace LanguageTranslation {
    const char* PackingSpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_packing_spec_unknown";
            case 1L: return "e_packing_spec_none";
            case 2L: return "e_packing_spec_mixed";
            case 3L: return "e_packing_spec_dense";
            default: return "";
        }
    }

    std::string PackingSpecifier(int64_t i, const std::string &strip) {
        std::string s = PackingSpecifier(i);
        if (s.empty())
            s = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PackingSpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationPackingSpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::PackingSpecifier(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::PackingSpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::PackingSpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationPackingSpecifier() {
        return stringify::LanguageTranslation::PackingSpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/general_language_translation.h line 52
namespace stringify { namespace LanguageTranslation {
    const char* ExpressionKind(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_unknown";
            case 2L: return "e_access_modifier_public";
            case 3L: return "e_access_modifier_private";
            case 4L: return "e_storage_modifier_contiguous";
            case 5L: return "e_storage_modifier_external";
            case 6L: return "e_storage_modifier_static";
            case 7L: return "e_storage_modifier_location";
            case 8L: return "e_storage_modifier_jovial_def";
            case 9L: return "e_storage_modifier_jovial_ref";
            case 10L: return "e_type_modifier_list";
            case 11L: return "e_type_modifier_abstract";
            case 12L: return "e_type_modifier_allocatable";
            case 13L: return "e_type_modifier_asynchronous";
            case 14L: return "e_type_modifier_bind_c";
            case 15L: return "e_type_modifier_const";
            case 16L: return "e_type_modifier_intent_in";
            case 17L: return "e_type_modifier_intent_out";
            case 18L: return "e_type_modifier_intent_inout";
            case 19L: return "e_type_modifier_intrinsic";
            case 20L: return "e_type_modifier_optional";
            case 21L: return "e_type_modifier_parameter";
            case 22L: return "e_type_modifier_pointer";
            case 23L: return "e_type_modifier_protected";
            case 24L: return "e_type_modifier_round";
            case 25L: return "e_type_modifier_save";
            case 26L: return "e_type_modifier_target";
            case 27L: return "e_type_modifier_truncate";
            case 28L: return "e_type_modifier_volatile";
            case 29L: return "e_type_modifier_z";
            case 30L: return "e_param_binding_value";
            case 31L: return "e_param_binding_reference";
            case 32L: return "e_param_binding_result";
            case 33L: return "e_struct_modifier_list";
            case 34L: return "e_struct_item_modifier_list";
            case 35L: return "e_operator_assign";
            case 36L: return "e_operator_exponentiate";
            case 37L: return "e_operator_concatenate";
            case 38L: return "e_operator_add";
            case 39L: return "e_operator_subtract";
            case 40L: return "e_operator_mod";
            case 41L: return "e_operator_multiply";
            case 42L: return "e_operator_divide";
            case 43L: return "e_operator_and";
            case 44L: return "e_operator_or";
            case 45L: return "e_operator_xor";
            case 46L: return "e_operator_equiv";
            case 47L: return "e_operator_less_than";
            case 48L: return "e_operator_greater_than";
            case 49L: return "e_operator_less_or_equal";
            case 50L: return "e_operator_greater_or_equal";
            case 51L: return "e_operator_equality";
            case 52L: return "e_operator_not_equal";
            case 53L: return "e_operator_eqv";
            case 54L: return "e_operator_not_eqv";
            case 55L: return "e_operator_unary_plus";
            case 56L: return "e_operator_unary_minus";
            case 57L: return "e_operator_unary_not";
            case 58L: return "e_operator_unity";
            case 59L: return "e_literalExpression";
            case 60L: return "e_function_reference";
            case 61L: return "e_procedure_call";
            case 62L: return "e_argument_list";
            case 63L: return "e_argument_keyword";
            case 64L: return "e_variable_reference";
            case 65L: return "e_array_reference";
            case 66L: return "e_case_range";
            case 67L: return "e_case_selector";
            case 68L: return "e_array_shape";
            case 69L: return "e_explicit_shape";
            case 70L: return "e_assumed_or_implied_shape";
            case 71L: return "e_assumed_shape";
            case 72L: return "e_assumed_size";
            case 73L: return "e_array_subscripts";
            case 74L: return "e_array_index_triplet";
            case 75L: return "e_section_subscripts";
            case 76L: return "e_explicit_dimension";
            case 77L: return "e_star_dimension";
            case 78L: return "e_star_expression";
            case 79L: return "e_initializer";
            case 80L: return "e_struct_initializer";
            case 81L: return "e_switch_stmt";
            case 82L: return "e_end_switch_stmt";
            case 83L: return "e_case_option_stmt";
            case 84L: return "e_case_default_option_stmt";
            case 85L: return "e_end_proc_ref_stmt";
            case 86L: return "e_end_proc_def_stmt";
            case 87L: return "e_define_directive_stmt";
            case 88L: return "e_fortran_dimension_stmt";
            case 89L: return "e_fortran_import_stmt";
            case 90L: return "e_fortran_if_stmt";
            case 91L: return "e_fortran_if_then_stmt";
            case 92L: return "e_fortran_else_if_stmt";
            case 93L: return "e_fortran_else_stmt";
            case 94L: return "e_fortran_end_do_stmt";
            case 95L: return "e_fortran_do_concurrent_stmt";
            case 96L: return "e_fortran_concurrent_header";
            case 97L: return "e_fortran_concurrent_control";
            case 98L: return "e_fortran_concurrent_locality";
            case 99L: return "e_fortran_forall_stmt";
            case 100L: return "e_fortran_end_forall_stmt";
            case 101L: return "e_fortran_sync_all_stmt";
            case 102L: return "e_fortran_sync_images_stmt";
            case 103L: return "e_fortran_sync_memory_stmt";
            case 104L: return "e_fortran_sync_team_stmt";
            case 105L: return "e_fortran_lock_stmt";
            case 106L: return "e_fortran_unlock_stmt";
            case 107L: return "e_fortran_sync_stat_list";
            case 108L: return "e_fortran_sync_stat_stat";
            case 109L: return "e_fortran_sync_stat_errmsg";
            case 110L: return "e_fortran_stat_acquired_lock";
            case 111L: return "e_jovial_compool_stmt";
            case 112L: return "e_cuda_host";
            case 113L: return "e_cuda_device";
            case 114L: return "e_cuda_global_function";
            case 115L: return "e_cuda_grid_global";
            case 116L: return "e_cuda_global";
            case 117L: return "e_cuda_device_memory";
            case 118L: return "e_cuda_managed";
            case 119L: return "e_cuda_constant";
            case 120L: return "e_cuda_shared";
            case 121L: return "e_cuda_pinned";
            case 122L: return "e_cuda_texture";
            case 123L: return "e_last";
            default: return "";
        }
    }

    std::string ExpressionKind(int64_t i, const std::string &strip) {
        std::string s = ExpressionKind(i);
        if (s.empty())
            s = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExpressionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L
        };
        static const std::vector<int64_t> retval(values, values + 124);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyLanguageTranslationExpressionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::LanguageTranslation::ExpressionKind(i);
        if (retval.empty()) {
            retval = "(LanguageTranslation::ExpressionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "LanguageTranslation::ExpressionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLanguageTranslationExpressionKind() {
        return stringify::LanguageTranslation::ExpressionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/SageTreeBuilder.h line 55
namespace stringify { namespace Rose { namespace builder { namespace SageTreeBuilder {
    const char* LanguageEnum(int64_t i) {
        switch (i) {
            case 0L: return "Fortran";
            case 1L: return "Jovial";
            default: return "";
        }
    }

    std::string LanguageEnum(int64_t i, const std::string &strip) {
        std::string s = LanguageEnum(i);
        if (s.empty())
            s = "(Rose::builder::SageTreeBuilder::LanguageEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LanguageEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringify_builderSageTreeBuilderLanguageEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::builder::SageTreeBuilder::LanguageEnum(i);
        if (retval.empty()) {
            retval = "(Rose::builder::SageTreeBuilder::LanguageEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::builder::SageTreeBuilder::LanguageEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_builderSageTreeBuilderLanguageEnum() {
        return stringify::Rose::builder::SageTreeBuilder::LanguageEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Experimental_General_Language_Support/Tokens.h line 18
namespace stringify { namespace Rose { namespace builder {
    const char* JovialEnum(int64_t i) {
        switch (i) {
            case 0L: return "unknown";
            case 98L: return "define";
            case 99L: return "comment";
            default: return "";
        }
    }

    std::string JovialEnum(int64_t i, const std::string &strip) {
        std::string s = JovialEnum(i);
        if (s.empty())
            s = "(Rose::builder::JovialEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& JovialEnum() {
        static const int64_t values[] = {
            0L,
            98L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringify_builderJovialEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::builder::JovialEnum(i);
        if (retval.empty()) {
            retval = "(Rose::builder::JovialEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::builder::JovialEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_builderJovialEnum() {
        return stringify::Rose::builder::JovialEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/Assembler.h line 80
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Assembler {
    const char* EncodingType(int64_t i) {
        switch (i) {
            case 0L: return "ET_SHORTEST";
            case 1L: return "ET_LONGEST";
            case 2L: return "ET_MATCHES";
            default: return "";
        }
    }

    std::string EncodingType(int64_t i, const std::string &strip) {
        std::string s = EncodingType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EncodingType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerEncodingType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Assembler::EncodingType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Assembler::EncodingType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Assembler::EncodingType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerEncodingType() {
        return stringify::Rose::BinaryAnalysis::Assembler::EncodingType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86Init.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "x86_unknown_instruction";
            case 1L: return "x86_aaa";
            case 2L: return "x86_aad";
            case 3L: return "x86_aam";
            case 4L: return "x86_aas";
            case 5L: return "x86_adc";
            case 6L: return "x86_add";
            case 7L: return "x86_addpd";
            case 8L: return "x86_addps";
            case 9L: return "x86_addsd";
            case 10L: return "x86_addss";
            case 11L: return "x86_addsubpd";
            case 12L: return "x86_addsubps";
            case 13L: return "x86_and";
            case 14L: return "x86_andnpd";
            case 15L: return "x86_andnps";
            case 16L: return "x86_andpd";
            case 17L: return "x86_andps";
            case 18L: return "x86_arpl";
            case 19L: return "x86_blendpd";
            case 20L: return "x86_blendps";
            case 21L: return "x86_blendvpd";
            case 22L: return "x86_blendvps";
            case 23L: return "x86_bound";
            case 24L: return "x86_bsf";
            case 25L: return "x86_bsr";
            case 26L: return "x86_bswap";
            case 27L: return "x86_bt";
            case 28L: return "x86_btc";
            case 29L: return "x86_btr";
            case 30L: return "x86_bts";
            case 31L: return "x86_call";
            case 32L: return "x86_cbw";
            case 33L: return "x86_cdq";
            case 34L: return "x86_cdqe";
            case 35L: return "x86_clc";
            case 36L: return "x86_cld";
            case 37L: return "x86_clflush";
            case 38L: return "x86_clgi";
            case 39L: return "x86_cli";
            case 40L: return "x86_clts";
            case 41L: return "x86_cmc";
            case 42L: return "x86_cmova";
            case 43L: return "x86_cmovae";
            case 44L: return "x86_cmovb";
            case 45L: return "x86_cmovbe";
            case 46L: return "x86_cmove";
            case 47L: return "x86_cmovg";
            case 48L: return "x86_cmovge";
            case 49L: return "x86_cmovl";
            case 50L: return "x86_cmovle";
            case 51L: return "x86_cmovne";
            case 52L: return "x86_cmovno";
            case 53L: return "x86_cmovns";
            case 54L: return "x86_cmovo";
            case 55L: return "x86_cmovpe";
            case 56L: return "x86_cmovpo";
            case 57L: return "x86_cmovs";
            case 58L: return "x86_cmp";
            case 59L: return "x86_cmppd";
            case 60L: return "x86_cmpps";
            case 61L: return "x86_cmpsb";
            case 62L: return "x86_cmpsd";
            case 63L: return "x86_cmpsq";
            case 64L: return "x86_cmpss";
            case 65L: return "x86_cmpsw";
            case 66L: return "x86_cmpxchg";
            case 67L: return "x86_cmpxchg16b";
            case 68L: return "x86_cmpxchg8b";
            case 69L: return "x86_comisd";
            case 70L: return "x86_comiss";
            case 71L: return "x86_cpuid";
            case 72L: return "x86_cqo";
            case 73L: return "x86_crc32";
            case 74L: return "x86_cvtdq2pd";
            case 75L: return "x86_cvtdq2ps";
            case 76L: return "x86_cvtpd2dq";
            case 77L: return "x86_cvtpd2pi";
            case 78L: return "x86_cvtpd2ps";
            case 79L: return "x86_cvtpi2pd";
            case 80L: return "x86_cvtpi2ps";
            case 81L: return "x86_cvtps2dq";
            case 82L: return "x86_cvtps2pd";
            case 83L: return "x86_cvtps2pi";
            case 84L: return "x86_cvtsd2si";
            case 85L: return "x86_cvtsd2ss";
            case 86L: return "x86_cvtsi2sd";
            case 87L: return "x86_cvtsi2ss";
            case 88L: return "x86_cvtss2sd";
            case 89L: return "x86_cvtss2si";
            case 90L: return "x86_cvttpd2dq";
            case 91L: return "x86_cvttpd2pi";
            case 92L: return "x86_cvttps2dq";
            case 93L: return "x86_cvttps2pi";
            case 94L: return "x86_cvttsd2si";
            case 95L: return "x86_cvttss2si";
            case 96L: return "x86_cwd";
            case 97L: return "x86_cwde";
            case 98L: return "x86_daa";
            case 99L: return "x86_das";
            case 100L: return "x86_dec";
            case 101L: return "x86_div";
            case 102L: return "x86_divpd";
            case 103L: return "x86_divps";
            case 104L: return "x86_divsd";
            case 105L: return "x86_divss";
            case 106L: return "x86_dppd";
            case 107L: return "x86_dpps";
            case 108L: return "x86_emms";
            case 109L: return "x86_enter";
            case 110L: return "x86_extractps";
            case 111L: return "x86_extrq";
            case 112L: return "x86_f2xm1";
            case 113L: return "x86_fabs";
            case 114L: return "x86_fadd";
            case 115L: return "x86_faddp";
            case 116L: return "x86_farcall";
            case 117L: return "x86_farjmp";
            case 118L: return "x86_fbld";
            case 119L: return "x86_fbstp";
            case 120L: return "x86_fchs";
            case 121L: return "x86_fcmovb";
            case 122L: return "x86_fcmovbe";
            case 123L: return "x86_fcmove";
            case 124L: return "x86_fcmovnb";
            case 125L: return "x86_fcmovnbe";
            case 126L: return "x86_fcmovne";
            case 127L: return "x86_fcmovnu";
            case 128L: return "x86_fcmovu";
            case 129L: return "x86_fcom";
            case 130L: return "x86_fcomi";
            case 131L: return "x86_fcomip";
            case 132L: return "x86_fcomp";
            case 133L: return "x86_fcompp";
            case 134L: return "x86_fcos";
            case 135L: return "x86_fdecstp";
            case 136L: return "x86_fdiv";
            case 137L: return "x86_fdivp";
            case 138L: return "x86_fdivr";
            case 139L: return "x86_fdivrp";
            case 140L: return "x86_femms";
            case 141L: return "x86_ffree";
            case 142L: return "x86_fiadd";
            case 143L: return "x86_ficom";
            case 144L: return "x86_ficomp";
            case 145L: return "x86_fidiv";
            case 146L: return "x86_fidivr";
            case 147L: return "x86_fild";
            case 148L: return "x86_fimul";
            case 149L: return "x86_fincstp";
            case 150L: return "x86_fist";
            case 151L: return "x86_fistp";
            case 152L: return "x86_fisttp";
            case 153L: return "x86_fisub";
            case 154L: return "x86_fisubr";
            case 155L: return "x86_fld";
            case 156L: return "x86_fld1";
            case 157L: return "x86_fldcw";
            case 158L: return "x86_fldenv";
            case 159L: return "x86_fldl2e";
            case 160L: return "x86_fldl2t";
            case 161L: return "x86_fldlg2";
            case 162L: return "x86_fldln2";
            case 163L: return "x86_fldpi";
            case 164L: return "x86_fldz";
            case 165L: return "x86_fmul";
            case 166L: return "x86_fmulp";
            case 167L: return "x86_fnclex";
            case 168L: return "x86_fninit";
            case 169L: return "x86_fnop";
            case 170L: return "x86_fnsave";
            case 171L: return "x86_fnstcw";
            case 172L: return "x86_fnstenv";
            case 173L: return "x86_fnstsw";
            case 174L: return "x86_fpatan";
            case 175L: return "x86_fprem";
            case 176L: return "x86_fprem1";
            case 177L: return "x86_fptan";
            case 178L: return "x86_frndint";
            case 179L: return "x86_frstor";
            case 180L: return "x86_fscale";
            case 181L: return "x86_fsin";
            case 182L: return "x86_fsincos";
            case 183L: return "x86_fsqrt";
            case 184L: return "x86_fst";
            case 185L: return "x86_fstp";
            case 186L: return "x86_fsub";
            case 187L: return "x86_fsubp";
            case 188L: return "x86_fsubr";
            case 189L: return "x86_fsubrp";
            case 190L: return "x86_ftst";
            case 191L: return "x86_fucom";
            case 192L: return "x86_fucomi";
            case 193L: return "x86_fucomip";
            case 194L: return "x86_fucomp";
            case 195L: return "x86_fucompp";
            case 196L: return "x86_fwait";
            case 197L: return "x86_fxam";
            case 198L: return "x86_fxch";
            case 199L: return "x86_fxrstor";
            case 200L: return "x86_fxsave";
            case 201L: return "x86_fxtract";
            case 202L: return "x86_fyl2x";
            case 203L: return "x86_fyl2xp1";
            case 204L: return "x86_getsec";
            case 205L: return "x86_haddpd";
            case 206L: return "x86_haddps";
            case 207L: return "x86_hlt";
            case 208L: return "x86_hsubpd";
            case 209L: return "x86_hsubps";
            case 210L: return "x86_idiv";
            case 211L: return "x86_imul";
            case 212L: return "x86_in";
            case 213L: return "x86_inc";
            case 214L: return "x86_insb";
            case 215L: return "x86_insd";
            case 216L: return "x86_insertps";
            case 217L: return "x86_insertq";
            case 218L: return "x86_insw";
            case 219L: return "x86_int";
            case 220L: return "x86_int1";
            case 221L: return "x86_int3";
            case 222L: return "x86_into";
            case 223L: return "x86_invd";
            case 224L: return "x86_invept";
            case 225L: return "x86_invlpg";
            case 226L: return "x86_invlpga";
            case 227L: return "x86_invvpid";
            case 228L: return "x86_iret";
            case 229L: return "x86_ja";
            case 230L: return "x86_jae";
            case 231L: return "x86_jb";
            case 232L: return "x86_jbe";
            case 233L: return "x86_jcxz";
            case 234L: return "x86_je";
            case 235L: return "x86_jecxz";
            case 236L: return "x86_jg";
            case 237L: return "x86_jge";
            case 238L: return "x86_jl";
            case 239L: return "x86_jle";
            case 240L: return "x86_jmp";
            case 241L: return "x86_jmpe";
            case 242L: return "x86_jne";
            case 243L: return "x86_jno";
            case 244L: return "x86_jns";
            case 245L: return "x86_jo";
            case 246L: return "x86_jpe";
            case 247L: return "x86_jpo";
            case 248L: return "x86_jrcxz";
            case 249L: return "x86_js";
            case 250L: return "x86_lahf";
            case 251L: return "x86_lar";
            case 252L: return "x86_lddqu";
            case 253L: return "x86_ldmxcsr";
            case 254L: return "x86_lds";
            case 255L: return "x86_lea";
            case 256L: return "x86_leave";
            case 257L: return "x86_les";
            case 258L: return "x86_lfence";
            case 259L: return "x86_lfs";
            case 260L: return "x86_lgdt";
            case 261L: return "x86_lgs";
            case 262L: return "x86_lidt";
            case 263L: return "x86_lldt";
            case 264L: return "x86_lmsw";
            case 265L: return "x86_lock";
            case 266L: return "x86_lodsb";
            case 267L: return "x86_lodsd";
            case 268L: return "x86_lodsq";
            case 269L: return "x86_lodsw";
            case 270L: return "x86_loop";
            case 271L: return "x86_loopnz";
            case 272L: return "x86_loopz";
            case 273L: return "x86_lsl";
            case 274L: return "x86_lss";
            case 275L: return "x86_ltr";
            case 276L: return "x86_lzcnt";
            case 277L: return "x86_maskmovq";
            case 278L: return "x86_maxpd";
            case 279L: return "x86_maxps";
            case 280L: return "x86_maxsd";
            case 281L: return "x86_maxss";
            case 282L: return "x86_mfence";
            case 283L: return "x86_minpd";
            case 284L: return "x86_minps";
            case 285L: return "x86_minsd";
            case 286L: return "x86_minss";
            case 287L: return "x86_monitor";
            case 288L: return "x86_mov";
            case 289L: return "x86_movapd";
            case 290L: return "x86_movaps";
            case 291L: return "x86_movbe";
            case 292L: return "x86_movd";
            case 293L: return "x86_movddup";
            case 294L: return "x86_movdq2q";
            case 295L: return "x86_movdqa";
            case 296L: return "x86_movdqu";
            case 297L: return "x86_movhlps";
            case 298L: return "x86_movhpd";
            case 299L: return "x86_movhps";
            case 300L: return "x86_movlhps";
            case 301L: return "x86_movlpd";
            case 302L: return "x86_movlps";
            case 303L: return "x86_movmskpd";
            case 304L: return "x86_movmskps";
            case 305L: return "x86_movntdq";
            case 306L: return "x86_movntdqa";
            case 307L: return "x86_movnti";
            case 308L: return "x86_movntpd";
            case 309L: return "x86_movntps";
            case 310L: return "x86_movntq";
            case 311L: return "x86_movntsd";
            case 312L: return "x86_movntss";
            case 313L: return "x86_movq";
            case 314L: return "x86_movq2dq";
            case 315L: return "x86_movsb";
            case 316L: return "x86_movsd";
            case 317L: return "x86_movsd_sse";
            case 318L: return "x86_movshdup";
            case 319L: return "x86_movsldup";
            case 320L: return "x86_movsq";
            case 321L: return "x86_movss";
            case 322L: return "x86_movsw";
            case 323L: return "x86_movsx";
            case 324L: return "x86_movsxd";
            case 325L: return "x86_movupd";
            case 326L: return "x86_movups";
            case 327L: return "x86_movzx";
            case 328L: return "x86_mpsadbw";
            case 329L: return "x86_mul";
            case 330L: return "x86_mulpd";
            case 331L: return "x86_mulps";
            case 332L: return "x86_mulsd";
            case 333L: return "x86_mulss";
            case 334L: return "x86_mwait";
            case 335L: return "x86_neg";
            case 336L: return "x86_nop";
            case 337L: return "x86_not";
            case 338L: return "x86_or";
            case 339L: return "x86_orpd";
            case 340L: return "x86_orps";
            case 341L: return "x86_out";
            case 342L: return "x86_outs";
            case 343L: return "x86_outsb";
            case 344L: return "x86_outsd";
            case 345L: return "x86_outsw";
            case 346L: return "x86_pabsb";
            case 347L: return "x86_pabsd";
            case 348L: return "x86_pabsw";
            case 349L: return "x86_packssdw";
            case 350L: return "x86_packsswb";
            case 351L: return "x86_packusdw";
            case 352L: return "x86_packuswb";
            case 353L: return "x86_paddb";
            case 354L: return "x86_paddd";
            case 355L: return "x86_paddq";
            case 356L: return "x86_paddsb";
            case 357L: return "x86_paddsw";
            case 358L: return "x86_paddusb";
            case 359L: return "x86_paddusw";
            case 360L: return "x86_paddw";
            case 361L: return "x86_palignr";
            case 362L: return "x86_pand";
            case 363L: return "x86_pandn";
            case 364L: return "x86_pause";
            case 365L: return "x86_pavgb";
            case 366L: return "x86_pavgusb";
            case 367L: return "x86_pavgw";
            case 368L: return "x86_pblendvb";
            case 369L: return "x86_pblendw";
            case 370L: return "x86_pcmpeqb";
            case 371L: return "x86_pcmpeqd";
            case 372L: return "x86_pcmpeqq";
            case 373L: return "x86_pcmpeqw";
            case 374L: return "x86_pcmpestri";
            case 375L: return "x86_pcmpestrm";
            case 376L: return "x86_pcmpgtb";
            case 377L: return "x86_pcmpgtd";
            case 378L: return "x86_pcmpgtq";
            case 379L: return "x86_pcmpgtw";
            case 380L: return "x86_pcmpistri";
            case 381L: return "x86_pcmpistrm";
            case 382L: return "x86_pextrb";
            case 383L: return "x86_pextrd";
            case 384L: return "x86_pextrq";
            case 385L: return "x86_pextrw";
            case 386L: return "x86_pf2id";
            case 387L: return "x86_pf2iw";
            case 388L: return "x86_pfacc";
            case 389L: return "x86_pfadd";
            case 390L: return "x86_pfcmpeq";
            case 391L: return "x86_pfcmpge";
            case 392L: return "x86_pfcmpgt";
            case 393L: return "x86_pfmax";
            case 394L: return "x86_pfmin";
            case 395L: return "x86_pfmul";
            case 396L: return "x86_pfnacc";
            case 397L: return "x86_pfpnacc";
            case 398L: return "x86_pfrcp";
            case 399L: return "x86_pfrcpit1";
            case 400L: return "x86_pfrcpit2";
            case 401L: return "x86_pfrsqit1";
            case 402L: return "x86_pfrsqrt";
            case 403L: return "x86_pfsub";
            case 404L: return "x86_pfsubr";
            case 405L: return "x86_phaddd";
            case 406L: return "x86_phaddsw";
            case 407L: return "x86_phaddw";
            case 408L: return "x86_phminposuw";
            case 409L: return "x86_phsubd";
            case 410L: return "x86_phsubsw";
            case 411L: return "x86_phsubw";
            case 412L: return "x86_pi2fd";
            case 413L: return "x86_pi2fw";
            case 414L: return "x86_pinsrb";
            case 415L: return "x86_pinsrd";
            case 416L: return "x86_pinsrq";
            case 417L: return "x86_pinsrw";
            case 418L: return "x86_pmaddubsw";
            case 419L: return "x86_pmaddwd";
            case 420L: return "x86_pmaxsb";
            case 421L: return "x86_pmaxsd";
            case 422L: return "x86_pmaxsw";
            case 423L: return "x86_pmaxub";
            case 424L: return "x86_pmaxud";
            case 425L: return "x86_pmaxuw";
            case 426L: return "x86_pminsb";
            case 427L: return "x86_pminsd";
            case 428L: return "x86_pminsw";
            case 429L: return "x86_pminub";
            case 430L: return "x86_pminud";
            case 431L: return "x86_pminuw";
            case 432L: return "x86_pmovmskb";
            case 433L: return "x86_pmovsxbd";
            case 434L: return "x86_pmovsxbq";
            case 435L: return "x86_pmovsxbw";
            case 436L: return "x86_pmovsxdq";
            case 437L: return "x86_pmovsxwd";
            case 438L: return "x86_pmovsxwq";
            case 439L: return "x86_pmovzxbd";
            case 440L: return "x86_pmovzxbq";
            case 441L: return "x86_pmovzxbw";
            case 442L: return "x86_pmovzxdq";
            case 443L: return "x86_pmovzxwd";
            case 444L: return "x86_pmovzxwq";
            case 445L: return "x86_pmuldq";
            case 446L: return "x86_pmulhrsw";
            case 447L: return "x86_pmulhrw";
            case 448L: return "x86_pmulhuw";
            case 449L: return "x86_pmulhw";
            case 450L: return "x86_pmulld";
            case 451L: return "x86_pmullw";
            case 452L: return "x86_pmuludq";
            case 453L: return "x86_pop";
            case 454L: return "x86_popa";
            case 455L: return "x86_popad";
            case 456L: return "x86_popcnt";
            case 457L: return "x86_popf";
            case 458L: return "x86_popfd";
            case 459L: return "x86_popfq";
            case 460L: return "x86_por";
            case 461L: return "x86_prefetch";
            case 462L: return "x86_prefetchnta";
            case 463L: return "x86_prefetcht0";
            case 464L: return "x86_prefetcht1";
            case 465L: return "x86_prefetcht2";
            case 466L: return "x86_prefetchw";
            case 467L: return "x86_psadbw";
            case 468L: return "x86_pshufb";
            case 469L: return "x86_pshufd";
            case 470L: return "x86_pshufhw";
            case 471L: return "x86_pshuflw";
            case 472L: return "x86_pshufw";
            case 473L: return "x86_psignb";
            case 474L: return "x86_psignd";
            case 475L: return "x86_psignw";
            case 476L: return "x86_pslld";
            case 477L: return "x86_pslldq";
            case 478L: return "x86_psllq";
            case 479L: return "x86_psllw";
            case 480L: return "x86_psrad";
            case 481L: return "x86_psraq";
            case 482L: return "x86_psraw";
            case 483L: return "x86_psrld";
            case 484L: return "x86_psrldq";
            case 485L: return "x86_psrlq";
            case 486L: return "x86_psrlw";
            case 487L: return "x86_psubb";
            case 488L: return "x86_psubd";
            case 489L: return "x86_psubq";
            case 490L: return "x86_psubsb";
            case 491L: return "x86_psubsw";
            case 492L: return "x86_psubusb";
            case 493L: return "x86_psubusw";
            case 494L: return "x86_psubw";
            case 495L: return "x86_pswapd";
            case 496L: return "x86_ptest";
            case 497L: return "x86_punpckhbw";
            case 498L: return "x86_punpckhdq";
            case 499L: return "x86_punpckhqdq";
            case 500L: return "x86_punpckhwd";
            case 501L: return "x86_punpcklbw";
            case 502L: return "x86_punpckldq";
            case 503L: return "x86_punpcklqdq";
            case 504L: return "x86_punpcklwd";
            case 505L: return "x86_push";
            case 506L: return "x86_pusha";
            case 507L: return "x86_pushad";
            case 508L: return "x86_pushf";
            case 509L: return "x86_pushfd";
            case 510L: return "x86_pushfq";
            case 511L: return "x86_pxor";
            case 512L: return "x86_rcl";
            case 513L: return "x86_rcpps";
            case 514L: return "x86_rcpss";
            case 515L: return "x86_rcr";
            case 516L: return "x86_rdmsr";
            case 517L: return "x86_rdpmc";
            case 518L: return "x86_rdtsc";
            case 519L: return "x86_rdtscp";
            case 520L: return "x86_rep_insb";
            case 521L: return "x86_rep_insd";
            case 522L: return "x86_rep_insw";
            case 523L: return "x86_rep_lodsb";
            case 524L: return "x86_rep_lodsd";
            case 525L: return "x86_rep_lodsq";
            case 526L: return "x86_rep_lodsw";
            case 527L: return "x86_rep_movsb";
            case 528L: return "x86_rep_movsd";
            case 529L: return "x86_rep_movsq";
            case 530L: return "x86_rep_movsw";
            case 531L: return "x86_rep_outsb";
            case 532L: return "x86_rep_outsd";
            case 533L: return "x86_rep_outsw";
            case 534L: return "x86_rep_stosb";
            case 535L: return "x86_rep_stosd";
            case 536L: return "x86_rep_stosq";
            case 537L: return "x86_rep_stosw";
            case 538L: return "x86_repe_cmpsb";
            case 539L: return "x86_repe_cmpsd";
            case 540L: return "x86_repe_cmpsq";
            case 541L: return "x86_repe_cmpsw";
            case 542L: return "x86_repe_scasb";
            case 543L: return "x86_repe_scasd";
            case 544L: return "x86_repe_scasq";
            case 545L: return "x86_repe_scasw";
            case 546L: return "x86_repne_cmpsb";
            case 547L: return "x86_repne_cmpsd";
            case 548L: return "x86_repne_cmpsq";
            case 549L: return "x86_repne_cmpsw";
            case 550L: return "x86_repne_scasb";
            case 551L: return "x86_repne_scasd";
            case 552L: return "x86_repne_scasq";
            case 553L: return "x86_repne_scasw";
            case 554L: return "x86_ret";
            case 555L: return "x86_retf";
            case 556L: return "x86_rol";
            case 557L: return "x86_ror";
            case 558L: return "x86_roundpd";
            case 559L: return "x86_roundps";
            case 560L: return "x86_roundsd";
            case 561L: return "x86_roundss";
            case 562L: return "x86_rsm";
            case 563L: return "x86_rsqrtps";
            case 564L: return "x86_rsqrtss";
            case 565L: return "x86_sahf";
            case 566L: return "x86_salc";
            case 567L: return "x86_sar";
            case 568L: return "x86_sbb";
            case 569L: return "x86_scasb";
            case 570L: return "x86_scasd";
            case 571L: return "x86_scasq";
            case 572L: return "x86_scasw";
            case 573L: return "x86_seta";
            case 574L: return "x86_setae";
            case 575L: return "x86_setb";
            case 576L: return "x86_setbe";
            case 577L: return "x86_sete";
            case 578L: return "x86_setg";
            case 579L: return "x86_setge";
            case 580L: return "x86_setl";
            case 581L: return "x86_setle";
            case 582L: return "x86_setne";
            case 583L: return "x86_setno";
            case 584L: return "x86_setns";
            case 585L: return "x86_seto";
            case 586L: return "x86_setpe";
            case 587L: return "x86_setpo";
            case 588L: return "x86_sets";
            case 589L: return "x86_sfence";
            case 590L: return "x86_sgdt";
            case 591L: return "x86_shl";
            case 592L: return "x86_shld";
            case 593L: return "x86_shr";
            case 594L: return "x86_shrd";
            case 595L: return "x86_shufpd";
            case 596L: return "x86_shufps";
            case 597L: return "x86_sidt";
            case 598L: return "x86_skinit";
            case 599L: return "x86_sldt";
            case 600L: return "x86_smsw";
            case 601L: return "x86_sqrtpd";
            case 602L: return "x86_sqrtps";
            case 603L: return "x86_sqrtsd";
            case 604L: return "x86_sqrtss";
            case 605L: return "x86_stc";
            case 606L: return "x86_std";
            case 607L: return "x86_stgi";
            case 608L: return "x86_sti";
            case 609L: return "x86_stmxcsr";
            case 610L: return "x86_stos";
            case 611L: return "x86_stosb";
            case 612L: return "x86_stosd";
            case 613L: return "x86_stosq";
            case 614L: return "x86_stosw";
            case 615L: return "x86_str";
            case 616L: return "x86_sub";
            case 617L: return "x86_subpd";
            case 618L: return "x86_subps";
            case 619L: return "x86_subsd";
            case 620L: return "x86_subss";
            case 621L: return "x86_swapgs";
            case 622L: return "x86_syscall";
            case 623L: return "x86_sysenter";
            case 624L: return "x86_sysexit";
            case 625L: return "x86_sysret";
            case 626L: return "x86_test";
            case 627L: return "x86_ucomisd";
            case 628L: return "x86_ucomiss";
            case 629L: return "x86_ud2";
            case 630L: return "x86_unpckhpd";
            case 631L: return "x86_unpckhps";
            case 632L: return "x86_unpcklpd";
            case 633L: return "x86_unpcklps";
            case 634L: return "x86_verr";
            case 635L: return "x86_verw";
            case 636L: return "x86_vmcall";
            case 637L: return "x86_vmclear";
            case 638L: return "x86_vmlaunch";
            case 639L: return "x86_vmload";
            case 640L: return "x86_vmmcall";
            case 641L: return "x86_vmoff";
            case 642L: return "x86_vmptrld";
            case 643L: return "x86_vmptrst";
            case 644L: return "x86_vmread";
            case 645L: return "x86_vmresume";
            case 646L: return "x86_vmrun";
            case 647L: return "x86_vmsave";
            case 648L: return "x86_vmwrite";
            case 649L: return "x86_vmxoff";
            case 650L: return "x86_vmxon";
            case 651L: return "x86_wait";
            case 652L: return "x86_wbinvd";
            case 653L: return "x86_wrmsr";
            case 654L: return "x86_xadd";
            case 655L: return "x86_xchg";
            case 656L: return "x86_xgetbv";
            case 657L: return "x86_xlatb";
            case 658L: return "x86_xor";
            case 659L: return "x86_xorpd";
            case 660L: return "x86_xorps";
            case 661L: return "x86_xrstor";
            case 662L: return "x86_xsave";
            case 663L: return "x86_xsetbv";
            case 664L: return "x86_last_instruction";
            default: return "";
        }
    }

    std::string X86InstructionKind(int64_t i, const std::string &strip) {
        std::string s = X86InstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L
        };
        static const std::vector<int64_t> retval(values, values + 665);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionKind() {
        return stringify::Rose::BinaryAnalysis::X86InstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 146
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* OperandDefn(int64_t i) {
        switch (i) {
            case 0L: return "od_none";
            case 1L: return "od_AL";
            case 2L: return "od_AX";
            case 3L: return "od_EAX";
            case 4L: return "od_RAX";
            case 5L: return "od_DX";
            case 6L: return "od_CS";
            case 7L: return "od_DS";
            case 8L: return "od_ES";
            case 9L: return "od_FS";
            case 10L: return "od_GS";
            case 11L: return "od_SS";
            case 12L: return "od_rel8";
            case 13L: return "od_rel16";
            case 14L: return "od_rel32";
            case 15L: return "od_rel64";
            case 16L: return "od_ptr16_16";
            case 17L: return "od_ptr16_32";
            case 18L: return "od_ptr16_64";
            case 19L: return "od_r8";
            case 20L: return "od_r16";
            case 21L: return "od_r32";
            case 22L: return "od_r64";
            case 23L: return "od_imm8";
            case 24L: return "od_imm16";
            case 25L: return "od_imm32";
            case 26L: return "od_imm64";
            case 27L: return "od_r_m8";
            case 28L: return "od_r_m16";
            case 29L: return "od_r_m32";
            case 30L: return "od_r_m64";
            case 31L: return "od_m";
            case 32L: return "od_m8";
            case 33L: return "od_m16";
            case 34L: return "od_m32";
            case 35L: return "od_m64";
            case 36L: return "od_m128";
            case 37L: return "od_m16_16";
            case 38L: return "od_m16_32";
            case 39L: return "od_m16_64";
            case 40L: return "od_m16a16";
            case 41L: return "od_m16a32";
            case 42L: return "od_m32a32";
            case 43L: return "od_m16a64";
            case 44L: return "od_moffs8";
            case 45L: return "od_moffs16";
            case 46L: return "od_moffs32";
            case 47L: return "od_moffs64";
            case 48L: return "od_sreg";
            case 49L: return "od_m32fp";
            case 50L: return "od_m64fp";
            case 51L: return "od_m80fp";
            case 52L: return "od_st0";
            case 53L: return "od_st1";
            case 54L: return "od_st2";
            case 55L: return "od_st3";
            case 56L: return "od_st4";
            case 57L: return "od_st5";
            case 58L: return "od_st6";
            case 59L: return "od_st7";
            case 60L: return "od_sti";
            case 61L: return "od_mm";
            case 62L: return "od_mm_m32";
            case 63L: return "od_mm_m64";
            case 64L: return "od_xmm";
            case 65L: return "od_xmm_m16";
            case 66L: return "od_xmm_m32";
            case 67L: return "od_xmm_m64";
            case 68L: return "od_xmm_m128";
            case 69L: return "od_XMM0";
            case 70L: return "od_0";
            case 71L: return "od_1";
            case 72L: return "od_m80";
            case 73L: return "od_dec";
            case 74L: return "od_m80bcd";
            case 75L: return "od_m2byte";
            case 76L: return "od_m14_28byte";
            case 77L: return "od_m94_108byte";
            case 78L: return "od_m512byte";
            case 79L: return "od_r16_m16";
            case 80L: return "od_r32_m8";
            case 81L: return "od_r32_m16";
            case 82L: return "od_r64_m16";
            case 83L: return "od_CR0";
            case 84L: return "od_CR7";
            case 85L: return "od_CR8";
            case 86L: return "od_CR0CR7";
            case 87L: return "od_DR0DR7";
            case 88L: return "od_reg";
            case 89L: return "od_CL";
            default: return "";
        }
    }

    std::string OperandDefn(int64_t i, const std::string &strip) {
        std::string s = OperandDefn(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OperandDefn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L
        };
        static const std::vector<int64_t> retval(values, values + 90);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86OperandDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::OperandDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::OperandDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86OperandDefn() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::OperandDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/frontend/Disassemblers/AssemblerX86.h line 387
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AssemblerX86 {
    const char* MemoryReferencePattern(int64_t i) {
        switch (i) {
            case 0L: return "mrp_unknown";
            case 1L: return "mrp_disp";
            case 2L: return "mrp_index";
            case 3L: return "mrp_index_disp";
            case 4L: return "mrp_base";
            case 5L: return "mrp_base_disp";
            case 6L: return "mrp_base_index";
            case 7L: return "mrp_base_index_disp";
            default: return "";
        }
    }

    std::string MemoryReferencePattern(int64_t i, const std::string &strip) {
        std::string s = MemoryReferencePattern(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryReferencePattern() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAssemblerX86MemoryReferencePattern() {
        return stringify::Rose::BinaryAnalysis::AssemblerX86::MemoryReferencePattern();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h line 36
namespace stringify { namespace SgAsmLESectionTableEntry {
    const char* LESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_TYPE_NORMAL";
            case 1L: return "SF_READABLE";
            case 2L: return "SF_WRITABLE";
            case 4L: return "SF_EXECUTABLE";
            case 8L: return "SF_RESOURCE";
            case 16L: return "SF_DISCARDABLE";
            case 32L: return "SF_SHARED";
            case 64L: return "SF_PRELOAD_PAGES";
            case 128L: return "SF_INVALID_PAGES";
            case 256L: return "SF_TYPE_ZERO";
            case 512L: return "SF_TYPE_RESIDENT";
            case 768L: return "SF_TYPE_RESCONT";
            case 1024L: return "SF_RES_LONG_LOCK";
            case 4096L: return "SF_1616_ALIAS";
            case 8192L: return "SF_BIG_BIT";
            case 16384L: return "SF_CODE_CONFORM";
            case 32768L: return "SF_IO_PRIV";
            case 4294903808L: return "SF_RESERVED";
            default: return "";
        }
    }

    std::string LESectionFlags(int64_t i, const std::string &strip) {
        std::string s = LESectionFlags(i);
        if (s.empty())
            s = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            16384L,
            32768L,
            4294903808L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLESectionTableEntryLESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLESectionTableEntry::LESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLESectionTableEntry::LESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLESectionTableEntryLESectionFlags() {
        return stringify::SgAsmLESectionTableEntry::LESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h line 114
namespace stringify { namespace SgAsmPEFileHeader {
    const char* HeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_PROGRAM";
            case 2L: return "HF_EXECUTABLE";
            case 512L: return "HF_FIXED";
            case 8192L: return "HF_LIBRARY";
            case 56829L: return "HF_RESERVED_MASK";
            default: return "";
        }
    }

    std::string HeaderFlags(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags() {
        static const int64_t values[] = {
            0L,
            2L,
            512L,
            8192L,
            56829L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::HeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::HeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderHeaderFlags() {
        return stringify::SgAsmPEFileHeader::HeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h line 123
namespace stringify { namespace SgAsmPEFileHeader {
    const char* Subsystem(int64_t i) {
        switch (i) {
            case 0L: return "HF_SPEC_UNKNOWN";
            case 1L: return "HF_NATIVE";
            case 2L: return "HF_WINGUI";
            case 3L: return "HF_WINCHAR";
            case 5L: return "HF_OS2CHAR";
            case 7L: return "HF_POSIX";
            default: return "";
        }
    }

    std::string Subsystem(int64_t i, const std::string &strip) {
        std::string s = Subsystem(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Subsystem() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderSubsystem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::Subsystem(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::Subsystem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::Subsystem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderSubsystem() {
        return stringify::SgAsmPEFileHeader::Subsystem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h line 133
namespace stringify { namespace SgAsmPEFileHeader {
    const char* DLLFlags(int64_t i) {
        switch (i) {
            case 1L: return "DLL_PROC_INIT";
            case 2L: return "DLL_PROC_TERM";
            case 4L: return "DLL_THRD_INIT";
            case 8L: return "DLL_THRD_TERM";
            case 65520L: return "DLL_RESERVED_MASK";
            default: return "";
        }
    }

    std::string DLLFlags(int64_t i, const std::string &strip) {
        std::string s = DLLFlags(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DLLFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            65520L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderDLLFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::DLLFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::DLLFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderDLLFlags() {
        return stringify::SgAsmPEFileHeader::DLLFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h line 142
namespace stringify { namespace SgAsmPEFileHeader {
    const char* PairPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PAIR_EXPORTS";
            case 1L: return "PAIR_IMPORTS";
            case 2L: return "PAIR_RESOURCES";
            case 3L: return "PAIR_EXCEPTIONS";
            case 4L: return "PAIR_CERTIFICATES";
            case 5L: return "PAIR_BASERELOCS";
            case 6L: return "PAIR_DEBUG";
            case 7L: return "PAIR_ARCHITECTURE";
            case 8L: return "PAIR_GLOBALPTR";
            case 9L: return "PAIR_TLS";
            case 10L: return "PAIR_LOADCONFIG";
            case 11L: return "PAIR_BOUNDIMPORT";
            case 12L: return "PAIR_IAT";
            case 13L: return "PAIR_DELAYIMPORT";
            case 14L: return "PAIR_CLRRUNTIME";
            case 15L: return "PAIR_RESERVED15";
            default: return "";
        }
    }

    std::string PairPurpose(int64_t i, const std::string &strip) {
        std::string s = PairPurpose(i);
        if (s.empty())
            s = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PairPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPEFileHeaderPairPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPEFileHeader::PairPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmPEFileHeader::PairPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPEFileHeaderPairPurpose() {
        return stringify::SgAsmPEFileHeader::PairPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h line 20
namespace stringify { namespace SgAsmGenericFile {
    const char* AddressSpace(int64_t i) {
        switch (i) {
            case 1L: return "ADDRSP_MEMORY";
            case 2L: return "ADDRSP_FILE";
            case 3L: return "ADDRSP_ALL";
            default: return "";
        }
    }

    std::string AddressSpace(int64_t i, const std::string &strip) {
        std::string s = AddressSpace(i);
        if (s.empty())
            s = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AddressSpace() {
        static const int64_t values[] = {
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileAddressSpace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::AddressSpace(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::AddressSpace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::AddressSpace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileAddressSpace() {
        return stringify::SgAsmGenericFile::AddressSpace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h line 27
namespace stringify { namespace SgAsmGenericFile {
    const char* Elasticity(int64_t i) {
        switch (i) {
            case 0L: return "ELASTIC_NONE";
            case 1L: return "ELASTIC_UNREF";
            case 2L: return "ELASTIC_HOLE";
            default: return "";
        }
    }

    std::string Elasticity(int64_t i, const std::string &strip) {
        std::string s = Elasticity(i);
        if (s.empty())
            s = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Elasticity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericFileElasticity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericFile::Elasticity(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericFile::Elasticity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericFile::Elasticity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericFileElasticity() {
        return stringify::SgAsmGenericFile::Elasticity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h line 23
namespace stringify { namespace SgAsmGenericSection {
    const char* SectionPurpose(int64_t i) {
        switch (i) {
            case 0L: return "SP_UNSPECIFIED";
            case 1L: return "SP_PROGRAM";
            case 2L: return "SP_HEADER";
            case 3L: return "SP_SYMTAB";
            case 4L: return "SP_OTHER";
            default: return "";
        }
    }

    std::string SectionPurpose(int64_t i, const std::string &strip) {
        std::string s = SectionPurpose(i);
        if (s.empty())
            s = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSectionSectionPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSection::SectionPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSection::SectionPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSection::SectionPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSectionSectionPurpose() {
        return stringify::SgAsmGenericSection::SectionPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h line 11
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentType(int64_t i) {
        switch (i) {
            case 0L: return "PT_NULL";
            case 1L: return "PT_LOAD";
            case 2L: return "PT_DYNAMIC";
            case 3L: return "PT_INTERP";
            case 4L: return "PT_NOTE";
            case 5L: return "PT_SHLIB";
            case 6L: return "PT_PHDR";
            case 7L: return "PT_TLS";
            case 1610612736L: return "PT_LOOS";
            case 1685382480L: return "PT_GNU_EH_FRAME";
            case 1685382481L: return "PT_GNU_STACK";
            case 1685382482L: return "PT_GNU_RELRO";
            case 1694766464L: return "PT_PAX_FLAGS";
            case 1879048186L: return "PT_SUNWBSS";
            case 1879048187L: return "PT_SUNWSTACK";
            case 1879048191L: return "PT_HIOS";
            case 1879048192L: return "PT_LOPROC";
            case 2147483647L: return "PT_HIPROC";
            default: return "";
        }
    }

    std::string SegmentType(int64_t i, const std::string &strip) {
        std::string s = SegmentType(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            1610612736L,
            1685382480L,
            1685382481L,
            1685382482L,
            1694766464L,
            1879048186L,
            1879048187L,
            1879048191L,
            1879048192L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentType() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h line 39
namespace stringify { namespace SgAsmElfSegmentTableEntry {
    const char* SegmentFlags(int64_t i) {
        switch (i) {
            case 0L: return "PF_NONE";
            case 1L: return "PF_XPERM";
            case 2L: return "PF_WPERM";
            case 4L: return "PF_RPERM";
            case 1048568L: return "PF_RESERVED";
            case 267386880L: return "PF_OS_MASK";
            case 4026531840L: return "PF_PROC_MASK";
            default: return "";
        }
    }

    std::string SegmentFlags(int64_t i, const std::string &strip) {
        std::string s = SegmentFlags(i);
        if (s.empty())
            s = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SegmentFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            1048568L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSegmentTableEntrySegmentFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSegmentTableEntry::SegmentFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSegmentTableEntry::SegmentFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSegmentTableEntrySegmentFlags() {
        return stringify::SgAsmElfSegmentTableEntry::SegmentFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h line 11
namespace stringify { namespace SgAsmElfDynamicEntry {
    const char* EntryType(int64_t i) {
        switch (i) {
            case 0L: return "DT_NULL";
            case 1L: return "DT_NEEDED";
            case 2L: return "DT_PLTRELSZ";
            case 3L: return "DT_PLTGOT";
            case 4L: return "DT_HASH";
            case 5L: return "DT_STRTAB";
            case 6L: return "DT_SYMTAB";
            case 7L: return "DT_RELA";
            case 8L: return "DT_RELASZ";
            case 9L: return "DT_RELAENT";
            case 10L: return "DT_STRSZ";
            case 11L: return "DT_SYMENT";
            case 12L: return "DT_INIT";
            case 13L: return "DT_FINI";
            case 14L: return "DT_SONAME";
            case 15L: return "DT_RPATH";
            case 16L: return "DT_SYMBOLIC";
            case 17L: return "DT_REL";
            case 18L: return "DT_RELSZ";
            case 19L: return "DT_RELENT";
            case 20L: return "DT_PLTREL";
            case 21L: return "DT_DEBUG";
            case 22L: return "DT_TEXTREL";
            case 23L: return "DT_JMPREL";
            case 24L: return "DT_BIND_NOW";
            case 25L: return "DT_INIT_ARRAY";
            case 26L: return "DT_FINI_ARRAY";
            case 27L: return "DT_INIT_ARRAYSZ";
            case 28L: return "DT_FINI_ARRAYSZ";
            case 29L: return "DT_RUNPATH";
            case 30L: return "DT_FLAGS";
            case 32L: return "DT_PREINIT_ARRAY";
            case 33L: return "DT_PREINIT_ARRAYSZ";
            case 34L: return "DT_NUM";
            case 1879047669L: return "DT_GNU_PRELINKED";
            case 1879047670L: return "DT_GNU_CONFLICTSZ";
            case 1879047671L: return "DT_GNU_LIBLISTSZ";
            case 1879047672L: return "DT_CHECKSUM";
            case 1879047673L: return "DT_PLTPADSZ";
            case 1879047674L: return "DT_MOVEENT";
            case 1879047675L: return "DT_MOVESZ";
            case 1879047676L: return "DT_FEATURE_1";
            case 1879047677L: return "DT_POSFLAG_1";
            case 1879047678L: return "DT_SYMINSZ";
            case 1879047679L: return "DT_SYMINENT";
            case 1879047925L: return "DT_GNU_HASH";
            case 1879047926L: return "DT_TLSDESC_PLT";
            case 1879047927L: return "DT_TLSDESC_GOT";
            case 1879047928L: return "DT_GNU_CONFLICT";
            case 1879047929L: return "DT_GNU_LIBLIST";
            case 1879047930L: return "DT_CONFIG";
            case 1879047931L: return "DT_DEPAUDIT";
            case 1879047932L: return "DT_AUDIT";
            case 1879047933L: return "DT_PLTPAD";
            case 1879047934L: return "DT_MOVETAB";
            case 1879047935L: return "DT_SYMINFO";
            case 1879048176L: return "DT_VERSYM";
            case 1879048185L: return "DT_RELACOUNT";
            case 1879048186L: return "DT_RELCOUNT";
            case 1879048187L: return "DT_FLAGS_1";
            case 1879048188L: return "DT_VERDEF";
            case 1879048189L: return "DT_VERDEFNUM";
            case 1879048190L: return "DT_VERNEED";
            case 1879048191L: return "DT_VERNEEDNUM";
            case 2147483645L: return "DT_AUXILIARY";
            case 2147483647L: return "DT_FILTER";
            default: return "";
        }
    }

    std::string EntryType(int64_t i, const std::string &strip) {
        std::string s = EntryType(i);
        if (s.empty())
            s = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EntryType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            32L,
            33L,
            34L,
            1879047669L,
            1879047670L,
            1879047671L,
            1879047672L,
            1879047673L,
            1879047674L,
            1879047675L,
            1879047676L,
            1879047677L,
            1879047678L,
            1879047679L,
            1879047925L,
            1879047926L,
            1879047927L,
            1879047928L,
            1879047929L,
            1879047930L,
            1879047931L,
            1879047932L,
            1879047933L,
            1879047934L,
            1879047935L,
            1879048176L,
            1879048185L,
            1879048186L,
            1879048187L,
            1879048188L,
            1879048189L,
            1879048190L,
            1879048191L,
            2147483645L,
            2147483647L
        };
        static const std::vector<int64_t> retval(values, values + 66);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfDynamicEntryEntryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfDynamicEntry::EntryType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfDynamicEntry::EntryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfDynamicEntryEntryType() {
        return stringify::SgAsmElfDynamicEntry::EntryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h line 13
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymBinding(int64_t i) {
        switch (i) {
            case 0L: return "STB_LOCAL";
            case 1L: return "STB_GLOBAL";
            case 2L: return "STB_WEAK";
            default: return "";
        }
    }

    std::string ElfSymBinding(int64_t i, const std::string &strip) {
        std::string s = ElfSymBinding(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymBinding() {
        return stringify::SgAsmElfSymbol::ElfSymBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h line 19
namespace stringify { namespace SgAsmElfSymbol {
    const char* ElfSymType(int64_t i) {
        switch (i) {
            case 0L: return "STT_NOTYPE";
            case 1L: return "STT_OBJECT";
            case 2L: return "STT_FUNC";
            case 3L: return "STT_SECTION";
            case 4L: return "STT_FILE";
            case 5L: return "STT_COMMON";
            case 6L: return "STT_TLS";
            case 10L: return "STT_IFUNC";
            default: return "";
        }
    }

    std::string ElfSymType(int64_t i, const std::string &strip) {
        std::string s = ElfSymType(i);
        if (s.empty())
            s = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ElfSymType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSymbolElfSymType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSymbol::ElfSymType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSymbol::ElfSymType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSymbol::ElfSymType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSymbolElfSymType() {
        return stringify::SgAsmElfSymbol::ElfSymType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h line 27
namespace stringify { namespace SgAsmNESectionTableEntry {
    const char* NESectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SF_CODE";
            case 1L: return "SF_DATA";
            case 2L: return "SF_ALLOC";
            case 4L: return "SF_LOAD";
            case 7L: return "SF_TYPE_MASK";
            case 16L: return "SF_MOVABLE";
            case 32L: return "SF_PURE";
            case 64L: return "SF_PRELOAD";
            case 128L: return "SF_NOT_WRITABLE";
            case 256L: return "SF_RELOCINFO";
            case 3592L: return "SF_RESERVED";
            case 4096L: return "SF_DISCARDABLE";
            case 61440L: return "SF_DISCARD";
            default: return "";
        }
    }

    std::string NESectionFlags(int64_t i, const std::string &strip) {
        std::string s = NESectionFlags(i);
        if (s.empty())
            s = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NESectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            7L,
            16L,
            32L,
            64L,
            128L,
            256L,
            3592L,
            4096L,
            61440L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNESectionTableEntryNESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNESectionTableEntry::NESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNESectionTableEntry::NESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNESectionTableEntryNESectionFlags() {
        return stringify::SgAsmNESectionTableEntry::NESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h line 61
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecFamily(int64_t i) {
        switch (i) {
            case 0L: return "FAMILY_UNSPECIFIED";
            case 1L: return "FAMILY_DOS";
            case 2L: return "FAMILY_ELF";
            case 3L: return "FAMILY_JVM";
            case 4L: return "FAMILY_LE";
            case 5L: return "FAMILY_LX";
            case 6L: return "FAMILY_NE";
            case 7L: return "FAMILY_PE";
            default: return "";
        }
    }

    std::string ExecFamily(int64_t i, const std::string &strip) {
        std::string s = ExecFamily(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecFamily() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecFamily(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecFamily() {
        return stringify::SgAsmExecutableFileFormat::ExecFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h line 73
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecABI(int64_t i) {
        switch (i) {
            case 0L: return "ABI_UNSPECIFIED";
            case 1L: return "ABI_OTHER";
            case 2L: return "ABI_86OPEN";
            case 3L: return "ABI_AIX";
            case 4L: return "ABI_ARM";
            case 5L: return "ABI_FREEBSD";
            case 6L: return "ABI_HPUX";
            case 7L: return "ABI_IRIX";
            case 8L: return "ABI_HURD";
            case 9L: return "ABI_JVM";
            case 10L: return "ABI_LINUX";
            case 11L: return "ABI_MODESTO";
            case 12L: return "ABI_MONTEREY";
            case 13L: return "ABI_MSDOS";
            case 14L: return "ABI_NT";
            case 15L: return "ABI_NETBSD";
            case 16L: return "ABI_OS2";
            case 17L: return "ABI_SOLARIS";
            case 18L: return "ABI_SYSV";
            case 19L: return "ABI_TRU64";
            case 20L: return "ABI_WIN386";
            default: return "";
        }
    }

    std::string ExecABI(int64_t i, const std::string &strip) {
        std::string s = ExecABI(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecABI() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecABI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecABI(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecABI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecABI() {
        return stringify::SgAsmExecutableFileFormat::ExecABI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h line 98
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* InsSetArchitecture(int64_t i) {
        switch (i) {
            case 0L: return "ISA_UNSPECIFIED";
            case 256L: return "ISA_IA32_Family";
            case 257L: return "ISA_IA32_286";
            case 258L: return "ISA_IA32_386";
            case 259L: return "ISA_IA32_486";
            case 260L: return "ISA_IA32_Pentium";
            case 261L: return "ISA_IA32_Cyrix6x86";
            case 262L: return "ISA_IA32_AMDK5";
            case 263L: return "ISA_IA32_PentiumPro";
            case 264L: return "ISA_IA32_PentiumII";
            case 265L: return "ISA_IA32_Athlon";
            case 266L: return "ISA_IA32_Pentium4";
            case 267L: return "ISA_IA32_PentiumM";
            case 512L: return "ISA_X8664_Family";
            case 513L: return "ISA_X8664_Athlon64";
            case 514L: return "ISA_X8664_Prescott";
            case 515L: return "ISA_X8664_IntelCore";
            case 516L: return "ISA_X8664_AMDPhenom";
            case 768L: return "ISA_SPARC_Family";
            case 769L: return "ISA_SPARC_V7";
            case 770L: return "ISA_SPARC_V8";
            case 771L: return "ISA_SPARC_V8E";
            case 772L: return "ISA_SPARC_V9";
            case 773L: return "ISA_SPARC_V9JPS1";
            case 774L: return "ISA_SPARC_V9UA";
            case 775L: return "ISA_SPARC_V9JPS2";
            case 1024L: return "ISA_M68K_Family";
            case 1025L: return "ISA_M68K_68000";
            case 1026L: return "ISA_M68K_68EC000";
            case 1027L: return "ISA_M68K_68HC000";
            case 1028L: return "ISA_M68K_68008";
            case 1029L: return "ISA_M68K_68010";
            case 1030L: return "ISA_M68K_68012";
            case 1031L: return "ISA_M68K_68020";
            case 1032L: return "ISA_M68K_68EC020";
            case 1033L: return "ISA_M68K_68030";
            case 1034L: return "ISA_M68K_68EC030";
            case 1035L: return "ISA_M68K_68040";
            case 1036L: return "ISA_M68K_68EC040";
            case 1037L: return "ISA_M68K_68LC040";
            case 1038L: return "ISA_M68K_68060";
            case 1039L: return "ISA_M68K_ColdFire";
            case 1040L: return "ISA_M68K_DragonBall";
            case 1280L: return "ISA_M88K_Family";
            case 1281L: return "ISA_M88K_88100";
            case 1282L: return "ISA_M88K_88110";
            case 1283L: return "ISA_M88K_88110MP";
            case 1284L: return "ISA_M88K_88120";
            case 1536L: return "ISA_MIPS_Family";
            case 1537L: return "ISA_MIPS_MarkI";
            case 1538L: return "ISA_MIPS_MarkII";
            case 1539L: return "ISA_MIPS_MarkIII";
            case 1540L: return "ISA_MIPS_R2000";
            case 1541L: return "ISA_MIPS_R3000";
            case 1542L: return "ISA_MIPS_R4000";
            case 1543L: return "ISA_MIPS_R4200";
            case 1544L: return "ISA_MIPS_R4300";
            case 1545L: return "ISA_MIPS_R4600";
            case 1546L: return "ISA_MIPS_R4650";
            case 1547L: return "ISA_MIPS_R4700";
            case 1548L: return "ISA_MIPS_R5000";
            case 1549L: return "ISA_MIPS_RM7000";
            case 1550L: return "ISA_MIPS_R8000";
            case 1551L: return "ISA_MIPS_R10000";
            case 1552L: return "ISA_MIPS_R12000";
            case 1553L: return "ISA_MIPS_R14000";
            case 1554L: return "ISA_MIPS_R16000";
            case 1555L: return "ISA_MIPS_R16000A";
            case 1556L: return "ISA_MIPS_16";
            case 1557L: return "ISA_MIPS_FPU";
            case 1558L: return "ISA_MIPS_16FPU";
            case 1792L: return "ISA_I860_Family";
            case 1793L: return "ISA_I860_860XR";
            case 1794L: return "ISA_I860_860XP";
            case 2048L: return "ISA_IA64_Family";
            case 2049L: return "ISA_IA64_Itanium";
            case 2050L: return "ISA_IA64_Itanium2";
            case 2304L: return "ISA_ARM_Family";
            case 2305L: return "ISA_ARM_ARM1";
            case 2306L: return "ISA_ARM_ARM2";
            case 2307L: return "ISA_ARM_ARM3";
            case 2308L: return "ISA_ARM_ARM6";
            case 2309L: return "ISA_ARM_ARM7";
            case 2310L: return "ISA_ARM_ARM7TDMI";
            case 2311L: return "ISA_ARM_StrongARM";
            case 2312L: return "ISA_ARM_ARM8";
            case 2313L: return "ISA_ARM_ARM9TDMI";
            case 2314L: return "ISA_ARM_ARM9E";
            case 2315L: return "ISA_ARM_ARM10E";
            case 2316L: return "ISA_ARM_XScale";
            case 2317L: return "ISA_ARM_ARM11";
            case 2318L: return "ISA_ARM_Cortex";
            case 2319L: return "ISA_ARM_A64";
            case 2560L: return "ISA_JVM";
            case 61440L: return "ISA_OTHER_Family";
            case 61441L: return "ISA_ATT_WE_32100";
            case 61442L: return "ISA_IBM_System_370";
            case 61443L: return "ISA_HPPA";
            case 61444L: return "ISA_Fujitsu_VPP500";
            case 61445L: return "ISA_Sun_v8plus";
            case 61446L: return "ISA_PowerPC";
            case 61447L: return "ISA_PowerPC_64bit";
            case 61448L: return "ISA_IBM_S390";
            case 61449L: return "ISA_NEC_V800_series";
            case 61450L: return "ISA_Fujitsu_FR20";
            case 61451L: return "ISA_TRW_RH_32";
            case 61452L: return "ISA_Motorola_RCE";
            case 61454L: return "ISA_Digital_Alpha_fake";
            case 61455L: return "ISA_Hitachi_SH";
            case 61456L: return "ISA_Siemens_Tricore";
            case 61457L: return "ISA_Argonaut_RISC_Core";
            case 61458L: return "ISA_Hitachi_H8_300";
            case 61459L: return "ISA_Hitachi_H8_300H";
            case 61460L: return "ISA_Hitachi_H8S";
            case 61461L: return "ISA_Hitachi_H8_500";
            case 61462L: return "ISA_Stanford_MIPS_X";
            case 61463L: return "ISA_Motorola_M68HC12";
            case 61464L: return "ISA_Fujitsu_MMA_Multimedia_Accelerator";
            case 61465L: return "ISA_Siemens_PCP";
            case 61466L: return "ISA_Sony_nCPU_embeeded_RISC";
            case 61467L: return "ISA_Denso_NDR1_microprocessor";
            case 61468L: return "ISA_Motorola_Start_Core_processor";
            case 61469L: return "ISA_Toyota_ME16_processor";
            case 61470L: return "ISA_STMicroelectronic_ST100_processor";
            case 61471L: return "ISA_Advanced_Logic_Corp_Tinyj_emb_family";
            case 61472L: return "ISA_AMD_x86_64_architecture";
            case 61473L: return "ISA_Sony_DSP_Processor";
            case 61474L: return "ISA_Siemens_FX66_microcontroller";
            case 61475L: return "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller";
            case 61476L: return "ISA_STMicroelectronics_ST7_8bit_microcontroller";
            case 61477L: return "ISA_Motorola_MC68HC16_microcontroller";
            case 61478L: return "ISA_Motorola_MC68HC11_microcontroller";
            case 61479L: return "ISA_Motorola_MC68HC08_microcontroller";
            case 61480L: return "ISA_Motorola_MC68HC05_microcontroller";
            case 61481L: return "ISA_Silicon_Graphics_SVx";
            case 61482L: return "ISA_STMicroelectronics_ST19_8bit_microcontroller";
            case 61483L: return "ISA_Digital_VAX";
            case 61484L: return "ISA_Axis_Communications_32bit_embedded_processor";
            case 61485L: return "ISA_Infineon_Technologies_32bit_embedded_processor";
            case 61486L: return "ISA_Element_14_64bit_DSP_Processor";
            case 61487L: return "ISA_LSI_Logic_16bit_DSP_Processor";
            case 61488L: return "ISA_Donald_Knuths_educational_64bit_processor";
            case 61489L: return "ISA_Harvard_University_machine_independent_object_files";
            case 61490L: return "ISA_SiTera_Prism";
            case 61491L: return "ISA_Atmel_AVR_8bit_microcontroller";
            case 61492L: return "ISA_Fujitsu_FR30";
            case 61493L: return "ISA_Mitsubishi_D10V";
            case 61494L: return "ISA_Mitsubishi_D30V";
            case 61495L: return "ISA_NEC_v850";
            case 61496L: return "ISA_Mitsubishi_M32R";
            case 61497L: return "ISA_Matsushita_MN10300";
            case 61498L: return "ISA_Matsushita_MN10200";
            case 61499L: return "ISA_picoJava";
            case 61500L: return "ISA_OpenRISC_32bit_embedded_processor";
            case 61501L: return "ISA_ARC_Cores_Tangent_A5";
            case 61502L: return "ISA_Tensilica_Xtensa_Architecture";
            case 61503L: return "ISA_Digital_Alpha";
            case 61504L: return "ISA_Matsushita_AM33";
            case 61505L: return "ISA_EFI_ByteCode";
            case 65280L: return "ISA_FAMILY_MASK";
            case 65535L: return "ISA_OTHER";
            default: return "";
        }
    }

    std::string InsSetArchitecture(int64_t i, const std::string &strip) {
        std::string s = InsSetArchitecture(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsSetArchitecture() {
        static const int64_t values[] = {
            0L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            512L,
            513L,
            514L,
            515L,
            516L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1280L,
            1281L,
            1282L,
            1283L,
            1284L,
            1536L,
            1537L,
            1538L,
            1539L,
            1540L,
            1541L,
            1542L,
            1543L,
            1544L,
            1545L,
            1546L,
            1547L,
            1548L,
            1549L,
            1550L,
            1551L,
            1552L,
            1553L,
            1554L,
            1555L,
            1556L,
            1557L,
            1558L,
            1792L,
            1793L,
            1794L,
            2048L,
            2049L,
            2050L,
            2304L,
            2305L,
            2306L,
            2307L,
            2308L,
            2309L,
            2310L,
            2311L,
            2312L,
            2313L,
            2314L,
            2315L,
            2316L,
            2317L,
            2318L,
            2319L,
            2560L,
            61440L,
            61441L,
            61442L,
            61443L,
            61444L,
            61445L,
            61446L,
            61447L,
            61448L,
            61449L,
            61450L,
            61451L,
            61452L,
            61454L,
            61455L,
            61456L,
            61457L,
            61458L,
            61459L,
            61460L,
            61461L,
            61462L,
            61463L,
            61464L,
            61465L,
            61466L,
            61467L,
            61468L,
            61469L,
            61470L,
            61471L,
            61472L,
            61473L,
            61474L,
            61475L,
            61476L,
            61477L,
            61478L,
            61479L,
            61480L,
            61481L,
            61482L,
            61483L,
            61484L,
            61485L,
            61486L,
            61487L,
            61488L,
            61489L,
            61490L,
            61491L,
            61492L,
            61493L,
            61494L,
            61495L,
            61496L,
            61497L,
            61498L,
            61499L,
            61500L,
            61501L,
            61502L,
            61503L,
            61504L,
            61505L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 161);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatInsSetArchitecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::InsSetArchitecture(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::InsSetArchitecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatInsSetArchitecture() {
        return stringify::SgAsmExecutableFileFormat::InsSetArchitecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h line 280
namespace stringify { namespace SgAsmExecutableFileFormat {
    const char* ExecPurpose(int64_t i) {
        switch (i) {
            case 0L: return "PURPOSE_UNSPECIFIED";
            case 1L: return "PURPOSE_OTHER";
            case 2L: return "PURPOSE_EXECUTABLE";
            case 3L: return "PURPOSE_LIBRARY";
            case 4L: return "PURPOSE_CORE_DUMP";
            case 5L: return "PURPOSE_OS_SPECIFIC";
            case 6L: return "PURPOSE_PROC_SPECIFIC";
            default: return "";
        }
    }

    std::string ExecPurpose(int64_t i, const std::string &strip) {
        std::string s = ExecPurpose(i);
        if (s.empty())
            s = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ExecPurpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmExecutableFileFormatExecPurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmExecutableFileFormat::ExecPurpose(i);
        if (retval.empty()) {
            retval = "(SgAsmExecutableFileFormat::ExecPurpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmExecutableFileFormatExecPurpose() {
        return stringify::SgAsmExecutableFileFormat::ExecPurpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h line 74
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags1(int64_t i) {
        switch (i) {
            case 0L: return "HF1_NO_DATA";
            case 1L: return "HF1_SINGLE_DATA";
            case 2L: return "HF1_MULTIPLE_DATA";
            case 2048L: return "HF1_LOADER_SEGMENT";
            case 8192L: return "HF1_FATAL_ERRORS";
            case 22516L: return "HF1_RESERVED";
            case 32768L: return "HF1_LIBRARY";
            default: return "";
        }
    }

    std::string HeaderFlags1(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags1(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags1() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            2048L,
            8192L,
            22516L,
            32768L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags1(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags1(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags1)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags1() {
        return stringify::SgAsmNEFileHeader::HeaderFlags1();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h line 85
namespace stringify { namespace SgAsmNEFileHeader {
    const char* HeaderFlags2(int64_t i) {
        switch (i) {
            case 2L: return "HF2_PROTECTED_MODE";
            case 4L: return "HF2_PFONTS";
            case 8L: return "HF2_FASTLOAD";
            case 241L: return "HF2_RESERVED";
            default: return "";
        }
    }

    std::string HeaderFlags2(int64_t i, const std::string &strip) {
        std::string s = HeaderFlags2(i);
        if (s.empty())
            s = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HeaderFlags2() {
        static const int64_t values[] = {
            2L,
            4L,
            8L,
            241L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEFileHeaderHeaderFlags2(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEFileHeader::HeaderFlags2(i);
        if (retval.empty()) {
            retval = "(SgAsmNEFileHeader::HeaderFlags2)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEFileHeaderHeaderFlags2() {
        return stringify::SgAsmNEFileHeader::HeaderFlags2();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h line 9
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolDefState(int64_t i) {
        switch (i) {
            case 0L: return "SYM_UNDEFINED";
            case 1L: return "SYM_TENTATIVE";
            case 2L: return "SYM_DEFINED";
            default: return "";
        }
    }

    std::string SymbolDefState(int64_t i, const std::string &strip) {
        std::string s = SymbolDefState(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolDefState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolDefState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolDefState(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolDefState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolDefState() {
        return stringify::SgAsmGenericSymbol::SymbolDefState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h line 16
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolType(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_TYPE";
            case 1L: return "SYM_DATA";
            case 2L: return "SYM_FUNC";
            case 3L: return "SYM_SECTION";
            case 4L: return "SYM_FILE";
            case 5L: return "SYM_ARRAY";
            case 6L: return "SYM_TLS";
            case 7L: return "SYM_REGISTER";
            case 8L: return "SYM_COMMON";
            case 9L: return "SYM_IFUNC";
            default: return "";
        }
    }

    std::string SymbolType(int64_t i, const std::string &strip) {
        std::string s = SymbolType(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolType(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolType() {
        return stringify::SgAsmGenericSymbol::SymbolType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h line 30
namespace stringify { namespace SgAsmGenericSymbol {
    const char* SymbolBinding(int64_t i) {
        switch (i) {
            case 0L: return "SYM_NO_BINDING";
            case 1L: return "SYM_LOCAL";
            case 2L: return "SYM_GLOBAL";
            case 3L: return "SYM_WEAK";
            default: return "";
        }
    }

    std::string SymbolBinding(int64_t i, const std::string &strip) {
        std::string s = SymbolBinding(i);
        if (s.empty())
            s = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SymbolBinding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmGenericSymbolSymbolBinding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmGenericSymbol::SymbolBinding(i);
        if (retval.empty()) {
            retval = "(SgAsmGenericSymbol::SymbolBinding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmGenericSymbolSymbolBinding() {
        return stringify::SgAsmGenericSymbol::SymbolBinding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmFunction.h line 29
namespace stringify { namespace SgAsmFunction {
    const char* MayReturn(int64_t i) {
        switch (i) {
            case 0L: return "RET_UNKNOWN";
            case 1L: return "RET_NEVER";
            case 2L: return "RET_SOMETIMES";
            case 3L: return "RET_ALWAYS";
            default: return "";
        }
    }

    std::string MayReturn(int64_t i, const std::string &strip) {
        std::string s = MayReturn(i);
        if (s.empty())
            s = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayReturn() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionMayReturn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::MayReturn(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::MayReturn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::MayReturn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionMayReturn() {
        return stringify::SgAsmFunction::MayReturn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmFunction.h line 39
namespace stringify { namespace SgAsmFunction {
    const char* FunctionReason(int64_t i) {
        switch (i) {
            case 0L: return "FUNC_NONE";
            case 1L: return "FUNC_INTERPADFUNC";
            case 2L: return "FUNC_PESCRAMBLER_DISPATCH";
            case 3L: return "FUNC_CONFIGURED";
            case 4L: return "FUNC_CMDLINE";
            case 5L: return "FUNC_SCAN_RO_DATA";
            case 6L: return "FUNC_INSN_RO_DATA";
            case 255L: return "FUNC_MISCMASK";
            case 16384L: return "FUNC_THUNK_TARGET";
            case 32768L: return "FUNC_EXCEPTION_HANDLER";
            case 65536L: return "FUNC_ENTRY_POINT";
            case 131072L: return "FUNC_CALL_TARGET";
            case 262144L: return "FUNC_CALL_INSN";
            case 524288L: return "FUNC_EH_FRAME";
            case 1048576L: return "FUNC_SYMBOL";
            case 2097152L: return "FUNC_PATTERN";
            case 4194304L: return "FUNC_GRAPH";
            case 8388608L: return "FUNC_USERDEF";
            case 16777216L: return "FUNC_PADDING";
            case 33554432L: return "FUNC_DISCONT";
            case 67108864L: return "FUNC_INSNHEAD";
            case 134217728L: return "FUNC_IMPORT";
            case 268435456L: return "FUNC_LEFTOVERS";
            case 536870912L: return "FUNC_INTRABLOCK";
            case 1073741824L: return "FUNC_THUNK";
            case 2147483648L: return "FUNC_EXPORT";
            case 4026499327L: return "FUNC_DEFAULT";
            default: return "";
        }
    }

    std::string FunctionReason(int64_t i, const std::string &strip) {
        std::string s = FunctionReason(i);
        if (s.empty())
            s = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L,
            16384L,
            32768L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4026499327L
        };
        static const std::vector<int64_t> retval(values, values + 27);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunctionFunctionReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::FunctionReason(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::FunctionReason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::FunctionReason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunctionFunctionReason() {
        return stringify::SgAsmFunction::FunctionReason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmFunction.h line 126
namespace stringify { namespace SgAsmFunction {
    const char* function_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_standard";
            case 2L: return "e_library";
            case 3L: return "e_imported";
            case 4L: return "e_thunk";
            case 5L: return "e_last";
            default: return "";
        }
    }

    std::string function_kind_enum(int64_t i, const std::string &strip) {
        std::string s = function_kind_enum(i);
        if (s.empty())
            s = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFunction_function_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFunction::function_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmFunction::function_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFunction::function_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFunction_function_kind_enum() {
        return stringify::SgAsmFunction::function_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmJvmStackMapVerificationType.h line 10
namespace stringify { namespace SgAsmJvmStackMapVerificationType {
    const char* verification_type_tag(int64_t i) {
        switch (i) {
            case 0L: return "ITEM_Top";
            case 1L: return "ITEM_Integer";
            case 2L: return "ITEM_Float";
            case 3L: return "ITEM_Double";
            case 4L: return "ITEM_Long";
            case 5L: return "ITEM_Null";
            case 6L: return "ITEM_UninitializedThis";
            case 7L: return "ITEM_Object";
            case 8L: return "ITEM_Uninitialized";
            default: return "";
        }
    }

    std::string verification_type_tag(int64_t i, const std::string &strip) {
        std::string s = verification_type_tag(i);
        if (s.empty())
            s = "(SgAsmJvmStackMapVerificationType::verification_type_tag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& verification_type_tag() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmJvmStackMapVerificationType_verification_type_tag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmJvmStackMapVerificationType::verification_type_tag(i);
        if (retval.empty()) {
            retval = "(SgAsmJvmStackMapVerificationType::verification_type_tag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmJvmStackMapVerificationType::verification_type_tag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmJvmStackMapVerificationType_verification_type_tag() {
        return stringify::SgAsmJvmStackMapVerificationType::verification_type_tag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h line 235
namespace stringify { namespace SgAsmCilMetadataHeap {
    const char* ReferenceKind(int64_t i) {
        switch (i) {
            case 1L: return "e_ref_string_heap";
            case 2L: return "e_ref_guid_heap";
            case 4L: return "e_ref_blob_heap";
            case 8L: return "e_ref_assembly_ref";
            case 16L: return "e_ref_type_def";
            case 32L: return "e_ref_event";
            case 64L: return "e_ref_field";
            case 128L: return "e_ref_generic_param";
            case 256L: return "e_ref_module_ref";
            case 512L: return "e_ref_method_def";
            case 1024L: return "e_ref_param";
            case 2048L: return "e_ref_property";
            case 4096L: return "e_ref_has_constant";
            case 8192L: return "e_ref_has_custom_attribute";
            case 16384L: return "e_ref_has_decl_security";
            case 32768L: return "e_ref_has_field_marshall";
            case 65536L: return "e_ref_has_semantics";
            case 131072L: return "e_ref_method_def_or_ref";
            case 262144L: return "e_ref_type_def_or_ref";
            case 524288L: return "e_ref_implementation";
            case 1048576L: return "e_ref_member_forwarded";
            case 2097152L: return "e_ref_member_ref_parent";
            case 4194304L: return "e_ref_type_or_method_def";
            case 8388608L: return "e_ref_custom_attribute_type";
            case 16777216L: return "e_ref_resolution_scope";
            case 33554432L: return "e_ref_last";
            default: return "";
        }
    }

    std::string ReferenceKind(int64_t i, const std::string &strip) {
        std::string s = ReferenceKind(i);
        if (s.empty())
            s = "(SgAsmCilMetadataHeap::ReferenceKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ReferenceKind() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            2048L,
            4096L,
            8192L,
            16384L,
            32768L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L
        };
        static const std::vector<int64_t> retval(values, values + 26);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmCilMetadataHeapReferenceKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmCilMetadataHeap::ReferenceKind(i);
        if (retval.empty()) {
            retval = "(SgAsmCilMetadataHeap::ReferenceKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmCilMetadataHeap::ReferenceKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmCilMetadataHeapReferenceKind() {
        return stringify::SgAsmCilMetadataHeap::ReferenceKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h line 6
namespace stringify { namespace SgAsmNEEntryPoint {
    const char* NEEntryFlags(int64_t i) {
        switch (i) {
            case 0L: return "EF_ZERO";
            case 1L: return "EF_EXPORTED";
            case 2L: return "EF_GLOBAL";
            case 252L: return "EF_RESERVED";
            default: return "";
        }
    }

    std::string NEEntryFlags(int64_t i, const std::string &strip) {
        std::string s = NEEntryFlags(i);
        if (s.empty())
            s = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NEEntryFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            252L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNEEntryPointNEEntryFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNEEntryPoint::NEEntryFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNEEntryPoint::NEEntryFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNEEntryPointNEEntryFlags() {
        return stringify::SgAsmNEEntryPoint::NEEntryFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmFloatType.h line 9
namespace stringify { namespace SgAsmFloatType {
    const char* Flag(int64_t i) {
        switch (i) {
            case 1L: return "GRADUAL_UNDERFLOW";
            case 2L: return "IMPLICIT_BIT_CONVENTION";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(SgAsmFloatType::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmFloatTypeFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmFloatType::Flag(i);
        if (retval.empty()) {
            retval = "(SgAsmFloatType::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmFloatType::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmFloatTypeFlag() {
        return stringify::SgAsmFloatType::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h line 11
namespace stringify { namespace SgAsmElfRelocEntry {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "R_386_NONE";
            case 1L: return "R_386_32";
            case 2L: return "R_386_PC32";
            case 3L: return "R_386_GOT32";
            case 4L: return "R_386_PLT32";
            case 5L: return "R_386_COPY";
            case 6L: return "R_386_GLOB_DAT";
            case 7L: return "R_386_JMP_SLOT";
            case 8L: return "R_386_RELATIVE";
            case 9L: return "R_386_GOTOFF";
            case 10L: return "R_386_GOTPC";
            case 11L: return "R_386_32PLT";
            case 14L: return "R_386_TLS_TPOFF";
            case 15L: return "R_386_TLS_IE";
            case 16L: return "R_386_TLS_GOTIE";
            case 17L: return "R_386_TLS_LE";
            case 18L: return "R_386_TLS_GD";
            case 19L: return "R_386_TLS_LDM";
            case 20L: return "R_386_16";
            case 21L: return "R_386_PC16";
            case 22L: return "R_386_8";
            case 23L: return "R_386_PC8";
            case 24L: return "R_386_TLS_GD_32";
            case 25L: return "R_386_TLS_GD_PUSH";
            case 26L: return "R_386_TLS_GD_CALL";
            case 27L: return "R_386_TLS_GD_POP";
            case 28L: return "R_386_TLS_LDM_32";
            case 29L: return "R_386_TLS_LDM_PUSH";
            case 30L: return "R_386_TLS_LDM_CALL";
            case 31L: return "R_386_TLS_LDM_POP";
            case 32L: return "R_386_TLS_LDO_32";
            case 33L: return "R_386_TLS_IE_32";
            case 34L: return "R_386_TLS_LE_32";
            case 35L: return "R_386_TLS_DTPMOD32";
            case 36L: return "R_386_TLS_DTPOFF32";
            case 37L: return "R_386_TLS_TPOFF32";
            case 100L: return "R_X86_64_NONE";
            case 101L: return "R_X86_64_64";
            case 102L: return "R_X86_64_PC32";
            case 103L: return "R_X86_64_GOT32";
            case 104L: return "R_X86_64_PLT32";
            case 105L: return "R_X86_64_COPY";
            case 106L: return "R_X86_64_GLOB_DAT";
            case 107L: return "R_X86_64_JUMP_SLOT";
            case 108L: return "R_X86_64_RELATIVE";
            case 109L: return "R_X86_64_GOTPCREL";
            case 110L: return "R_X86_64_32";
            case 111L: return "R_X86_64_32S";
            case 112L: return "R_X86_64_16";
            case 113L: return "R_X86_64_PC16";
            case 114L: return "R_X86_64_8";
            case 115L: return "R_X86_64_PC8";
            case 116L: return "R_X86_64_DTPMOD64";
            case 117L: return "R_X86_64_DTPOFF64";
            case 118L: return "R_X86_64_TPOFF64";
            case 119L: return "R_X86_64_TLSGD";
            case 120L: return "R_X86_64_TLSLD";
            case 121L: return "R_X86_64_DTPOFF32";
            case 122L: return "R_X86_64_GOTTPOFF";
            case 123L: return "R_X86_64_TPOFF32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfRelocEntryRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfRelocEntry::RelocType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfRelocEntry::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfRelocEntry::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfRelocEntryRelocType() {
        return stringify::SgAsmElfRelocEntry::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h line 32
namespace stringify { namespace SgAsmPESectionTableEntry {
    const char* PESectionFlags(int64_t i) {
        switch (i) {
            case 32L: return "OF_CODE";
            case 64L: return "OF_IDATA";
            case 128L: return "OF_UDATA";
            case 512L: return "OF_INFO";
            case 2048L: return "OF_REMOVE";
            case 4096L: return "OF_COMDAT";
            case 16384L: return "OF_NO_DEFER_SPEC_EXC";
            case 32768L: return "OF_GPREL";
            case 1048576L: return "OF_ALIGN_1";
            case 2097152L: return "OF_ALIGN_2";
            case 3145728L: return "OF_ALIGN_4";
            case 4194304L: return "OF_ALIGN_8";
            case 5242880L: return "OF_ALIGN_16";
            case 6291456L: return "OF_ALIGN_32";
            case 7340032L: return "OF_ALIGN_64";
            case 8388608L: return "OF_ALIGN_128";
            case 9437184L: return "OF_ALIGN_256";
            case 10485760L: return "OF_ALIGN_512";
            case 11534336L: return "OF_ALIGN_1k";
            case 12582912L: return "OF_ALIGN_2k";
            case 13631488L: return "OF_ALIGN_4k";
            case 14680064L: return "OF_ALIGN_8k";
            case 15728640L: return "OF_ALIGN_MASK";
            case 16777216L: return "OF_NRELOC_OVFL";
            case 33554432L: return "OF_DISCARDABLE";
            case 67108864L: return "OF_NO_CACHE";
            case 134217728L: return "OF_NO_PAGING";
            case 268435456L: return "OF_SHARED";
            case 536870912L: return "OF_EXECUTABLE";
            case 1073741824L: return "OF_READABLE";
            case 2147483648L: return "OF_WRITABLE";
            default: return "";
        }
    }

    std::string PESectionFlags(int64_t i, const std::string &strip) {
        std::string s = PESectionFlags(i);
        if (s.empty())
            s = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PESectionFlags() {
        static const int64_t values[] = {
            32L,
            64L,
            128L,
            512L,
            2048L,
            4096L,
            16384L,
            32768L,
            1048576L,
            2097152L,
            3145728L,
            4194304L,
            5242880L,
            6291456L,
            7340032L,
            8388608L,
            9437184L,
            10485760L,
            11534336L,
            12582912L,
            13631488L,
            14680064L,
            15728640L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 31);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmPESectionTableEntryPESectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmPESectionTableEntry::PESectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmPESectionTableEntry::PESectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmPESectionTableEntryPESectionFlags() {
        return stringify::SgAsmPESectionTableEntry::PESectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmBlock.h line 33
namespace stringify { namespace SgAsmBlock {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "BLK_NONE";
            case 1L: return "BLK_FINDDATA";
            case 2L: return "BLK_POSTFUNC";
            case 255L: return "BLK_MISCMASK";
            case 65536L: return "BLK_ENTRY_POINT";
            case 131072L: return "BLK_PADDING";
            case 524288L: return "BLK_FRAGMENT";
            case 1048576L: return "BLK_CFGHEAD";
            case 2097152L: return "BLK_USERDEF";
            case 4194304L: return "BLK_LEFTOVERS";
            case 8388608L: return "BLK_JUMPTABLE";
            case 16777216L: return "BLK_GRAPH1";
            case 33554432L: return "BLK_GRAPH2";
            case 67108864L: return "BLK_GRAPH3";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            255L,
            65536L,
            131072L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L
        };
        static const std::vector<int64_t> retval(values, values + 14);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmBlockReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmBlock::Reason(i);
        if (retval.empty()) {
            retval = "(SgAsmBlock::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmBlock::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmBlockReason() {
        return stringify::SgAsmBlock::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h line 17
namespace stringify { namespace SgAsmElfFileHeader {
    const char* ObjectType(int64_t i) {
        switch (i) {
            case 0L: return "ET_NONE";
            case 1L: return "ET_REL";
            case 2L: return "ET_EXEC";
            case 3L: return "ET_DYN";
            case 4L: return "ET_CORE";
            case 65024L: return "ET_LOOS";
            case 65279L: return "ET_HIOS";
            case 65280L: return "ET_LOPROC";
            case 65535L: return "ET_HIPROC";
            default: return "";
        }
    }

    std::string ObjectType(int64_t i, const std::string &strip) {
        std::string s = ObjectType(i);
        if (s.empty())
            s = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ObjectType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            65024L,
            65279L,
            65280L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfFileHeaderObjectType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfFileHeader::ObjectType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfFileHeader::ObjectType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfFileHeader::ObjectType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfFileHeaderObjectType() {
        return stringify::SgAsmElfFileHeader::ObjectType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h line 11
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionType(int64_t i) {
        switch (i) {
            case 0L: return "SHT_NULL";
            case 1L: return "SHT_PROGBITS";
            case 2L: return "SHT_SYMTAB";
            case 3L: return "SHT_STRTAB";
            case 4L: return "SHT_RELA";
            case 5L: return "SHT_HASH";
            case 6L: return "SHT_DYNAMIC";
            case 7L: return "SHT_NOTE";
            case 8L: return "SHT_NOBITS";
            case 9L: return "SHT_REL";
            case 10L: return "SHT_SHLIB";
            case 11L: return "SHT_DYNSYM";
            case 1610612736L: return "SHT_LOOS";
            case 1879048189L: return "SHT_GNU_verdef";
            case 1879048190L: return "SHT_GNU_verneed";
            case 1879048191L: return "SHT_GNU_versym";
            case 1879048192L: return "SHT_LOPROC";
            case 2147483647L: return "SHT_HIPROC";
            case 2147483648L: return "SHT_LOUSER";
            case 4294967295L: return "SHT_HIUSER";
            default: return "";
        }
    }

    std::string SectionType(int64_t i, const std::string &strip) {
        std::string s = SectionType(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            1610612736L,
            1879048189L,
            1879048190L,
            1879048191L,
            1879048192L,
            2147483647L,
            2147483648L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionType(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionType() {
        return stringify::SgAsmElfSectionTableEntry::SectionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h line 38
namespace stringify { namespace SgAsmElfSectionTableEntry {
    const char* SectionFlags(int64_t i) {
        switch (i) {
            case 0L: return "SHF_NULL";
            case 1L: return "SHF_WRITE";
            case 2L: return "SHF_ALLOC";
            case 4L: return "SHF_EXECINSTR";
            case 16L: return "SHF_MERGE";
            case 32L: return "SHF_STRINGS";
            case 64L: return "SHF_INFO_LINK";
            case 128L: return "SHF_LINK_ORDER";
            case 256L: return "SHF_OS_NONCONFORMING";
            case 512L: return "SHF_GROUP";
            case 1024L: return "SHF_TLS";
            case 267386880L: return "SHF_MASKOS";
            case 4026531840L: return "SHF_MASKPROC";
            default: return "";
        }
    }

    std::string SectionFlags(int64_t i, const std::string &strip) {
        std::string s = SectionFlags(i);
        if (s.empty())
            s = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SectionFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L,
            1024L,
            267386880L,
            4026531840L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmElfSectionTableEntrySectionFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmElfSectionTableEntry::SectionFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmElfSectionTableEntry::SectionFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmElfSectionTableEntrySectionFlags() {
        return stringify::SgAsmElfSectionTableEntry::SectionFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h line 14
namespace stringify { namespace SgAsmJvmConstantPoolEntry {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "CONSTANT_Utf8";
            case 3L: return "CONSTANT_Integer";
            case 4L: return "CONSTANT_Float";
            case 5L: return "CONSTANT_Long";
            case 6L: return "CONSTANT_Double";
            case 7L: return "CONSTANT_Class";
            case 8L: return "CONSTANT_String";
            case 9L: return "CONSTANT_Fieldref";
            case 10L: return "CONSTANT_Methodref";
            case 11L: return "CONSTANT_InterfaceMethodref";
            case 12L: return "CONSTANT_NameAndType";
            case 15L: return "CONSTANT_MethodHandle";
            case 16L: return "CONSTANT_MethodType";
            case 17L: return "CONSTANT_Dynamic";
            case 18L: return "CONSTANT_InvokeDynamic";
            case 19L: return "CONSTANT_Module";
            case 20L: return "CONSTANT_Package";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(SgAsmJvmConstantPoolEntry::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmJvmConstantPoolEntryKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmJvmConstantPoolEntry::Kind(i);
        if (retval.empty()) {
            retval = "(SgAsmJvmConstantPoolEntry::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmJvmConstantPoolEntry::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmJvmConstantPoolEntryKind() {
        return stringify::SgAsmJvmConstantPoolEntry::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h line 80
namespace stringify { namespace SgAsmLEFileHeader {
    const char* LEFileHeaderFlags(int64_t i) {
        switch (i) {
            case 0L: return "HF_MODTYPE_PROG";
            case 4L: return "HF_PROC_LIB_INIT";
            case 16L: return "HF_IFIXUPS_APPLIED";
            case 32L: return "HF_EFIXUPS_APPLIED";
            case 256L: return "HF_PM_WINDOW_NO";
            case 512L: return "HF_PM_WINDOW_OK";
            case 768L: return "HF_PM_WINDOW_USE";
            case 8192L: return "HF_NOT_LOADABLE";
            case 32768L: return "HF_MODTYPE_LIB";
            case 98304L: return "HF_MODTYPE_PLIB";
            case 131072L: return "HF_MODTYPE_PDEV";
            case 163840L: return "HF_MODTYPE_VDEV";
            case 229376L: return "HF_MODTYPE_MASK";
            case 1073741824L: return "HF_PROC_LIB_TERM";
            case 3220987083L: return "HF_RESERVED";
            default: return "";
        }
    }

    std::string LEFileHeaderFlags(int64_t i, const std::string &strip) {
        std::string s = LEFileHeaderFlags(i);
        if (s.empty())
            s = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LEFileHeaderFlags() {
        static const int64_t values[] = {
            0L,
            4L,
            16L,
            32L,
            256L,
            512L,
            768L,
            8192L,
            32768L,
            98304L,
            131072L,
            163840L,
            229376L,
            1073741824L,
            3220987083L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmLEFileHeaderLEFileHeaderFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmLEFileHeader::LEFileHeaderFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmLEFileHeader::LEFileHeaderFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmLEFileHeaderLEFileHeaderFlags() {
        return stringify::SgAsmLEFileHeader::LEFileHeaderFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNullInstruction.h line 4
namespace stringify { namespace SgAsmNullInstruction {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "null_unknown";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(SgAsmNullInstruction::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNullInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNullInstruction::Kind(i);
        if (retval.empty()) {
            retval = "(SgAsmNullInstruction::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNullInstruction::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNullInstructionKind() {
        return stringify::SgAsmNullInstruction::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h line 8
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocSrcType(int64_t i) {
        switch (i) {
            case 0L: return "RF_SRCTYPE_8OFF";
            case 2L: return "RF_SRCTYPE_WORDSEG";
            case 3L: return "RF_SRCTYPE_16PTR";
            case 5L: return "RF_SRCTYPE_16OFF";
            case 6L: return "RF_SRCTYPE_32PTR";
            case 7L: return "RF_SRCTYPE_32OFF";
            case 8L: return "RF_SRCTYPE_NEARCALL";
            case 11L: return "RF_SRCTYPE_48PTR";
            case 13L: return "RF_SRCTYPE_32OFF_b";
            default: return "";
        }
    }

    std::string NERelocSrcType(int64_t i, const std::string &strip) {
        std::string s = NERelocSrcType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocSrcType() {
        static const int64_t values[] = {
            0L,
            2L,
            3L,
            5L,
            6L,
            7L,
            8L,
            11L,
            13L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocSrcType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocSrcType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocSrcType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocSrcType() {
        return stringify::SgAsmNERelocEntry::NERelocSrcType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h line 20
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocTgtType(int64_t i) {
        switch (i) {
            case 0L: return "RF_TGTTYPE_IREF";
            case 1L: return "RF_TGTTYPE_IORD";
            case 2L: return "RF_TGTTYPE_INAME";
            case 3L: return "RF_TGTTYPE_OSFIXUP";
            default: return "";
        }
    }

    std::string NERelocTgtType(int64_t i, const std::string &strip) {
        std::string s = NERelocTgtType(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocTgtType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocTgtType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocTgtType(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocTgtType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocTgtType() {
        return stringify::SgAsmNERelocEntry::NERelocTgtType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h line 27
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocModifiers(int64_t i) {
        switch (i) {
            case 1L: return "RF_MODIFIER_SINGLE";
            case 3L: return "RF_MODIFIER_MULTI";
            default: return "";
        }
    }

    std::string NERelocModifiers(int64_t i, const std::string &strip) {
        std::string s = NERelocModifiers(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocModifiers() {
        static const int64_t values[] = {
            1L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocModifiers(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocModifiers(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocModifiers)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocModifiers() {
        return stringify::SgAsmNERelocEntry::NERelocModifiers();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h line 32
namespace stringify { namespace SgAsmNERelocEntry {
    const char* NERelocFlags(int64_t i) {
        switch (i) {
            case 1L: return "RF_ADDITIVE";
            case 2L: return "RF_RESERVED";
            case 4L: return "RF_2EXTRA";
            case 8L: return "RF_32ADD";
            case 16L: return "RF_16SECTION";
            case 32L: return "RF_8ORDINAL";
            default: return "";
        }
    }

    std::string NERelocFlags(int64_t i, const std::string &strip) {
        std::string s = NERelocFlags(i);
        if (s.empty())
            s = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NERelocFlags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmNERelocEntryNERelocFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmNERelocEntry::NERelocFlags(i);
        if (retval.empty()) {
            retval = "(SgAsmNERelocEntry::NERelocFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmNERelocEntryNERelocFlags() {
        return stringify::SgAsmNERelocEntry::NERelocFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h line 23
namespace stringify { namespace SgAsmRiscOperation {
    const char* RiscOperator(int64_t i) {
        switch (i) {
            case 0L: return "OP_NONE";
            case 1L: return "OP_bottom";
            case 2L: return "OP_undefined";
            case 3L: return "OP_unspecified";
            case 4L: return "OP_filterCallTarget";
            case 5L: return "OP_filterReturnTarget";
            case 6L: return "OP_filterIndirectJumpTarget";
            case 7L: return "OP_hlt";
            case 8L: return "OP_cpuid";
            case 9L: return "OP_rdtsc";
            case 10L: return "OP_and_";
            case 11L: return "OP_or_";
            case 12L: return "OP_xor_";
            case 13L: return "OP_invert";
            case 14L: return "OP_extract";
            case 15L: return "OP_concat";
            case 16L: return "OP_leastSignificantSetBit";
            case 17L: return "OP_mostSignificantSetBit";
            case 18L: return "OP_rotateLeft";
            case 19L: return "OP_rotateRight";
            case 20L: return "OP_shiftLeft";
            case 21L: return "OP_shiftRight";
            case 22L: return "OP_shiftRightArithmetic";
            case 23L: return "OP_equalToZero";
            case 24L: return "OP_ite";
            case 25L: return "OP_isEqual";
            case 26L: return "OP_isNotEqual";
            case 27L: return "OP_isUnsignedLessThan";
            case 28L: return "OP_isUnsignedLessThanOrEqual";
            case 29L: return "OP_isUnsignedGreaterThan";
            case 30L: return "OP_isUnsignedGreaterThanOrEqual";
            case 31L: return "OP_isSignedLessThan";
            case 32L: return "OP_isSignedLessThanOrEqual";
            case 33L: return "OP_isSignedGreaterThan";
            case 34L: return "OP_isSignedGreaterThanOrEqual";
            case 35L: return "OP_unsignedExtend";
            case 36L: return "OP_signExtend";
            case 37L: return "OP_add";
            case 38L: return "OP_addCarries";
            case 39L: return "OP_subtract";
            case 40L: return "OP_negate";
            case 41L: return "OP_signedDivide";
            case 42L: return "OP_signedModulo";
            case 43L: return "OP_signedMultiply";
            case 44L: return "OP_unsignedDivide";
            case 45L: return "OP_unsignedModulo";
            case 46L: return "OP_unsignedMultiply";
            case 47L: return "OP_interrupt";
            case 48L: return "OP_readRegister";
            case 49L: return "OP_peekRegister";
            case 50L: return "OP_writeRegister";
            case 51L: return "OP_readMemory";
            case 52L: return "OP_peekMemory";
            case 53L: return "OP_writeMemory";
            case 54L: return "OP_N_OPERATORS";
            default: return "";
        }
    }

    std::string RiscOperator(int64_t i, const std::string &strip) {
        std::string s = RiscOperator(i);
        if (s.empty())
            s = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RiscOperator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmRiscOperationRiscOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmRiscOperation::RiscOperator(i);
        if (retval.empty()) {
            retval = "(SgAsmRiscOperation::RiscOperator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmRiscOperation::RiscOperator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmRiscOperationRiscOperator() {
        return stringify::SgAsmRiscOperation::RiscOperator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 25
namespace stringify { namespace Rose { namespace StringUtility {
    const char* OSType(int64_t i) {
        switch (i) {
            case 0L: return "OS_TYPE_UNKNOWN";
            case 1L: return "OS_TYPE_LINUX";
            case 2L: return "OS_TYPE_OSX";
            case 3L: return "OS_TYPE_WINDOWS";
            case 4L: return "OS_TPYE_WINDOWSXP";
            default: return "";
        }
    }

    std::string OSType(int64_t i, const std::string &strip) {
        std::string s = OSType(i);
        if (s.empty())
            s = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OSType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityOSType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::OSType(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::OSType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::OSType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityOSType() {
        return stringify::Rose::StringUtility::OSType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/util/stringSupport/FileUtility.h line 150
namespace stringify { namespace Rose { namespace StringUtility {
    const char* FileNameLocation(int64_t i) {
        switch (i) {
            case 0L: return "FILENAME_LOCATION_UNKNOWN";
            case 1L: return "FILENAME_LOCATION_USER";
            case 2L: return "FILENAME_LOCATION_LIBRARY";
            case 3L: return "FILENAME_LOCATION_NOT_EXIST";
            default: return "";
        }
    }

    std::string FileNameLocation(int64_t i, const std::string &strip) {
        std::string s = FileNameLocation(i);
        if (s.empty())
            s = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FileNameLocation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyStringUtilityFileNameLocation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::StringUtility::FileNameLocation(i);
        if (retval.empty()) {
            retval = "(Rose::StringUtility::FileNameLocation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::StringUtility::FileNameLocation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyStringUtilityFileNameLocation() {
        return stringify::Rose::StringUtility::FileNameLocation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/asmUnparser/AsmUnparser.h line 259
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace AsmUnparser {
    const char* Organization(int64_t i) {
        switch (i) {
            case 0L: return "ORGANIZED_BY_AST";
            case 1L: return "ORGANIZED_BY_ADDRESS";
            default: return "";
        }
    }

    std::string Organization(int64_t i, const std::string &strip) {
        std::string s = Organization(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::AsmUnparser::Organization)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Organization() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAsmUnparserOrganization(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::AsmUnparser::Organization(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::AsmUnparser::Organization)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::AsmUnparser::Organization::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAsmUnparserOrganization() {
        return stringify::Rose::BinaryAnalysis::AsmUnparser::Organization();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/formatSupport/unparse_format.h line 51
namespace stringify {
    const char* Format_Opt(int64_t i) {
        switch (i) {
            case 0L: return "FORMAT_BEFORE_DIRECTIVE";
            case 1L: return "FORMAT_AFTER_DIRECTIVE";
            case 2L: return "FORMAT_BEFORE_STMT";
            case 3L: return "FORMAT_AFTER_STMT";
            case 4L: return "FORMAT_BEFORE_BASIC_BLOCK1";
            case 5L: return "FORMAT_AFTER_BASIC_BLOCK1";
            case 6L: return "FORMAT_BEFORE_BASIC_BLOCK2";
            case 7L: return "FORMAT_AFTER_BASIC_BLOCK2";
            case 8L: return "FORMAT_BEFORE_NESTED_STATEMENT";
            case 9L: return "FORMAT_AFTER_NESTED_STATEMENT";
            default: return "";
        }
    }

    std::string Format_Opt(int64_t i, const std::string &strip) {
        std::string s = Format_Opt(i);
        if (s.empty())
            s = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format_Opt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFormat_Opt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Format_Opt(i);
        if (retval.empty()) {
            retval = "(Format_Opt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Format_Opt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormat_Opt() {
        return stringify::Format_Opt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 19
namespace stringify {
    const char* AssociativitySpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_assoc_none";
            case 1L: return "e_assoc_right";
            case 2L: return "e_assoc_left";
            case 3L: return "e_assoc_last";
            default: return "";
        }
    }

    std::string AssociativitySpecifier(int64_t i, const std::string &strip) {
        std::string s = AssociativitySpecifier(i);
        if (s.empty())
            s = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AssociativitySpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyAssociativitySpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AssociativitySpecifier(i);
        if (retval.empty()) {
            retval = "(AssociativitySpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AssociativitySpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAssociativitySpecifier() {
        return stringify::AssociativitySpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 40
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* token_sequence_position_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_leading_whitespace_start";
            case 1L: return "e_leading_whitespace_end";
            case 2L: return "e_token_subsequence_start";
            case 3L: return "e_token_subsequence_end";
            case 4L: return "e_trailing_whitespace_start";
            case 5L: return "e_trailing_whitespace_end";
            case 6L: return "e_else_whitespace_start";
            case 7L: return "e_else_whitespace_end";
            default: return "";
        }
    }

    std::string token_sequence_position_enum_type(int64_t i, const std::string &strip) {
        std::string s = token_sequence_position_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& token_sequence_position_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::token_sequence_position_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h line 66
namespace stringify { namespace UnparseLanguageIndependentConstructs {
    const char* unparsed_as_enum_type(int64_t i) {
        switch (i) {
            case 0L: return "e_unparsed_as_error";
            case 1L: return "e_unparsed_as_AST";
            case 2L: return "e_unparsed_as_partial_token_sequence";
            case 3L: return "e_unparsed_as_token_stream";
            case 4L: return "e_unparsed_as_last";
            default: return "";
        }
    }

    std::string unparsed_as_enum_type(int64_t i, const std::string &strip) {
        std::string s = unparsed_as_enum_type(i);
        if (s.empty())
            s = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparsed_as_enum_type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type(i);
        if (retval.empty()) {
            retval = "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type() {
        return stringify::UnparseLanguageIndependentConstructs::unparsed_as_enum_type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Sarif/BasicTypes.h line 15
namespace stringify { namespace Rose { namespace Sarif {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "PASS";
            case 1L: return "OPEN";
            case 2L: return "INFORMATIONAL";
            case 3L: return "NOT_APPLICABLE";
            case 4L: return "REVIEW";
            case 5L: return "FAIL";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(Rose::Sarif::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySarifKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Sarif::Kind(i);
        if (retval.empty()) {
            retval = "(Rose::Sarif::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Sarif::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySarifKind() {
        return stringify::Rose::Sarif::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Sarif/BasicTypes.h line 25
namespace stringify { namespace Rose { namespace Sarif {
    const char* Severity(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "NOTE";
            case 2L: return "WARNING";
            case 3L: return "ERROR";
            default: return "";
        }
    }

    std::string Severity(int64_t i, const std::string &strip) {
        std::string s = Severity(i);
        if (s.empty())
            s = "(Rose::Sarif::Severity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Severity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySarifSeverity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Sarif::Severity(i);
        if (retval.empty()) {
            retval = "(Rose::Sarif::Severity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Sarif::Severity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySarifSeverity() {
        return stringify::Rose::Sarif::Severity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/FormattedTable.h line 22
namespace stringify { namespace Rose { namespace FormattedTable {
    const char* Format(int64_t i) {
        switch (i) {
            case 0L: return "PLAIN";
            case 1L: return "HTML";
            case 2L: return "CSV";
            case 3L: return "SHELL";
            default: return "";
        }
    }

    std::string Format(int64_t i, const std::string &strip) {
        std::string s = Format(i);
        if (s.empty())
            s = "(Rose::FormattedTable::Format)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFormattedTableFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::FormattedTable::Format(i);
        if (retval.empty()) {
            retval = "(Rose::FormattedTable::Format)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::FormattedTable::Format::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormattedTableFormat() {
        return stringify::Rose::FormattedTable::Format();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/FormattedTable.h line 35
namespace stringify { namespace Rose { namespace FormattedTable {
    const char* Alignment(int64_t i) {
        switch (i) {
            case 0L: return "LEFT";
            case 1L: return "RIGHT";
            case 2L: return "CENTER";
            default: return "";
        }
    }

    std::string Alignment(int64_t i, const std::string &strip) {
        std::string s = Alignment(i);
        if (s.empty())
            s = "(Rose::FormattedTable::Alignment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Alignment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyFormattedTableAlignment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::FormattedTable::Alignment(i);
        if (retval.empty()) {
            retval = "(Rose::FormattedTable::Alignment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::FormattedTable::Alignment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFormattedTableAlignment() {
        return stringify::Rose::FormattedTable::Alignment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 22
namespace stringify { namespace Rose { namespace Color {
    const char* Enabled(int64_t i) {
        switch (i) {
            case 0L: return "OFF";
            case 1L: return "ON";
            case 2L: return "AUTO";
            default: return "";
        }
    }

    std::string Enabled(int64_t i, const std::string &strip) {
        std::string s = Enabled(i);
        if (s.empty())
            s = "(Rose::Color::Enabled)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Enabled() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorEnabled(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Enabled(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Enabled)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Enabled::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorEnabled() {
        return stringify::Rose::Color::Enabled();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 31
namespace stringify { namespace Rose { namespace Color {
    const char* Theme(int64_t i) {
        switch (i) {
            case 0L: return "DARK_ON_LIGHT";
            case 1L: return "LIGHT_ON_DARK";
            default: return "";
        }
    }

    std::string Theme(int64_t i, const std::string &strip) {
        std::string s = Theme(i);
        if (s.empty())
            s = "(Rose::Color::Theme)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Theme() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorTheme(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Theme(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Theme)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Theme::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorTheme() {
        return stringify::Rose::Color::Theme();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 49
namespace stringify { namespace Rose { namespace Color {
    const char* Layer(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "FOREGROUND";
            case 2L: return "BACKGROUND";
            default: return "";
        }
    }

    std::string Layer(int64_t i, const std::string &strip) {
        std::string s = Layer(i);
        if (s.empty())
            s = "(Rose::Color::Layer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Layer() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorLayer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::Layer(i);
        if (retval.empty()) {
            retval = "(Rose::Color::Layer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::Layer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorLayer() {
        return stringify::Rose::Color::Layer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Color.h line 366
namespace stringify { namespace Rose { namespace Color {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "CLEAR";
            case 1L: return "RED";
            case 2L: return "GREEN";
            case 3L: return "YELLOW";
            case 4L: return "BLUE";
            case 5L: return "MAGENTA";
            case 6L: return "CYAN";
            case 7L: return "GRAY";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyColorAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Color::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Rose::Color::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Color::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyColorAnsiColor() {
        return stringify::Rose::Color::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CommandLine/SuffixMultiplierParser.h line 36
namespace stringify { namespace Rose { namespace CommandLine { namespace SuffixMultiplierParser {
    const char* Preferred(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Preferred(int64_t i, const std::string &strip) {
        std::string s = Preferred(i);
        if (s.empty())
            s = "(Rose::CommandLine::SuffixMultiplierParser::Preferred)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Preferred() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineSuffixMultiplierParserPreferred(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::SuffixMultiplierParser::Preferred(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::SuffixMultiplierParser::Preferred)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::SuffixMultiplierParser::Preferred::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineSuffixMultiplierParserPreferred() {
        return stringify::Rose::CommandLine::SuffixMultiplierParser::Preferred();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CommandLine/Parser.C line 32
namespace stringify { namespace Rose { namespace CommandLine { namespace FailedAssertionBehaviorAdjuster {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "ABORT_ON_FAILURE";
            case 1L: return "EXIT_ON_FAILURE";
            case 2L: return "THROW_ON_FAILURE";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCommandLineFailedAssertionBehaviorAdjusterBehavior() {
        return stringify::Rose::CommandLine::FailedAssertionBehaviorAdjuster::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/CodeGen/Object.h line 12
namespace stringify { namespace Rose { namespace CodeGen {
    const char* Object(int64_t i) {
        switch (i) {
            case 0L: return "a_namespace";
            case 1L: return "a_class";
            case 2L: return "a_typedef";
            case 3L: return "a_variable";
            case 4L: return "a_function";
            default: return "";
        }
    }

    std::string Object(int64_t i, const std::string &strip) {
        std::string s = Object(i);
        if (s.empty())
            s = "(Rose::CodeGen::Object)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Object() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCodeGenObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::CodeGen::Object(i);
        if (retval.empty()) {
            retval = "(Rose::CodeGen::Object)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::CodeGen::Object::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCodeGenObject() {
        return stringify::Rose::CodeGen::Object();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Defect.h line 27
namespace stringify { namespace Rose { namespace AST { namespace Defects {
    const char* Kind(int64_t i) {
        switch (i) {
            case 0L: return "any";
            case 1L: return "integrity_edges";
            case 2L: return "integrity_declarations";
            case 3L: return "integrity_symbols";
            case 4L: return "integrity_types";
            default: return "";
        }
    }

    std::string Kind(int64_t i, const std::string &strip) {
        std::string s = Kind(i);
        if (s.empty())
            s = "(Rose::AST::Defects::Kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_DefectsKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Defects::Kind(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Defects::Kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Defects::Kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_DefectsKind() {
        return stringify::Rose::AST::Defects::Kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Defect.h line 117
namespace stringify { namespace Rose { namespace AST { namespace Defects {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "invalid";
            case 1L: return "incompatible";
            case 2L: return "unallocated";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(Rose::AST::Defects::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_DefectsReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Defects::Reason(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Defects::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Defects::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_DefectsReason() {
        return stringify::Rose::AST::Defects::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 25
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace graphviz_t {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "tree";
            case 1L: return "graph";
            case 2L: return "unknown";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::graphviz_t::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_graphviz_tMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::graphviz_t::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::graphviz_t::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::graphviz_t::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_graphviz_tMode() {
        return stringify::Rose::AST::cmdline::graphviz_t::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 43
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace checker_t {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "all";
            case 1L: return "integrity";
            case 2L: return "integrity_edges";
            case 3L: return "integrity_declarations";
            case 4L: return "integrity_symbols";
            case 5L: return "integrity_types";
            case 6L: return "consistency";
            case 7L: return "unknown";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::checker_t::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_checker_tMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::checker_t::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::checker_t::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::checker_t::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_checker_tMode() {
        return stringify::Rose::AST::cmdline::checker_t::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/cmdline.h line 54
namespace stringify { namespace Rose { namespace AST { namespace cmdline { namespace checker_t {
    const char* Effect(int64_t i) {
        switch (i) {
            case 0L: return "none";
            case 1L: return "summary";
            case 2L: return "report";
            case 3L: return "fail";
            case 4L: return "unknown";
            default: return "";
        }
    }

    std::string Effect(int64_t i, const std::string &strip) {
        std::string s = Effect(i);
        if (s.empty())
            s = "(Rose::AST::cmdline::checker_t::Effect)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Effect() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyASTcmdline_checker_tEffect(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::cmdline::checker_t::Effect(i);
        if (retval.empty()) {
            retval = "(Rose::AST::cmdline::checker_t::Effect)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::cmdline::checker_t::Effect::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyASTcmdline_checker_tEffect() {
        return stringify::Rose::AST::cmdline::checker_t::Effect();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/AST/Traversal.h line 19
namespace stringify { namespace Rose { namespace AST { namespace Traversal {
    const char* Order(int64_t i) {
        switch (i) {
            case 1L: return "PRE";
            case 2L: return "POST";
            default: return "";
        }
    }

    std::string Order(int64_t i, const std::string &strip) {
        std::string s = Order(i);
        if (s.empty())
            s = "(Rose::AST::Traversal::Order)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Order() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyAST_TraversalOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::AST::Traversal::Order(i);
        if (retval.empty()) {
            retval = "(Rose::AST::Traversal::Order)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::AST::Traversal::Order::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAST_TraversalOrder() {
        return stringify::Rose::AST::Traversal::Order();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SRecord.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Syntax(int64_t i) {
        switch (i) {
            case 0L: return "SREC_MOTOROLA";
            case 1L: return "SREC_INTEL";
            case 2L: return "SREC_UNKNOWN_SYNTAX";
            default: return "";
        }
    }

    std::string Syntax(int64_t i, const std::string &strip) {
        std::string s = Syntax(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Syntax() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordSyntax(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Syntax(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Syntax)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Syntax::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordSyntax() {
        return stringify::Rose::BinaryAnalysis::SRecord::Syntax();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SRecord.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SRecord {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "SREC_M_HEADER";
            case 1L: return "SREC_M_DATA16";
            case 2L: return "SREC_M_DATA24";
            case 3L: return "SREC_M_DATA32";
            case 4L: return "SREC_M_RESERVED";
            case 5L: return "SREC_M_COUNT16";
            case 6L: return "SREC_M_COUNT24";
            case 7L: return "SREC_M_START32";
            case 8L: return "SREC_M_START24";
            case 9L: return "SREC_M_START16";
            case 10L: return "SREC_I_DATA";
            case 11L: return "SREC_I_END";
            case 12L: return "SREC_I_EXTENDED_SA";
            case 13L: return "SREC_I_START_SA";
            case 14L: return "SREC_I_EXTENDED_LA";
            case 15L: return "SREC_I_START_LA";
            case 16L: return "SREC_UNKNOWN_TYPE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SRecord::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SRecord::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SRecord::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSRecordType() {
        return stringify::Rose::BinaryAnalysis::SRecord::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/RegisterDictionary.h line 314
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace RegisterDictionary { namespace SortBySize {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "ASCENDING";
            case 1L: return "DESCENDING";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisRegisterDictionarySortBySizeDirection() {
        return stringify::Rose::BinaryAnalysis::RegisterDictionary::SortBySize::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/TaintedFlow.h line 24
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Taintedness(int64_t i) {
        switch (i) {
            case 0L: return "BOTTOM";
            case 1L: return "NOT_TAINTED";
            case 2L: return "TAINTED";
            case 3L: return "TOP";
            default: return "";
        }
    }

    std::string Taintedness(int64_t i, const std::string &strip) {
        std::string s = Taintedness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Taintedness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowTaintedness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Taintedness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Taintedness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowTaintedness() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Taintedness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/TaintedFlow.h line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace TaintedFlow {
    const char* Approximation(int64_t i) {
        switch (i) {
            case 0L: return "UNDER_APPROXIMATE";
            case 1L: return "OVER_APPROXIMATE";
            default: return "";
        }
    }

    std::string Approximation(int64_t i, const std::string &strip) {
        std::string s = Approximation(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Approximation() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisTaintedFlowApproximation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::TaintedFlow::Approximation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::TaintedFlow::Approximation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisTaintedFlowApproximation() {
        return stringify::Rose::BinaryAnalysis::TaintedFlow::Approximation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ByteOrder.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ByteOrder {
    const char* Endianness(int64_t i) {
        switch (i) {
            case 0L: return "ORDER_UNSPECIFIED";
            case 1L: return "ORDER_LSB";
            case 2L: return "ORDER_MSB";
            default: return "";
        }
    }

    std::string Endianness(int64_t i, const std::string &strip) {
        std::string s = Endianness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Endianness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisByteOrderEndianness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ByteOrder::Endianness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ByteOrder::Endianness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ByteOrder::Endianness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisByteOrderEndianness() {
        return stringify::Rose::BinaryAnalysis::ByteOrder::Endianness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Commit {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCommitBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Commit::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Commit::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Commit::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCommitBoolean() {
        return stringify::Rose::BinaryAnalysis::Commit::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* AggregationDirection(int64_t i) {
        switch (i) {
            case 1L: return "AGGREGATE_PREDECESSORS";
            case 2L: return "AGGREGATE_SUCCESSORS";
            default: return "";
        }
    }

    std::string AggregationDirection(int64_t i, const std::string &strip) {
        std::string s = AggregationDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AggregationDirection() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterAggregationDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::AggregationDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::AggregationDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterAggregationDirection() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::AggregationDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* NopPadding(int64_t i) {
        switch (i) {
            case 0L: return "PAD_NOP_BACK";
            case 1L: return "PAD_NOP_FRONT";
            case 2L: return "PAD_RANDOM_BACK";
            default: return "";
        }
    }

    std::string NopPadding(int64_t i, const std::string &strip) {
        std::string s = NopPadding(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& NopPadding() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterNopPadding(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::NopPadding)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::NopPadding::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterNopPadding() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::NopPadding();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CodeInserter.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CodeInserter {
    const char* RelocType(int64_t i) {
        switch (i) {
            case 0L: return "RELOC_INDEX_ABS_LE32";
            case 1L: return "RELOC_INDEX_ABS_LE32HI";
            case 2L: return "RELOC_INDEX_ABS_BE32";
            case 3L: return "RELOC_ADDR_REL_LE32";
            case 4L: return "RELOC_ADDR_REL_BE32";
            case 5L: return "RELOC_INSN_ABS_LE32";
            case 6L: return "RELOC_INSN_REL_LE32";
            case 7L: return "RELOC_INSN_REL_BE32";
            default: return "";
        }
    }

    std::string RelocType(int64_t i, const std::string &strip) {
        std::string s = RelocType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RelocType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCodeInserterRelocType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CodeInserter::RelocType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CodeInserter::RelocType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CodeInserter::RelocType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCodeInserterRelocType() {
        return stringify::Rose::BinaryAnalysis::CodeInserter::RelocType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherAarch32.h line 159
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherAarch32 {
    const char* SrType(int64_t i) {
        switch (i) {
            case 0L: return "LSL";
            case 1L: return "LSR";
            case 2L: return "ASR";
            case 3L: return "ROR";
            case 4L: return "RRX";
            default: return "";
        }
    }

    std::string SrType(int64_t i, const std::string &strip) {
        std::string s = SrType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SrType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32SrType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32SrType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::SrType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherAarch32.h line 160
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherAarch32 {
    const char* BranchType(int64_t i) {
        switch (i) {
            case 0L: return "DIRCALL";
            case 1L: return "DIR";
            case 2L: return "INDCALL";
            case 3L: return "ERET";
            case 4L: return "DBGEXIT";
            case 5L: return "RET";
            case 6L: return "INDIR";
            case 7L: return "EXCEPTION";
            case 8L: return "RESET";
            case 9L: return "UNKNOWN";
            default: return "";
        }
    }

    std::string BranchType(int64_t i, const std::string &strip) {
        std::string s = BranchType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BranchType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32BranchType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherAarch32BranchType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherAarch32::BranchType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DataFlowSemantics.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DataFlowSemantics { namespace DataFlowEdge {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 0L: return "CLOBBER";
            case 1L: return "AUGMENT";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDataFlowSemanticsDataFlowEdgeEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDataFlowSemanticsDataFlowEdgeEdgeType() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DataFlowSemantics::DataFlowEdge::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/TaintSemantics.h line 17
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace TaintSemantics {
    const char* Taintedness(int64_t i) {
        switch (i) {
            case 0L: return "BOTTOM";
            case 1L: return "UNTAINTED";
            case 2L: return "TAINTED";
            case 3L: return "TOP";
            default: return "";
        }
    }

    std::string Taintedness(int64_t i, const std::string &strip) {
        std::string s = Taintedness(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Taintedness() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsTaintSemanticsTaintedness(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsTaintSemanticsTaintedness() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::TaintSemantics::Taintedness();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/IntervalSemantics.C line 924
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace IntervalSemantics {
    const char* Carry(int64_t i) {
        switch (i) {
            case 0L: return "C_FALSE";
            case 1L: return "C_TRUE";
            case 2L: return "C_UNKNOWN";
            default: return "";
        }
    }

    std::string Carry(int64_t i, const std::string &strip) {
        std::string s = Carry(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Carry() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsCarry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsCarry() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::IntervalSemantics::Carry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherX86.h line 157
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace DispatcherX86 {
    const char* AccessMode(int64_t i) {
        switch (i) {
            case 0L: return "READ_REGISTER";
            case 1L: return "PEEK_REGISTER";
            default: return "";
        }
    }

    std::string AccessMode(int64_t i, const std::string &strip) {
        std::string s = AccessMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AccessMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsDispatcherX86AccessMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsDispatcherX86AccessMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::DispatcherX86::AccessMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherPowerpc.C line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace UpdateCr {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsUpdateCrFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsUpdateCrFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::UpdateCr::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/DispatcherPowerpc.C line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SaveLink {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSaveLinkFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSaveLinkFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SaveLink::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/RiscOperators.h line 483
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace BaseSemantics { namespace RiscOperators {
    const char* IteStatus(int64_t i) {
        switch (i) {
            case 0L: return "NEITHER";
            case 1L: return "A";
            case 2L: return "B";
            case 3L: return "BOTH";
            default: return "";
        }
    }

    std::string IteStatus(int64_t i, const std::string &strip) {
        std::string s = IteStatus(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IteStatus() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsRiscOperatorsIteStatus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsRiscOperatorsIteStatus() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators::IteStatus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/BasicTypes.h line 88
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace BaseSemantics {
    const char* InputOutputProperty(int64_t i) {
        switch (i) {
            case 0L: return "IO_READ";
            case 1L: return "IO_WRITE";
            case 2L: return "IO_INIT";
            case 3L: return "IO_READ_BEFORE_WRITE";
            case 4L: return "IO_READ_AFTER_WRITE";
            case 5L: return "IO_READ_UNINITIALIZED";
            default: return "";
        }
    }

    std::string InputOutputProperty(int64_t i, const std::string &strip) {
        std::string s = InputOutputProperty(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InputOutputProperty() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsInputOutputProperty(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsBaseSemanticsInputOutputProperty() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::InputOutputProperty();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 67
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics { namespace AllowSideEffects {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsAllowSideEffectsFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsAllowSideEffectsFlag() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::AllowSideEffects::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 703
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics {
    const char* WritersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_WRITERS";
            case 1L: return "TRACK_LATEST_WRITER";
            case 2L: return "TRACK_ALL_WRITERS";
            default: return "";
        }
    }

    std::string WritersMode(int64_t i, const std::string &strip) {
        std::string s = WritersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WritersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsWritersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsWritersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::WritersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionSemantics/SymbolicSemantics.h line 710
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace InstructionSemantics { namespace SymbolicSemantics {
    const char* DefinersMode(int64_t i) {
        switch (i) {
            case 0L: return "TRACK_NO_DEFINERS";
            case 1L: return "TRACK_LATEST_DEFINER";
            case 2L: return "TRACK_ALL_DEFINERS";
            default: return "";
        }
    }

    std::string DefinersMode(int64_t i, const std::string &strip) {
        std::string s = DefinersMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DefinersMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsDefinersMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisInstructionSemanticsSymbolicSemanticsDefinersMode() {
        return stringify::Rose::BinaryAnalysis::InstructionSemantics::SymbolicSemantics::DefinersMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace TypeStyle {
    const char* Flag(int64_t i) {
        switch (i) {
            case 0L: return "FULL";
            case 1L: return "ABBREVIATED";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionTypeStyleFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionTypeStyleFlag() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::TypeStyle::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 77
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression {
    const char* Operator(int64_t i) {
        switch (i) {
            case 0L: return "OP_ADD";
            case 1L: return "OP_AND";
            case 2L: return "OP_ASR";
            case 3L: return "OP_CONCAT";
            case 4L: return "OP_EQ";
            case 5L: return "OP_EXTRACT";
            case 6L: return "OP_INVERT";
            case 7L: return "OP_ITE";
            case 8L: return "OP_LET";
            case 9L: return "OP_LSSB";
            case 10L: return "OP_MSSB";
            case 11L: return "OP_NE";
            case 12L: return "OP_NEGATE";
            case 13L: return "OP_NOOP";
            case 14L: return "OP_OR";
            case 15L: return "OP_READ";
            case 16L: return "OP_ROL";
            case 17L: return "OP_ROR";
            case 18L: return "OP_SDIV";
            case 19L: return "OP_SET";
            case 20L: return "OP_SEXTEND";
            case 21L: return "OP_SGE";
            case 22L: return "OP_SGT";
            case 23L: return "OP_SHL0";
            case 24L: return "OP_SHL1";
            case 25L: return "OP_SHR0";
            case 26L: return "OP_SHR1";
            case 27L: return "OP_SLE";
            case 28L: return "OP_SLT";
            case 29L: return "OP_SMOD";
            case 30L: return "OP_SMUL";
            case 31L: return "OP_UDIV";
            case 32L: return "OP_UEXTEND";
            case 33L: return "OP_UGE";
            case 34L: return "OP_UGT";
            case 35L: return "OP_ULE";
            case 36L: return "OP_ULT";
            case 37L: return "OP_UMOD";
            case 38L: return "OP_UMUL";
            case 39L: return "OP_WRITE";
            case 40L: return "OP_XOR";
            case 41L: return "OP_ZEROP";
            case 42L: return "OP_FP_ABS";
            case 43L: return "OP_FP_NEGATE";
            case 44L: return "OP_FP_ADD";
            case 45L: return "OP_FP_MUL";
            case 46L: return "OP_FP_DIV";
            case 47L: return "OP_FP_MULADD";
            case 48L: return "OP_FP_SQRT";
            case 49L: return "OP_FP_MOD";
            case 50L: return "OP_FP_ROUND";
            case 51L: return "OP_FP_MIN";
            case 52L: return "OP_FP_MAX";
            case 53L: return "OP_FP_LE";
            case 54L: return "OP_FP_LT";
            case 55L: return "OP_FP_GE";
            case 56L: return "OP_FP_GT";
            case 57L: return "OP_FP_EQ";
            case 58L: return "OP_FP_ISNORM";
            case 59L: return "OP_FP_ISSUBNORM";
            case 60L: return "OP_FP_ISZERO";
            case 61L: return "OP_FP_ISINFINITE";
            case 62L: return "OP_FP_ISNAN";
            case 63L: return "OP_FP_ISNEG";
            case 64L: return "OP_FP_ISPOS";
            case 65L: return "OP_CONVERT";
            case 66L: return "OP_REINTERPRET";
            case 67L: return "OP_NONE";
            default: return "";
        }
    }

    std::string Operator(int64_t i, const std::string &strip) {
        std::string s = Operator(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Operator)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Operator() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L
        };
        static const std::vector<int64_t> retval(values, values + 68);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionOperator(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Operator(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Operator)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Operator::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionOperator() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Operator();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 162
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace Formatter {
    const char* ShowComments(int64_t i) {
        switch (i) {
            case 0L: return "CMT_SILENT";
            case 1L: return "CMT_AFTER";
            case 2L: return "CMT_INSTEAD";
            case 3L: return "CMT_BEFORE";
            default: return "";
        }
    }

    std::string ShowComments(int64_t i, const std::string &strip) {
        std::string s = ShowComments(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowComments() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionFormatterShowComments(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionFormatterShowComments() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Formatter::ShowComments();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 183
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression {
    const char* VisitAction(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE";
            case 1L: return "TRUNCATE";
            case 2L: return "TERMINATE";
            default: return "";
        }
    }

    std::string VisitAction(int64_t i, const std::string &strip) {
        std::string s = VisitAction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::VisitAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VisitAction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionVisitAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::VisitAction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::VisitAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::VisitAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionVisitAction() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::VisitAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpression.h line 225
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpression { namespace Type {
    const char* TypeClass(int64_t i) {
        switch (i) {
            case 0L: return "INTEGER";
            case 1L: return "FP";
            case 2L: return "MEMORY";
            case 3L: return "INVALID";
            default: return "";
        }
    }

    std::string TypeClass(int64_t i, const std::string &strip) {
        std::string s = TypeClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionTypeTypeClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionTypeTypeClass() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpression::Type::TypeClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SymbolicExpressionParser.h line 59
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SymbolicExpressionParser { namespace Token {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "LTPAREN";
            case 2L: return "RTPAREN";
            case 3L: return "BITVECTOR";
            case 4L: return "SYMBOL";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSymbolicExpressionParserTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSymbolicExpressionParserTokenType() {
        return stringify::Rose::BinaryAnalysis::SymbolicExpressionParser::Token::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsCil.h line 14
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* CilFamily(int64_t i) {
        switch (i) {
            case 4294967295L: return "Cil_family";
            default: return "";
        }
    }

    std::string CilFamily(int64_t i, const std::string &strip) {
        std::string s = CilFamily(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CilFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CilFamily() {
        static const int64_t values[] = {
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCilFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CilFamily(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CilFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CilFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCilFamily() {
        return stringify::Rose::BinaryAnalysis::CilFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsCil.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* CilInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "Cil_unknown_instruction";
            case 61440L: return "Cil_mono_icall";
            case 61441L: return "Cil_mono_objaddr";
            case 61442L: return "Cil_mono_ldptr";
            case 61443L: return "Cil_mono_vtaddr";
            case 61444L: return "Cil_mono_newobj";
            case 61445L: return "Cil_mono_retobj";
            case 61446L: return "Cil_mono_ldnativeobj";
            case 61447L: return "Cil_mono_cisinst";
            case 61448L: return "Cil_mono_ccastclass";
            case 61449L: return "Cil_mono_save_lmf";
            case 61450L: return "Cil_mono_restore_lmf";
            case 61451L: return "Cil_mono_classconst";
            case 61452L: return "Cil_mono_not_taken";
            case 61453L: return "Cil_mono_tls";
            case 61454L: return "Cil_mono_icall_addr";
            case 61455L: return "Cil_mono_dyn_call";
            case 61456L: return "Cil_mono_memory_barrier";
            case 61457L: return "Cil_unused71";
            case 61458L: return "Cil_unused72";
            case 61459L: return "Cil_mono_jit_icall_addr";
            case 61460L: return "Cil_mono_ldptr_int_req_flag";
            case 61461L: return "Cil_mono_ldptr_card_table";
            case 61462L: return "Cil_mono_ldptr_nursery_start";
            case 61463L: return "Cil_mono_ldptr_nursery_bits";
            case 61464L: return "Cil_mono_calli_extra_arg";
            case 61465L: return "Cil_mono_lddomain";
            case 61466L: return "Cil_mono_atomic_store_i4";
            case 61467L: return "Cil_mono_save_last_error";
            case 61468L: return "Cil_mono_get_rgctx_arg";
            case 61469L: return "Cil_mono_ldptr_prof_alloc_count";
            case 61470L: return "Cil_mono_ld_delegate_method_ptr";
            case 61471L: return "Cil_mono_rethrow";
            case 61472L: return "Cil_mono_get_sp";
            case 61473L: return "Cil_mono_methodconst";
            case 61474L: return "Cil_mono_pinvoke_addr_cache";
            case 61475L: return "Cil_last_instruction";
            case 65024L: return "Cil_arglist";
            case 65025L: return "Cil_ceq";
            case 65026L: return "Cil_cgt";
            case 65027L: return "Cil_cgt_un";
            case 65028L: return "Cil_clt";
            case 65029L: return "Cil_clt_un";
            case 65030L: return "Cil_ldftn";
            case 65031L: return "Cil_ldvirtftn";
            case 65032L: return "Cil_unused56";
            case 65033L: return "Cil_ldarg";
            case 65034L: return "Cil_ldarga";
            case 65035L: return "Cil_starg";
            case 65036L: return "Cil_ldloc";
            case 65037L: return "Cil_ldloca";
            case 65038L: return "Cil_stloc";
            case 65039L: return "Cil_localloc";
            case 65040L: return "Cil_unused57";
            case 65041L: return "Cil_endfilter";
            case 65042L: return "Cil_unaligned_";
            case 65043L: return "Cil_volatile_";
            case 65044L: return "Cil_tail_";
            case 65045L: return "Cil_initobj";
            case 65046L: return "Cil_constrained_";
            case 65047L: return "Cil_cpblk";
            case 65048L: return "Cil_initblk";
            case 65049L: return "Cil_no_";
            case 65050L: return "Cil_rethrow";
            case 65051L: return "Cil_unused";
            case 65052L: return "Cil_sizeof";
            case 65053L: return "Cil_refanytype";
            case 65054L: return "Cil_readonly_";
            case 65055L: return "Cil_unused53";
            case 65056L: return "Cil_unused54";
            case 65057L: return "Cil_unused55";
            case 65058L: return "Cil_unused70";
            case 65280L: return "Cil_nop";
            case 65281L: return "Cil_break";
            case 65282L: return "Cil_ldarg_0";
            case 65283L: return "Cil_ldarg_1";
            case 65284L: return "Cil_ldarg_2";
            case 65285L: return "Cil_ldarg_3";
            case 65286L: return "Cil_ldloc_0";
            case 65287L: return "Cil_ldloc_1";
            case 65288L: return "Cil_ldloc_2";
            case 65289L: return "Cil_ldloc_3";
            case 65290L: return "Cil_stloc_0";
            case 65291L: return "Cil_stloc_1";
            case 65292L: return "Cil_stloc_2";
            case 65293L: return "Cil_stloc_3";
            case 65294L: return "Cil_ldarg_s";
            case 65295L: return "Cil_ldarga_s";
            case 65296L: return "Cil_starg_s";
            case 65297L: return "Cil_ldloc_s";
            case 65298L: return "Cil_ldloca_s";
            case 65299L: return "Cil_stloc_s";
            case 65300L: return "Cil_ldnull";
            case 65301L: return "Cil_ldc_i4_m1";
            case 65302L: return "Cil_ldc_i4_0";
            case 65303L: return "Cil_ldc_i4_1";
            case 65304L: return "Cil_ldc_i4_2";
            case 65305L: return "Cil_ldc_i4_3";
            case 65306L: return "Cil_ldc_i4_4";
            case 65307L: return "Cil_ldc_i4_5";
            case 65308L: return "Cil_ldc_i4_6";
            case 65309L: return "Cil_ldc_i4_7";
            case 65310L: return "Cil_ldc_i4_8";
            case 65311L: return "Cil_ldc_i4_s";
            case 65312L: return "Cil_ldc_i4";
            case 65313L: return "Cil_ldc_i8";
            case 65314L: return "Cil_ldc_r4";
            case 65315L: return "Cil_ldc_r8";
            case 65316L: return "Cil_unused99";
            case 65317L: return "Cil_dup";
            case 65318L: return "Cil_pop";
            case 65319L: return "Cil_jmp";
            case 65320L: return "Cil_call";
            case 65321L: return "Cil_calli";
            case 65322L: return "Cil_ret";
            case 65323L: return "Cil_br_s";
            case 65324L: return "Cil_brfalse_s";
            case 65325L: return "Cil_brtrue_s";
            case 65326L: return "Cil_beq_s";
            case 65327L: return "Cil_bge_s";
            case 65328L: return "Cil_bgt_s";
            case 65329L: return "Cil_ble_s";
            case 65330L: return "Cil_blt_s";
            case 65331L: return "Cil_bne_un_s";
            case 65332L: return "Cil_bge_un_s";
            case 65333L: return "Cil_bgt_un_s";
            case 65334L: return "Cil_ble_un_s";
            case 65335L: return "Cil_blt_un_s";
            case 65336L: return "Cil_br";
            case 65337L: return "Cil_brfalse";
            case 65338L: return "Cil_brtrue";
            case 65339L: return "Cil_beq";
            case 65340L: return "Cil_bge";
            case 65341L: return "Cil_bgt";
            case 65342L: return "Cil_ble";
            case 65343L: return "Cil_blt";
            case 65344L: return "Cil_bne_un";
            case 65345L: return "Cil_bge_un";
            case 65346L: return "Cil_bgt_un";
            case 65347L: return "Cil_ble_un";
            case 65348L: return "Cil_blt_un";
            case 65349L: return "Cil_switch";
            case 65350L: return "Cil_ldind_i1";
            case 65351L: return "Cil_ldind_u1";
            case 65352L: return "Cil_ldind_i2";
            case 65353L: return "Cil_ldind_u2";
            case 65354L: return "Cil_ldind_i4";
            case 65355L: return "Cil_ldind_u4";
            case 65356L: return "Cil_ldind_i8";
            case 65357L: return "Cil_ldind_i";
            case 65358L: return "Cil_ldind_r4";
            case 65359L: return "Cil_ldind_r8";
            case 65360L: return "Cil_ldind_ref";
            case 65361L: return "Cil_stind_ref";
            case 65362L: return "Cil_stind_i1";
            case 65363L: return "Cil_stind_i2";
            case 65364L: return "Cil_stind_i4";
            case 65365L: return "Cil_stind_i8";
            case 65366L: return "Cil_stind_r4";
            case 65367L: return "Cil_stind_r8";
            case 65368L: return "Cil_add";
            case 65369L: return "Cil_sub";
            case 65370L: return "Cil_mul";
            case 65371L: return "Cil_div";
            case 65372L: return "Cil_div_un";
            case 65373L: return "Cil_rem";
            case 65374L: return "Cil_rem_un";
            case 65375L: return "Cil_and";
            case 65376L: return "Cil_or";
            case 65377L: return "Cil_xor";
            case 65378L: return "Cil_shl";
            case 65379L: return "Cil_shr";
            case 65380L: return "Cil_shr_un";
            case 65381L: return "Cil_neg";
            case 65382L: return "Cil_not";
            case 65383L: return "Cil_conv_i1";
            case 65384L: return "Cil_conv_i2";
            case 65385L: return "Cil_conv_i4";
            case 65386L: return "Cil_conv_i8";
            case 65387L: return "Cil_conv_r4";
            case 65388L: return "Cil_conv_r8";
            case 65389L: return "Cil_conv_u4";
            case 65390L: return "Cil_conv_u8";
            case 65391L: return "Cil_callvirt";
            case 65392L: return "Cil_cpobj";
            case 65393L: return "Cil_ldobj";
            case 65394L: return "Cil_ldstr";
            case 65395L: return "Cil_newobj";
            case 65396L: return "Cil_castclass";
            case 65397L: return "Cil_isinst";
            case 65398L: return "Cil_conv_r_un";
            case 65399L: return "Cil_unused58";
            case 65400L: return "Cil_unused1";
            case 65401L: return "Cil_unbox";
            case 65402L: return "Cil_throw";
            case 65403L: return "Cil_ldfld";
            case 65404L: return "Cil_ldflda";
            case 65405L: return "Cil_stfld";
            case 65406L: return "Cil_ldsfld";
            case 65407L: return "Cil_ldsflda";
            case 65408L: return "Cil_stsfld";
            case 65409L: return "Cil_stobj";
            case 65410L: return "Cil_conv_ovf_i1_un";
            case 65411L: return "Cil_conv_ovf_i2_un";
            case 65412L: return "Cil_conv_ovf_i4_un";
            case 65413L: return "Cil_conv_ovf_i8_un";
            case 65414L: return "Cil_conv_ovf_u1_un";
            case 65415L: return "Cil_conv_ovf_u2_un";
            case 65416L: return "Cil_conv_ovf_u4_un";
            case 65417L: return "Cil_conv_ovf_u8_un";
            case 65418L: return "Cil_conv_ovf_i_un";
            case 65419L: return "Cil_conv_ovf_u_un";
            case 65420L: return "Cil_box";
            case 65421L: return "Cil_newarr";
            case 65422L: return "Cil_ldlen";
            case 65423L: return "Cil_ldelema";
            case 65424L: return "Cil_ldelem_i1";
            case 65425L: return "Cil_ldelem_u1";
            case 65426L: return "Cil_ldelem_i2";
            case 65427L: return "Cil_ldelem_u2";
            case 65428L: return "Cil_ldelem_i4";
            case 65429L: return "Cil_ldelem_u4";
            case 65430L: return "Cil_ldelem_i8";
            case 65431L: return "Cil_ldelem_i";
            case 65432L: return "Cil_ldelem_r4";
            case 65433L: return "Cil_ldelem_r8";
            case 65434L: return "Cil_ldelem_ref";
            case 65435L: return "Cil_stelem_i";
            case 65436L: return "Cil_stelem_i1";
            case 65437L: return "Cil_stelem_i2";
            case 65438L: return "Cil_stelem_i4";
            case 65439L: return "Cil_stelem_i8";
            case 65440L: return "Cil_stelem_r4";
            case 65441L: return "Cil_stelem_r8";
            case 65442L: return "Cil_stelem_ref";
            case 65443L: return "Cil_ldelem";
            case 65444L: return "Cil_stelem";
            case 65445L: return "Cil_unbox_any";
            case 65446L: return "Cil_unused5";
            case 65447L: return "Cil_unused6";
            case 65448L: return "Cil_unused7";
            case 65449L: return "Cil_unused8";
            case 65450L: return "Cil_unused9";
            case 65451L: return "Cil_unused10";
            case 65452L: return "Cil_unused11";
            case 65453L: return "Cil_unused12";
            case 65454L: return "Cil_unused13";
            case 65455L: return "Cil_unused14";
            case 65456L: return "Cil_unused15";
            case 65457L: return "Cil_unused16";
            case 65458L: return "Cil_unused17";
            case 65459L: return "Cil_conv_ovf_i1";
            case 65460L: return "Cil_conv_ovf_u1";
            case 65461L: return "Cil_conv_ovf_i2";
            case 65462L: return "Cil_conv_ovf_u2";
            case 65463L: return "Cil_conv_ovf_i4";
            case 65464L: return "Cil_conv_ovf_u4";
            case 65465L: return "Cil_conv_ovf_i8";
            case 65466L: return "Cil_conv_ovf_u8";
            case 65467L: return "Cil_unused50";
            case 65468L: return "Cil_unused18";
            case 65469L: return "Cil_unused19";
            case 65470L: return "Cil_unused20";
            case 65471L: return "Cil_unused21";
            case 65472L: return "Cil_unused22";
            case 65473L: return "Cil_unused23";
            case 65474L: return "Cil_refanyval";
            case 65475L: return "Cil_ckfinite";
            case 65476L: return "Cil_unused24";
            case 65477L: return "Cil_unused25";
            case 65478L: return "Cil_mkrefany";
            case 65479L: return "Cil_unused59";
            case 65480L: return "Cil_unused60";
            case 65481L: return "Cil_unused61";
            case 65482L: return "Cil_unused62";
            case 65483L: return "Cil_unused63";
            case 65484L: return "Cil_unused64";
            case 65485L: return "Cil_unused65";
            case 65486L: return "Cil_unused66";
            case 65487L: return "Cil_unused67";
            case 65488L: return "Cil_ldtoken";
            case 65489L: return "Cil_conv_u2";
            case 65490L: return "Cil_conv_u1";
            case 65491L: return "Cil_conv_i";
            case 65492L: return "Cil_conv_ovf_i";
            case 65493L: return "Cil_conv_ovf_u";
            case 65494L: return "Cil_add_ovf";
            case 65495L: return "Cil_add_ovf_un";
            case 65496L: return "Cil_mul_ovf";
            case 65497L: return "Cil_mul_ovf_un";
            case 65498L: return "Cil_sub_ovf";
            case 65499L: return "Cil_sub_ovf_un";
            case 65500L: return "Cil_endfinally";
            case 65501L: return "Cil_leave";
            case 65502L: return "Cil_leave_s";
            case 65503L: return "Cil_stind_i";
            case 65504L: return "Cil_conv_u";
            case 65505L: return "Cil_unused26";
            case 65506L: return "Cil_unused27";
            case 65507L: return "Cil_unused28";
            case 65508L: return "Cil_unused29";
            case 65509L: return "Cil_unused30";
            case 65510L: return "Cil_unused31";
            case 65511L: return "Cil_unused32";
            case 65512L: return "Cil_unused33";
            case 65513L: return "Cil_unused34";
            case 65514L: return "Cil_unused35";
            case 65515L: return "Cil_unused36";
            case 65516L: return "Cil_unused37";
            case 65517L: return "Cil_unused38";
            case 65518L: return "Cil_unused39";
            case 65519L: return "Cil_unused40";
            case 65520L: return "Cil_unused41";
            case 65521L: return "Cil_unused42";
            case 65522L: return "Cil_unused43";
            case 65523L: return "Cil_unused44";
            case 65524L: return "Cil_unused45";
            case 65525L: return "Cil_unused46";
            case 65526L: return "Cil_unused47";
            case 65527L: return "Cil_unused48";
            case 65528L: return "Cil_prefix7";
            case 65529L: return "Cil_prefix6";
            case 65530L: return "Cil_prefix5";
            case 65531L: return "Cil_prefix4";
            case 65532L: return "Cil_prefix3";
            case 65533L: return "Cil_prefix2";
            case 65534L: return "Cil_prefix1";
            case 65535L: return "Cil_prefixref";
            default: return "";
        }
    }

    std::string CilInstructionKind(int64_t i, const std::string &strip) {
        std::string s = CilInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CilInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CilInstructionKind() {
        static const int64_t values[] = {
            0L,
            61440L,
            61441L,
            61442L,
            61443L,
            61444L,
            61445L,
            61446L,
            61447L,
            61448L,
            61449L,
            61450L,
            61451L,
            61452L,
            61453L,
            61454L,
            61455L,
            61456L,
            61457L,
            61458L,
            61459L,
            61460L,
            61461L,
            61462L,
            61463L,
            61464L,
            61465L,
            61466L,
            61467L,
            61468L,
            61469L,
            61470L,
            61471L,
            61472L,
            61473L,
            61474L,
            61475L,
            65024L,
            65025L,
            65026L,
            65027L,
            65028L,
            65029L,
            65030L,
            65031L,
            65032L,
            65033L,
            65034L,
            65035L,
            65036L,
            65037L,
            65038L,
            65039L,
            65040L,
            65041L,
            65042L,
            65043L,
            65044L,
            65045L,
            65046L,
            65047L,
            65048L,
            65049L,
            65050L,
            65051L,
            65052L,
            65053L,
            65054L,
            65055L,
            65056L,
            65057L,
            65058L,
            65280L,
            65281L,
            65282L,
            65283L,
            65284L,
            65285L,
            65286L,
            65287L,
            65288L,
            65289L,
            65290L,
            65291L,
            65292L,
            65293L,
            65294L,
            65295L,
            65296L,
            65297L,
            65298L,
            65299L,
            65300L,
            65301L,
            65302L,
            65303L,
            65304L,
            65305L,
            65306L,
            65307L,
            65308L,
            65309L,
            65310L,
            65311L,
            65312L,
            65313L,
            65314L,
            65315L,
            65316L,
            65317L,
            65318L,
            65319L,
            65320L,
            65321L,
            65322L,
            65323L,
            65324L,
            65325L,
            65326L,
            65327L,
            65328L,
            65329L,
            65330L,
            65331L,
            65332L,
            65333L,
            65334L,
            65335L,
            65336L,
            65337L,
            65338L,
            65339L,
            65340L,
            65341L,
            65342L,
            65343L,
            65344L,
            65345L,
            65346L,
            65347L,
            65348L,
            65349L,
            65350L,
            65351L,
            65352L,
            65353L,
            65354L,
            65355L,
            65356L,
            65357L,
            65358L,
            65359L,
            65360L,
            65361L,
            65362L,
            65363L,
            65364L,
            65365L,
            65366L,
            65367L,
            65368L,
            65369L,
            65370L,
            65371L,
            65372L,
            65373L,
            65374L,
            65375L,
            65376L,
            65377L,
            65378L,
            65379L,
            65380L,
            65381L,
            65382L,
            65383L,
            65384L,
            65385L,
            65386L,
            65387L,
            65388L,
            65389L,
            65390L,
            65391L,
            65392L,
            65393L,
            65394L,
            65395L,
            65396L,
            65397L,
            65398L,
            65399L,
            65400L,
            65401L,
            65402L,
            65403L,
            65404L,
            65405L,
            65406L,
            65407L,
            65408L,
            65409L,
            65410L,
            65411L,
            65412L,
            65413L,
            65414L,
            65415L,
            65416L,
            65417L,
            65418L,
            65419L,
            65420L,
            65421L,
            65422L,
            65423L,
            65424L,
            65425L,
            65426L,
            65427L,
            65428L,
            65429L,
            65430L,
            65431L,
            65432L,
            65433L,
            65434L,
            65435L,
            65436L,
            65437L,
            65438L,
            65439L,
            65440L,
            65441L,
            65442L,
            65443L,
            65444L,
            65445L,
            65446L,
            65447L,
            65448L,
            65449L,
            65450L,
            65451L,
            65452L,
            65453L,
            65454L,
            65455L,
            65456L,
            65457L,
            65458L,
            65459L,
            65460L,
            65461L,
            65462L,
            65463L,
            65464L,
            65465L,
            65466L,
            65467L,
            65468L,
            65469L,
            65470L,
            65471L,
            65472L,
            65473L,
            65474L,
            65475L,
            65476L,
            65477L,
            65478L,
            65479L,
            65480L,
            65481L,
            65482L,
            65483L,
            65484L,
            65485L,
            65486L,
            65487L,
            65488L,
            65489L,
            65490L,
            65491L,
            65492L,
            65493L,
            65494L,
            65495L,
            65496L,
            65497L,
            65498L,
            65499L,
            65500L,
            65501L,
            65502L,
            65503L,
            65504L,
            65505L,
            65506L,
            65507L,
            65508L,
            65509L,
            65510L,
            65511L,
            65512L,
            65513L,
            65514L,
            65515L,
            65516L,
            65517L,
            65518L,
            65519L,
            65520L,
            65521L,
            65522L,
            65523L,
            65524L,
            65525L,
            65526L,
            65527L,
            65528L,
            65529L,
            65530L,
            65531L,
            65532L,
            65533L,
            65534L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 328);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCilInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CilInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CilInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CilInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCilInstructionKind() {
        return stringify::Rose::BinaryAnalysis::CilInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 13
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86InstructionSize(int64_t i) {
        switch (i) {
            case 0L: return "x86_insnsize_none";
            case 1L: return "x86_insnsize_16";
            case 2L: return "x86_insnsize_32";
            case 3L: return "x86_insnsize_64";
            default: return "";
        }
    }

    std::string X86InstructionSize(int64_t i, const std::string &strip) {
        std::string s = X86InstructionSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86InstructionSize() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86InstructionSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86InstructionSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86InstructionSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86InstructionSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86InstructionSize() {
        return stringify::Rose::BinaryAnalysis::X86InstructionSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 21
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "x86_regclass_gpr";
            case 1L: return "x86_regclass_segment";
            case 2L: return "x86_regclass_cr";
            case 3L: return "x86_regclass_dr";
            case 4L: return "x86_regclass_st";
            case 5L: return "x86_regclass_xmm";
            case 6L: return "x86_regclass_ip";
            case 7L: return "x86_regclass_flags";
            default: return "";
        }
    }

    std::string X86RegisterClass(int64_t i, const std::string &strip) {
        std::string s = X86RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RegisterClass() {
        return stringify::Rose::BinaryAnalysis::X86RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86SegmentRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_segreg_es";
            case 1L: return "x86_segreg_cs";
            case 2L: return "x86_segreg_ss";
            case 3L: return "x86_segreg_ds";
            case 4L: return "x86_segreg_fs";
            case 5L: return "x86_segreg_gs";
            case 16L: return "x86_segreg_none";
            default: return "";
        }
    }

    std::string X86SegmentRegister(int64_t i, const std::string &strip) {
        std::string s = X86SegmentRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86SegmentRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86SegmentRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86SegmentRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86SegmentRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86SegmentRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86SegmentRegister() {
        return stringify::Rose::BinaryAnalysis::X86SegmentRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86GeneralPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_gpr_ax";
            case 1L: return "x86_gpr_cx";
            case 2L: return "x86_gpr_dx";
            case 3L: return "x86_gpr_bx";
            case 4L: return "x86_gpr_sp";
            case 5L: return "x86_gpr_bp";
            case 6L: return "x86_gpr_si";
            case 7L: return "x86_gpr_di";
            case 8L: return "x86_gpr_r8";
            case 9L: return "x86_gpr_r9";
            case 10L: return "x86_gpr_r10";
            case 11L: return "x86_gpr_r11";
            case 12L: return "x86_gpr_r12";
            case 13L: return "x86_gpr_r13";
            case 14L: return "x86_gpr_r14";
            case 15L: return "x86_gpr_r15";
            default: return "";
        }
    }

    std::string X86GeneralPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = X86GeneralPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86GeneralPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 16);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86GeneralPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86GeneralPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86GeneralPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::X86GeneralPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 65
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86StRegister(int64_t i) {
        switch (i) {
            case 0L: return "x86_st_0";
            case 1L: return "x86_st_1";
            case 2L: return "x86_st_2";
            case 3L: return "x86_st_3";
            case 4L: return "x86_st_4";
            case 5L: return "x86_st_5";
            case 6L: return "x86_st_6";
            case 7L: return "x86_st_7";
            case 8L: return "x86_st_nregs";
            default: return "";
        }
    }

    std::string X86StRegister(int64_t i, const std::string &strip) {
        std::string s = X86StRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86StRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86StRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86StRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86StRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86StRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86StRegister() {
        return stringify::Rose::BinaryAnalysis::X86StRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 78
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flags(int64_t i) {
        switch (i) {
            case 0L: return "x86_flags_status";
            case 1L: return "x86_flags_fpstatus";
            case 2L: return "x86_flags_fptag";
            case 3L: return "x86_flags_fpctl";
            case 4L: return "x86_flags_mxcsr";
            default: return "";
        }
    }

    std::string X86Flags(int64_t i, const std::string &strip) {
        std::string s = X86Flags(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flags(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flags() {
        return stringify::Rose::BinaryAnalysis::X86Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 87
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Flag(int64_t i) {
        switch (i) {
            case 0L: return "x86_flag_cf";
            case 2L: return "x86_flag_pf";
            case 4L: return "x86_flag_af";
            case 6L: return "x86_flag_zf";
            case 7L: return "x86_flag_sf";
            case 8L: return "x86_flag_tf";
            case 9L: return "x86_flag_if";
            case 10L: return "x86_flag_df";
            case 11L: return "x86_flag_of";
            case 12L: return "x86_flag_iopl";
            case 14L: return "x86_flag_nt";
            case 16L: return "x86_flag_rf";
            case 17L: return "x86_flag_vm";
            case 18L: return "x86_flag_ac";
            case 19L: return "x86_flag_vif";
            case 20L: return "x86_flag_vip";
            case 21L: return "x86_flag_id";
            default: return "";
        }
    }

    std::string X86Flag(int64_t i, const std::string &strip) {
        std::string s = X86Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Flag() {
        static const int64_t values[] = {
            0L,
            2L,
            4L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            14L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 17);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Flag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Flag() {
        return stringify::Rose::BinaryAnalysis::X86Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 108
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86BranchPrediction(int64_t i) {
        switch (i) {
            case 0L: return "x86_branch_prediction_none";
            case 1L: return "x86_branch_prediction_taken";
            case 2L: return "x86_branch_prediction_not_taken";
            default: return "";
        }
    }

    std::string X86BranchPrediction(int64_t i, const std::string &strip) {
        std::string s = X86BranchPrediction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86BranchPrediction() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86BranchPrediction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86BranchPrediction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86BranchPrediction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86BranchPrediction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86BranchPrediction() {
        return stringify::Rose::BinaryAnalysis::X86BranchPrediction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 116
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86RepeatPrefix(int64_t i) {
        switch (i) {
            case 0L: return "x86_repeat_none";
            case 1L: return "x86_repeat_repne";
            case 2L: return "x86_repeat_repe";
            default: return "";
        }
    }

    std::string X86RepeatPrefix(int64_t i, const std::string &strip) {
        std::string s = X86RepeatPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86RepeatPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86RepeatPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86RepeatPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86RepeatPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86RepeatPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86RepeatPrefix() {
        return stringify::Rose::BinaryAnalysis::X86RepeatPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsX86.h line 125
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* X86Exception(int64_t i) {
        switch (i) {
            case 0L: return "x86_exception_int";
            case 1L: return "x86_exception_sysenter";
            case 2L: return "x86_exception_syscall";
            case 3L: return "x86_exception_de";
            case 4L: return "x86_exception_db";
            case 5L: return "x86_exception_bp";
            case 6L: return "x86_exception_of";
            case 7L: return "x86_exception_br";
            case 8L: return "x86_exception_ud";
            case 9L: return "x86_exception_nm";
            case 10L: return "x86_exception_df";
            case 11L: return "x86_exception_ts";
            case 12L: return "x86_exception_np";
            case 13L: return "x86_exception_ss";
            case 14L: return "x86_exception_gp";
            case 15L: return "x86_exception_pf";
            case 16L: return "x86_exception_mf";
            case 17L: return "x86_exception_ac";
            case 18L: return "x86_exception_mc";
            case 19L: return "x86_exception_xm";
            default: return "";
        }
    }

    std::string X86Exception(int64_t i, const std::string &strip) {
        std::string s = X86Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& X86Exception() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisX86Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::X86Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::X86Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::X86Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisX86Exception() {
        return stringify::Rose::BinaryAnalysis::X86Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/BinaryLoader.h line 66
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* MappingContribution(int64_t i) {
        switch (i) {
            case 0L: return "CONTRIBUTE_NONE";
            case 1L: return "CONTRIBUTE_ADD";
            case 2L: return "CONTRIBUTE_SUB";
            default: return "";
        }
    }

    std::string MappingContribution(int64_t i, const std::string &strip) {
        std::string s = MappingContribution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MappingContribution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderMappingContribution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::MappingContribution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::MappingContribution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderMappingContribution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::MappingContribution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/BinaryLoader.h line 74
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace BinaryLoader {
    const char* ConflictResolution(int64_t i) {
        switch (i) {
            case 0L: return "RESOLVE_THROW";
            case 1L: return "RESOLVE_OVERMAP";
            case 2L: return "RESOLVE_REMAP";
            case 3L: return "RESOLVE_REMAP_ABOVE";
            default: return "";
        }
    }

    std::string ConflictResolution(int64_t i, const std::string &strip) {
        std::string s = ConflictResolution(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConflictResolution() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisBinaryLoaderConflictResolution(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::BinaryLoader::ConflictResolution)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::BinaryLoader::ConflictResolution::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisBinaryLoaderConflictResolution() {
        return stringify::Rose::BinaryAnalysis::BinaryLoader::ConflictResolution();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64Exception(int64_t i) {
        switch (i) {
            case 0L: return "brk";
            default: return "";
        }
    }

    std::string Aarch64Exception(int64_t i, const std::string &strip) {
        std::string s = Aarch64Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64Exception() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64Exception() {
        return stringify::Rose::BinaryAnalysis::Aarch64Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 42
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "aarch64_regclass_gpr";
            case 1L: return "aarch64_regclass_sp";
            case 2L: return "aarch64_regclass_ext";
            case 3L: return "aarch64_regclass_pc";
            case 4L: return "aarch64_regclass_cc";
            case 5L: return "aarch64_regclass_system";
            default: return "";
        }
    }

    std::string Aarch64RegisterClass(int64_t i, const std::string &strip) {
        std::string s = Aarch64RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64RegisterClass() {
        return stringify::Rose::BinaryAnalysis::Aarch64RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch64.h line 57
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch64SystemRegisters(int64_t i) {
        switch (i) {
            case 0L: return "aarch64_system_actlr";
            case 4L: return "aarch64_system_ccsidr";
            case 8L: return "aarch64_system_clidr";
            case 12L: return "aarch64_system_cntfrq";
            case 16L: return "aarch64_system_cntpct";
            case 20L: return "aarch64_system_cntkctl";
            case 24L: return "aarch64_system_cntp_cval";
            case 28L: return "aarch64_system_cpacr";
            case 32L: return "aarch64_system_csselr";
            case 36L: return "aarch64_system_cntp_ctl";
            case 40L: return "aarch64_system_ctr";
            case 44L: return "aarch64_system_dczid";
            case 48L: return "aarch64_system_elr";
            case 52L: return "aarch64_system_esr";
            case 56L: return "aarch64_system_far";
            case 60L: return "aarch64_system_hcr";
            case 64L: return "aarch64_system_mair";
            case 68L: return "aarch64_system_midr";
            case 72L: return "aarch64_system_mpidr";
            case 76L: return "aarch64_system_scr";
            case 80L: return "aarch64_system_sctlr";
            case 84L: return "aarch64_system_spsr";
            case 88L: return "aarch64_system_tcr";
            case 92L: return "aarch64_system_tpidr";
            case 96L: return "aarch64_system_tpidrr0";
            case 100L: return "aarch64_system_ttbr0";
            case 104L: return "aarch64_system_ttbr1";
            case 108L: return "aarch64_system_vbar";
            case 112L: return "aarch64_system_vtcr";
            case 116L: return "aarch64_system_vttbr";
            default: return "";
        }
    }

    std::string Aarch64SystemRegisters(int64_t i, const std::string &strip) {
        std::string s = Aarch64SystemRegisters(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch64SystemRegisters)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch64SystemRegisters() {
        static const int64_t values[] = {
            0L,
            4L,
            8L,
            12L,
            16L,
            20L,
            24L,
            28L,
            32L,
            36L,
            40L,
            44L,
            48L,
            52L,
            56L,
            60L,
            64L,
            68L,
            72L,
            76L,
            80L,
            84L,
            88L,
            92L,
            96L,
            100L,
            104L,
            108L,
            112L,
            116L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch64SystemRegisters(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch64SystemRegisters(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch64SystemRegisters)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch64SystemRegisters::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch64SystemRegisters() {
        return stringify::Rose::BinaryAnalysis::Aarch64SystemRegisters();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 12
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcCapability(int64_t i) {
        switch (i) {
            case 1L: return "powerpc_capability_uisa";
            case 2L: return "powerpc_capability_vea";
            case 4L: return "powerpc_capability_oea";
            case 8L: return "powerpc_capability_440fpu";
            case 16L: return "powerpc_capability_uncategorized";
            case 23L: return "powerpc_capability_default";
            case 31L: return "powerpc_capability_all";
            default: return "";
        }
    }

    std::string PowerpcCapability(int64_t i, const std::string &strip) {
        std::string s = PowerpcCapability(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcCapability)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcCapability() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            23L,
            31L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcCapability(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcCapability(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcCapability)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcCapability::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcCapability() {
        return stringify::Rose::BinaryAnalysis::PowerpcCapability();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 52
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcWordSize(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_32";
            case 1L: return "powerpc_64";
            default: return "";
        }
    }

    std::string PowerpcWordSize(int64_t i, const std::string &strip) {
        std::string s = PowerpcWordSize(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcWordSize() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcWordSize(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcWordSize(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcWordSize)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcWordSize::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcWordSize() {
        return stringify::Rose::BinaryAnalysis::PowerpcWordSize();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 58
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_unknown_instruction";
            case 1L: return "powerpc_add";
            case 2L: return "powerpc_add_record";
            case 3L: return "powerpc_addo";
            case 4L: return "powerpc_addo_record";
            case 5L: return "powerpc_addc";
            case 6L: return "powerpc_addc_record";
            case 7L: return "powerpc_addco";
            case 8L: return "powerpc_addco_record";
            case 9L: return "powerpc_adde";
            case 10L: return "powerpc_adde_record";
            case 11L: return "powerpc_addeo";
            case 12L: return "powerpc_addeo_record";
            case 13L: return "powerpc_addi";
            case 14L: return "powerpc_addic";
            case 15L: return "powerpc_addic_record";
            case 16L: return "powerpc_addis";
            case 17L: return "powerpc_addme";
            case 18L: return "powerpc_addme_record";
            case 19L: return "powerpc_addmeo";
            case 20L: return "powerpc_addmeo_record";
            case 21L: return "powerpc_addze";
            case 22L: return "powerpc_addze_record";
            case 23L: return "powerpc_addzeo";
            case 24L: return "powerpc_addzeo_record";
            case 25L: return "powerpc_and";
            case 26L: return "powerpc_and_record";
            case 27L: return "powerpc_andc";
            case 28L: return "powerpc_andc_record";
            case 29L: return "powerpc_andi_record";
            case 30L: return "powerpc_andis_record";
            case 31L: return "powerpc_b";
            case 32L: return "powerpc_ba";
            case 33L: return "powerpc_bl";
            case 34L: return "powerpc_bla";
            case 35L: return "powerpc_bc";
            case 36L: return "powerpc_bca";
            case 37L: return "powerpc_bcl";
            case 38L: return "powerpc_bcla";
            case 39L: return "powerpc_bcctr";
            case 40L: return "powerpc_bcctrl";
            case 41L: return "powerpc_bclr";
            case 42L: return "powerpc_bclrl";
            case 43L: return "powerpc_cmp";
            case 44L: return "powerpc_cmpi";
            case 45L: return "powerpc_cmpl";
            case 46L: return "powerpc_cmpli";
            case 47L: return "powerpc_cntlzd";
            case 48L: return "powerpc_cntlzd_record";
            case 49L: return "powerpc_cntlzw";
            case 50L: return "powerpc_cntlzw_record";
            case 51L: return "powerpc_crand";
            case 52L: return "powerpc_crandc";
            case 53L: return "powerpc_creqv";
            case 54L: return "powerpc_crnand";
            case 55L: return "powerpc_crnor";
            case 56L: return "powerpc_cror";
            case 57L: return "powerpc_crorc";
            case 58L: return "powerpc_crxor";
            case 59L: return "powerpc_dcbf";
            case 60L: return "powerpc_dcba";
            case 61L: return "powerpc_dcbi";
            case 62L: return "powerpc_dcbst";
            case 63L: return "powerpc_dcbt";
            case 64L: return "powerpc_dcbtst";
            case 65L: return "powerpc_dcbz";
            case 66L: return "powerpc_divd";
            case 67L: return "powerpc_divd_record";
            case 68L: return "powerpc_divdo";
            case 69L: return "powerpc_divdo_record";
            case 70L: return "powerpc_divdu";
            case 71L: return "powerpc_divdu_record";
            case 72L: return "powerpc_divduo";
            case 73L: return "powerpc_divduo_record";
            case 74L: return "powerpc_divw";
            case 75L: return "powerpc_divw_record";
            case 76L: return "powerpc_divwo";
            case 77L: return "powerpc_divwo_record";
            case 78L: return "powerpc_divwu";
            case 79L: return "powerpc_divwu_record";
            case 80L: return "powerpc_divwuo";
            case 81L: return "powerpc_divwuo_record";
            case 82L: return "powerpc_dst";
            case 83L: return "powerpc_dstt";
            case 84L: return "powerpc_dstst";
            case 85L: return "powerpc_dststt";
            case 86L: return "powerpc_dss";
            case 87L: return "powerpc_dssall";
            case 88L: return "powerpc_eciwx";
            case 89L: return "powerpc_ecowx";
            case 90L: return "powerpc_eieio";
            case 91L: return "powerpc_eqv";
            case 92L: return "powerpc_eqv_record";
            case 93L: return "powerpc_extsb";
            case 94L: return "powerpc_extsb_record";
            case 95L: return "powerpc_extsh";
            case 96L: return "powerpc_extsh_record";
            case 97L: return "powerpc_extsw";
            case 98L: return "powerpc_extsw_record";
            case 99L: return "powerpc_fabs";
            case 100L: return "powerpc_fabs_record";
            case 101L: return "powerpc_fadd";
            case 102L: return "powerpc_fadd_record";
            case 103L: return "powerpc_fadds";
            case 104L: return "powerpc_fadds_record";
            case 105L: return "powerpc_fcfid";
            case 106L: return "powerpc_fcfid_record";
            case 107L: return "powerpc_fcmpo";
            case 108L: return "powerpc_fcmpu";
            case 109L: return "powerpc_fctid";
            case 110L: return "powerpc_fctid_record";
            case 111L: return "powerpc_fctidz";
            case 112L: return "powerpc_fctidz_record";
            case 113L: return "powerpc_fctiw";
            case 114L: return "powerpc_fctiw_record";
            case 115L: return "powerpc_fctiwz";
            case 116L: return "powerpc_fctiwz_record";
            case 117L: return "powerpc_fdiv";
            case 118L: return "powerpc_fdiv_record";
            case 119L: return "powerpc_fdivs";
            case 120L: return "powerpc_fdivs_record";
            case 121L: return "powerpc_fmadd";
            case 122L: return "powerpc_fmadd_record";
            case 123L: return "powerpc_fmadds";
            case 124L: return "powerpc_fmadds_record";
            case 125L: return "powerpc_fmr";
            case 126L: return "powerpc_fmr_record";
            case 127L: return "powerpc_fmsub";
            case 128L: return "powerpc_fmsub_record";
            case 129L: return "powerpc_fmsubs";
            case 130L: return "powerpc_fmsubs_record";
            case 131L: return "powerpc_fmul";
            case 132L: return "powerpc_fmul_record";
            case 133L: return "powerpc_fmuls";
            case 134L: return "powerpc_fmuls_record";
            case 135L: return "powerpc_fnabs";
            case 136L: return "powerpc_fnabs_record";
            case 137L: return "powerpc_fneg";
            case 138L: return "powerpc_fneg_record";
            case 139L: return "powerpc_fnmadd";
            case 140L: return "powerpc_fnmadd_record";
            case 141L: return "powerpc_fnmadds";
            case 142L: return "powerpc_fnmadds_record";
            case 143L: return "powerpc_fnmsub";
            case 144L: return "powerpc_fnmsub_record";
            case 145L: return "powerpc_fnmsubs";
            case 146L: return "powerpc_fnmsubs_record";
            case 147L: return "powerpc_fpmul";
            case 148L: return "powerpc_fxmul";
            case 149L: return "powerpc_fxpmul";
            case 150L: return "powerpc_fxsmul";
            case 151L: return "powerpc_fpadd";
            case 152L: return "powerpc_fpsub";
            case 153L: return "powerpc_fpre";
            case 154L: return "powerpc_fprsqrte";
            case 155L: return "powerpc_fpmr";
            case 156L: return "powerpc_fpabs";
            case 157L: return "powerpc_lfssx";
            case 158L: return "powerpc_fpneg";
            case 159L: return "powerpc_lfssux";
            case 160L: return "powerpc_fprsp";
            case 161L: return "powerpc_lfsdx";
            case 162L: return "powerpc_fpnabs";
            case 163L: return "powerpc_lfsdux";
            case 164L: return "powerpc_lfxsx";
            case 165L: return "powerpc_fsmr";
            case 166L: return "powerpc_lfxsux";
            case 167L: return "powerpc_lfxdx";
            case 168L: return "powerpc_fsabs";
            case 169L: return "powerpc_lfxdux";
            case 170L: return "powerpc_lfpsx";
            case 171L: return "powerpc_fsneg";
            case 172L: return "powerpc_lfpsux";
            case 173L: return "powerpc_lfpdx";
            case 174L: return "powerpc_fsnabs";
            case 175L: return "powerpc_lfpdux";
            case 176L: return "powerpc_stfpiwx";
            case 177L: return "powerpc_fxmr";
            case 178L: return "powerpc_fpctiw";
            case 179L: return "powerpc_stfssx";
            case 180L: return "powerpc_stfssux";
            case 181L: return "powerpc_fpctiwz";
            case 182L: return "powerpc_stfsdx";
            case 183L: return "powerpc_stfsdux";
            case 184L: return "powerpc_stfxsx";
            case 185L: return "powerpc_fsmtp";
            case 186L: return "powerpc_stfxsux";
            case 187L: return "powerpc_stfxdx";
            case 188L: return "powerpc_stfxdux";
            case 189L: return "powerpc_stfpsx";
            case 190L: return "powerpc_fsmfp";
            case 191L: return "powerpc_stfpsux";
            case 192L: return "powerpc_stfpdx";
            case 193L: return "powerpc_stfpdux";
            case 194L: return "powerpc_fpsel";
            case 195L: return "powerpc_fpmadd";
            case 196L: return "powerpc_fpmsub";
            case 197L: return "powerpc_fxmadd";
            case 198L: return "powerpc_fxcpmadd";
            case 199L: return "powerpc_fxcsmadd";
            case 200L: return "powerpc_fpnmadd";
            case 201L: return "powerpc_fxnmadd";
            case 202L: return "powerpc_fxcpnmadd";
            case 203L: return "powerpc_fxcsnmadd";
            case 204L: return "powerpc_fxcpnpma";
            case 205L: return "powerpc_fxmsub";
            case 206L: return "powerpc_fxcsnpma";
            case 207L: return "powerpc_fxcpmsub";
            case 208L: return "powerpc_fxcpnsma";
            case 209L: return "powerpc_fxcsmsub";
            case 210L: return "powerpc_fxcsnsma";
            case 211L: return "powerpc_fpnmsub";
            case 212L: return "powerpc_fxcxma";
            case 213L: return "powerpc_fxnmsub";
            case 214L: return "powerpc_fxcxnpma";
            case 215L: return "powerpc_fxcpnmsub";
            case 216L: return "powerpc_fxcxnsma";
            case 217L: return "powerpc_fxcsnmsub";
            case 218L: return "powerpc_fxcxnms";
            case 219L: return "powerpc_fre";
            case 220L: return "powerpc_fre_record";
            case 221L: return "powerpc_fres";
            case 222L: return "powerpc_fres_record";
            case 223L: return "powerpc_frsp";
            case 224L: return "powerpc_frsp_record";
            case 225L: return "powerpc_frsqrte";
            case 226L: return "powerpc_frsqrte_record";
            case 227L: return "powerpc_frsqrtes";
            case 228L: return "powerpc_frsqrtes_record";
            case 229L: return "powerpc_fsel";
            case 230L: return "powerpc_fsel_record";
            case 231L: return "powerpc_fsqrt";
            case 232L: return "powerpc_fsqrt_record";
            case 233L: return "powerpc_fsqrts";
            case 234L: return "powerpc_fsqrts_record";
            case 235L: return "powerpc_fsub";
            case 236L: return "powerpc_fsub_record";
            case 237L: return "powerpc_fsubs";
            case 238L: return "powerpc_fsubs_record";
            case 239L: return "powerpc_icbi";
            case 240L: return "powerpc_illegal";
            case 241L: return "powerpc_isync";
            case 242L: return "powerpc_lbz";
            case 243L: return "powerpc_lbzu";
            case 244L: return "powerpc_lbzux";
            case 245L: return "powerpc_lbzx";
            case 246L: return "powerpc_ld";
            case 247L: return "powerpc_ldarx";
            case 248L: return "powerpc_ldu";
            case 249L: return "powerpc_ldux";
            case 250L: return "powerpc_ldx";
            case 251L: return "powerpc_lfd";
            case 252L: return "powerpc_lfdu";
            case 253L: return "powerpc_lfdux";
            case 254L: return "powerpc_lfdx";
            case 255L: return "powerpc_lfs";
            case 256L: return "powerpc_lfsu";
            case 257L: return "powerpc_lfsux";
            case 258L: return "powerpc_lfsx";
            case 259L: return "powerpc_lha";
            case 260L: return "powerpc_lhau";
            case 261L: return "powerpc_lhaux";
            case 262L: return "powerpc_lhax";
            case 263L: return "powerpc_lhbrx";
            case 264L: return "powerpc_lhz";
            case 265L: return "powerpc_lhzu";
            case 266L: return "powerpc_lhzux";
            case 267L: return "powerpc_lhzx";
            case 268L: return "powerpc_lmw";
            case 269L: return "powerpc_lswi";
            case 270L: return "powerpc_lswx";
            case 271L: return "powerpc_lwa";
            case 272L: return "powerpc_lwarx";
            case 273L: return "powerpc_lwaux";
            case 274L: return "powerpc_lwax";
            case 275L: return "powerpc_lwbrx";
            case 276L: return "powerpc_lwz";
            case 277L: return "powerpc_lwzu";
            case 278L: return "powerpc_lwzux";
            case 279L: return "powerpc_lwzx";
            case 280L: return "powerpc_mcrf";
            case 281L: return "powerpc_mcrfs";
            case 282L: return "powerpc_mcrxr";
            case 283L: return "powerpc_mfcr";
            case 284L: return "powerpc_mffs";
            case 285L: return "powerpc_mffs_record";
            case 286L: return "powerpc_mfmsr";
            case 287L: return "powerpc_mfspr";
            case 288L: return "powerpc_mfsr";
            case 289L: return "powerpc_mfsrin";
            case 290L: return "powerpc_mftb";
            case 291L: return "powerpc_mtcrf";
            case 292L: return "powerpc_mtfsb0";
            case 293L: return "powerpc_mtfsb0_record";
            case 294L: return "powerpc_mtfsb1";
            case 295L: return "powerpc_mtfsb1_record";
            case 296L: return "powerpc_mtfsf";
            case 297L: return "powerpc_mtfsf_record";
            case 298L: return "powerpc_mtfsfi";
            case 299L: return "powerpc_mtfsfi_record";
            case 300L: return "powerpc_mtmsr";
            case 301L: return "powerpc_mtmsrd";
            case 302L: return "powerpc_mtspr";
            case 303L: return "powerpc_mtsr";
            case 304L: return "powerpc_mtsrd";
            case 305L: return "powerpc_mtsrdin";
            case 306L: return "powerpc_mtsrin";
            case 307L: return "powerpc_mulhd";
            case 308L: return "powerpc_mulhd_record";
            case 309L: return "powerpc_mulhdu";
            case 310L: return "powerpc_mulhdu_record";
            case 311L: return "powerpc_mulhw";
            case 312L: return "powerpc_mulhw_record";
            case 313L: return "powerpc_mulhwu";
            case 314L: return "powerpc_mulhwu_record";
            case 315L: return "powerpc_mulld";
            case 316L: return "powerpc_mulld_record";
            case 317L: return "powerpc_mulldo";
            case 318L: return "powerpc_mulldo_record";
            case 319L: return "powerpc_mulli";
            case 320L: return "powerpc_mullw";
            case 321L: return "powerpc_mullw_record";
            case 322L: return "powerpc_mullwo";
            case 323L: return "powerpc_mullwo_record";
            case 324L: return "powerpc_nand";
            case 325L: return "powerpc_nand_record";
            case 326L: return "powerpc_neg";
            case 327L: return "powerpc_neg_record";
            case 328L: return "powerpc_nego";
            case 329L: return "powerpc_nego_record";
            case 330L: return "powerpc_nor";
            case 331L: return "powerpc_nor_record";
            case 332L: return "powerpc_or";
            case 333L: return "powerpc_or_record";
            case 334L: return "powerpc_orc";
            case 335L: return "powerpc_orc_record";
            case 336L: return "powerpc_ori";
            case 337L: return "powerpc_oris";
            case 338L: return "powerpc_popcntb";
            case 339L: return "powerpc_rfi";
            case 340L: return "powerpc_rfid";
            case 341L: return "powerpc_rldcl";
            case 342L: return "powerpc_rldcl_record";
            case 343L: return "powerpc_rldcr";
            case 344L: return "powerpc_rldcr_record";
            case 345L: return "powerpc_rldic";
            case 346L: return "powerpc_rldic_record";
            case 347L: return "powerpc_rldicl";
            case 348L: return "powerpc_rldicl_record";
            case 349L: return "powerpc_rldicr";
            case 350L: return "powerpc_rldicr_record";
            case 351L: return "powerpc_rldimi";
            case 352L: return "powerpc_rldimi_record";
            case 353L: return "powerpc_rlwimi";
            case 354L: return "powerpc_rlwimi_record";
            case 355L: return "powerpc_rlwinm";
            case 356L: return "powerpc_rlwinm_record";
            case 357L: return "powerpc_rlwnm";
            case 358L: return "powerpc_rlwnm_record";
            case 359L: return "powerpc_sc";
            case 360L: return "powerpc_slbia";
            case 361L: return "powerpc_slbie";
            case 362L: return "powerpc_sld";
            case 363L: return "powerpc_sld_record";
            case 364L: return "powerpc_slw";
            case 365L: return "powerpc_slw_record";
            case 366L: return "powerpc_srad";
            case 367L: return "powerpc_srad_record";
            case 368L: return "powerpc_sradi";
            case 369L: return "powerpc_sradi_record";
            case 370L: return "powerpc_srd";
            case 371L: return "powerpc_srd_record";
            case 372L: return "powerpc_sraw";
            case 373L: return "powerpc_sraw_record";
            case 374L: return "powerpc_srawi";
            case 375L: return "powerpc_srawi_record";
            case 376L: return "powerpc_srw";
            case 377L: return "powerpc_srw_record";
            case 378L: return "powerpc_stb";
            case 379L: return "powerpc_stbu";
            case 380L: return "powerpc_stbux";
            case 381L: return "powerpc_stbx";
            case 382L: return "powerpc_std";
            case 383L: return "powerpc_stdcx_record";
            case 384L: return "powerpc_stdu";
            case 385L: return "powerpc_stdux";
            case 386L: return "powerpc_stdx";
            case 387L: return "powerpc_stfd";
            case 388L: return "powerpc_stfdu";
            case 389L: return "powerpc_stfdux";
            case 390L: return "powerpc_stfdx";
            case 391L: return "powerpc_stfiwx";
            case 392L: return "powerpc_stfs";
            case 393L: return "powerpc_stfsu";
            case 394L: return "powerpc_stfsux";
            case 395L: return "powerpc_stfsx";
            case 396L: return "powerpc_sth";
            case 397L: return "powerpc_sthbrx";
            case 398L: return "powerpc_sthu";
            case 399L: return "powerpc_sthux";
            case 400L: return "powerpc_sthx";
            case 401L: return "powerpc_stmw";
            case 402L: return "powerpc_stswi";
            case 403L: return "powerpc_stswx";
            case 404L: return "powerpc_stw";
            case 405L: return "powerpc_stwbrx";
            case 406L: return "powerpc_stwcx_record";
            case 407L: return "powerpc_stwu";
            case 408L: return "powerpc_stwux";
            case 409L: return "powerpc_stwx";
            case 410L: return "powerpc_subf";
            case 411L: return "powerpc_subf_record";
            case 412L: return "powerpc_subfo";
            case 413L: return "powerpc_subfo_record";
            case 414L: return "powerpc_subfc";
            case 415L: return "powerpc_subfc_record";
            case 416L: return "powerpc_subfco";
            case 417L: return "powerpc_subfco_record";
            case 418L: return "powerpc_subfe";
            case 419L: return "powerpc_subfe_record";
            case 420L: return "powerpc_subfeo";
            case 421L: return "powerpc_subfeo_record";
            case 422L: return "powerpc_subfic";
            case 423L: return "powerpc_subfme";
            case 424L: return "powerpc_subfme_record";
            case 425L: return "powerpc_subfmeo";
            case 426L: return "powerpc_subfmeo_record";
            case 427L: return "powerpc_subfze";
            case 428L: return "powerpc_subfze_record";
            case 429L: return "powerpc_subfzeo";
            case 430L: return "powerpc_subfzeo_record";
            case 431L: return "powerpc_sync";
            case 432L: return "powerpc_td";
            case 433L: return "powerpc_tdi";
            case 434L: return "powerpc_tlbia";
            case 435L: return "powerpc_tlbie";
            case 436L: return "powerpc_tlbsync";
            case 437L: return "powerpc_tw";
            case 438L: return "powerpc_twi";
            case 439L: return "powerpc_xor";
            case 440L: return "powerpc_xor_record";
            case 441L: return "powerpc_xori";
            case 442L: return "powerpc_xoris";
            case 443L: return "powerpc_last_instruction";
            default: return "";
        }
    }

    std::string PowerpcInstructionKind(int64_t i, const std::string &strip) {
        std::string s = PowerpcInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            346L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            377L,
            378L,
            379L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L
        };
        static const std::vector<int64_t> retval(values, values + 444);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcInstructionKind() {
        return stringify::Rose::BinaryAnalysis::PowerpcInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 506
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_regclass_unknown";
            case 1L: return "powerpc_regclass_gpr";
            case 2L: return "powerpc_regclass_fpr";
            case 3L: return "powerpc_regclass_cr";
            case 4L: return "powerpc_regclass_fpscr";
            case 5L: return "powerpc_regclass_spr";
            case 6L: return "powerpc_regclass_tbr";
            case 7L: return "powerpc_regclass_msr";
            case 8L: return "powerpc_regclass_sr";
            case 9L: return "powerpc_regclass_iar";
            case 10L: return "powerpc_regclass_pvr";
            case 11L: return "powerpc_last_register_class";
            default: return "";
        }
    }

    std::string PowerpcRegisterClass(int64_t i, const std::string &strip) {
        std::string s = PowerpcRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcRegisterClass() {
        return stringify::Rose::BinaryAnalysis::PowerpcRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 522
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcConditionRegisterAccessGranularity(int64_t i) {
        switch (i) {
            case 0L: return "powerpc_condreggranularity_whole";
            case 1L: return "powerpc_condreggranularity_field";
            case 2L: return "powerpc_condreggranularity_bit";
            default: return "";
        }
    }

    std::string PowerpcConditionRegisterAccessGranularity(int64_t i, const std::string &strip) {
        std::string s = PowerpcConditionRegisterAccessGranularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcConditionRegisterAccessGranularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcConditionRegisterAccessGranularity() {
        return stringify::Rose::BinaryAnalysis::PowerpcConditionRegisterAccessGranularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 529
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 1L: return "powerpc_spr_xer";
            case 8L: return "powerpc_spr_lr";
            case 9L: return "powerpc_spr_ctr";
            case 18L: return "powerpc_spr_dsisr";
            case 19L: return "powerpc_spr_dar";
            case 22L: return "powerpc_spr_dec";
            default: return "";
        }
    }

    std::string PowerpcSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcSpecialPurposeRegister() {
        static const int64_t values[] = {
            1L,
            8L,
            9L,
            18L,
            19L,
            22L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsPowerpc.h line 540
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* PowerpcTimeBaseRegister(int64_t i) {
        switch (i) {
            case 268L: return "powerpc_tbr_tbl";
            case 269L: return "powerpc_tbr_tbu";
            default: return "";
        }
    }

    std::string PowerpcTimeBaseRegister(int64_t i, const std::string &strip) {
        std::string s = PowerpcTimeBaseRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& PowerpcTimeBaseRegister() {
        static const int64_t values[] = {
            268L,
            269L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPowerpcTimeBaseRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PowerpcTimeBaseRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PowerpcTimeBaseRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPowerpcTimeBaseRegister() {
        return stringify::Rose::BinaryAnalysis::PowerpcTimeBaseRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackParameterOrder(int64_t i) {
        switch (i) {
            case 0L: return "LEFT_TO_RIGHT";
            case 1L: return "RIGHT_TO_LEFT";
            case 2L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackParameterOrder(int64_t i, const std::string &strip) {
        std::string s = StackParameterOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackParameterOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackParameterOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackParameterOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackParameterOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackParameterOrder() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackParameterOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackDirection(int64_t i) {
        switch (i) {
            case 0L: return "GROWS_UP";
            case 1L: return "GROWS_DOWN";
            default: return "";
        }
    }

    std::string StackDirection(int64_t i, const std::string &strip) {
        std::string s = StackDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackDirection() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/CallingConvention/BasicTypes.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace CallingConvention {
    const char* StackCleanup(int64_t i) {
        switch (i) {
            case 0L: return "BY_CALLER";
            case 1L: return "BY_CALLEE";
            case 2L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string StackCleanup(int64_t i, const std::string &strip) {
        std::string s = StackCleanup(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StackCleanup() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisCallingConventionStackCleanup(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::CallingConvention::StackCleanup)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::CallingConvention::StackCleanup::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisCallingConventionStackCleanup() {
        return stringify::Rose::BinaryAnalysis::CallingConvention::StackCleanup();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 14
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_TAG(int64_t i) {
        switch (i) {
            case 1L: return "DW_TAG_array_type";
            case 2L: return "DW_TAG_class_type";
            case 3L: return "DW_TAG_entry_point";
            case 4L: return "DW_TAG_enumeration_type";
            case 5L: return "DW_TAG_formal_parameter";
            case 8L: return "DW_TAG_imported_declaration";
            case 10L: return "DW_TAG_label";
            case 11L: return "DW_TAG_lexical_block";
            case 13L: return "DW_TAG_member";
            case 15L: return "DW_TAG_pointer_type";
            case 16L: return "DW_TAG_reference_type";
            case 17L: return "DW_TAG_compile_unit";
            case 18L: return "DW_TAG_string_type";
            case 19L: return "DW_TAG_structure_type";
            case 21L: return "DW_TAG_subroutine_type";
            case 22L: return "DW_TAG_typedef";
            case 23L: return "DW_TAG_union_type";
            case 24L: return "DW_TAG_unspecified_parameters";
            case 25L: return "DW_TAG_variant";
            case 26L: return "DW_TAG_common_block";
            case 27L: return "DW_TAG_common_inclusion";
            case 28L: return "DW_TAG_inheritance";
            case 29L: return "DW_TAG_inlined_subroutine";
            case 30L: return "DW_TAG_module";
            case 31L: return "DW_TAG_ptr_to_member_type";
            case 32L: return "DW_TAG_set_type";
            case 33L: return "DW_TAG_subrange_type";
            case 34L: return "DW_TAG_with_stmt";
            case 35L: return "DW_TAG_access_declaration";
            case 36L: return "DW_TAG_base_type";
            case 37L: return "DW_TAG_catch_block";
            case 38L: return "DW_TAG_const_type";
            case 39L: return "DW_TAG_constant";
            case 40L: return "DW_TAG_enumerator";
            case 41L: return "DW_TAG_file_type";
            case 42L: return "DW_TAG_friend";
            case 43L: return "DW_TAG_namelist";
            case 44L: return "DW_TAG_namelist_item";
            case 45L: return "DW_TAG_packed_type";
            case 46L: return "DW_TAG_subprogram";
            case 47L: return "DW_TAG_template_type_parameter";
            case 48L: return "DW_TAG_template_value_parameter";
            case 49L: return "DW_TAG_thrown_type";
            case 50L: return "DW_TAG_try_block";
            case 51L: return "DW_TAG_variant_part";
            case 52L: return "DW_TAG_variable";
            case 53L: return "DW_TAG_volatile_type";
            case 54L: return "DW_TAG_dwarf_procedure";
            case 55L: return "DW_TAG_restrict_type";
            case 56L: return "DW_TAG_interface_type";
            case 57L: return "DW_TAG_namespace";
            case 58L: return "DW_TAG_imported_module";
            case 59L: return "DW_TAG_unspecified_type";
            case 60L: return "DW_TAG_partial_unit";
            case 61L: return "DW_TAG_imported_unit";
            case 62L: return "DW_TAG_mutable_type";
            case 63L: return "DW_TAG_condition";
            case 64L: return "DW_TAG_shared_type";
            case 65L: return "DW_TAG_type_unit";
            case 66L: return "DW_TAG_rvalue_reference_type";
            case 67L: return "DW_TAG_template_alias";
            case 16512L: return "DW_TAG_lo_user";
            case 16513L: return "DW_TAG_MIPS_loop";
            case 16528L: return "DW_TAG_HP_array_descriptor";
            case 16641L: return "DW_TAG_format_label";
            case 16642L: return "DW_TAG_function_template";
            case 16643L: return "DW_TAG_class_template";
            case 16644L: return "DW_TAG_GNU_BINCL";
            case 16645L: return "DW_TAG_GNU_EINCL";
            case 16646L: return "DW_TAG_GNU_template_template_parameter";
            case 16647L: return "DW_TAG_GNU_template_parameter_pack";
            case 16648L: return "DW_TAG_GNU_formal_parameter_pack";
            case 16649L: return "DW_TAG_GNU_call_site";
            case 16650L: return "DW_TAG_GNU_call_site_parameter";
            case 16897L: return "DW_TAG_SUN_function_template";
            case 16898L: return "DW_TAG_SUN_class_template";
            case 16899L: return "DW_TAG_SUN_struct_template";
            case 16900L: return "DW_TAG_SUN_union_template";
            case 16901L: return "DW_TAG_SUN_indirect_inheritance";
            case 16902L: return "DW_TAG_SUN_codeflags";
            case 16903L: return "DW_TAG_SUN_memop_info";
            case 16904L: return "DW_TAG_SUN_omp_child_func";
            case 16905L: return "DW_TAG_SUN_rtti_descriptor";
            case 16906L: return "DW_TAG_SUN_dtor_info";
            case 16907L: return "DW_TAG_SUN_dtor";
            case 16908L: return "DW_TAG_SUN_f90_interface";
            case 16909L: return "DW_TAG_SUN_fortran_vax_structure";
            case 17151L: return "DW_TAG_SUN_hi";
            case 20737L: return "DW_TAG_ALTIUM_circ_type";
            case 20738L: return "DW_TAG_ALTIUM_mwa_circ_type";
            case 20739L: return "DW_TAG_ALTIUM_rev_carry_type";
            case 20753L: return "DW_TAG_ALTIUM_rom";
            case 34661L: return "DW_TAG_upc_shared_type";
            case 34662L: return "DW_TAG_upc_strict_type";
            case 34663L: return "DW_TAG_upc_relaxed_type";
            case 40960L: return "DW_TAG_PGI_kanji_type";
            case 40992L: return "DW_TAG_PGI_interface_block";
            case 65535L: return "DW_TAG_hi_user";
            default: return "";
        }
    }

    std::string DWARF_TAG(int64_t i, const std::string &strip) {
        std::string s = DWARF_TAG(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_TAG)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_TAG() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            8L,
            10L,
            11L,
            13L,
            15L,
            16L,
            17L,
            18L,
            19L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            16512L,
            16513L,
            16528L,
            16641L,
            16642L,
            16643L,
            16644L,
            16645L,
            16646L,
            16647L,
            16648L,
            16649L,
            16650L,
            16897L,
            16898L,
            16899L,
            16900L,
            16901L,
            16902L,
            16903L,
            16904L,
            16905L,
            16906L,
            16907L,
            16908L,
            16909L,
            17151L,
            20737L,
            20738L,
            20739L,
            20753L,
            34661L,
            34662L,
            34663L,
            40960L,
            40992L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 98);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_TAG(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_TAG(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_TAG)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_TAG::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_TAG() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_TAG();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 117
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_FORM(int64_t i) {
        switch (i) {
            case 1L: return "DW_FORM_addr";
            case 3L: return "DW_FORM_block2";
            case 4L: return "DW_FORM_block4";
            case 5L: return "DW_FORM_data2";
            case 6L: return "DW_FORM_data4";
            case 7L: return "DW_FORM_data8";
            case 8L: return "DW_FORM_string";
            case 9L: return "DW_FORM_block";
            case 10L: return "DW_FORM_block1";
            case 11L: return "DW_FORM_data1";
            case 12L: return "DW_FORM_flag";
            case 13L: return "DW_FORM_sdata";
            case 14L: return "DW_FORM_strp";
            case 15L: return "DW_FORM_udata";
            case 16L: return "DW_FORM_ref_addr";
            case 17L: return "DW_FORM_ref1";
            case 18L: return "DW_FORM_ref2";
            case 19L: return "DW_FORM_ref4";
            case 20L: return "DW_FORM_ref8";
            case 21L: return "DW_FORM_ref_udata";
            case 22L: return "DW_FORM_indirect";
            case 23L: return "DW_FORM_sec_offset";
            case 24L: return "DW_FORM_exprloc";
            case 25L: return "DW_FORM_flag_present";
            case 32L: return "DW_FORM_ref_sig8";
            default: return "";
        }
    }

    std::string DWARF_FORM(int64_t i, const std::string &strip) {
        std::string s = DWARF_FORM(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_FORM)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_FORM() {
        static const int64_t values[] = {
            1L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_FORM(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_FORM(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_FORM)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_FORM::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_FORM() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_FORM();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 146
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_AT(int64_t i) {
        switch (i) {
            case 1L: return "DW_AT_sibling";
            case 2L: return "DW_AT_location";
            case 3L: return "DW_AT_name";
            case 9L: return "DW_AT_ordering";
            case 10L: return "DW_AT_subscr_data";
            case 11L: return "DW_AT_byte_size";
            case 12L: return "DW_AT_bit_offset";
            case 13L: return "DW_AT_bit_size";
            case 15L: return "DW_AT_element_list";
            case 16L: return "DW_AT_stmt_list";
            case 17L: return "DW_AT_low_pc";
            case 18L: return "DW_AT_high_pc";
            case 19L: return "DW_AT_language";
            case 20L: return "DW_AT_member";
            case 21L: return "DW_AT_discr";
            case 22L: return "DW_AT_discr_value";
            case 23L: return "DW_AT_visibility";
            case 24L: return "DW_AT_import";
            case 25L: return "DW_AT_string_length";
            case 26L: return "DW_AT_common_reference";
            case 27L: return "DW_AT_comp_dir";
            case 28L: return "DW_AT_const_value";
            case 29L: return "DW_AT_containing_type";
            case 30L: return "DW_AT_default_value";
            case 32L: return "DW_AT_inline";
            case 33L: return "DW_AT_is_optional";
            case 34L: return "DW_AT_lower_bound";
            case 37L: return "DW_AT_producer";
            case 39L: return "DW_AT_prototyped";
            case 42L: return "DW_AT_return_addr";
            case 44L: return "DW_AT_start_scope";
            case 46L: return "DW_AT_stride_size";
            case 47L: return "DW_AT_upper_bound";
            case 49L: return "DW_AT_abstract_origin";
            case 50L: return "DW_AT_accessibility";
            case 51L: return "DW_AT_address_class";
            case 52L: return "DW_AT_artificial";
            case 53L: return "DW_AT_base_types";
            case 54L: return "DW_AT_calling_convention";
            case 55L: return "DW_AT_count";
            case 56L: return "DW_AT_data_member_location";
            case 57L: return "DW_AT_decl_column";
            case 58L: return "DW_AT_decl_file";
            case 59L: return "DW_AT_decl_line";
            case 60L: return "DW_AT_declaration";
            case 61L: return "DW_AT_discr_list";
            case 62L: return "DW_AT_encoding";
            case 63L: return "DW_AT_external";
            case 64L: return "DW_AT_frame_base";
            case 65L: return "DW_AT_friend";
            case 66L: return "DW_AT_identifier_case";
            case 67L: return "DW_AT_macro_info";
            case 68L: return "DW_AT_namelist_item";
            case 69L: return "DW_AT_priority";
            case 70L: return "DW_AT_segment";
            case 71L: return "DW_AT_specification";
            case 72L: return "DW_AT_static_link";
            case 73L: return "DW_AT_type";
            case 74L: return "DW_AT_use_location";
            case 75L: return "DW_AT_variable_parameter";
            case 76L: return "DW_AT_virtuality";
            case 77L: return "DW_AT_vtable_elem_location";
            case 78L: return "DW_AT_allocated";
            case 79L: return "DW_AT_associated";
            case 80L: return "DW_AT_data_location";
            case 81L: return "DW_AT_byte_stride";
            case 82L: return "DW_AT_entry_pc";
            case 83L: return "DW_AT_use_UTF8";
            case 84L: return "DW_AT_extension";
            case 85L: return "DW_AT_ranges";
            case 86L: return "DW_AT_trampoline";
            case 87L: return "DW_AT_call_column";
            case 88L: return "DW_AT_call_file";
            case 89L: return "DW_AT_call_line";
            case 90L: return "DW_AT_description";
            case 91L: return "DW_AT_binary_scale";
            case 92L: return "DW_AT_decimal_scale";
            case 93L: return "DW_AT_small";
            case 94L: return "DW_AT_decimal_sign";
            case 95L: return "DW_AT_digit_count";
            case 96L: return "DW_AT_picture_string";
            case 97L: return "DW_AT_mutable";
            case 98L: return "DW_AT_threads_scaled";
            case 99L: return "DW_AT_explicit";
            case 100L: return "DW_AT_object_pointer";
            case 101L: return "DW_AT_endianity";
            case 102L: return "DW_AT_elemental";
            case 103L: return "DW_AT_pure";
            case 104L: return "DW_AT_recursive";
            case 105L: return "DW_AT_signature";
            case 106L: return "DW_AT_main_subprogram";
            case 107L: return "DW_AT_data_bit_offset";
            case 108L: return "DW_AT_const_expr";
            case 109L: return "DW_AT_enum_class";
            case 110L: return "DW_AT_linkage_name";
            case 8192L: return "DW_AT_HP_block_index";
            case 8193L: return "DW_AT_MIPS_fde";
            case 8194L: return "DW_AT_MIPS_loop_begin";
            case 8195L: return "DW_AT_MIPS_tail_loop_begin";
            case 8196L: return "DW_AT_MIPS_epilog_begin";
            case 8197L: return "DW_AT_MIPS_loop_unroll_factor";
            case 8198L: return "DW_AT_MIPS_software_pipeline_depth";
            case 8199L: return "DW_AT_MIPS_linkage_name";
            case 8200L: return "DW_AT_MIPS_stride";
            case 8201L: return "DW_AT_MIPS_abstract_name";
            case 8202L: return "DW_AT_MIPS_clone_origin";
            case 8203L: return "DW_AT_MIPS_has_inlines";
            case 8204L: return "DW_AT_MIPS_stride_byte";
            case 8205L: return "DW_AT_MIPS_stride_elem";
            case 8206L: return "DW_AT_MIPS_ptr_dopetype";
            case 8207L: return "DW_AT_MIPS_allocatable_dopetype";
            case 8208L: return "DW_AT_MIPS_assumed_shape_dopetype";
            case 8209L: return "DW_AT_MIPS_assumed_size";
            case 8210L: return "DW_AT_HP_raw_data_ptr";
            case 8211L: return "DW_AT_HP_pass_by_reference";
            case 8212L: return "DW_AT_HP_opt_level";
            case 8213L: return "DW_AT_HP_prof_version_id";
            case 8214L: return "DW_AT_HP_opt_flags";
            case 8215L: return "DW_AT_HP_cold_region_low_pc";
            case 8216L: return "DW_AT_HP_cold_region_high_pc";
            case 8217L: return "DW_AT_HP_all_variables_modifiable";
            case 8218L: return "DW_AT_HP_linkage_name";
            case 8219L: return "DW_AT_HP_prof_flags";
            case 8230L: return "DW_AT_INTEL_other_endian";
            case 8449L: return "DW_AT_sf_names";
            case 8450L: return "DW_AT_src_info";
            case 8451L: return "DW_AT_mac_info";
            case 8452L: return "DW_AT_src_coords";
            case 8453L: return "DW_AT_body_begin";
            case 8454L: return "DW_AT_body_end";
            case 8455L: return "DW_AT_GNU_vector";
            case 8456L: return "DW_AT_GNU_guarded_by";
            case 8457L: return "DW_AT_GNU_pt_guarded_by";
            case 8458L: return "DW_AT_GNU_guarded";
            case 8459L: return "DW_AT_GNU_pt_guarded";
            case 8460L: return "DW_AT_GNU_locks_excluded";
            case 8461L: return "DW_AT_GNU_exclusive_locks_required";
            case 8462L: return "DW_AT_GNU_shared_locks_required";
            case 8463L: return "DW_AT_GNU_odr_signature";
            case 8464L: return "DW_AT_GNU_template_name";
            case 8465L: return "DW_AT_GNU_call_site_value";
            case 8466L: return "DW_AT_GNU_call_site_data_value";
            case 8467L: return "DW_AT_GNU_call_site_target";
            case 8468L: return "DW_AT_GNU_call_site_target_clobbered";
            case 8469L: return "DW_AT_GNU_tail_call";
            case 8470L: return "DW_AT_GNU_all_tail_call_sites";
            case 8471L: return "DW_AT_GNU_all_call_sites";
            case 8472L: return "DW_AT_GNU_all_source_call_sites";
            case 8705L: return "DW_AT_SUN_template";
            case 8706L: return "DW_AT_SUN_alignment";
            case 8707L: return "DW_AT_SUN_vtable";
            case 8708L: return "DW_AT_SUN_count_guarantee";
            case 8709L: return "DW_AT_SUN_command_line";
            case 8710L: return "DW_AT_SUN_vbase";
            case 8711L: return "DW_AT_SUN_compile_options";
            case 8712L: return "DW_AT_SUN_language";
            case 8713L: return "DW_AT_SUN_browser_file";
            case 8720L: return "DW_AT_SUN_vtable_abi";
            case 8721L: return "DW_AT_SUN_func_offsets";
            case 8722L: return "DW_AT_SUN_cf_kind";
            case 8723L: return "DW_AT_SUN_vtable_index";
            case 8724L: return "DW_AT_SUN_omp_tpriv_addr";
            case 8725L: return "DW_AT_SUN_omp_child_func";
            case 8726L: return "DW_AT_SUN_func_offset";
            case 8727L: return "DW_AT_SUN_memop_type_ref";
            case 8728L: return "DW_AT_SUN_profile_id";
            case 8729L: return "DW_AT_SUN_memop_signature";
            case 8736L: return "DW_AT_SUN_obj_dir";
            case 8737L: return "DW_AT_SUN_obj_file";
            case 8738L: return "DW_AT_SUN_original_name";
            case 8739L: return "DW_AT_SUN_hwcprof_signature";
            case 8740L: return "DW_AT_SUN_amd64_parmdump";
            case 8741L: return "DW_AT_SUN_part_link_name";
            case 8742L: return "DW_AT_SUN_link_name";
            case 8743L: return "DW_AT_SUN_pass_with_const";
            case 8744L: return "DW_AT_SUN_return_with_const";
            case 8745L: return "DW_AT_SUN_import_by_name";
            case 8746L: return "DW_AT_SUN_f90_pointer";
            case 8747L: return "DW_AT_SUN_pass_by_ref";
            case 8748L: return "DW_AT_SUN_f90_allocatable";
            case 8749L: return "DW_AT_SUN_f90_assumed_shape_array";
            case 8750L: return "DW_AT_SUN_c_vla";
            case 8752L: return "DW_AT_SUN_return_value_ptr";
            case 8753L: return "DW_AT_SUN_dtor_start";
            case 8754L: return "DW_AT_SUN_dtor_length";
            case 8755L: return "DW_AT_SUN_dtor_state_initial";
            case 8756L: return "DW_AT_SUN_dtor_state_final";
            case 8757L: return "DW_AT_SUN_dtor_state_deltas";
            case 8758L: return "DW_AT_SUN_import_by_lname";
            case 8759L: return "DW_AT_SUN_f90_use_only";
            case 8760L: return "DW_AT_SUN_namelist_spec";
            case 8761L: return "DW_AT_SUN_is_omp_child_func";
            case 8762L: return "DW_AT_SUN_fortran_main_alias";
            case 8763L: return "DW_AT_SUN_fortran_based";
            case 8960L: return "DW_AT_ALTIUM_loclist";
            case 8961L: return "DW_AT_use_GNAT_descriptive_type";
            case 8962L: return "DW_AT_GNAT_descriptive_type";
            case 12816L: return "DW_AT_upc_threads_scaled";
            case 14848L: return "DW_AT_PGI_lbase";
            case 14849L: return "DW_AT_PGI_soffset";
            case 14850L: return "DW_AT_PGI_lstride";
            case 16353L: return "DW_AT_APPLE_optimized";
            case 16354L: return "DW_AT_APPLE_flags";
            case 16355L: return "DW_AT_APPLE_isa";
            case 16356L: return "DW_AT_APPLE_block";
            case 16357L: return "DW_AT_APPLE_major_runtime_vers";
            case 16358L: return "DW_AT_APPLE_runtime_class";
            case 16359L: return "DW_AT_APPLE_omit_frame_ptr";
            case 16383L: return "DW_AT_hi_user";
            default: return "";
        }
    }

    std::string DWARF_AT(int64_t i, const std::string &strip) {
        std::string s = DWARF_AT(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_AT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_AT() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            9L,
            10L,
            11L,
            12L,
            13L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            32L,
            33L,
            34L,
            37L,
            39L,
            42L,
            44L,
            46L,
            47L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            8192L,
            8193L,
            8194L,
            8195L,
            8196L,
            8197L,
            8198L,
            8199L,
            8200L,
            8201L,
            8202L,
            8203L,
            8204L,
            8205L,
            8206L,
            8207L,
            8208L,
            8209L,
            8210L,
            8211L,
            8212L,
            8213L,
            8214L,
            8215L,
            8216L,
            8217L,
            8218L,
            8219L,
            8230L,
            8449L,
            8450L,
            8451L,
            8452L,
            8453L,
            8454L,
            8455L,
            8456L,
            8457L,
            8458L,
            8459L,
            8460L,
            8461L,
            8462L,
            8463L,
            8464L,
            8465L,
            8466L,
            8467L,
            8468L,
            8469L,
            8470L,
            8471L,
            8472L,
            8705L,
            8706L,
            8707L,
            8708L,
            8709L,
            8710L,
            8711L,
            8712L,
            8713L,
            8720L,
            8721L,
            8722L,
            8723L,
            8724L,
            8725L,
            8726L,
            8727L,
            8728L,
            8729L,
            8736L,
            8737L,
            8738L,
            8739L,
            8740L,
            8741L,
            8742L,
            8743L,
            8744L,
            8745L,
            8746L,
            8747L,
            8748L,
            8749L,
            8750L,
            8752L,
            8753L,
            8754L,
            8755L,
            8756L,
            8757L,
            8758L,
            8759L,
            8760L,
            8761L,
            8762L,
            8763L,
            8960L,
            8961L,
            8962L,
            12816L,
            14848L,
            14849L,
            14850L,
            16353L,
            16354L,
            16355L,
            16356L,
            16357L,
            16358L,
            16359L,
            16383L
        };
        static const std::vector<int64_t> retval(values, values + 209);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_AT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_AT(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_AT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_AT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_AT() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_AT();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Dwarf/Constants.h line 360
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Dwarf {
    const char* DWARF_LANG(int64_t i) {
        switch (i) {
            case 1L: return "DW_LANG_C89";
            case 2L: return "DW_LANG_C";
            case 3L: return "DW_LANG_Ada83";
            case 4L: return "DW_LANG_C_plus_plus";
            case 5L: return "DW_LANG_Cobol74";
            case 6L: return "DW_LANG_Cobol85";
            case 7L: return "DW_LANG_Fortran77";
            case 8L: return "DW_LANG_Fortran90";
            case 9L: return "DW_LANG_Pascal83";
            case 10L: return "DW_LANG_Modula2";
            case 11L: return "DW_LANG_Java";
            case 12L: return "DW_LANG_C99";
            case 13L: return "DW_LANG_Ada95";
            case 14L: return "DW_LANG_Fortran95";
            case 15L: return "DW_LANG_PLI";
            case 16L: return "DW_LANG_ObjC";
            case 17L: return "DW_LANG_ObjC_plus_plus";
            case 18L: return "DW_LANG_UPC";
            case 19L: return "DW_LANG_D";
            case 20L: return "DW_LANG_Python";
            case 21L: return "DW_LANG_OpenCL";
            case 22L: return "DW_LANG_Go";
            case 23L: return "DW_LANG_Modula3";
            case 24L: return "DW_LANG_Haskel";
            case 32768L: return "DW_LANG_lo_user";
            case 32769L: return "DW_LANG_Mips_Assembler";
            case 34661L: return "DW_LANG_Upc";
            case 36865L: return "DW_LANG_SUN_Assembler";
            case 37121L: return "DW_LANG_ALTIUM_Assembler";
            case 65535L: return "DW_LANG_hi_user";
            default: return "";
        }
    }

    std::string DWARF_LANG(int64_t i, const std::string &strip) {
        std::string s = DWARF_LANG(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Dwarf::DWARF_LANG)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DWARF_LANG() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            32768L,
            32769L,
            34661L,
            36865L,
            37121L,
            65535L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDwarfDWARF_LANG(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Dwarf::DWARF_LANG(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Dwarf::DWARF_LANG)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Dwarf::DWARF_LANG::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDwarfDWARF_LANG() {
        return stringify::Rose::BinaryAnalysis::Dwarf::DWARF_LANG();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 134
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap { namespace Attach {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapAttachBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::Attach::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::Attach::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapAttachBoolean() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::Attach::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 141
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap {
    const char* Clobber(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Clobber(int64_t i, const std::string &strip) {
        std::string s = Clobber(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::Clobber)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Clobber() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapClobber(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::Clobber(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::Clobber)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::Clobber::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapClobber() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::Clobber();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MemoryMap.h line 303
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MemoryMap {
    const char* InsertFileMapMode(int64_t i) {
        switch (i) {
            case 0L: return "MAP_PRIVATE";
            case 1L: return "MAP_READWRITE";
            case 2L: return "MAP_RDONLY";
            default: return "";
        }
    }

    std::string InsertFileMapMode(int64_t i, const std::string &strip) {
        std::string s = InsertFileMapMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InsertFileMapMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMemoryMapInsertFileMapMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMemoryMapInsertFileMapMode() {
        return stringify::Rose::BinaryAnalysis::MemoryMap::InsertFileMapMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Architecture/ArmAarch32.h line 56
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Architecture { namespace ArmAarch32 {
    const char* InstructionSet(int64_t i) {
        switch (i) {
            case 0L: return "T32";
            case 1L: return "A32";
            default: return "";
        }
    }

    std::string InstructionSet(int64_t i, const std::string &strip) {
        std::string s = InstructionSet(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InstructionSet() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisArchitectureArmAarch32InstructionSet(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisArchitectureArmAarch32InstructionSet() {
        return stringify::Rose::BinaryAnalysis::Architecture::ArmAarch32::InstructionSet();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsJvm.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* JvmInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "nop";
            case 1L: return "aconst_null";
            case 2L: return "iconst_m1";
            case 3L: return "iconst_0";
            case 4L: return "iconst_1";
            case 5L: return "iconst_2";
            case 6L: return "iconst_3";
            case 7L: return "iconst_4";
            case 8L: return "iconst_5";
            case 9L: return "lconst_0";
            case 10L: return "lconst_1";
            case 11L: return "fconst_0";
            case 12L: return "fconst_1";
            case 13L: return "fconst_2";
            case 14L: return "dconst_0";
            case 15L: return "dconst_1";
            case 16L: return "bipush";
            case 17L: return "sipush";
            case 18L: return "ldc";
            case 19L: return "ldc_w";
            case 20L: return "ldc2_w";
            case 21L: return "iload";
            case 22L: return "lload";
            case 23L: return "fload";
            case 24L: return "dload";
            case 25L: return "aload";
            case 26L: return "iload_0";
            case 27L: return "iload_1";
            case 28L: return "iload_2";
            case 29L: return "iload_3";
            case 30L: return "lload_0";
            case 31L: return "lload_1";
            case 32L: return "lload_2";
            case 33L: return "lload_3";
            case 34L: return "fload_0";
            case 35L: return "fload_1";
            case 36L: return "fload_2";
            case 37L: return "fload_3";
            case 38L: return "dload_0";
            case 39L: return "dload_1";
            case 40L: return "dload_2";
            case 41L: return "dload_3";
            case 42L: return "aload_0";
            case 43L: return "aload_1";
            case 44L: return "aload_2";
            case 45L: return "aload_3";
            case 46L: return "iaload";
            case 47L: return "laload";
            case 48L: return "faload";
            case 49L: return "daload";
            case 50L: return "aaload";
            case 51L: return "baload";
            case 52L: return "caload";
            case 53L: return "saload";
            case 54L: return "istore";
            case 55L: return "lstore";
            case 56L: return "fstore";
            case 57L: return "dstore";
            case 58L: return "astore";
            case 59L: return "istore_0";
            case 60L: return "istore_1";
            case 61L: return "istore_2";
            case 62L: return "istore_3";
            case 63L: return "lstore_0";
            case 64L: return "lstore_1";
            case 65L: return "lstore_2";
            case 66L: return "lstore_3";
            case 67L: return "fstore_0";
            case 68L: return "fstore_1";
            case 69L: return "fstore_2";
            case 70L: return "fstore_3";
            case 71L: return "dstore_0";
            case 72L: return "dstore_1";
            case 73L: return "dstore_2";
            case 74L: return "dstore_3";
            case 75L: return "astore_0";
            case 76L: return "astore_1";
            case 77L: return "astore_2";
            case 78L: return "astore_3";
            case 79L: return "iastore";
            case 80L: return "lastore";
            case 81L: return "fastore";
            case 82L: return "dastore";
            case 83L: return "aastore";
            case 84L: return "bastore";
            case 85L: return "castore";
            case 86L: return "sastore";
            case 87L: return "pop";
            case 88L: return "pop2";
            case 89L: return "dup";
            case 90L: return "dup_x1";
            case 91L: return "dup_x2";
            case 92L: return "dup2";
            case 93L: return "dup2_x1";
            case 94L: return "dup2_x2";
            case 95L: return "swap";
            case 96L: return "iadd";
            case 97L: return "ladd";
            case 98L: return "fadd";
            case 99L: return "dadd";
            case 100L: return "isub";
            case 101L: return "lsub";
            case 102L: return "fsub";
            case 103L: return "dsub";
            case 104L: return "imul";
            case 105L: return "lmul";
            case 106L: return "fmul";
            case 107L: return "dmul";
            case 108L: return "idiv";
            case 109L: return "ldiv";
            case 110L: return "fdiv";
            case 111L: return "ddiv";
            case 112L: return "irem";
            case 113L: return "lrem";
            case 114L: return "frem";
            case 115L: return "drem";
            case 116L: return "ineg";
            case 117L: return "lneg";
            case 118L: return "fneg";
            case 119L: return "dneg";
            case 120L: return "ishl";
            case 121L: return "lshl";
            case 122L: return "ishr";
            case 123L: return "lshr";
            case 124L: return "iushr";
            case 125L: return "lushr";
            case 126L: return "iand";
            case 127L: return "land";
            case 128L: return "ior";
            case 129L: return "lor";
            case 130L: return "ixor";
            case 131L: return "lxor";
            case 132L: return "iinc";
            case 133L: return "i2l";
            case 134L: return "i2f";
            case 135L: return "i2d";
            case 136L: return "l2i";
            case 137L: return "l2f";
            case 138L: return "l2d";
            case 139L: return "f2i";
            case 140L: return "f2l";
            case 141L: return "f2d";
            case 142L: return "d2i";
            case 143L: return "d2l";
            case 144L: return "d2f";
            case 145L: return "i2b";
            case 146L: return "i2c";
            case 147L: return "i2s";
            case 148L: return "lcmp";
            case 149L: return "fcmpl";
            case 150L: return "fcmpg";
            case 151L: return "dcmpl";
            case 152L: return "dcmpg";
            case 153L: return "ifeq";
            case 154L: return "ifne";
            case 155L: return "iflt";
            case 156L: return "ifge";
            case 157L: return "ifgt";
            case 158L: return "ifle";
            case 159L: return "if_icmpeq";
            case 160L: return "if_icmpne";
            case 161L: return "if_icmplt";
            case 162L: return "if_icmpge";
            case 163L: return "if_icmpgt";
            case 164L: return "if_icmple";
            case 165L: return "if_acmpeq";
            case 166L: return "if_acmpne";
            case 167L: return "goto_";
            case 168L: return "jsr";
            case 169L: return "ret";
            case 170L: return "tableswitch";
            case 171L: return "lookupswitch";
            case 172L: return "ireturn";
            case 173L: return "lreturn";
            case 174L: return "freturn";
            case 175L: return "dreturn";
            case 176L: return "areturn";
            case 177L: return "return_";
            case 178L: return "getstatic";
            case 179L: return "putstatic";
            case 180L: return "getfield";
            case 181L: return "putfield";
            case 182L: return "invokevirtual";
            case 183L: return "invokespecial";
            case 184L: return "invokestatic";
            case 185L: return "invokeinterface";
            case 186L: return "invokedynamic";
            case 187L: return "new_";
            case 188L: return "newarray";
            case 189L: return "anewarray";
            case 190L: return "arraylength";
            case 191L: return "athrow";
            case 192L: return "checkcast";
            case 193L: return "instanceof";
            case 194L: return "monitorenter";
            case 195L: return "monitorexit";
            case 196L: return "wide";
            case 197L: return "multianewarray";
            case 198L: return "ifnull";
            case 199L: return "ifnonnull";
            case 200L: return "goto_w";
            case 201L: return "jsr_w";
            case 202L: return "breakpoint";
            case 254L: return "impdep1";
            case 255L: return "impdep2";
            case 666L: return "unknown";
            default: return "";
        }
    }

    std::string JvmInstructionKind(int64_t i, const std::string &strip) {
        std::string s = JvmInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::JvmInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& JvmInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            254L,
            255L,
            666L
        };
        static const std::vector<int64_t> retval(values, values + 206);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisJvmInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::JvmInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::JvmInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::JvmInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisJvmInstructionKind() {
        return stringify::Rose::BinaryAnalysis::JvmInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Reachability.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Reachability {
    const char* Reason(int64_t i) {
        switch (i) {
            case 0L: return "NOT_REACHABLE";
            case 1L: return "PROGRAM_ENTRY_POINT";
            case 2L: return "EXPORTED_FUNCTION";
            case 4L: return "SIGNAL_HANDLER";
            case 128L: return "ASSUMED";
            case 256L: return "EXPLICIT_MEM_CONSTANT";
            case 512L: return "EXPLICIT_INSN_CONSTANT";
            case 1024L: return "IMPLICIT_FUNC_CONSTANT";
            case 65536L: return "USER_DEFINED_0";
            case 131072L: return "USER_DEFINED_1";
            case 262144L: return "USER_DEFINED_2";
            case 524288L: return "USER_DEFINED_3";
            case 1048576L: return "USER_DEFINED_4";
            case 2097152L: return "USER_DEFINED_5";
            case 4194304L: return "USER_DEFINED_6";
            case 8388608L: return "USER_DEFINED_7";
            case 16777216L: return "USER_DEFINED_8";
            case 33554432L: return "USER_DEFINED_9";
            case 67108864L: return "USER_DEFINED_10";
            case 134217728L: return "USER_DEFINED_11";
            case 268435456L: return "USER_DEFINED_12";
            case 536870912L: return "USER_DEFINED_13";
            case 1073741824L: return "USER_DEFINED_14";
            case 2147483648L: return "USER_DEFINED_15";
            default: return "";
        }
    }

    std::string Reason(int64_t i, const std::string &strip) {
        std::string s = Reason(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Reason() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            128L,
            256L,
            512L,
            1024L,
            65536L,
            131072L,
            262144L,
            524288L,
            1048576L,
            2097152L,
            4194304L,
            8388608L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisReachabilityReason(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Reachability::Reason(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Reachability::Reason)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Reachability::Reason::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisReachabilityReason() {
        return stringify::Rose::BinaryAnalysis::Reachability::Reason();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 163
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* TestMode(int64_t i) {
        switch (i) {
            case 0L: return "OFF";
            case 1L: return "MAY";
            case 2L: return "MUST";
            default: return "";
        }
    }

    std::string TestMode(int64_t i, const std::string &strip) {
        std::string s = TestMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::TestMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TestMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerTestMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::TestMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::TestMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::TestMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerTestMode() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::TestMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 170
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* IoMode(int64_t i) {
        switch (i) {
            case 0L: return "WRITE";
            case 1L: return "READ";
            default: return "";
        }
    }

    std::string IoMode(int64_t i, const std::string &strip) {
        std::string s = IoMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::IoMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerIoMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::IoMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::IoMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::IoMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerIoMode() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::IoMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 176
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* Prune(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Prune(int64_t i, const std::string &strip) {
        std::string s = Prune(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::Prune)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Prune() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerPrune(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::Prune(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::Prune)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::Prune::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerPrune() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::Prune();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/BasicTypes.h line 182
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker {
    const char* WorkerState(int64_t i) {
        switch (i) {
            case 0L: return "STARTING";
            case 1L: return "WAITING";
            case 2L: return "WORKING";
            case 3L: return "FINISHED";
            default: return "";
        }
    }

    std::string WorkerState(int64_t i, const std::string &strip) {
        std::string s = WorkerState(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::WorkerState)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WorkerState() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerWorkerState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::WorkerState(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::WorkerState)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::WorkerState::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerWorkerState() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::WorkerState();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ModelChecker/PartitionerModel.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ModelChecker { namespace PartitionerModel { namespace Settings {
    const char* MemoryType(int64_t i) {
        switch (i) {
            case 0L: return "LIST";
            case 1L: return "MAP";
            default: return "";
        }
    }

    std::string MemoryType(int64_t i, const std::string &strip) {
        std::string s = MemoryType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisModelCheckerPartitionerModelSettingsMemoryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisModelCheckerPartitionerModelSettingsMemoryType() {
        return stringify::Rose::BinaryAnalysis::ModelChecker::PartitionerModel::Settings::MemoryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/CfgPath.h line 472
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Inliner {
    const char* HowInline(int64_t i) {
        switch (i) {
            case 0L: return "INLINE_NONE";
            case 1L: return "INLINE_NORMAL";
            case 2L: return "INLINE_USER";
            default: return "";
        }
    }

    std::string HowInline(int64_t i, const std::string &strip) {
        std::string s = HowInline(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& HowInline() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2InlinerHowInline(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2InlinerHowInline() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Inliner::HowInline();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/ModulesX86.h line 109
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace ModulesX86 { namespace SwitchSuccessors {
    const char* EntryType(int64_t i) {
        switch (i) {
            case 0L: return "ABSOLUTE";
            case 1L: return "RELATIVE";
            default: return "";
        }
    }

    std::string EntryType(int64_t i, const std::string &strip) {
        std::string s = EntryType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EntryType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ModulesX86SwitchSuccessorsEntryType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ModulesX86SwitchSuccessorsEntryType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::ModulesX86::SwitchSuccessors::EntryType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/ModulesElf.h line 88
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace ModulesElf { namespace FixUndefinedSymbols {
    const char* Boolean(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Boolean(int64_t i, const std::string &strip) {
        std::string s = Boolean(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Boolean() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ModulesElfFixUndefinedSymbolsBoolean() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::ModulesElf::FixUndefinedSymbols::Boolean();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Modules.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace BasicBlockCallback {
    const char* Termination(int64_t i) {
        switch (i) {
            case 0L: return "CONTINUE_DISCOVERY";
            case 1L: return "TERMINATE_NOW";
            case 2L: return "TERMINATE_PRIOR";
            default: return "";
        }
    }

    std::string Termination(int64_t i, const std::string &strip) {
        std::string s = Termination(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Termination() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Precision {
    const char* Level(int64_t i) {
        switch (i) {
            case 0L: return "LOW";
            case 1L: return "HIGH";
            default: return "";
        }
    }

    std::string Level(int64_t i, const std::string &strip) {
        std::string s = Level(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Level() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PrecisionLevel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Precision::Level)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Precision::Level::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PrecisionLevel() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Precision::Level();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace AllowParallelEdges {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2AllowParallelEdgesType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::AllowParallelEdges::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 51
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* VertexType(int64_t i) {
        switch (i) {
            case 0L: return "V_BASIC_BLOCK";
            case 1L: return "V_UNDISCOVERED";
            case 2L: return "V_INDETERMINATE";
            case 3L: return "V_NONEXISTING";
            case 4L: return "V_USER_DEFINED";
            default: return "";
        }
    }

    std::string VertexType(int64_t i, const std::string &strip) {
        std::string s = VertexType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VertexType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2VertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::VertexType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::VertexType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::VertexType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2VertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::VertexType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 62
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* EdgeType(int64_t i) {
        switch (i) {
            case 1L: return "E_NORMAL";
            case 2L: return "E_FUNCTION_CALL";
            case 4L: return "E_FUNCTION_RETURN";
            case 8L: return "E_CALL_RETURN";
            case 16L: return "E_FUNCTION_XFER";
            case 32L: return "E_USER_DEFINED";
            default: return "";
        }
    }

    std::string EdgeType(int64_t i, const std::string &strip) {
        std::string s = EdgeType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeType() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2EdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::EdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::EdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2EdgeType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::EdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 86
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* Confidence(int64_t i) {
        switch (i) {
            case 0L: return "ASSUMED";
            case 1L: return "PROVED";
            default: return "";
        }
    }

    std::string Confidence(int64_t i, const std::string &strip) {
        std::string s = Confidence(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Confidence() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2Confidence(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Confidence(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Confidence)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Confidence::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2Confidence() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Confidence();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 92
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 179
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* MemoryDataAdjustment(int64_t i) {
        switch (i) {
            case 0L: return "DATA_IS_CONSTANT";
            case 1L: return "DATA_IS_INITIALIZED";
            case 2L: return "DATA_NO_CHANGE";
            default: return "";
        }
    }

    std::string MemoryDataAdjustment(int64_t i, const std::string &strip) {
        std::string s = MemoryDataAdjustment(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MemoryDataAdjustment() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2MemoryDataAdjustment() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::MemoryDataAdjustment();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/BasicTypes.h line 312
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 {
    const char* FunctionReturnAnalysis(int64_t i) {
        switch (i) {
            case 0L: return "MAYRETURN_DEFAULT_YES";
            case 1L: return "MAYRETURN_DEFAULT_NO";
            case 2L: return "MAYRETURN_ALWAYS_YES";
            case 3L: return "MAYRETURN_ALWAYS_NO";
            default: return "";
        }
    }

    std::string FunctionReturnAnalysis(int64_t i, const std::string &strip) {
        std::string s = FunctionReturnAnalysis(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FunctionReturnAnalysis() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionReturnAnalysis() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::FunctionReturnAnalysis();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Partitioner.h line 1396
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Partitioner { namespace MayReturnVertexInfo {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "INIT";
            case 1L: return "CALCULATING";
            case 2L: return "FINISHED";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Reference.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Reference {
    const char* Granularity(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "ADDRESS";
            case 2L: return "INSTRUCTION";
            case 3L: return "BASIC_BLOCK";
            case 4L: return "FUNCTION";
            default: return "";
        }
    }

    std::string Granularity(int64_t i, const std::string &strip) {
        std::string s = Granularity(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Granularity() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2ReferenceGranularity(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Reference::Granularity)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Reference::Granularity::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2ReferenceGranularity() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Reference::Granularity();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/Function.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace Function {
    const char* Ownership(int64_t i) {
        switch (i) {
            case 0L: return "OWN_UNOWNED";
            case 1L: return "OWN_EXPLICIT";
            case 2L: return "OWN_PROVISIONAL";
            default: return "";
        }
    }

    std::string Ownership(int64_t i, const std::string &strip) {
        std::string s = Ownership(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Ownership() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2FunctionOwnership(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::Function::Ownership)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::Function::Ownership::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2FunctionOwnership() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::Function::Ownership();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Partitioner2/DataFlow.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Partitioner2 { namespace DataFlow { namespace DfCfgVertex {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "BBLOCK";
            case 1L: return "FAKED_CALL";
            case 2L: return "FUNCRET";
            case 3L: return "INDET";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType() {
        return stringify::Rose::BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/PointerDetection.h line 177
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace PointerDetection { namespace PointerDescriptor {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisPointerDetectionPointerDescriptorDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisPointerDetectionPointerDescriptorDirection() {
        return stringify::Rose::BinaryAnalysis::PointerDetection::PointerDescriptor::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Mips.h line 66
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Mips { namespace Decoder {
    const char* Architecture(int64_t i) {
        switch (i) {
            case 0L: return "Release1";
            case 1L: return "Release2";
            case 2L: return "Release3";
            case 3L: return "Micro";
            default: return "";
        }
    }

    std::string Architecture(int64_t i, const std::string &strip) {
        std::string s = Architecture(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Architecture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerMipsDecoderArchitecture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerMipsDecoderArchitecture() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Mips::Decoder::Architecture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Aarch32.h line 25
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Aarch32 {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "V8";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Aarch32::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerAarch32Mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Aarch32::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Aarch32::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Aarch32::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerAarch32Mode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Aarch32::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/X86.h line 149
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace X86 {
    const char* RegisterMode(int64_t i) {
        switch (i) {
            case 0L: return "rmLegacyByte";
            case 1L: return "rmRexByte";
            case 2L: return "rmWord";
            case 3L: return "rmDWord";
            case 4L: return "rmQWord";
            case 5L: return "rmSegment";
            case 6L: return "rmST";
            case 7L: return "rmMM";
            case 8L: return "rmXMM";
            case 9L: return "rmControl";
            case 10L: return "rmDebug";
            case 11L: return "rmReturnNull";
            default: return "";
        }
    }

    std::string RegisterMode(int64_t i, const std::string &strip) {
        std::string s = RegisterMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::X86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegisterMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86RegisterMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::X86::RegisterMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::X86::RegisterMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::X86::RegisterMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86RegisterMode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::X86::RegisterMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/X86.h line 154
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace X86 {
    const char* MMPrefix(int64_t i) {
        switch (i) {
            case 0L: return "mmNone";
            case 1L: return "mmF3";
            case 2L: return "mm66";
            case 3L: return "mmF2";
            default: return "";
        }
    }

    std::string MMPrefix(int64_t i, const std::string &strip) {
        std::string s = MMPrefix(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::X86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MMPrefix() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerX86MMPrefix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::X86::MMPrefix(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::X86::MMPrefix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::X86::MMPrefix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerX86MMPrefix() {
        return stringify::Rose::BinaryAnalysis::Disassembler::X86::MMPrefix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Disassembler/Aarch64.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Disassembler { namespace Aarch64 {
    const char* Mode(int64_t i) {
        switch (i) {
            case 0L: return "MODE_MCLASS";
            default: return "";
        }
    }

    std::string Mode(int64_t i, const std::string &strip) {
        std::string s = Mode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Disassembler::Aarch64::Mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mode() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDisassemblerAarch64Mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Disassembler::Aarch64::Mode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Disassembler::Aarch64::Mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Disassembler::Aarch64::Mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDisassemblerAarch64Mode() {
        return stringify::Rose::BinaryAnalysis::Disassembler::Aarch64::Mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/StackVariable.h line 23
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables { namespace StackVariable {
    const char* Purpose(int64_t i) {
        switch (i) {
            case 0L: return "RETURN_ADDRESS";
            case 1L: return "FRAME_POINTER";
            case 2L: return "STACK_POINTER";
            case 3L: return "SPILL_AREA";
            case 4L: return "NORMAL";
            case 5L: return "UNKNOWN";
            case 6L: return "OTHER";
            default: return "";
        }
    }

    std::string Purpose(int64_t i, const std::string &strip) {
        std::string s = Purpose(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::StackVariable::Purpose)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Purpose() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesStackVariablePurpose(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::StackVariable::Purpose(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::StackVariable::Purpose)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::StackVariable::Purpose::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesStackVariablePurpose() {
        return stringify::Rose::BinaryAnalysis::Variables::StackVariable::Purpose();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/BasicTypes.h line 47
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "READ";
            case 2L: return "WRITE";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::Access(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesAccess() {
        return stringify::Rose::BinaryAnalysis::Variables::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Variables/StackFrame.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Variables { namespace StackFrame {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "GROWS_UP";
            case 1L: return "GROWS_DOWN";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Variables::StackFrame::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisVariablesStackFrameDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Variables::StackFrame::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Variables::StackFrame::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Variables::StackFrame::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisVariablesStackFrameDirection() {
        return stringify::Rose::BinaryAnalysis::Variables::StackFrame::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/HotPatch.h line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "PATCH_REGISTER";
            case 1L: return "PATCH_NONE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordType() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/HotPatch.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace HotPatch { namespace Record {
    const char* Behavior(int64_t i) {
        switch (i) {
            case 0L: return "MATCH_CONTINUE";
            case 1L: return "MATCH_BREAK";
            default: return "";
        }
    }

    std::string Behavior(int64_t i, const std::string &strip) {
        std::string s = Behavior(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Behavior() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisHotPatchRecordBehavior(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::HotPatch::Record::Behavior)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::HotPatch::Record::Behavior::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisHotPatchRecordBehavior() {
        return stringify::Rose::BinaryAnalysis::HotPatch::Record::Behavior();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FunctionSimilarity.h line 73
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* CValKind(int64_t i) {
        switch (i) {
            case 0L: return "CARTESIAN_POINT";
            case 1L: return "ORDERED_LIST";
            default: return "";
        }
    }

    std::string CValKind(int64_t i, const std::string &strip) {
        std::string s = CValKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CValKind() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityCValKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::CValKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::CValKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityCValKind() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::CValKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FunctionSimilarity.h line 85
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FunctionSimilarity {
    const char* Statistic(int64_t i) {
        switch (i) {
            case 0L: return "AVERAGE";
            case 1L: return "MEDIAN";
            case 2L: return "MAXIMUM";
            default: return "";
        }
    }

    std::string Statistic(int64_t i, const std::string &strip) {
        std::string s = Statistic(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Statistic() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFunctionSimilarityStatistic(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FunctionSimilarity::Statistic)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FunctionSimilarity::Statistic::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFunctionSimilarityStatistic() {
        return stringify::Rose::BinaryAnalysis::FunctionSimilarity::Statistic();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SearchMode(int64_t i) {
        switch (i) {
            case 0L: return "SEARCH_SINGLE_DFS";
            case 1L: return "SEARCH_SINGLE_BFS";
            case 2L: return "SEARCH_MULTI";
            default: return "";
        }
    }

    std::string SearchMode(int64_t i, const std::string &strip) {
        std::string s = SearchMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SearchMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSearchMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SearchMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SearchMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSearchMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SearchMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 44
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* SemanticMemoryParadigm(int64_t i) {
        switch (i) {
            case 0L: return "LIST_BASED_MEMORY";
            case 1L: return "MAP_BASED_MEMORY";
            default: return "";
        }
    }

    std::string SemanticMemoryParadigm(int64_t i, const std::string &strip) {
        std::string s = SemanticMemoryParadigm(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SemanticMemoryParadigm() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathSemanticMemoryParadigm() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::SemanticMemoryParadigm();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* EdgeVisitOrder(int64_t i) {
        switch (i) {
            case 0L: return "VISIT_NATURAL";
            case 1L: return "VISIT_REVERSE";
            case 2L: return "VISIT_RANDOM";
            default: return "";
        }
    }

    std::string EdgeVisitOrder(int64_t i, const std::string &strip) {
        std::string s = EdgeVisitOrder(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgeVisitOrder() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathEdgeVisitOrder() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::EdgeVisitOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 57
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* IoMode(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string IoMode(int64_t i, const std::string &strip) {
        std::string s = IoMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoMode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathIoMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::IoMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::IoMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathIoMode() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::IoMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 60
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath {
    const char* MayOrMust(int64_t i) {
        switch (i) {
            case 0L: return "MAY";
            case 1L: return "MUST";
            default: return "";
        }
    }

    std::string MayOrMust(int64_t i, const std::string &strip) {
        std::string s = MayOrMust(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MayOrMust() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathMayOrMust(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::MayOrMust)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::MayOrMust::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathMayOrMust() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::MayOrMust();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/FeasiblePath.h line 180
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace FeasiblePath { namespace PathProcessor {
    const char* Action(int64_t i) {
        switch (i) {
            case 0L: return "BREAK";
            case 1L: return "CONTINUE";
            default: return "";
        }
    }

    std::string Action(int64_t i, const std::string &strip) {
        std::string s = Action(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Action() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisFeasiblePathPathProcessorAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisFeasiblePathPathProcessorAction() {
        return stringify::Rose::BinaryAnalysis::FeasiblePath::PathProcessor::Action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 33
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* OutputPart(int64_t i) {
        switch (i) {
            case 0L: return "FIRST_LINE";
            case 1L: return "LAST_LINE";
            case 2L: return "MIDDLE_LINE";
            case 3L: return "INTER_LINE";
            default: return "";
        }
    }

    std::string OutputPart(int64_t i, const std::string &strip) {
        std::string s = OutputPart(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& OutputPart() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsOutputPart() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::OutputPart();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 61
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowStylePreset(int64_t i) {
        switch (i) {
            case 0L: return "UNICODE_1";
            case 1L: return "UNICODE_2";
            case 2L: return "ASCII_1";
            case 3L: return "ASCII_2";
            case 4L: return "ASCII_3";
            default: return "";
        }
    }

    std::string ArrowStylePreset(int64_t i, const std::string &strip) {
        std::string s = ArrowStylePreset(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowStylePreset() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowStylePreset() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowStylePreset();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/EdgeArrows.h line 70
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace EdgeArrows {
    const char* ArrowSide(int64_t i) {
        switch (i) {
            case 0L: return "LEFT";
            case 1L: return "RIGHT";
            default: return "";
        }
    }

    std::string ArrowSide(int64_t i, const std::string &strip) {
        std::string s = ArrowSide(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ArrowSide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserEdgeArrowsArrowSide() {
        return stringify::Rose::BinaryAnalysis::Unparser::EdgeArrows::ArrowSide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Unparser/Base.h line 51
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Unparser { namespace ArrowMargin {
    const char* Flags(int64_t i) {
        switch (i) {
            case 1L: return "POINTABLE_ENTITY_START";
            case 2L: return "POINTABLE_ENTITY_END";
            case 4L: return "POINTABLE_ENTITY_INSIDE";
            case 8L: return "ALWAYS_RENDER";
            default: return "";
        }
    }

    std::string Flags(int64_t i, const std::string &strip) {
        std::string s = Flags(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flags() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisUnparserArrowMarginFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisUnparserArrowMarginFlags() {
        return stringify::Rose::BinaryAnalysis::Unparser::ArrowMargin::Flags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 27
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* DetachMode(int64_t i) {
        switch (i) {
            case 0L: return "KILL";
            case 1L: return "DETACH";
            case 2L: return "CONTINUE";
            case 3L: return "NOTHING";
            default: return "";
        }
    }

    std::string DetachMode(int64_t i, const std::string &strip) {
        std::string s = DetachMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::DetachMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DetachMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxDetachMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::DetachMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::DetachMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::DetachMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxDetachMode() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::DetachMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 35
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* Flag(int64_t i) {
        switch (i) {
            case 1L: return "ATTACH";
            case 2L: return "REDIRECT_INPUT";
            case 4L: return "REDIRECT_OUTPUT";
            case 8L: return "REDIRECT_ERROR";
            case 16L: return "CLOSE_FILES";
            case 19L: return "DEFAULT_FLAGS";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::Flag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxFlag() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Linux.h line 191
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Linux {
    const char* RegCacheType(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "REGS";
            case 2L: return "FPREGS";
            default: return "";
        }
    }

    std::string RegCacheType(int64_t i, const std::string &strip) {
        std::string s = RegCacheType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Linux::RegCacheType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& RegCacheType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerLinuxRegCacheType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Linux::RegCacheType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Linux::RegCacheType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Linux::RegCacheType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerLinuxRegCacheType() {
        return stringify::Rose::BinaryAnalysis::Debugger::Linux::RegCacheType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 19
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_DIGITS";
            case 4L: return "TOK_SYMBOL";
            case 5L: return "TOK_STRING";
            case 6L: return "TOK_GDB";
            case 7L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseTokenType() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 68
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* ResultClass(int64_t i) {
        switch (i) {
            case 0L: return "DONE";
            case 1L: return "RUNNING";
            case 2L: return "CONNECTED";
            case 3L: return "ERROR";
            case 4L: return "EXIT";
            case 5L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string ResultClass(int64_t i, const std::string &strip) {
        std::string s = ResultClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ResultClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseResultClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseResultClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::ResultClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/GdbResponse.h line 71
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace GdbResponse {
    const char* AsyncClass(int64_t i) {
        switch (i) {
            case 0L: return "STOPPED";
            case 1L: return "RUNNING";
            case 2L: return "THREAD_GROUP_ADDED";
            case 3L: return "THREAD_GROUP_STARTED";
            case 4L: return "THREAD_GROUP_EXITED";
            case 5L: return "THREAD_CREATED";
            case 6L: return "THREAD_EXITED";
            case 7L: return "BREAKPOINT_MODIFIED";
            case 8L: return "OTHER";
            case 9L: return "UNSPECIFIED";
            default: return "";
        }
    }

    std::string AsyncClass(int64_t i, const std::string &strip) {
        std::string s = AsyncClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AsyncClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseAsyncClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseAsyncClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::GdbResponse::AsyncClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/BasicTypes.h line 39
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger {
    const char* FilterActionFlag(int64_t i) {
        switch (i) {
            case 1L: return "REJECT";
            case 2L: return "STOP";
            default: return "";
        }
    }

    std::string FilterActionFlag(int64_t i, const std::string &strip) {
        std::string s = FilterActionFlag(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::FilterActionFlag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& FilterActionFlag() {
        static const int64_t values[] = {
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerFilterActionFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::FilterActionFlag(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::FilterActionFlag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::FilterActionFlag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerFilterActionFlag() {
        return stringify::Rose::BinaryAnalysis::Debugger::FilterActionFlag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Debugger/Gdb.h line 172
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Debugger { namespace Gdb { namespace Response { namespace ResultRecord {
    const char* ResultClass(int64_t i) {
        switch (i) {
            case 0L: return "EMPTY";
            case 1L: return "DONE";
            case 2L: return "RUNNING";
            case 3L: return "CONNECTED";
            case 4L: return "ERROR";
            case 5L: return "EXIT";
            default: return "";
        }
    }

    std::string ResultClass(int64_t i, const std::string &strip) {
        std::string s = ResultClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ResultClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisDebuggerGdbResponseResultRecordResultClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisDebuggerGdbResponseResultRecordResultClass() {
        return stringify::Rose::BinaryAnalysis::Debugger::Gdb::Response::ResultRecord::ResultClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SerialIo.h line 120
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Format(int64_t i) {
        switch (i) {
            case 0L: return "BINARY";
            case 1L: return "TEXT";
            case 2L: return "XML";
            default: return "";
        }
    }

    std::string Format(int64_t i, const std::string &strip) {
        std::string s = Format(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Format() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Format(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Format)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Format::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoFormat() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Format();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SerialIo.h line 131
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SerialIo {
    const char* Savable(int64_t i) {
        switch (i) {
            case 0L: return "NO_OBJECT";
            case 1L: return "PARTITIONER";
            case 2L: return "AST";
            case 65534L: return "END_OF_DATA";
            case 65535L: return "ERROR";
            case 65536L: return "USER_DEFINED";
            case 4294967295L: return "USER_DEFINED_LAST";
            default: return "";
        }
    }

    std::string Savable(int64_t i, const std::string &strip) {
        std::string s = Savable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Savable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            65534L,
            65535L,
            65536L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSerialIoSavable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SerialIo::Savable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SerialIo::Savable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SerialIo::Savable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSerialIoSavable() {
        return stringify::Rose::BinaryAnalysis::SerialIo::Savable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/MagicNumber.h line 21
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace MagicNumber {
    const char* Mechanism(int64_t i) {
        switch (i) {
            case 0L: return "FAST";
            case 1L: return "SLOW";
            case 2L: return "NONE";
            default: return "";
        }
    }

    std::string Mechanism(int64_t i, const std::string &strip) {
        std::string s = Mechanism(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Mechanism() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMagicNumberMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MagicNumber::Mechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MagicNumber::Mechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMagicNumberMechanism() {
        return stringify::Rose::BinaryAnalysis::MagicNumber::Mechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 18
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32Exception(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_exception_svc";
            case 1L: return "aarch32_exception_udf";
            case 2L: return "aarch32_exception_hvc";
            default: return "";
        }
    }

    std::string Aarch32Exception(int64_t i, const std::string &strip) {
        std::string s = Aarch32Exception(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32Exception)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32Exception() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32Exception(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32Exception(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32Exception)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32Exception::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32Exception() {
        return stringify::Rose::BinaryAnalysis::Aarch32Exception();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 25
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32RegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_regclass_gpr";
            case 1L: return "aarch32_regclass_sys";
            case 2L: return "aarch32_regclass_ext";
            case 3L: return "aarch32_regclass_coproc";
            case 4L: return "aarch32_regclass_debug";
            default: return "";
        }
    }

    std::string Aarch32RegisterClass(int64_t i, const std::string &strip) {
        std::string s = Aarch32RegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32RegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32RegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32RegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32RegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32RegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32RegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32RegisterClass() {
        return stringify::Rose::BinaryAnalysis::Aarch32RegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 34
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32GeneralPurposeRegister(int64_t i) {
        switch (i) {
            case 9L: return "aarch32_gpr_sb";
            case 10L: return "aarch32_gpr_sl";
            case 11L: return "aarch32_gpr_fp";
            case 12L: return "aarch32_gpr_ip";
            case 13L: return "aarch32_gpr_sp";
            case 14L: return "aarch32_gpr_lr";
            case 15L: return "aarch32_gpr_pc";
            default: return "";
        }
    }

    std::string Aarch32GeneralPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32GeneralPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32GeneralPurposeRegister() {
        static const int64_t values[] = {
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32GeneralPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32GeneralPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32GeneralPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 45
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32DebugRegister(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_debug_didr";
            case 6L: return "aarch32_debug_wfar";
            case 7L: return "aarch32_debug_vcr";
            case 9L: return "aarch32_debug_ecr";
            case 10L: return "aarch32_debug_dsccr";
            case 11L: return "aarch32_debug_dsmcr";
            case 32L: return "aarch32_debug_dtrrx";
            case 33L: return "aarch32_debug_itr";
            case 34L: return "aarch32_debug_dscr";
            case 35L: return "aarch32_debug_dtrtx";
            case 36L: return "aarch32_debug_drcr";
            case 64L: return "aarch32_debug_bvr0";
            case 80L: return "aarch32_debug_bcr0";
            case 96L: return "aarch32_debug_wvr0";
            case 112L: return "aarch32_debug_wcr0";
            case 192L: return "aarch32_debug_oslar";
            case 193L: return "aarch32_debug_oslsr";
            case 194L: return "aarch32_debug_ossrr";
            case 196L: return "aarch32_debug_prcr";
            case 197L: return "aarch32_debug_prsr";
            case 960L: return "aarch32_debug_itctrl";
            case 1000L: return "aarch32_debug_claimset";
            case 1001L: return "aarch32_debug_claimclr";
            case 1004L: return "aarch32_debug_lar";
            case 1005L: return "aarch32_debug_lsr";
            case 1006L: return "aarch32_debug_authstatus";
            case 1010L: return "aarch32_debug_devid";
            case 1011L: return "aarch32_debug_devtype";
            case 1012L: return "aarch32_debug_peripheralid0";
            case 1020L: return "aarch32_debug_componentid0";
            case 2000L: return "aarch32_debug_drar";
            case 2001L: return "aarch32_debug_dsar";
            default: return "";
        }
    }

    std::string Aarch32DebugRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32DebugRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32DebugRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32DebugRegister() {
        static const int64_t values[] = {
            0L,
            6L,
            7L,
            9L,
            10L,
            11L,
            32L,
            33L,
            34L,
            35L,
            36L,
            64L,
            80L,
            96L,
            112L,
            192L,
            193L,
            194L,
            196L,
            197L,
            960L,
            1000L,
            1001L,
            1004L,
            1005L,
            1006L,
            1010L,
            1011L,
            1012L,
            1020L,
            2000L,
            2001L
        };
        static const std::vector<int64_t> retval(values, values + 32);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32DebugRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32DebugRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32DebugRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32DebugRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32DebugRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32DebugRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsAarch32.h line 103
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* Aarch32SystemRegister(int64_t i) {
        switch (i) {
            case 0L: return "aarch32_sys_r8_usr";
            case 1L: return "aarch32_sys_r8_fiq";
            case 2L: return "aarch32_sys_r9_usr";
            case 3L: return "aarch32_sys_r9_fiq";
            case 4L: return "aarch32_sys_r10_usr";
            case 5L: return "aarch32_sys_r10_fiq";
            case 6L: return "aarch32_sys_r11_usr";
            case 7L: return "aarch32_sys_r11_fiq";
            case 8L: return "aarch32_sys_r12_usr";
            case 9L: return "aarch32_sys_r12_fiq";
            case 10L: return "aarch32_sys_sp_hyp";
            case 11L: return "aarch32_sys_sp_svc";
            case 12L: return "aarch32_sys_sp_abt";
            case 13L: return "aarch32_sys_sp_und";
            case 14L: return "aarch32_sys_sp_mon";
            case 15L: return "aarch32_sys_sp_irq";
            case 16L: return "aarch32_sys_sp_fiq";
            case 17L: return "aarch32_sys_sp_usr";
            case 18L: return "aarch32_sys_lr_svc";
            case 19L: return "aarch32_sys_lr_abt";
            case 20L: return "aarch32_sys_lr_und";
            case 21L: return "aarch32_sys_lr_mon";
            case 22L: return "aarch32_sys_lr_irq";
            case 23L: return "aarch32_sys_lr_fiq";
            case 24L: return "aarch32_sys_lr_usr";
            case 25L: return "aarch32_sys_cpsr";
            case 26L: return "aarch32_sys_apsr";
            case 27L: return "aarch32_sys_spsr";
            case 28L: return "aarch32_sys_spsr_hyp";
            case 29L: return "aarch32_sys_spsr_svc";
            case 30L: return "aarch32_sys_spsr_abt";
            case 31L: return "aarch32_sys_spsr_und";
            case 32L: return "aarch32_sys_spsr_mon";
            case 33L: return "aarch32_sys_spsr_irq";
            case 34L: return "aarch32_sys_spsr_fiq";
            case 35L: return "aarch32_sys_ipsr";
            case 36L: return "aarch32_sys_iepsr";
            case 37L: return "aarch32_sys_iapsr";
            case 38L: return "aarch32_sys_eapsr";
            case 39L: return "aarch32_sys_psr";
            case 40L: return "aarch32_sys_msp";
            case 41L: return "aarch32_sys_psp";
            case 42L: return "aarch32_sys_primask";
            case 43L: return "aarch32_sys_control";
            case 44L: return "aarch32_sys_fpsid";
            case 45L: return "aarch32_sys_fpscr";
            case 46L: return "aarch32_sys_fpexc";
            case 47L: return "aarch32_sys_fpinst";
            case 48L: return "aarch32_sys_fpinst2";
            case 49L: return "aarch32_sys_mvfr0";
            case 50L: return "aarch32_sys_mvfr1";
            case 51L: return "aarch32_sys_mvfr2";
            case 52L: return "aarch32_sys_itstate";
            case 53L: return "aarch32_sys_unknown";
            default: return "";
        }
    }

    std::string Aarch32SystemRegister(int64_t i, const std::string &strip) {
        std::string s = Aarch32SystemRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Aarch32SystemRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Aarch32SystemRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L
        };
        static const std::vector<int64_t> retval(values, values + 54);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisAarch32SystemRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Aarch32SystemRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Aarch32SystemRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Aarch32SystemRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisAarch32SystemRegister() {
        return stringify::Rose::BinaryAnalysis::Aarch32SystemRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/ConcreteLocation.h line 29
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace ConcreteLocation {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_LOCATION";
            case 1L: return "REGISTER";
            case 2L: return "RELATIVE";
            case 3L: return "ABSOLUTE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::ConcreteLocation::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcreteLocationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::ConcreteLocation::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::ConcreteLocation::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::ConcreteLocation::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcreteLocationType() {
        return stringify::Rose::BinaryAnalysis::ConcreteLocation::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 51
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* LinkMode(int64_t i) {
        switch (i) {
            case 0L: return "LM_NONE";
            case 1L: return "LM_LIBRARY";
            case 2L: return "LM_EXECUTABLE";
            case 3L: return "LM_ANY";
            default: return "";
        }
    }

    std::string LinkMode(int64_t i, const std::string &strip) {
        std::string s = LinkMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& LinkMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverLinkMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::LinkMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::LinkMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverLinkMode() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::LinkMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 63
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Type(int64_t i) {
        switch (i) {
            case 0L: return "NO_TYPE";
            case 1L: return "BOOLEAN";
            case 2L: return "BIT_VECTOR";
            case 3L: return "MEM_STATE";
            default: return "";
        }
    }

    std::string Type(int64_t i, const std::string &strip) {
        std::string s = Type(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Type() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Type(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Type)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Type::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverType() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Type();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/SmtSolver.h line 87
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace SmtSolver {
    const char* Satisfiable(int64_t i) {
        switch (i) {
            case 0L: return "SAT_NO";
            case 1L: return "SAT_YES";
            case 2L: return "SAT_UNKNOWN";
            default: return "";
        }
    }

    std::string Satisfiable(int64_t i, const std::string &strip) {
        std::string s = Satisfiable(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Satisfiable() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisSmtSolverSatisfiable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::SmtSolver::Satisfiable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::SmtSolver::Satisfiable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisSmtSolverSatisfiable() {
        return stringify::Rose::BinaryAnalysis::SmtSolver::Satisfiable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 18
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kFamily(int64_t i) {
        switch (i) {
            case 1L: return "m68k_68000_only";
            case 2L: return "m68k_68ec000";
            case 4L: return "m68k_68hc000";
            case 7L: return "m68k_68000";
            case 8L: return "m68k_68008";
            case 16L: return "m68k_68010";
            case 32L: return "m68k_68012";
            case 255L: return "m68k_generation_1";
            case 256L: return "m68k_68020_only";
            case 512L: return "m68k_68ec020";
            case 768L: return "m68k_68020";
            case 1024L: return "m68k_68030_only";
            case 4096L: return "m68k_68ec030";
            case 8192L: return "m68k_68030";
            case 65280L: return "m68k_generation_2";
            case 65536L: return "m68k_68040_only";
            case 131072L: return "m68k_68ec040";
            case 262144L: return "m68k_68lc040";
            case 458752L: return "m68k_68040";
            case 16711680L: return "m68k_generation_3";
            case 16777216L: return "m68k_freescale_cpu32";
            case 33554432L: return "m68k_freescale_isaa";
            case 67108864L: return "m68k_freescale_isab";
            case 134217728L: return "m68k_freescale_isac";
            case 268435456L: return "m68k_freescale_fpu";
            case 536870912L: return "m68k_freescale_mac";
            case 1073741824L: return "m68k_freescale_emac";
            case 2147483648L: return "m68k_freescale_emacb";
            case 4278190080L: return "m68k_freescale";
            case 4294967295L: return "m68k_family";
            default: return "";
        }
    }

    std::string M68kFamily(int64_t i, const std::string &strip) {
        std::string s = M68kFamily(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kFamily() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            7L,
            8L,
            16L,
            32L,
            255L,
            256L,
            512L,
            768L,
            1024L,
            4096L,
            8192L,
            65280L,
            65536L,
            131072L,
            262144L,
            458752L,
            16711680L,
            16777216L,
            33554432L,
            67108864L,
            134217728L,
            268435456L,
            536870912L,
            1073741824L,
            2147483648L,
            4278190080L,
            4294967295L
        };
        static const std::vector<int64_t> retval(values, values + 30);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kFamily(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kFamily(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kFamily)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kFamily::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kFamily() {
        return stringify::Rose::BinaryAnalysis::M68kFamily();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 56
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "m68k_regclass_data";
            case 1L: return "m68k_regclass_addr";
            case 2L: return "m68k_regclass_fpr";
            case 3L: return "m68k_regclass_spr";
            case 4L: return "m68k_regclass_mac";
            case 5L: return "m68k_regclass_sup";
            default: return "";
        }
    }

    std::string M68kRegisterClass(int64_t i, const std::string &strip) {
        std::string s = M68kRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kRegisterClass() {
        return stringify::Rose::BinaryAnalysis::M68kRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 66
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_spr_pc";
            case 1L: return "m68k_spr_sr";
            case 2L: return "m68k_spr_fpcr";
            case 3L: return "m68k_spr_fpsr";
            case 4L: return "m68k_spr_fpiar";
            default: return "";
        }
    }

    std::string M68kSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 75
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kMacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_mac_macsr";
            case 1L: return "m68k_mac_acc0";
            case 2L: return "m68k_mac_acc1";
            case 3L: return "m68k_mac_acc2";
            case 4L: return "m68k_mac_acc3";
            case 5L: return "m68k_mac_ext01";
            case 6L: return "m68k_mac_ext23";
            case 7L: return "m68k_mac_ext0";
            case 8L: return "m68k_mac_ext1";
            case 9L: return "m68k_mac_ext2";
            case 10L: return "m68k_mac_ext3";
            case 11L: return "m68k_mac_mask";
            default: return "";
        }
    }

    std::string M68kMacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kMacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kMacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L
        };
        static const std::vector<int64_t> retval(values, values + 12);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kMacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kMacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kMacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kMacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kMacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kMacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 91
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEmacRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_emac_macsr";
            case 1L: return "m68k_emac_acc0";
            case 2L: return "m68k_emac_acc1";
            case 3L: return "m68k_emac_acc2";
            case 4L: return "m68k_emac_acc3";
            case 5L: return "m68k_emac_mask";
            default: return "";
        }
    }

    std::string M68kEmacRegister(int64_t i, const std::string &strip) {
        std::string s = M68kEmacRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEmacRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEmacRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEmacRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEmacRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEmacRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEmacRegister() {
        return stringify::Rose::BinaryAnalysis::M68kEmacRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 101
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kSupervisorRegister(int64_t i) {
        switch (i) {
            case 0L: return "m68k_sup_vbr";
            case 1L: return "m68k_sup_ssp";
            case 2L: return "m68k_sup_sfc";
            case 3L: return "m68k_sup_dfc";
            case 4L: return "m68k_sup_cacr";
            case 5L: return "m68k_sup_asid";
            case 6L: return "m68k_sup_acr0";
            case 7L: return "m68k_sup_acr1";
            case 8L: return "m68k_sup_acr2";
            case 9L: return "m68k_sup_acr3";
            case 10L: return "m68k_sup_mmubar";
            case 11L: return "m68k_sup_rombar0";
            case 12L: return "m68k_sup_rombar1";
            case 13L: return "m68k_sup_rambar0";
            case 14L: return "m68k_sup_rambar1";
            case 15L: return "m68k_sup_mbar";
            case 16L: return "m68k_sup_mpcr";
            case 17L: return "m68k_sup_edrambar";
            case 18L: return "m68k_sup_secmbar";
            case 19L: return "m68k_sup_0_pcr1";
            case 20L: return "m68k_sup_0_pcr2";
            case 21L: return "m68k_sup_0_pcr3";
            case 22L: return "m68k_sup_1_pcr1";
            case 23L: return "m68k_sup_1_pcr2";
            case 24L: return "m68k_sup_1_pcr3";
            default: return "";
        }
    }

    std::string M68kSupervisorRegister(int64_t i, const std::string &strip) {
        std::string s = M68kSupervisorRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kSupervisorRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L
        };
        static const std::vector<int64_t> retval(values, values + 25);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kSupervisorRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kSupervisorRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kSupervisorRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kSupervisorRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kSupervisorRegister() {
        return stringify::Rose::BinaryAnalysis::M68kSupervisorRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 187
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kEffectiveAddressMode(int64_t i) {
        switch (i) {
            case 0L: return "m68k_eam_unknown";
            case 1L: return "m68k_eam_drd";
            case 2L: return "m68k_eam_ard";
            case 3L: return "m68k_eam_rd";
            case 4L: return "m68k_eam_ari";
            case 8L: return "m68k_eam_inc";
            case 16L: return "m68k_eam_dec";
            case 32L: return "m68k_eam_dsp";
            case 60L: return "m68k_eam_ri";
            case 64L: return "m68k_eam_idx8";
            case 128L: return "m68k_eam_idxbd";
            case 192L: return "m68k_eam_idx";
            case 256L: return "m68k_eam_mpost";
            case 512L: return "m68k_eam_mpre";
            case 768L: return "m68k_eam_mi";
            case 1024L: return "m68k_eam_pcdsp";
            case 2048L: return "m68k_eam_pcidx8";
            case 4096L: return "m68k_eam_pcidxbd";
            case 6144L: return "m68k_eam_pcidx";
            case 8192L: return "m68k_eam_pcmpost";
            case 16384L: return "m68k_eam_pcmpre";
            case 24576L: return "m68k_eam_pcmi";
            case 29568L: return "m68k_eam_234";
            case 31744L: return "m68k_eam_pc";
            case 32768L: return "m68k_eam_absw";
            case 65536L: return "m68k_eam_absl";
            case 98304L: return "m68k_eam_abs";
            case 123903L: return "m68k_eam_alter";
            case 131044L: return "m68k_eam_control";
            case 131072L: return "m68k_eam_imm";
            case 262140L: return "m68k_eam_memory";
            case 262141L: return "m68k_eam_data";
            case 262143L: return "m68k_eam_all";
            default: return "";
        }
    }

    std::string M68kEffectiveAddressMode(int64_t i, const std::string &strip) {
        std::string s = M68kEffectiveAddressMode(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kEffectiveAddressMode() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            60L,
            64L,
            128L,
            192L,
            256L,
            512L,
            768L,
            1024L,
            2048L,
            4096L,
            6144L,
            8192L,
            16384L,
            24576L,
            29568L,
            31744L,
            32768L,
            65536L,
            98304L,
            123903L,
            131044L,
            131072L,
            262140L,
            262141L,
            262143L
        };
        static const std::vector<int64_t> retval(values, values + 33);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kEffectiveAddressMode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kEffectiveAddressMode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kEffectiveAddressMode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kEffectiveAddressMode() {
        return stringify::Rose::BinaryAnalysis::M68kEffectiveAddressMode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 241
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kDataFormat(int64_t i) {
        switch (i) {
            case 0L: return "m68k_fmt_i32";
            case 1L: return "m68k_fmt_f32";
            case 2L: return "m68k_fmt_f96";
            case 3L: return "m68k_fmt_p96";
            case 4L: return "m68k_fmt_i16";
            case 5L: return "m68k_fmt_f64";
            case 6L: return "m68k_fmt_i8";
            case 255L: return "m68k_fmt_unknown";
            default: return "";
        }
    }

    std::string M68kDataFormat(int64_t i, const std::string &strip) {
        std::string s = M68kDataFormat(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kDataFormat() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            255L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kDataFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kDataFormat(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kDataFormat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kDataFormat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kDataFormat() {
        return stringify::Rose::BinaryAnalysis::M68kDataFormat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsM68k.h line 253
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* M68kInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "m68k_unknown_instruction";
            case 1L: return "m68k_abcd";
            case 2L: return "m68k_add";
            case 3L: return "m68k_adda";
            case 4L: return "m68k_addi";
            case 5L: return "m68k_addq";
            case 6L: return "m68k_addx";
            case 7L: return "m68k_and";
            case 8L: return "m68k_andi";
            case 9L: return "m68k_asl";
            case 10L: return "m68k_asr";
            case 11L: return "m68k_bcc";
            case 12L: return "m68k_bcs";
            case 13L: return "m68k_beq";
            case 14L: return "m68k_bge";
            case 15L: return "m68k_bgt";
            case 16L: return "m68k_bhi";
            case 17L: return "m68k_ble";
            case 18L: return "m68k_bls";
            case 19L: return "m68k_blt";
            case 20L: return "m68k_bmi";
            case 21L: return "m68k_bne";
            case 22L: return "m68k_bpl";
            case 23L: return "m68k_bvc";
            case 24L: return "m68k_bvs";
            case 25L: return "m68k_bchg";
            case 26L: return "m68k_bclr";
            case 27L: return "m68k_bfchg";
            case 28L: return "m68k_bfclr";
            case 29L: return "m68k_bfexts";
            case 30L: return "m68k_bfextu";
            case 31L: return "m68k_bfins";
            case 32L: return "m68k_bfset";
            case 33L: return "m68k_bftst";
            case 34L: return "m68k_bkpt";
            case 35L: return "m68k_bra";
            case 36L: return "m68k_bset";
            case 37L: return "m68k_bsr";
            case 38L: return "m68k_btst";
            case 39L: return "m68k_callm";
            case 40L: return "m68k_cas";
            case 41L: return "m68k_cas2";
            case 42L: return "m68k_chk";
            case 43L: return "m68k_chk2";
            case 44L: return "m68k_clr";
            case 45L: return "m68k_cmp";
            case 46L: return "m68k_cmp2";
            case 47L: return "m68k_cmpa";
            case 48L: return "m68k_cmpi";
            case 49L: return "m68k_cmpm";
            case 50L: return "m68k_cpusha";
            case 51L: return "m68k_cpushl";
            case 52L: return "m68k_cpushp";
            case 53L: return "m68k_dbt";
            case 54L: return "m68k_dbf";
            case 55L: return "m68k_dbhi";
            case 56L: return "m68k_dbls";
            case 57L: return "m68k_dbcc";
            case 58L: return "m68k_dbcs";
            case 59L: return "m68k_dbne";
            case 60L: return "m68k_dbeq";
            case 61L: return "m68k_dbvc";
            case 62L: return "m68k_dbvs";
            case 63L: return "m68k_dbpl";
            case 64L: return "m68k_dbmi";
            case 65L: return "m68k_dbge";
            case 66L: return "m68k_dblt";
            case 67L: return "m68k_dbgt";
            case 68L: return "m68k_dble";
            case 69L: return "m68k_divs";
            case 70L: return "m68k_divsl";
            case 71L: return "m68k_divu";
            case 72L: return "m68k_divul";
            case 73L: return "m68k_eor";
            case 74L: return "m68k_eori";
            case 75L: return "m68k_exg";
            case 76L: return "m68k_ext";
            case 77L: return "m68k_extb";
            case 78L: return "m68k_fabs";
            case 79L: return "m68k_fadd";
            case 80L: return "m68k_fbeq";
            case 81L: return "m68k_fbne";
            case 82L: return "m68k_fbgt";
            case 83L: return "m68k_fbngt";
            case 84L: return "m68k_fbge";
            case 85L: return "m68k_fbnge";
            case 86L: return "m68k_fblt";
            case 87L: return "m68k_fbnlt";
            case 88L: return "m68k_fble";
            case 89L: return "m68k_fbnle";
            case 90L: return "m68k_fbgl";
            case 91L: return "m68k_fbngl";
            case 92L: return "m68k_fbgle";
            case 93L: return "m68k_fbngle";
            case 94L: return "m68k_fbogt";
            case 95L: return "m68k_fbule";
            case 96L: return "m68k_fboge";
            case 97L: return "m68k_fbult";
            case 98L: return "m68k_fbolt";
            case 99L: return "m68k_fbuge";
            case 100L: return "m68k_fbole";
            case 101L: return "m68k_fbugt";
            case 102L: return "m68k_fbogl";
            case 103L: return "m68k_fbueq";
            case 104L: return "m68k_fbor";
            case 105L: return "m68k_fbun";
            case 106L: return "m68k_fbf";
            case 107L: return "m68k_fbt";
            case 108L: return "m68k_fbsf";
            case 109L: return "m68k_fbst";
            case 110L: return "m68k_fbseq";
            case 111L: return "m68k_fbsne";
            case 112L: return "m68k_fcmp";
            case 113L: return "m68k_fdabs";
            case 114L: return "m68k_fdadd";
            case 115L: return "m68k_fddiv";
            case 116L: return "m68k_fdiv";
            case 117L: return "m68k_fdmove";
            case 118L: return "m68k_fdmul";
            case 119L: return "m68k_fdneg";
            case 120L: return "m68k_fdsqrt";
            case 121L: return "m68k_fdsub";
            case 122L: return "m68k_fint";
            case 123L: return "m68k_fintrz";
            case 124L: return "m68k_fmove";
            case 125L: return "m68k_fmovem";
            case 126L: return "m68k_fmul";
            case 127L: return "m68k_fneg";
            case 128L: return "m68k_fnop";
            case 129L: return "m68k_fsabs";
            case 130L: return "m68k_fsadd";
            case 131L: return "m68k_fsdiv";
            case 132L: return "m68k_fsmove";
            case 133L: return "m68k_fsmul";
            case 134L: return "m68k_fsneg";
            case 135L: return "m68k_fsqrt";
            case 136L: return "m68k_fssqrt";
            case 137L: return "m68k_fssub";
            case 138L: return "m68k_fsub";
            case 139L: return "m68k_ftst";
            case 140L: return "m68k_illegal";
            case 141L: return "m68k_jmp";
            case 142L: return "m68k_jsr";
            case 143L: return "m68k_lea";
            case 144L: return "m68k_link";
            case 145L: return "m68k_lsl";
            case 146L: return "m68k_lsr";
            case 147L: return "m68k_mac";
            case 148L: return "m68k_mov3q";
            case 149L: return "m68k_movclr";
            case 150L: return "m68k_move";
            case 151L: return "m68k_move_acc";
            case 152L: return "m68k_move_accext";
            case 153L: return "m68k_move_ccr";
            case 154L: return "m68k_move_macsr";
            case 155L: return "m68k_move_mask";
            case 156L: return "m68k_move_sr";
            case 157L: return "m68k_move16";
            case 158L: return "m68k_movea";
            case 159L: return "m68k_movec";
            case 160L: return "m68k_movem";
            case 161L: return "m68k_movep";
            case 162L: return "m68k_moveq";
            case 163L: return "m68k_msac";
            case 164L: return "m68k_muls";
            case 165L: return "m68k_mulu";
            case 166L: return "m68k_mvs";
            case 167L: return "m68k_mvz";
            case 168L: return "m68k_nbcd";
            case 169L: return "m68k_neg";
            case 170L: return "m68k_negx";
            case 171L: return "m68k_nop";
            case 172L: return "m68k_not";
            case 173L: return "m68k_or";
            case 174L: return "m68k_ori";
            case 175L: return "m68k_pack";
            case 176L: return "m68k_pea";
            case 177L: return "m68k_rol";
            case 178L: return "m68k_ror";
            case 179L: return "m68k_roxl";
            case 180L: return "m68k_roxr";
            case 181L: return "m68k_rtd";
            case 182L: return "m68k_rtm";
            case 183L: return "m68k_rtr";
            case 184L: return "m68k_rts";
            case 185L: return "m68k_sbcd";
            case 186L: return "m68k_st";
            case 187L: return "m68k_sf";
            case 188L: return "m68k_shi";
            case 189L: return "m68k_sls";
            case 190L: return "m68k_scc";
            case 191L: return "m68k_scs";
            case 192L: return "m68k_sne";
            case 193L: return "m68k_seq";
            case 194L: return "m68k_svc";
            case 195L: return "m68k_svs";
            case 196L: return "m68k_spl";
            case 197L: return "m68k_smi";
            case 198L: return "m68k_sge";
            case 199L: return "m68k_slt";
            case 200L: return "m68k_sgt";
            case 201L: return "m68k_sle";
            case 202L: return "m68k_sub";
            case 203L: return "m68k_suba";
            case 204L: return "m68k_subi";
            case 205L: return "m68k_subq";
            case 206L: return "m68k_subx";
            case 207L: return "m68k_swap";
            case 208L: return "m68k_tas";
            case 209L: return "m68k_trap";
            case 210L: return "m68k_trapt";
            case 211L: return "m68k_trapf";
            case 212L: return "m68k_traphi";
            case 213L: return "m68k_trapls";
            case 214L: return "m68k_trapcc";
            case 215L: return "m68k_trapcs";
            case 216L: return "m68k_trapne";
            case 217L: return "m68k_trapeq";
            case 218L: return "m68k_trapvc";
            case 219L: return "m68k_trapvs";
            case 220L: return "m68k_trappl";
            case 221L: return "m68k_trapmi";
            case 222L: return "m68k_trapge";
            case 223L: return "m68k_traplt";
            case 224L: return "m68k_trapgt";
            case 225L: return "m68k_traple";
            case 226L: return "m68k_trapv";
            case 227L: return "m68k_tst";
            case 228L: return "m68k_unlk";
            case 229L: return "m68k_unpk";
            case 230L: return "m68k_last_instruction";
            default: return "";
        }
    }

    std::string M68kInstructionKind(int64_t i, const std::string &strip) {
        std::string s = M68kInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& M68kInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L
        };
        static const std::vector<int64_t> retval(values, values + 231);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisM68kInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::M68kInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::M68kInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::M68kInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisM68kInstructionKind() {
        return stringify::Rose::BinaryAnalysis::M68kInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 28
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* Update(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Update(int64_t i, const std::string &strip) {
        std::string s = Update(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::Update)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Update() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicUpdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::Update(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::Update)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::Update::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicUpdate() {
        return stringify::Rose::BinaryAnalysis::Concolic::Update();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 31
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ShowEvents(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "INPUT";
            case 2L: return "ALL";
            default: return "";
        }
    }

    std::string ShowEvents(int64_t i, const std::string &strip) {
        std::string s = ShowEvents(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ShowEvents)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowEvents() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicShowEvents(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ShowEvents(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ShowEvents)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ShowEvents::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicShowEvents() {
        return stringify::Rose::BinaryAnalysis::Concolic::ShowEvents();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 37
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ShowAssertions(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string ShowAssertions(int64_t i, const std::string &strip) {
        std::string s = ShowAssertions(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ShowAssertions)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowAssertions() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicShowAssertions(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ShowAssertions(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ShowAssertions)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ShowAssertions::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicShowAssertions() {
        return stringify::Rose::BinaryAnalysis::Concolic::ShowAssertions();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 40
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* InputType(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "ARGC";
            case 2L: return "ARGV";
            case 3L: return "ENVP";
            case 4L: return "SYSCALL_RET";
            case 5L: return "SHMEM_READ";
            default: return "";
        }
    }

    std::string InputType(int64_t i, const std::string &strip) {
        std::string s = InputType(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::InputType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& InputType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicInputType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::InputType(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::InputType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::InputType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicInputType() {
        return stringify::Rose::BinaryAnalysis::Concolic::InputType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 50
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* IoDirection(int64_t i) {
        switch (i) {
            case 0L: return "READ";
            case 1L: return "WRITE";
            default: return "";
        }
    }

    std::string IoDirection(int64_t i, const std::string &strip) {
        std::string s = IoDirection(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::IoDirection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& IoDirection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicIoDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::IoDirection(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::IoDirection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::IoDirection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicIoDirection() {
        return stringify::Rose::BinaryAnalysis::Concolic::IoDirection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 58
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "PRE";
            case 1L: return "POST";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::When(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicWhen() {
        return stringify::Rose::BinaryAnalysis::Concolic::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/BasicTypes.h line 64
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic {
    const char* ConcolicPhase(int64_t i) {
        switch (i) {
            case 0L: return "REPLAY";
            case 1L: return "EMULATION";
            case 2L: return "POST_EMULATION";
            default: return "";
        }
    }

    std::string ConcolicPhase(int64_t i, const std::string &strip) {
        std::string s = ConcolicPhase(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ConcolicPhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConcolicPhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicConcolicPhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ConcolicPhase(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ConcolicPhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ConcolicPhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicConcolicPhase() {
        return stringify::Rose::BinaryAnalysis::Concolic::ConcolicPhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/Concolic/ExecutionEvent.h line 69
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Concolic { namespace ExecutionEvent {
    const char* Action(int64_t i) {
        switch (i) {
            case 0L: return "NONE";
            case 1L: return "BULK_MEMORY_MAP";
            case 2L: return "BULK_MEMORY_UNMAP";
            case 3L: return "BULK_MEMORY_WRITE";
            case 4L: return "BULK_MEMORY_HASH";
            case 5L: return "MEMORY_WRITE";
            case 6L: return "BULK_REGISTER_WRITE";
            case 7L: return "REGISTER_WRITE";
            case 8L: return "OS_SYSCALL";
            case 9L: return "OS_SHARED_MEMORY";
            default: return "";
        }
    }

    std::string Action(int64_t i, const std::string &strip) {
        std::string s = Action(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Action() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisConcolicExecutionEventAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisConcolicExecutionEventAction() {
        return stringify::Rose::BinaryAnalysis::Concolic::ExecutionEvent::Action();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/String.h line 198
namespace stringify { namespace Rose { namespace BinaryAnalysis { namespace Strings {
    const char* State(int64_t i) {
        switch (i) {
            case -4L: return "ERROR_STATE";
            case -3L: return "INITIAL_STATE";
            case -2L: return "COMPLETED_STATE";
            case -1L: return "FINAL_STATE";
            case 0L: return "USER_DEFINED_0";
            case 1L: return "USER_DEFINED_1";
            case 2L: return "USER_DEFINED_2";
            case 128L: return "USER_DEFINED_MAX";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            -4L,
            -3L,
            -2L,
            -1L,
            0L,
            1L,
            2L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifyBinaryAnalysisStringsState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::Strings::State(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::Strings::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::Strings::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisStringsState() {
        return stringify::Rose::BinaryAnalysis::Strings::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 11
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsRegisterClass(int64_t i) {
        switch (i) {
            case 0L: return "mips_regclass_gpr";
            case 1L: return "mips_regclass_spr";
            case 2L: return "mips_regclass_fpr";
            case 3L: return "mips_regclass_fcsr";
            case 4L: return "mips_regclass_cp0gpr";
            case 5L: return "mips_regclass_cp2gpr";
            case 6L: return "mips_regclass_cp2spr";
            case 7L: return "mips_regclass_sgpr";
            case 8L: return "mips_regclass_hw";
            default: return "";
        }
    }

    std::string MipsRegisterClass(int64_t i, const std::string &strip) {
        std::string s = MipsRegisterClass(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsRegisterClass() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsRegisterClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsRegisterClass(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsRegisterClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsRegisterClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsRegisterClass() {
        return stringify::Rose::BinaryAnalysis::MipsRegisterClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 24
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsFcsrMinors(int64_t i) {
        switch (i) {
            case 0L: return "mips_fcsr_all";
            case 1L: return "mips_fcsr_fccr";
            case 2L: return "mips_fcsr_fexr";
            case 3L: return "mips_fcsr_fenr";
            default: return "";
        }
    }

    std::string MipsFcsrMinors(int64_t i, const std::string &strip) {
        std::string s = MipsFcsrMinors(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsFcsrMinors() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsFcsrMinors(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsFcsrMinors(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsFcsrMinors)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsFcsrMinors::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsFcsrMinors() {
        return stringify::Rose::BinaryAnalysis::MipsFcsrMinors();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 32
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsSpecialPurposeRegister(int64_t i) {
        switch (i) {
            case 0L: return "mips_spr_hi";
            case 1L: return "mips_spr_lo";
            case 2L: return "mips_spr_pc";
            case 3L: return "mips_spr_fir";
            case 4L: return "mips_spr_fcsr";
            default: return "";
        }
    }

    std::string MipsSpecialPurposeRegister(int64_t i, const std::string &strip) {
        std::string s = MipsSpecialPurposeRegister(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsSpecialPurposeRegister() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsSpecialPurposeRegister(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsSpecialPurposeRegister)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsSpecialPurposeRegister::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsSpecialPurposeRegister() {
        return stringify::Rose::BinaryAnalysis::MipsSpecialPurposeRegister();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 41
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInterruptMajor(int64_t i) {
        switch (i) {
            case 0L: return "mips_signal_exception";
            default: return "";
        }
    }

    std::string MipsInterruptMajor(int64_t i, const std::string &strip) {
        std::string s = MipsInterruptMajor(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInterruptMajor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInterruptMajor() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInterruptMajor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInterruptMajor(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInterruptMajor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInterruptMajor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInterruptMajor() {
        return stringify::Rose::BinaryAnalysis::MipsInterruptMajor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 46
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInterruptMinor(int64_t i) {
        switch (i) {
            case 0L: return "mips_breakpoint";
            case 1L: return "mips_integer_overflow";
            case 2L: return "mips_reserved_instruction";
            default: return "";
        }
    }

    std::string MipsInterruptMinor(int64_t i, const std::string &strip) {
        std::string s = MipsInterruptMinor(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInterruptMinor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInterruptMinor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInterruptMinor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInterruptMinor(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInterruptMinor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInterruptMinor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInterruptMinor() {
        return stringify::Rose::BinaryAnalysis::MipsInterruptMinor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 53
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsDataFormat(int64_t i) {
        switch (i) {
            case 0L: return "mips_fmt_w";
            case 1L: return "mips_fmt_l";
            case 2L: return "mips_fmt_s";
            case 3L: return "mips_fmt_d";
            case 4L: return "mips_fmt_ps";
            default: return "";
        }
    }

    std::string MipsDataFormat(int64_t i, const std::string &strip) {
        std::string s = MipsDataFormat(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsDataFormat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsDataFormat() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsDataFormat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsDataFormat(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsDataFormat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsDataFormat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsDataFormat() {
        return stringify::Rose::BinaryAnalysis::MipsDataFormat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/BinaryAnalysis/InstructionEnumsMips.h line 62
namespace stringify { namespace Rose { namespace BinaryAnalysis {
    const char* MipsInstructionKind(int64_t i) {
        switch (i) {
            case 0L: return "mips_unknown_instruction";
            case 1L: return "mips_abs_s";
            case 2L: return "mips_abs_d";
            case 3L: return "mips_abs_ps";
            case 4L: return "mips_add";
            case 5L: return "mips_add_s";
            case 6L: return "mips_add_d";
            case 7L: return "mips_add_ps";
            case 8L: return "mips_addi";
            case 9L: return "mips_addiu";
            case 10L: return "mips_addu";
            case 11L: return "mips_alnv_ps";
            case 12L: return "mips_and";
            case 13L: return "mips_andi";
            case 14L: return "mips_b";
            case 15L: return "mips_bal";
            case 16L: return "mips_bc1f";
            case 17L: return "mips_bc1fl";
            case 18L: return "mips_bc1t";
            case 19L: return "mips_bc1tl";
            case 20L: return "mips_bc2f";
            case 21L: return "mips_bc2fl";
            case 22L: return "mips_bc2t";
            case 23L: return "mips_bc2tl";
            case 24L: return "mips_beq";
            case 25L: return "mips_beql";
            case 26L: return "mips_bgez";
            case 27L: return "mips_bgezal";
            case 28L: return "mips_bgezall";
            case 29L: return "mips_bgezl";
            case 30L: return "mips_bgtz";
            case 31L: return "mips_bgtzl";
            case 32L: return "mips_blez";
            case 33L: return "mips_blezl";
            case 34L: return "mips_bltz";
            case 35L: return "mips_bltzal";
            case 36L: return "mips_bltzall";
            case 37L: return "mips_bltzl";
            case 38L: return "mips_bne";
            case 39L: return "mips_bnel";
            case 40L: return "mips_break";
            case 41L: return "mips_c_f_s";
            case 42L: return "mips_c_un_s";
            case 43L: return "mips_c_eq_s";
            case 44L: return "mips_c_ueq_s";
            case 45L: return "mips_c_olt_s";
            case 46L: return "mips_c_ult_s";
            case 47L: return "mips_c_ole_s";
            case 48L: return "mips_c_ule_s";
            case 49L: return "mips_c_sf_s";
            case 50L: return "mips_c_ngle_s";
            case 51L: return "mips_c_seq_s";
            case 52L: return "mips_c_ngl_s";
            case 53L: return "mips_c_lt_s";
            case 54L: return "mips_c_nge_s";
            case 55L: return "mips_c_le_s";
            case 56L: return "mips_c_ngt_s";
            case 57L: return "mips_c_f_d";
            case 58L: return "mips_c_un_d";
            case 59L: return "mips_c_eq_d";
            case 60L: return "mips_c_ueq_d";
            case 61L: return "mips_c_olt_d";
            case 62L: return "mips_c_ult_d";
            case 63L: return "mips_c_ole_d";
            case 64L: return "mips_c_ule_d";
            case 65L: return "mips_c_sf_d";
            case 66L: return "mips_c_ngle_d";
            case 67L: return "mips_c_seq_d";
            case 68L: return "mips_c_ngl_d";
            case 69L: return "mips_c_lt_d";
            case 70L: return "mips_c_nge_d";
            case 71L: return "mips_c_le_d";
            case 72L: return "mips_c_ngt_d";
            case 73L: return "mips_c_f_ps";
            case 74L: return "mips_c_un_ps";
            case 75L: return "mips_c_eq_ps";
            case 76L: return "mips_c_ueq_ps";
            case 77L: return "mips_c_olt_ps";
            case 78L: return "mips_c_ult_ps";
            case 79L: return "mips_c_ole_ps";
            case 80L: return "mips_c_ule_ps";
            case 81L: return "mips_c_sf_ps";
            case 82L: return "mips_c_ngle_ps";
            case 83L: return "mips_c_seq_ps";
            case 84L: return "mips_c_ngl_ps";
            case 85L: return "mips_c_lt_ps";
            case 86L: return "mips_c_nge_ps";
            case 87L: return "mips_c_le_ps";
            case 88L: return "mips_c_ngt_ps";
            case 89L: return "mips_cache";
            case 90L: return "mips_cachee";
            case 91L: return "mips_ceil_l_s";
            case 92L: return "mips_ceil_l_d";
            case 93L: return "mips_ceil_w_s";
            case 94L: return "mips_ceil_w_d";
            case 95L: return "mips_cfc1";
            case 96L: return "mips_cfc2";
            case 97L: return "mips_clo";
            case 98L: return "mips_clz";
            case 99L: return "mips_cop2";
            case 100L: return "mips_ctc1";
            case 101L: return "mips_ctc2";
            case 102L: return "mips_cvt_d_s";
            case 103L: return "mips_cvt_d_w";
            case 104L: return "mips_cvt_d_l";
            case 105L: return "mips_cvt_l_s";
            case 106L: return "mips_cvt_l_d";
            case 107L: return "mips_cvt_ps_s";
            case 108L: return "mips_cvt_s_d";
            case 109L: return "mips_cvt_s_w";
            case 110L: return "mips_cvt_s_l";
            case 111L: return "mips_cvt_s_pl";
            case 112L: return "mips_cvt_s_pu";
            case 113L: return "mips_cvt_w_s";
            case 114L: return "mips_cvt_w_d";
            case 115L: return "mips_di";
            case 116L: return "mips_div";
            case 117L: return "mips_div_s";
            case 118L: return "mips_div_d";
            case 119L: return "mips_divu";
            case 120L: return "mips_ehb";
            case 121L: return "mips_ei";
            case 122L: return "mips_eret";
            case 123L: return "mips_ext";
            case 124L: return "mips_floor_l_s";
            case 125L: return "mips_floor_l_d";
            case 126L: return "mips_floor_w_s";
            case 127L: return "mips_floor_w_d";
            case 128L: return "mips_ins";
            case 129L: return "mips_j";
            case 130L: return "mips_jal";
            case 131L: return "mips_jalr";
            case 132L: return "mips_jalr_hb";
            case 133L: return "mips_jalx";
            case 134L: return "mips_jr";
            case 135L: return "mips_jr_hb";
            case 136L: return "mips_lb";
            case 137L: return "mips_lbe";
            case 138L: return "mips_lbu";
            case 139L: return "mips_lbue";
            case 140L: return "mips_ldc1";
            case 141L: return "mips_ldc2";
            case 142L: return "mips_ldxc1";
            case 143L: return "mips_lh";
            case 144L: return "mips_lhe";
            case 145L: return "mips_lhu";
            case 146L: return "mips_lhue";
            case 147L: return "mips_ll";
            case 148L: return "mips_lle";
            case 149L: return "mips_lui";
            case 150L: return "mips_luxc1";
            case 151L: return "mips_lw";
            case 152L: return "mips_lwc1";
            case 153L: return "mips_lwc2";
            case 154L: return "mips_lwe";
            case 155L: return "mips_lwl";
            case 156L: return "mips_lwle";
            case 157L: return "mips_lwr";
            case 158L: return "mips_lwre";
            case 159L: return "mips_lwu";
            case 160L: return "mips_lwxc1";
            case 161L: return "mips_madd";
            case 162L: return "mips_madd_s";
            case 163L: return "mips_madd_d";
            case 164L: return "mips_madd_ps";
            case 165L: return "mips_maddu";
            case 166L: return "mips_mfc0";
            case 167L: return "mips_mfc1";
            case 168L: return "mips_mfc2";
            case 169L: return "mips_mfhc1";
            case 170L: return "mips_mfhc2";
            case 171L: return "mips_mfhi";
            case 172L: return "mips_mflo";
            case 173L: return "mips_mov_s";
            case 174L: return "mips_mov_d";
            case 175L: return "mips_mov_ps";
            case 176L: return "mips_movf";
            case 177L: return "mips_movf_s";
            case 178L: return "mips_movf_d";
            case 179L: return "mips_movf_ps";
            case 180L: return "mips_movn";
            case 181L: return "mips_movn_s";
            case 182L: return "mips_movn_d";
            case 183L: return "mips_movn_ps";
            case 184L: return "mips_movt";
            case 185L: return "mips_movt_s";
            case 186L: return "mips_movt_d";
            case 187L: return "mips_movt_ps";
            case 188L: return "mips_movz";
            case 189L: return "mips_movz_s";
            case 190L: return "mips_movz_d";
            case 191L: return "mips_movz_ps";
            case 192L: return "mips_msub";
            case 193L: return "mips_msub_s";
            case 194L: return "mips_msub_d";
            case 195L: return "mips_msub_ps";
            case 196L: return "mips_msubu";
            case 197L: return "mips_mtc0";
            case 198L: return "mips_mtc1";
            case 199L: return "mips_mtc2";
            case 200L: return "mips_mthc1";
            case 201L: return "mips_mthc2";
            case 202L: return "mips_mthi";
            case 203L: return "mips_mtlo";
            case 204L: return "mips_mul";
            case 205L: return "mips_mul_s";
            case 206L: return "mips_mul_d";
            case 207L: return "mips_mul_ps";
            case 208L: return "mips_mult";
            case 209L: return "mips_multu";
            case 210L: return "mips_neg_s";
            case 211L: return "mips_neg_d";
            case 212L: return "mips_neg_ps";
            case 213L: return "mips_nmadd_s";
            case 214L: return "mips_nmadd_d";
            case 215L: return "mips_nmadd_ps";
            case 216L: return "mips_nmsub_s";
            case 217L: return "mips_nmsub_d";
            case 218L: return "mips_nmsub_ps";
            case 219L: return "mips_nop";
            case 220L: return "mips_nor";
            case 221L: return "mips_or";
            case 222L: return "mips_ori";
            case 223L: return "mips_pause";
            case 224L: return "mips_pll_ps";
            case 225L: return "mips_plu_ps";
            case 226L: return "mips_pref";
            case 227L: return "mips_prefe";
            case 228L: return "mips_prefx";
            case 229L: return "mips_pul_ps";
            case 230L: return "mips_puu_ps";
            case 231L: return "mips_rdhwr";
            case 232L: return "mips_rdpgpr";
            case 233L: return "mips_recip_s";
            case 234L: return "mips_recip_d";
            case 235L: return "mips_rotr";
            case 236L: return "mips_rotrv";
            case 237L: return "mips_round_l_s";
            case 238L: return "mips_round_l_d";
            case 239L: return "mips_round_w_s";
            case 240L: return "mips_round_w_d";
            case 241L: return "mips_rsqrt_s";
            case 242L: return "mips_rsqrt_d";
            case 243L: return "mips_sb";
            case 244L: return "mips_sbe";
            case 245L: return "mips_sc";
            case 246L: return "mips_sce";
            case 247L: return "mips_sdc1";
            case 248L: return "mips_sdc2";
            case 249L: return "mips_sdxc1";
            case 250L: return "mips_seb";
            case 251L: return "mips_seh";
            case 252L: return "mips_sh";
            case 253L: return "mips_she";
            case 254L: return "mips_sll";
            case 255L: return "mips_sllv";
            case 256L: return "mips_slt";
            case 257L: return "mips_slti";
            case 258L: return "mips_sltiu";
            case 259L: return "mips_sltu";
            case 260L: return "mips_sqrt_s";
            case 261L: return "mips_sqrt_d";
            case 262L: return "mips_sra";
            case 263L: return "mips_srav";
            case 264L: return "mips_srl";
            case 265L: return "mips_srlv";
            case 266L: return "mips_ssnop";
            case 267L: return "mips_sub";
            case 268L: return "mips_sub_s";
            case 269L: return "mips_sub_d";
            case 270L: return "mips_sub_ps";
            case 271L: return "mips_subu";
            case 272L: return "mips_suxc1";
            case 273L: return "mips_sw";
            case 274L: return "mips_swc1";
            case 275L: return "mips_swc2";
            case 276L: return "mips_swe";
            case 277L: return "mips_swl";
            case 278L: return "mips_swle";
            case 279L: return "mips_swr";
            case 280L: return "mips_swre";
            case 281L: return "mips_swxc1";
            case 282L: return "mips_sync";
            case 283L: return "mips_synci";
            case 284L: return "mips_syscall";
            case 285L: return "mips_teq";
            case 286L: return "mips_teqi";
            case 287L: return "mips_tge";
            case 288L: return "mips_tgei";
            case 289L: return "mips_tgeiu";
            case 290L: return "mips_tgeu";
            case 291L: return "mips_tlbinv";
            case 292L: return "mips_tlbinvf";
            case 293L: return "mips_tlbp";
            case 294L: return "mips_tlbr";
            case 295L: return "mips_tlbwi";
            case 296L: return "mips_tlbwr";
            case 297L: return "mips_tlt";
            case 298L: return "mips_tlti";
            case 299L: return "mips_tltiu";
            case 300L: return "mips_tltu";
            case 301L: return "mips_tne";
            case 302L: return "mips_tnei";
            case 303L: return "mips_trunc_l_s";
            case 304L: return "mips_trunc_l_d";
            case 305L: return "mips_trunc_w_s";
            case 306L: return "mips_trunc_w_d";
            case 307L: return "mips_wait";
            case 308L: return "mips_wrpgpr";
            case 309L: return "mips_wsbh";
            case 310L: return "mips_xor";
            case 311L: return "mips_xori";
            case 312L: return "mips_last_instruction";
            default: return "";
        }
    }

    std::string MipsInstructionKind(int64_t i, const std::string &strip) {
        std::string s = MipsInstructionKind(i);
        if (s.empty())
            s = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& MipsInstructionKind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L
        };
        static const std::vector<int64_t> retval(values, values + 313);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyBinaryAnalysisMipsInstructionKind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::BinaryAnalysis::MipsInstructionKind(i);
        if (retval.empty()) {
            retval = "(Rose::BinaryAnalysis::MipsInstructionKind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::BinaryAnalysis::MipsInstructionKind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBinaryAnalysisMipsInstructionKind() {
        return stringify::Rose::BinaryAnalysis::MipsInstructionKind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Rose/Logger.h line 14
namespace stringify { namespace Rose { namespace Logger {
    const char* Level(int64_t i) {
        switch (i) {
            case 0L: return "debug";
            case 1L: return "info";
            case 2L: return "warning";
            case 3L: return "error";
            case 4L: return "fatal";
            case 5L: return "enter";
            case 6L: return "leave";
            default: return "";
        }
    }

    std::string Level(int64_t i, const std::string &strip) {
        std::string s = Level(i);
        if (s.empty())
            s = "(Rose::Logger::Level)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Level() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyLoggerLevel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Logger::Level(i);
        if (retval.empty()) {
            retval = "(Rose::Logger::Level)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Logger::Level::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyLoggerLevel() {
        return stringify::Rose::Logger::Level();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 106
namespace stringify { namespace AstNodeClass {
    const char* locationInTree(int64_t i) {
        switch (i) {
            case 0L: return "LOCAL_LIST";
            case 1L: return "SUBTREE_LIST";
            default: return "";
        }
    }

    std::string locationInTree(int64_t i, const std::string &strip) {
        std::string s = locationInTree(i);
        if (s.empty())
            s = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& locationInTree() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_locationInTree(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::locationInTree(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::locationInTree)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::locationInTree::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_locationInTree() {
        return stringify::AstNodeClass::locationInTree();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 112
namespace stringify { namespace AstNodeClass {
    const char* includeExcludeMechanism(int64_t i) {
        switch (i) {
            case 0L: return "INCLUDE_LIST";
            case 1L: return "EXCLUDE_LIST";
            default: return "";
        }
    }

    std::string includeExcludeMechanism(int64_t i, const std::string &strip) {
        std::string s = includeExcludeMechanism(i);
        if (s.empty())
            s = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& includeExcludeMechanism() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClass_includeExcludeMechanism(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::includeExcludeMechanism(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::includeExcludeMechanism)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::includeExcludeMechanism::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClass_includeExcludeMechanism() {
        return stringify::AstNodeClass::includeExcludeMechanism();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/AstNodeClass.h line 333
namespace stringify { namespace AstNodeClass {
    const char* TypeEvaluation(int64_t i) {
        switch (i) {
            case 0L: return "CHAR_POINTER";
            case 1L: return "CONST_CHAR_POINTER";
            case 2L: return "ATTACHEDPREPROCESSINGINFOTYPE";
            case 3L: return "ROSE_HASH_MULTIMAP";
            case 4L: return "ROSE_GRAPH_HASH_MULTIMAP";
            case 5L: return "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP";
            case 6L: return "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP";
            case 7L: return "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP";
            case 8L: return "ROSE_GRAPH_INTEGER_NODE_HASH_MAP";
            case 9L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP";
            case 10L: return "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP";
            case 11L: return "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP";
            case 12L: return "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP";
            case 13L: return "SGCLASS_POINTER";
            case 14L: return "ROSEATTRUBUTESLISTCONTAINER";
            case 15L: return "SGCLASS_POINTER_LIST";
            case 16L: return "SGCLASS_POINTER_VECTOR";
            case 17L: return "SGCLASS_POINTER_VECTOR_NAMED_LIST";
            case 18L: return "STL_CONTAINER";
            case 19L: return "STL_SET";
            case 20L: return "STL_MULTIMAP";
            case 21L: return "STL_MAP";
            case 22L: return "STRING";
            case 23L: return "SGNAME";
            case 24L: return "BIT_VECTOR";
            case 25L: return "MODIFIERCLASS";
            case 26L: return "MODIFIERCLASS_WITHOUTEASYSTORAGE";
            case 27L: return "ASTATTRIBUTEMECHANISM";
            case 28L: return "TO_HANDLE";
            case 29L: return "OSTREAM";
            case 30L: return "ENUM_TYPE";
            case 31L: return "BASIC_DATA_TYPE";
            case 32L: return "SKIP_TYPE";
            case 33L: return "SGCLASS_POINTER_LIST_POINTER";
            default: return "";
        }
    }

    std::string TypeEvaluation(int64_t i, const std::string &strip) {
        std::string s = TypeEvaluation(i);
        if (s.empty())
            s = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TypeEvaluation() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L
        };
        static const std::vector<int64_t> retval(values, values + 34);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyAstNodeClassTypeEvaluation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::AstNodeClass::TypeEvaluation(i);
        if (retval.empty()) {
            retval = "(AstNodeClass::TypeEvaluation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "AstNodeClass::TypeEvaluation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyAstNodeClassTypeEvaluation() {
        return stringify::AstNodeClass::TypeEvaluation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 91
namespace stringify {
    const char* ConstructParamEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_CONSTRUCTOR_PARAMETER";
            case 1L: return "CONSTRUCTOR_PARAMETER";
            default: return "";
        }
    }

    std::string ConstructParamEnum(int64_t i, const std::string &strip) {
        std::string s = ConstructParamEnum(i);
        if (s.empty())
            s = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ConstructParamEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyConstructParamEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::ConstructParamEnum(i);
        if (retval.empty()) {
            retval = "(ConstructParamEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "ConstructParamEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyConstructParamEnum() {
        return stringify::ConstructParamEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 96
namespace stringify {
    const char* BuildAccessEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_ACCESS_FUNCTIONS";
            case 1L: return "BUILD_ACCESS_FUNCTIONS";
            case 2L: return "BUILD_FLAG_ACCESS_FUNCTIONS";
            case 3L: return "BUILD_LIST_ACCESS_FUNCTIONS";
            default: return "";
        }
    }

    std::string BuildAccessEnum(int64_t i, const std::string &strip) {
        std::string s = BuildAccessEnum(i);
        if (s.empty())
            s = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& BuildAccessEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyBuildAccessEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::BuildAccessEnum(i);
        if (retval.empty()) {
            retval = "(BuildAccessEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "BuildAccessEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyBuildAccessEnum() {
        return stringify::BuildAccessEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 104
namespace stringify {
    const char* CopyConfigEnum(int64_t i) {
        switch (i) {
            case 0L: return "NO_COPY_DATA";
            case 1L: return "COPY_DATA";
            case 2L: return "CLONE_PTR";
            case 3L: return "CLONE_TREE";
            default: return "";
        }
    }

    std::string CopyConfigEnum(int64_t i, const std::string &strip) {
        std::string s = CopyConfigEnum(i);
        if (s.empty())
            s = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CopyConfigEnum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCopyConfigEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::CopyConfigEnum(i);
        if (retval.empty()) {
            retval = "(CopyConfigEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "CopyConfigEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCopyConfigEnum() {
        return stringify::CopyConfigEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 125
namespace stringify {
    const char* TraversalEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_TRAVERSAL";
            case 1L: return "NO_TRAVERSAL";
            default: return "";
        }
    }

    std::string TraversalEnum(int64_t i, const std::string &strip) {
        std::string s = TraversalEnum(i);
        if (s.empty())
            s = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyTraversalEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TraversalEnum(i);
        if (retval.empty()) {
            retval = "(TraversalEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TraversalEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTraversalEnum() {
        return stringify::TraversalEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/ROSETTA/src/grammar.h line 130
namespace stringify {
    const char* DeleteEnum(int64_t i) {
        switch (i) {
            case 0L: return "DEF_DELETE";
            case 1L: return "NO_DELETE";
            default: return "";
        }
    }

    std::string DeleteEnum(int64_t i, const std::string &strip) {
        std::string s = DeleteEnum(i);
        if (s.empty())
            s = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& DeleteEnum() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyDeleteEnum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::DeleteEnum(i);
        if (retval.empty()) {
            retval = "(DeleteEnum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "DeleteEnum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyDeleteEnum() {
        return stringify::DeleteEnum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/GraphTraversal.h line 39
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "NO_EVENT";
            case 1L: return "ENTER_VERTEX";
            case 2L: return "ENTER_EDGE";
            case 4L: return "DISCOVER_VERTEX";
            case 8L: return "LEAVE_EDGE";
            case 16L: return "LEAVE_VERTEX";
            case 32L: return "FOLLOW_EDGE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            4L,
            8L,
            16L,
            32L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmTraversalEvent() {
        return stringify::Sawyer::Container::Algorithm::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Clexer.h line 26
namespace stringify { namespace Sawyer { namespace Language { namespace Clexer {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_EOF";
            case 1L: return "TOK_LEFT";
            case 2L: return "TOK_RIGHT";
            case 3L: return "TOK_CHAR";
            case 4L: return "TOK_STRING";
            case 5L: return "TOK_NUMBER";
            case 6L: return "TOK_WORD";
            case 7L: return "TOK_CPP";
            case 8L: return "TOK_COMMENT";
            case 9L: return "TOK_OTHER";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerLanguageClexerTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Language::Clexer::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Language::Clexer::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Language::Clexer::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerLanguageClexerTokenType() {
        return stringify::Sawyer::Language::Clexer::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 313
namespace stringify { namespace Sawyer { namespace Message {
    const char* Importance(int64_t i) {
        switch (i) {
            case 0L: return "DEBUG";
            case 1L: return "TRACE";
            case 2L: return "WHERE";
            case 3L: return "MARCH";
            case 4L: return "INFO";
            case 5L: return "WARN";
            case 6L: return "ERROR";
            case 7L: return "FATAL";
            case 8L: return "N_IMPORTANCE";
            default: return "";
        }
    }

    std::string Importance(int64_t i, const std::string &strip) {
        std::string s = Importance(i);
        if (s.empty())
            s = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Importance() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageImportance(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Importance(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Importance)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Importance::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageImportance() {
        return stringify::Sawyer::Message::Importance();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 343
namespace stringify { namespace Sawyer { namespace Message {
    const char* AnsiColor(int64_t i) {
        switch (i) {
            case 0L: return "COLOR_BLACK";
            case 1L: return "COLOR_RED";
            case 2L: return "COLOR_GREEN";
            case 3L: return "COLOR_YELLOW";
            case 4L: return "COLOR_BLUE";
            case 5L: return "COLOR_MAGENTA";
            case 6L: return "COLOR_CYAN";
            case 7L: return "COLOR_WHITE";
            case 8L: return "COLOR_DEFAULT";
            default: return "";
        }
    }

    std::string AnsiColor(int64_t i, const std::string &strip) {
        std::string s = AnsiColor(i);
        if (s.empty())
            s = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& AnsiColor() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerMessageAnsiColor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::AnsiColor(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::AnsiColor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::AnsiColor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessageAnsiColor() {
        return stringify::Sawyer::Message::AnsiColor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Message.h line 990
namespace stringify { namespace Sawyer { namespace Message { namespace Prefix {
    const char* When(int64_t i) {
        switch (i) {
            case 0L: return "NEVER";
            case 1L: return "SOMETIMES";
            case 2L: return "ALWAYS";
            default: return "";
        }
    }

    std::string When(int64_t i, const std::string &strip) {
        std::string s = When(i);
        if (s.empty())
            s = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& When() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerMessagePrefixWhen(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Message::Prefix::When(i);
        if (retval.empty()) {
            retval = "(Sawyer::Message::Prefix::When)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Message::Prefix::When::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerMessagePrefixWhen() {
        return stringify::Sawyer::Message::Prefix::When();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Tree.h line 44
namespace stringify { namespace Sawyer { namespace Tree {
    const char* TraversalEvent(int64_t i) {
        switch (i) {
            case 0L: return "ENTER";
            case 1L: return "LEAVE";
            default: return "";
        }
    }

    std::string TraversalEvent(int64_t i, const std::string &strip) {
        std::string s = TraversalEvent(i);
        if (s.empty())
            s = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TraversalEvent() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerTreeTraversalEvent(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::TraversalEvent(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::TraversalEvent)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::TraversalEvent::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeTraversalEvent() {
        return stringify::Sawyer::Tree::TraversalEvent();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Tree.h line 252
namespace stringify { namespace Sawyer { namespace Tree { namespace Vertex {
    const char* Link(int64_t i) {
        switch (i) {
            case 0L: return "NO";
            case 1L: return "YES";
            default: return "";
        }
    }

    std::string Link(int64_t i, const std::string &strip) {
        std::string s = Link(i);
        if (s.empty())
            s = "(Sawyer::Tree::Vertex::Link)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Link() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerTreeVertexLink(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Tree::Vertex::Link(i);
        if (retval.empty()) {
            retval = "(Sawyer::Tree::Vertex::Link)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Tree::Vertex::Link::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerTreeVertexLink() {
        return stringify::Sawyer::Tree::Vertex::Link();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/GraphAlgorithm.h line 478
namespace stringify { namespace Sawyer { namespace Container { namespace Algorithm {
    const char* CsiNextAction(int64_t i) {
        switch (i) {
            case 0L: return "CSI_CONTINUE";
            case 1L: return "CSI_ABORT";
            default: return "";
        }
    }

    std::string CsiNextAction(int64_t i, const std::string &strip) {
        std::string s = CsiNextAction(i);
        if (s.empty())
            s = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& CsiNextAction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerAlgorithmCsiNextAction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Algorithm::CsiNextAction(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Algorithm::CsiNextAction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Algorithm::CsiNextAction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerAlgorithmCsiNextAction() {
        return stringify::Sawyer::Container::Algorithm::CsiNextAction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Graph.h line 645
namespace stringify { namespace Sawyer { namespace Container { namespace Graph {
    const char* EdgePhase(int64_t i) {
        switch (i) {
            case 0L: return "IN_EDGES";
            case 1L: return "OUT_EDGES";
            case 2L: return "N_PHASES";
            default: return "";
        }
    }

    std::string EdgePhase(int64_t i, const std::string &strip) {
        std::string s = EdgePhase(i);
        if (s.empty())
            s = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& EdgePhase() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerContainerGraphEdgePhase(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Container::Graph::EdgePhase(i);
        if (retval.empty()) {
            retval = "(Sawyer::Container::Graph::EdgePhase)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerContainerGraphEdgePhase() {
        return stringify::Sawyer::Container::Graph::EdgePhase();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Database.h line 293
namespace stringify { namespace Sawyer { namespace Database { namespace Statement {
    const char* State(int64_t i) {
        switch (i) {
            case 0L: return "UNBOUND";
            case 1L: return "READY";
            case 2L: return "EXECUTING";
            case 3L: return "FINISHED";
            case 4L: return "DEAD";
            default: return "";
        }
    }

    std::string State(int64_t i, const std::string &strip) {
        std::string s = State(i);
        if (s.empty())
            s = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& State() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDatabaseStatementState(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Database::Statement::State(i);
        if (retval.empty()) {
            retval = "(Sawyer::Database::Statement::State)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Database::Statement::State::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDatabaseStatementState() {
        return stringify::Sawyer::Database::Statement::State();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Access.h line 19
namespace stringify { namespace Sawyer { namespace Access {
    const char* Access(int64_t i) {
        switch (i) {
            case 1L: return "EXECUTABLE";
            case 2L: return "WRITABLE";
            case 4L: return "READABLE";
            case 8L: return "IMMUTABLE";
            case 16L: return "PRIVATE";
            case 255L: return "RESERVED_MASK";
            case 4294967040L: return "USERDEF_MASK";
            default: return "";
        }
    }

    std::string Access(int64_t i, const std::string &strip) {
        std::string s = Access(i);
        if (s.empty())
            s = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Access() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            255L,
            4294967040L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerAccessAccess(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Access::Access(i);
        if (retval.empty()) {
            retval = "(Sawyer::Access::Access)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Access::Access::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerAccessAccess() {
        return stringify::Sawyer::Access::Access();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 151
namespace stringify { namespace Sawyer { namespace Yaml { namespace Exception {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "InternalError";
            case 1L: return "ParsingError";
            case 2L: return "OperationError";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Exception::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlException_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Exception::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Exception::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Exception::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlException_eType() {
        return stringify::Sawyer::Yaml::Exception::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 256
namespace stringify { namespace Sawyer { namespace Yaml { namespace Iterator {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Iterator::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlIterator_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Iterator::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Iterator::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Iterator::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlIterator_eType() {
        return stringify::Sawyer::Yaml::Iterator::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 313
namespace stringify { namespace Sawyer { namespace Yaml { namespace ConstIterator {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::ConstIterator::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlConstIterator_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::ConstIterator::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::ConstIterator::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::ConstIterator::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlConstIterator_eType() {
        return stringify::Sawyer::Yaml::ConstIterator::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/Yaml.h line 330
namespace stringify { namespace Sawyer { namespace Yaml { namespace Node {
    const char* eType(int64_t i) {
        switch (i) {
            case 0L: return "None";
            case 1L: return "SequenceType";
            case 2L: return "MapType";
            case 3L: return "ScalarType";
            default: return "";
        }
    }

    std::string eType(int64_t i, const std::string &strip) {
        std::string s = eType(i);
        if (s.empty())
            s = "(Sawyer::Yaml::Node::eType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& eType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerYamlNode_eType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Yaml::Node::eType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Yaml::Node::eType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Yaml::Node::eType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerYamlNode_eType() {
        return stringify::Sawyer::Yaml::Node::eType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 173
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SortOrder(int64_t i) {
        switch (i) {
            case 0L: return "INSERTION_ORDER";
            case 1L: return "DOCKEY_ORDER";
            default: return "";
        }
    }

    std::string SortOrder(int64_t i, const std::string &strip) {
        std::string s = SortOrder(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SortOrder() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSortOrder(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SortOrder(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SortOrder)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SortOrder::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSortOrder() {
        return stringify::Sawyer::CommandLine::SortOrder();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 186
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* Canonical(int64_t i) {
        switch (i) {
            case 0L: return "CANONICAL";
            case 1L: return "NONCANONICAL";
            case 2L: return "ALL_STRINGS";
            default: return "";
        }
    }

    std::string Canonical(int64_t i, const std::string &strip) {
        std::string s = Canonical(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Canonical() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineCanonical(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Canonical(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Canonical)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Canonical::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineCanonical() {
        return stringify::Sawyer::CommandLine::Canonical();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 194
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* ShowGroupName(int64_t i) {
        switch (i) {
            case 0L: return "SHOW_GROUP_OPTIONAL";
            case 1L: return "SHOW_GROUP_REQUIRED";
            case 2L: return "SHOW_GROUP_NONE";
            case 3L: return "SHOW_GROUP_INHERIT";
            default: return "";
        }
    }

    std::string ShowGroupName(int64_t i, const std::string &strip) {
        std::string s = ShowGroupName(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ShowGroupName() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineShowGroupName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::ShowGroupName(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::ShowGroupName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::ShowGroupName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineShowGroupName() {
        return stringify::Sawyer::CommandLine::ShowGroupName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 202
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* SwitchSkipping(int64_t i) {
        switch (i) {
            case 0L: return "SKIP_NEVER";
            case 1L: return "SKIP_WEAK";
            case 2L: return "SKIP_STRONG";
            default: return "";
        }
    }

    std::string SwitchSkipping(int64_t i, const std::string &strip) {
        std::string s = SwitchSkipping(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& SwitchSkipping() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineSwitchSkipping(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::SwitchSkipping(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::SwitchSkipping)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::SwitchSkipping::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineSwitchSkipping() {
        return stringify::Sawyer::CommandLine::SwitchSkipping();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 2010
namespace stringify { namespace Sawyer { namespace CommandLine {
    const char* WhichValue(int64_t i) {
        switch (i) {
            case 0L: return "SAVE_NONE";
            case 1L: return "SAVE_ONE";
            case 2L: return "SAVE_LAST";
            case 3L: return "SAVE_FIRST";
            case 4L: return "SAVE_ALL";
            case 5L: return "SAVE_AUGMENTED";
            default: return "";
        }
    }

    std::string WhichValue(int64_t i, const std::string &strip) {
        std::string s = WhichValue(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WhichValue() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifySawyerCommandLineWhichValue(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::WhichValue(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::WhichValue)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::WhichValue::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineWhichValue() {
        return stringify::Sawyer::CommandLine::WhichValue();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/CommandLine.h line 3065
namespace stringify { namespace Sawyer { namespace CommandLine { namespace Parser {
    const char* GroupingFlags(int64_t i) {
        switch (i) {
            case 0L: return "DEFAULT_GROUPING";
            case 1L: return "PROHIBIT_EMPTY_GROUPS";
            case 2L: return "SPLIT_SINGLE_GROUP";
            default: return "";
        }
    }

    std::string GroupingFlags(int64_t i, const std::string &strip) {
        std::string s = GroupingFlags(i);
        if (s.empty())
            s = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GroupingFlags() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerCommandLineParserGroupingFlags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::CommandLine::Parser::GroupingFlags(i);
        if (retval.empty()) {
            retval = "(Sawyer::CommandLine::Parser::GroupingFlags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::CommandLine::Parser::GroupingFlags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerCommandLineParserGroupingFlags() {
        return stringify::Sawyer::CommandLine::Parser::GroupingFlags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/DocumentMarkup.h line 42
namespace stringify { namespace Sawyer { namespace Document { namespace Markup {
    const char* TokenType(int64_t i) {
        switch (i) {
            case 0L: return "TOK_DATA";
            case 1L: return "TOK_FUNCTION";
            case 2L: return "TOK_LEFT";
            case 3L: return "TOK_RIGHT";
            case 4L: return "TOK_BLANK_LINE";
            default: return "";
        }
    }

    std::string TokenType(int64_t i, const std::string &strip) {
        std::string s = TokenType(i);
        if (s.empty())
            s = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& TokenType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}}}

namespace Rose {
    std::string stringifySawyerDocumentMarkupTokenType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sawyer::Document::Markup::TokenType(i);
        if (retval.empty()) {
            retval = "(Sawyer::Document::Markup::TokenType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sawyer::Document::Markup::TokenType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySawyerDocumentMarkupTokenType() {
        return stringify::Sawyer::Document::Markup::TokenType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/stringifyEnums.C line 39
namespace stringify {
    const char* Generate(int64_t i) {
        switch (i) {
            case 0L: return "GENERATE_NOTHING";
            case 1L: return "GENERATE_DECLARATIONS";
            case 2L: return "GENERATE_DEFINITIONS";
            default: return "";
        }
    }

    std::string Generate(int64_t i, const std::string &strip) {
        std::string s = Generate(i);
        if (s.empty())
            s = "(Generate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Generate() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyGenerate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Generate(i);
        if (retval.empty()) {
            retval = "(Generate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Generate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyGenerate() {
        return stringify::Generate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/Sawyer/stringifyEnums.C line 46
namespace stringify {
    const char* Flag(int64_t i) {
        switch (i) {
            case 2L: return "NO_CHECK";
            default: return "";
        }
    }

    std::string Flag(int64_t i, const std::string &strip) {
        std::string s = Flag(i);
        if (s.empty())
            s = "(Flag)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Flag() {
        static const int64_t values[] = {
            2L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyFlag(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Flag(i);
        if (retval.empty()) {
            retval = "(Flag)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Flag::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyFlag() {
        return stringify::Flag();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/transformationSupport.h line 37
namespace stringify { namespace TransformationSupport {
    const char* operatorCodeType(int64_t i) {
        switch (i) {
            case 0L: return "FUNCTION_CALL_OPERATOR_CODE";
            case 1L: return "ADD_OPERATOR_CODE";
            case 2L: return "SUBT_OPERATOR_CODE";
            case 3L: return "MULT_OPERATOR_CODE";
            case 4L: return "DIV_OPERATOR_CODE";
            case 5L: return "INTEGER_DIV_OPERATOR_CODE";
            case 6L: return "MOD_OPERATOR_CODE";
            case 7L: return "AND_OPERATOR_CODE";
            case 8L: return "OR_OPERATOR_CODE";
            case 9L: return "BITXOR_OPERATOR_CODE";
            case 10L: return "BITAND_OPERATOR_CODE";
            case 11L: return "BITOR_OPERATOR_CODE";
            case 12L: return "EQ_OPERATOR_CODE";
            case 13L: return "LT_OPERATOR_CODE";
            case 14L: return "GT_OPERATOR_CODE";
            case 15L: return "NE_OPERATOR_CODE";
            case 16L: return "LE_OPERATOR_CODE";
            case 17L: return "GE_OPERATOR_CODE";
            case 18L: return "ASSIGN_OPERATOR_CODE";
            case 19L: return "PLUS_ASSIGN_OPERATOR_CODE";
            case 20L: return "MINUS_ASSIGN_OPERATOR_CODE";
            case 21L: return "AND_ASSIGN_OPERATOR_CODE";
            case 22L: return "IOR_ASSIGN_OPERATOR_CODE";
            case 23L: return "MULT_ASSIGN_OPERATOR_CODE";
            case 24L: return "DIV_ASSIGN_OPERATOR_CODE";
            case 25L: return "MOD_ASSIGN_OPERATOR_CODE";
            case 26L: return "XOR_ASSIGN_OPERATOR_CODE";
            case 27L: return "PARENTHESIS_OPERATOR_CODE";
            case 28L: return "BRACKET_OPERATOR_CODE";
            case 29L: return "NOT_OPERATOR_CODE";
            case 30L: return "DEREFERENCE_OPERATOR_CODE";
            case 31L: return "ADDRESS_OPERATOR_CODE";
            case 32L: return "LSHIFT_OPERATOR_CODE";
            case 33L: return "RSHIFT_OPERATOR_CODE";
            case 34L: return "LSHIFT_ASSIGN_OPERATOR_CODE";
            case 35L: return "RSHIFT_ASSIGN_OPERATOR_CODE";
            case 36L: return "PREFIX_PLUSPLUS_OPERATOR_CODE";
            case 37L: return "POSTFIX_PLUSPLUS_OPERATOR_CODE";
            case 38L: return "PREFIX_MINUSMINUS_OPERATOR_CODE";
            case 39L: return "POSTFIX_MINUSMINUS_OPERATOR_CODE";
            case 99L: return "OPERATOR_CODE_LAST_TAG";
            default: return "";
        }
    }

    std::string operatorCodeType(int64_t i, const std::string &strip) {
        std::string s = operatorCodeType(i);
        if (s.empty())
            s = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& operatorCodeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            99L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifyTransformationSupport_operatorCodeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::TransformationSupport::operatorCodeType(i);
        if (retval.empty()) {
            retval = "(TransformationSupport::operatorCodeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "TransformationSupport::operatorCodeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyTransformationSupport_operatorCodeType() {
        return stringify::TransformationSupport::operatorCodeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/utility_functions.C line 1016
namespace stringify {
    const char* language_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_none";
            case 1L: return "e_c";
            case 2L: return "e_cxx";
            case 3L: return "e_fortran";
            case 4L: return "e_last_language";
            default: return "";
        }
    }

    std::string language_enum(int64_t i, const std::string &strip) {
        std::string s = language_enum(i);
        if (s.empty())
            s = "(language_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& language_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringify_language_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::language_enum(i);
        if (retval.empty()) {
            retval = "(language_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "language_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringify_language_enum() {
        return stringify::language_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /src/roseSupport/callbacks.h line 15
namespace stringify { namespace Rose { namespace Callbacks {
    const char* Direction(int64_t i) {
        switch (i) {
            case 0L: return "FORWARD";
            case 1L: return "BACKWARD";
            default: return "";
        }
    }

    std::string Direction(int64_t i, const std::string &strip) {
        std::string s = Direction(i);
        if (s.empty())
            s = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Direction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}}

namespace Rose {
    std::string stringifyCallbacksDirection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Rose::Callbacks::Direction(i);
        if (retval.empty()) {
            retval = "(Rose::Callbacks::Direction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Rose::Callbacks::Direction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCallbacksDirection() {
        return stringify::Rose::Callbacks::Direction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 3
namespace stringify {
    const char* E_SgSourceFile(int64_t i) {
        switch (i) {
            case 0L: return "SgSourceFile_globalScope";
            case 1L: return "SgSourceFile_package";
            case 2L: return "SgSourceFile_import_list";
            case 3L: return "SgSourceFile_class_list";
            default: return "";
        }
    }

    std::string E_SgSourceFile(int64_t i, const std::string &strip) {
        std::string s = E_SgSourceFile(i);
        if (s.empty())
            s = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSourceFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSourceFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSourceFile(i);
        if (retval.empty()) {
            retval = "(E_SgSourceFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSourceFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSourceFile() {
        return stringify::E_SgSourceFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 6
namespace stringify {
    const char* E_SgUnknownFile(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownFile_globalScope";
            default: return "";
        }
    }

    std::string E_SgUnknownFile(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownFile(i);
        if (s.empty())
            s = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownFile(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownFile() {
        return stringify::E_SgUnknownFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 9
namespace stringify {
    const char* E_SgJvmComposite(int64_t i) {
        switch (i) {
            case 0L: return "SgJvmComposite_genericFileList";
            case 1L: return "SgJvmComposite_interpretations";
            default: return "";
        }
    }

    std::string E_SgJvmComposite(int64_t i, const std::string &strip) {
        std::string s = E_SgJvmComposite(i);
        if (s.empty())
            s = "(E_SgJvmComposite)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJvmComposite() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJvmComposite(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJvmComposite(i);
        if (retval.empty()) {
            retval = "(E_SgJvmComposite)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJvmComposite::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJvmComposite() {
        return stringify::E_SgJvmComposite();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 12
namespace stringify {
    const char* E_SgBinaryComposite(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryComposite_genericFileList";
            case 1L: return "SgBinaryComposite_interpretations";
            default: return "";
        }
    }

    std::string E_SgBinaryComposite(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryComposite(i);
        if (s.empty())
            s = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryComposite() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryComposite(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryComposite(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryComposite)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryComposite::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryComposite() {
        return stringify::E_SgBinaryComposite();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 15
namespace stringify {
    const char* E_SgProject(int64_t i) {
        switch (i) {
            case 0L: return "SgProject_fileList_ptr";
            default: return "";
        }
    }

    std::string E_SgProject(int64_t i, const std::string &strip) {
        std::string s = E_SgProject(i);
        if (s.empty())
            s = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProject(i);
        if (retval.empty()) {
            retval = "(E_SgProject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProject() {
        return stringify::E_SgProject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 18
namespace stringify {
    const char* E_SgExpBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgExpBaseClass_base_class";
            case 1L: return "SgExpBaseClass_base_class_exp";
            default: return "";
        }
    }

    std::string E_SgExpBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgExpBaseClass(i);
        if (s.empty())
            s = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgExpBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpBaseClass() {
        return stringify::E_SgExpBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 21
namespace stringify {
    const char* E_SgNonrealBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealBaseClass_base_class";
            case 1L: return "SgNonrealBaseClass_base_class_nonreal";
            default: return "";
        }
    }

    std::string E_SgNonrealBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealBaseClass(i);
        if (s.empty())
            s = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealBaseClass() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealBaseClass() {
        return stringify::E_SgNonrealBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 24
namespace stringify {
    const char* E_SgBaseClass(int64_t i) {
        switch (i) {
            case 0L: return "SgBaseClass_base_class";
            default: return "";
        }
    }

    std::string E_SgBaseClass(int64_t i, const std::string &strip) {
        std::string s = E_SgBaseClass(i);
        if (s.empty())
            s = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBaseClass() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBaseClass(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBaseClass(i);
        if (retval.empty()) {
            retval = "(E_SgBaseClass)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBaseClass::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBaseClass() {
        return stringify::E_SgBaseClass();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 27
namespace stringify {
    const char* E_SgTemplateParameter(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameter_expression";
            case 1L: return "SgTemplateParameter_defaultExpressionParameter";
            case 2L: return "SgTemplateParameter_templateDeclaration";
            case 3L: return "SgTemplateParameter_defaultTemplateDeclarationParameter";
            case 4L: return "SgTemplateParameter_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateParameter(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameter(i);
        if (s.empty())
            s = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameter() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameter(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameter(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameter)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameter::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameter() {
        return stringify::E_SgTemplateParameter();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 30
namespace stringify {
    const char* E_SgTemplateArgument(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgument_expression";
            case 1L: return "SgTemplateArgument_templateDeclaration";
            case 2L: return "SgTemplateArgument_initializedName";
            default: return "";
        }
    }

    std::string E_SgTemplateArgument(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgument(i);
        if (s.empty())
            s = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgument() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgument(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgument(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgument)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgument::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgument() {
        return stringify::E_SgTemplateArgument();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 33
namespace stringify {
    const char* E_SgDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectory_fileList";
            case 1L: return "SgDirectory_directoryList";
            default: return "";
        }
    }

    std::string E_SgDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectory(i);
        if (s.empty())
            s = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectory() {
        return stringify::E_SgDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 36
namespace stringify {
    const char* E_SgFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgFileList_listOfFiles";
            default: return "";
        }
    }

    std::string E_SgFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgFileList(i);
        if (s.empty())
            s = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFileList(i);
        if (retval.empty()) {
            retval = "(E_SgFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFileList() {
        return stringify::E_SgFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 39
namespace stringify {
    const char* E_SgDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgDirectoryList_listOfDirectories";
            default: return "";
        }
    }

    std::string E_SgDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgDirectoryList(i);
        if (s.empty())
            s = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDirectoryList() {
        return stringify::E_SgDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 42
namespace stringify {
    const char* E_SgTemplateArgumentList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateArgumentList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateArgumentList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateArgumentList(i);
        if (s.empty())
            s = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateArgumentList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateArgumentList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateArgumentList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateArgumentList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateArgumentList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateArgumentList() {
        return stringify::E_SgTemplateArgumentList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 45
namespace stringify {
    const char* E_SgTemplateParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateParameterList_args";
            default: return "";
        }
    }

    std::string E_SgTemplateParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateParameterList(i);
        if (s.empty())
            s = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateParameterList() {
        return stringify::E_SgTemplateParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 48
namespace stringify {
    const char* E_SgIncludeFile(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeFile_include_file_list";
            default: return "";
        }
    }

    std::string E_SgIncludeFile(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeFile(i);
        if (s.empty())
            s = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeFile() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeFile(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeFile() {
        return stringify::E_SgIncludeFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 51
namespace stringify {
    const char* E_SgJavaImportStatementList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaImportStatementList_java_import_list";
            default: return "";
        }
    }

    std::string E_SgJavaImportStatementList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaImportStatementList(i);
        if (s.empty())
            s = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaImportStatementList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaImportStatementList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaImportStatementList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaImportStatementList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaImportStatementList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaImportStatementList() {
        return stringify::E_SgJavaImportStatementList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 54
namespace stringify {
    const char* E_SgJavaClassDeclarationList(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaClassDeclarationList_java_class_list";
            default: return "";
        }
    }

    std::string E_SgJavaClassDeclarationList(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaClassDeclarationList(i);
        if (s.empty())
            s = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaClassDeclarationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaClassDeclarationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaClassDeclarationList(i);
        if (retval.empty()) {
            retval = "(E_SgJavaClassDeclarationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaClassDeclarationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaClassDeclarationList() {
        return stringify::E_SgJavaClassDeclarationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 57
namespace stringify {
    const char* E_SgTypeUnknown(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnknown_type_kind";
            case 1L: return "SgTypeUnknown_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnknown(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnknown(i);
        if (s.empty())
            s = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnknown() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnknown(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnknown(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnknown)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnknown::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnknown() {
        return stringify::E_SgTypeUnknown();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 60
namespace stringify {
    const char* E_SgTypeChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar_type_kind";
            case 1L: return "SgTypeChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar(i);
        if (s.empty())
            s = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar() {
        return stringify::E_SgTypeChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 63
namespace stringify {
    const char* E_SgTypeSignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedChar_type_kind";
            case 1L: return "SgTypeSignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedChar(i);
        if (s.empty())
            s = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedChar() {
        return stringify::E_SgTypeSignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 66
namespace stringify {
    const char* E_SgTypeUnsignedChar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedChar_type_kind";
            case 1L: return "SgTypeUnsignedChar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedChar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedChar(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedChar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedChar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedChar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedChar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedChar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedChar() {
        return stringify::E_SgTypeUnsignedChar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 69
namespace stringify {
    const char* E_SgTypeShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeShort_type_kind";
            case 1L: return "SgTypeShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeShort(i);
        if (s.empty())
            s = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeShort() {
        return stringify::E_SgTypeShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 72
namespace stringify {
    const char* E_SgTypeSignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedShort_type_kind";
            case 1L: return "SgTypeSignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedShort(i);
        if (s.empty())
            s = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedShort() {
        return stringify::E_SgTypeSignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 75
namespace stringify {
    const char* E_SgTypeUnsignedShort(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedShort_type_kind";
            case 1L: return "SgTypeUnsignedShort_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedShort(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedShort(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedShort() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedShort(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedShort(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedShort)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedShort::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedShort() {
        return stringify::E_SgTypeUnsignedShort();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 78
namespace stringify {
    const char* E_SgTypeInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeInt_type_kind";
            case 1L: return "SgTypeInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeInt(i);
        if (s.empty())
            s = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeInt() {
        return stringify::E_SgTypeInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 81
namespace stringify {
    const char* E_SgTypeSignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedInt_type_kind";
            case 1L: return "SgTypeSignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedInt(i);
        if (s.empty())
            s = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedInt() {
        return stringify::E_SgTypeSignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 84
namespace stringify {
    const char* E_SgTypeUnsignedInt(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedInt_type_kind";
            case 1L: return "SgTypeUnsignedInt_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedInt(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedInt(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedInt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedInt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedInt(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedInt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedInt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedInt() {
        return stringify::E_SgTypeUnsignedInt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 87
namespace stringify {
    const char* E_SgTypeLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLong_type_kind";
            case 1L: return "SgTypeLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLong(i);
        if (s.empty())
            s = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLong() {
        return stringify::E_SgTypeLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 90
namespace stringify {
    const char* E_SgTypeSignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLong_type_kind";
            case 1L: return "SgTypeSignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLong() {
        return stringify::E_SgTypeSignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 93
namespace stringify {
    const char* E_SgTypeUnsignedLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLong_type_kind";
            case 1L: return "SgTypeUnsignedLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLong() {
        return stringify::E_SgTypeUnsignedLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 96
namespace stringify {
    const char* E_SgTypeVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeVoid_type_kind";
            case 1L: return "SgTypeVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeVoid(i);
        if (s.empty())
            s = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeVoid() {
        return stringify::E_SgTypeVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 99
namespace stringify {
    const char* E_SgTypeGlobalVoid(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeGlobalVoid_type_kind";
            case 1L: return "SgTypeGlobalVoid_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeGlobalVoid(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeGlobalVoid(i);
        if (s.empty())
            s = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeGlobalVoid() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeGlobalVoid(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeGlobalVoid(i);
        if (retval.empty()) {
            retval = "(E_SgTypeGlobalVoid)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeGlobalVoid::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeGlobalVoid() {
        return stringify::E_SgTypeGlobalVoid();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 102
namespace stringify {
    const char* E_SgTypeWchar(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeWchar_type_kind";
            case 1L: return "SgTypeWchar_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeWchar(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeWchar(i);
        if (s.empty())
            s = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeWchar() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeWchar(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeWchar(i);
        if (retval.empty()) {
            retval = "(E_SgTypeWchar)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeWchar::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeWchar() {
        return stringify::E_SgTypeWchar();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 105
namespace stringify {
    const char* E_SgTypeFloat(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat_type_kind";
            case 1L: return "SgTypeFloat_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat(i);
        if (s.empty())
            s = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat() {
        return stringify::E_SgTypeFloat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 108
namespace stringify {
    const char* E_SgTypeDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDouble_type_kind";
            case 1L: return "SgTypeDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDouble(i);
        if (s.empty())
            s = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDouble() {
        return stringify::E_SgTypeDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 111
namespace stringify {
    const char* E_SgTypeLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongLong_type_kind";
            case 1L: return "SgTypeLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongLong(i);
        if (s.empty())
            s = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongLong() {
        return stringify::E_SgTypeLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 114
namespace stringify {
    const char* E_SgTypeSignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSignedLongLong_type_kind";
            case 1L: return "SgTypeSignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSignedLongLong() {
        return stringify::E_SgTypeSignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 117
namespace stringify {
    const char* E_SgTypeUnsignedLongLong(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsignedLongLong_type_kind";
            case 1L: return "SgTypeUnsignedLongLong_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsignedLongLong(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsignedLongLong(i);
        if (s.empty())
            s = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsignedLongLong() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsignedLongLong(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsignedLongLong(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsignedLongLong)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsignedLongLong::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsignedLongLong() {
        return stringify::E_SgTypeUnsignedLongLong();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 120
namespace stringify {
    const char* E_SgTypeSigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeSigned128bitInteger_type_kind";
            case 1L: return "SgTypeSigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeSigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeSigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeSigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeSigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeSigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeSigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeSigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeSigned128bitInteger() {
        return stringify::E_SgTypeSigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 123
namespace stringify {
    const char* E_SgTypeUnsigned128bitInteger(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeUnsigned128bitInteger_type_kind";
            case 1L: return "SgTypeUnsigned128bitInteger_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeUnsigned128bitInteger(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeUnsigned128bitInteger(i);
        if (s.empty())
            s = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeUnsigned128bitInteger() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeUnsigned128bitInteger(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeUnsigned128bitInteger(i);
        if (retval.empty()) {
            retval = "(E_SgTypeUnsigned128bitInteger)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeUnsigned128bitInteger::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeUnsigned128bitInteger() {
        return stringify::E_SgTypeUnsigned128bitInteger();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 126
namespace stringify {
    const char* E_SgTypeFloat80(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat80_type_kind";
            case 1L: return "SgTypeFloat80_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat80(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat80(i);
        if (s.empty())
            s = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat80() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat80(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat80(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat80)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat80::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat80() {
        return stringify::E_SgTypeFloat80();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 129
namespace stringify {
    const char* E_SgTypeLongDouble(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLongDouble_type_kind";
            case 1L: return "SgTypeLongDouble_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLongDouble(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLongDouble(i);
        if (s.empty())
            s = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLongDouble() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLongDouble(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLongDouble(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLongDouble)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLongDouble::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLongDouble() {
        return stringify::E_SgTypeLongDouble();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 132
namespace stringify {
    const char* E_SgTypeString(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeString_type_kind";
            case 1L: return "SgTypeString_lengthExpression";
            default: return "";
        }
    }

    std::string E_SgTypeString(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeString(i);
        if (s.empty())
            s = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeString() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeString(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeString(i);
        if (retval.empty()) {
            retval = "(E_SgTypeString)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeString::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeString() {
        return stringify::E_SgTypeString();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 135
namespace stringify {
    const char* E_SgTypeBool(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeBool_type_kind";
            case 1L: return "SgTypeBool_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeBool(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeBool(i);
        if (s.empty())
            s = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeBool() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeBool(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeBool(i);
        if (retval.empty()) {
            retval = "(E_SgTypeBool)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeBool::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeBool() {
        return stringify::E_SgTypeBool();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 138
namespace stringify {
    const char* E_SgPointerMemberType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerMemberType_type_kind";
            case 1L: return "SgPointerMemberType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerMemberType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerMemberType(i);
        if (s.empty())
            s = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerMemberType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerMemberType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerMemberType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerMemberType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerMemberType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerMemberType() {
        return stringify::E_SgPointerMemberType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 141
namespace stringify {
    const char* E_SgPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerType_type_kind";
            case 1L: return "SgPointerType_base_type";
            default: return "";
        }
    }

    std::string E_SgPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerType(i);
        if (s.empty())
            s = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerType() {
        return stringify::E_SgPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 144
namespace stringify {
    const char* E_SgReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgReferenceType(i);
        if (s.empty())
            s = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReferenceType() {
        return stringify::E_SgReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 147
namespace stringify {
    const char* E_SgJavaParameterType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterType_type_kind";
            case 1L: return "SgJavaParameterType_builtin_type";
            case 2L: return "SgJavaParameterType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterType(i);
        if (s.empty())
            s = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterType() {
        return stringify::E_SgJavaParameterType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 150
namespace stringify {
    const char* E_SgJovialTableType(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableType_type_kind";
            case 1L: return "SgJovialTableType_builtin_type";
            case 2L: return "SgJovialTableType_declaration";
            case 3L: return "SgJovialTableType_dim_info";
            default: return "";
        }
    }

    std::string E_SgJovialTableType(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableType(i);
        if (s.empty())
            s = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableType(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableType() {
        return stringify::E_SgJovialTableType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 153
namespace stringify {
    const char* E_SgClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgClassType_type_kind";
            case 1L: return "SgClassType_builtin_type";
            case 2L: return "SgClassType_declaration";
            default: return "";
        }
    }

    std::string E_SgClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgClassType(i);
        if (s.empty())
            s = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassType(i);
        if (retval.empty()) {
            retval = "(E_SgClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassType() {
        return stringify::E_SgClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 156
namespace stringify {
    const char* E_SgEnumType(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumType_type_kind";
            case 1L: return "SgEnumType_builtin_type";
            case 2L: return "SgEnumType_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumType(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumType(i);
        if (s.empty())
            s = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumType(i);
        if (retval.empty()) {
            retval = "(E_SgEnumType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumType() {
        return stringify::E_SgEnumType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 159
namespace stringify {
    const char* E_SgTypedefType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefType_type_kind";
            case 1L: return "SgTypedefType_builtin_type";
            case 2L: return "SgTypedefType_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefType(i);
        if (s.empty())
            s = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefType(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefType() {
        return stringify::E_SgTypedefType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 162
namespace stringify {
    const char* E_SgNonrealType(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealType_type_kind";
            case 1L: return "SgNonrealType_builtin_type";
            case 2L: return "SgNonrealType_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealType(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealType(i);
        if (s.empty())
            s = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealType(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealType() {
        return stringify::E_SgNonrealType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 165
namespace stringify {
    const char* E_SgJavaParameterizedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaParameterizedType_type_kind";
            case 1L: return "SgJavaParameterizedType_builtin_type";
            case 2L: return "SgJavaParameterizedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaParameterizedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaParameterizedType(i);
        if (s.empty())
            s = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaParameterizedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaParameterizedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaParameterizedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaParameterizedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaParameterizedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaParameterizedType() {
        return stringify::E_SgJavaParameterizedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 168
namespace stringify {
    const char* E_SgJavaQualifiedType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaQualifiedType_type_kind";
            case 1L: return "SgJavaQualifiedType_builtin_type";
            case 2L: return "SgJavaQualifiedType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaQualifiedType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaQualifiedType(i);
        if (s.empty())
            s = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaQualifiedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaQualifiedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaQualifiedType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaQualifiedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaQualifiedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaQualifiedType() {
        return stringify::E_SgJavaQualifiedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 171
namespace stringify {
    const char* E_SgJavaWildcardType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaWildcardType_type_kind";
            case 1L: return "SgJavaWildcardType_builtin_type";
            case 2L: return "SgJavaWildcardType_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaWildcardType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaWildcardType(i);
        if (s.empty())
            s = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaWildcardType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaWildcardType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaWildcardType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaWildcardType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaWildcardType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaWildcardType() {
        return stringify::E_SgJavaWildcardType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 174
namespace stringify {
    const char* E_SgAdaTaskType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskType_type_kind";
            case 1L: return "SgAdaTaskType_builtin_type";
            case 2L: return "SgAdaTaskType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaTaskType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskType(i);
        if (s.empty())
            s = "(E_SgAdaTaskType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskType() {
        return stringify::E_SgAdaTaskType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 177
namespace stringify {
    const char* E_SgAdaProtectedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedType_type_kind";
            case 1L: return "SgAdaProtectedType_builtin_type";
            case 2L: return "SgAdaProtectedType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedType(i);
        if (s.empty())
            s = "(E_SgAdaProtectedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedType() {
        return stringify::E_SgAdaProtectedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 180
namespace stringify {
    const char* E_SgAdaFormalType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalType_type_kind";
            case 1L: return "SgAdaFormalType_builtin_type";
            case 2L: return "SgAdaFormalType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaFormalType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalType(i);
        if (s.empty())
            s = "(E_SgAdaFormalType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalType() {
        return stringify::E_SgAdaFormalType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 183
namespace stringify {
    const char* E_SgAdaDiscriminatedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminatedType_type_kind";
            case 1L: return "SgAdaDiscriminatedType_builtin_type";
            case 2L: return "SgAdaDiscriminatedType_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminatedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminatedType(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminatedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminatedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminatedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminatedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminatedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminatedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminatedType() {
        return stringify::E_SgAdaDiscriminatedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 186
namespace stringify {
    const char* E_SgNamedType(int64_t i) {
        switch (i) {
            case 0L: return "SgNamedType_type_kind";
            case 1L: return "SgNamedType_builtin_type";
            case 2L: return "SgNamedType_declaration";
            default: return "";
        }
    }

    std::string E_SgNamedType(int64_t i, const std::string &strip) {
        std::string s = E_SgNamedType(i);
        if (s.empty())
            s = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamedType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamedType(i);
        if (retval.empty()) {
            retval = "(E_SgNamedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamedType() {
        return stringify::E_SgNamedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 189
namespace stringify {
    const char* E_SgModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgModifierType_type_kind";
            case 1L: return "SgModifierType_base_type";
            default: return "";
        }
    }

    std::string E_SgModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgModifierType(i);
        if (s.empty())
            s = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModifierType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModifierType() {
        return stringify::E_SgModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 192
namespace stringify {
    const char* E_SgPartialFunctionModifierType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionModifierType_type_kind";
            case 1L: return "SgPartialFunctionModifierType_return_type";
            case 2L: return "SgPartialFunctionModifierType_orig_return_type";
            case 3L: return "SgPartialFunctionModifierType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionModifierType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionModifierType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionModifierType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionModifierType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionModifierType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionModifierType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionModifierType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionModifierType() {
        return stringify::E_SgPartialFunctionModifierType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 195
namespace stringify {
    const char* E_SgPartialFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgPartialFunctionType_type_kind";
            case 1L: return "SgPartialFunctionType_return_type";
            case 2L: return "SgPartialFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgPartialFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgPartialFunctionType(i);
        if (s.empty())
            s = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPartialFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPartialFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPartialFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgPartialFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPartialFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPartialFunctionType() {
        return stringify::E_SgPartialFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 198
namespace stringify {
    const char* E_SgMemberFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionType_type_kind";
            case 1L: return "SgMemberFunctionType_return_type";
            case 2L: return "SgMemberFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionType(i);
        if (s.empty())
            s = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionType() {
        return stringify::E_SgMemberFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 201
namespace stringify {
    const char* E_SgFunctionType(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionType_type_kind";
            case 1L: return "SgFunctionType_return_type";
            case 2L: return "SgFunctionType_orig_return_type";
            default: return "";
        }
    }

    std::string E_SgFunctionType(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionType(i);
        if (s.empty())
            s = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionType(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionType() {
        return stringify::E_SgFunctionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 204
namespace stringify {
    const char* E_SgArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgArrayType_type_kind";
            case 1L: return "SgArrayType_index";
            case 2L: return "SgArrayType_dim_info";
            default: return "";
        }
    }

    std::string E_SgArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgArrayType(i);
        if (s.empty())
            s = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrayType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrayType() {
        return stringify::E_SgArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 207
namespace stringify {
    const char* E_SgTypeEllipse(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeEllipse_type_kind";
            case 1L: return "SgTypeEllipse_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeEllipse(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeEllipse(i);
        if (s.empty())
            s = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeEllipse() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeEllipse(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeEllipse(i);
        if (retval.empty()) {
            retval = "(E_SgTypeEllipse)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeEllipse::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeEllipse() {
        return stringify::E_SgTypeEllipse();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 210
namespace stringify {
    const char* E_SgTemplateType(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateType_type_kind";
            case 1L: return "SgTemplateType_class_type";
            case 2L: return "SgTemplateType_parent_class_type";
            case 3L: return "SgTemplateType_template_parameter";
            default: return "";
        }
    }

    std::string E_SgTemplateType(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateType(i);
        if (s.empty())
            s = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateType(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateType() {
        return stringify::E_SgTemplateType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 213
namespace stringify {
    const char* E_SgQualifiedNameType(int64_t i) {
        switch (i) {
            case 0L: return "SgQualifiedNameType_type_kind";
            default: return "";
        }
    }

    std::string E_SgQualifiedNameType(int64_t i, const std::string &strip) {
        std::string s = E_SgQualifiedNameType(i);
        if (s.empty())
            s = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgQualifiedNameType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgQualifiedNameType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgQualifiedNameType(i);
        if (retval.empty()) {
            retval = "(E_SgQualifiedNameType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgQualifiedNameType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgQualifiedNameType() {
        return stringify::E_SgQualifiedNameType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 216
namespace stringify {
    const char* E_SgTypeComplex(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeComplex_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeComplex(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeComplex(i);
        if (s.empty())
            s = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeComplex() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeComplex(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeComplex(i);
        if (retval.empty()) {
            retval = "(E_SgTypeComplex)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeComplex::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeComplex() {
        return stringify::E_SgTypeComplex();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 219
namespace stringify {
    const char* E_SgTypeImaginary(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeImaginary_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeImaginary(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeImaginary(i);
        if (s.empty())
            s = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeImaginary() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeImaginary(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeImaginary(i);
        if (retval.empty()) {
            retval = "(E_SgTypeImaginary)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeImaginary::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeImaginary() {
        return stringify::E_SgTypeImaginary();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 222
namespace stringify {
    const char* E_SgTypeDefault(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeDefault_type_kind";
            case 1L: return "SgTypeDefault_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeDefault(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeDefault(i);
        if (s.empty())
            s = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeDefault() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeDefault(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeDefault(i);
        if (retval.empty()) {
            retval = "(E_SgTypeDefault)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeDefault::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeDefault() {
        return stringify::E_SgTypeDefault();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 225
namespace stringify {
    const char* E_SgTypeCAFTeam(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCAFTeam_type_kind";
            case 1L: return "SgTypeCAFTeam_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCAFTeam(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCAFTeam(i);
        if (s.empty())
            s = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCAFTeam() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCAFTeam(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCAFTeam(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCAFTeam)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCAFTeam::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCAFTeam() {
        return stringify::E_SgTypeCAFTeam();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 228
namespace stringify {
    const char* E_SgTypeCrayPointer(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeCrayPointer_type_kind";
            case 1L: return "SgTypeCrayPointer_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeCrayPointer(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeCrayPointer(i);
        if (s.empty())
            s = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeCrayPointer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeCrayPointer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeCrayPointer(i);
        if (retval.empty()) {
            retval = "(E_SgTypeCrayPointer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeCrayPointer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeCrayPointer() {
        return stringify::E_SgTypeCrayPointer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 231
namespace stringify {
    const char* E_SgTypeLabel(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeLabel_type_kind";
            case 1L: return "SgTypeLabel_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeLabel(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeLabel(i);
        if (s.empty())
            s = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeLabel() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeLabel(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeLabel(i);
        if (retval.empty()) {
            retval = "(E_SgTypeLabel)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeLabel::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeLabel() {
        return stringify::E_SgTypeLabel();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 234
namespace stringify {
    const char* E_SgJavaUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnionType_type_kind";
            default: return "";
        }
    }

    std::string E_SgJavaUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnionType(i);
        if (s.empty())
            s = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnionType() {
        return stringify::E_SgJavaUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 237
namespace stringify {
    const char* E_SgRvalueReferenceType(int64_t i) {
        switch (i) {
            case 0L: return "SgRvalueReferenceType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRvalueReferenceType(int64_t i, const std::string &strip) {
        std::string s = E_SgRvalueReferenceType(i);
        if (s.empty())
            s = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRvalueReferenceType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRvalueReferenceType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRvalueReferenceType(i);
        if (retval.empty()) {
            retval = "(E_SgRvalueReferenceType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRvalueReferenceType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRvalueReferenceType() {
        return stringify::E_SgRvalueReferenceType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 240
namespace stringify {
    const char* E_SgTypeNullptr(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeNullptr_type_kind";
            case 1L: return "SgTypeNullptr_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeNullptr(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeNullptr(i);
        if (s.empty())
            s = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeNullptr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeNullptr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeNullptr(i);
        if (retval.empty()) {
            retval = "(E_SgTypeNullptr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeNullptr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeNullptr() {
        return stringify::E_SgTypeNullptr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 243
namespace stringify {
    const char* E_SgDeclType(int64_t i) {
        switch (i) {
            case 0L: return "SgDeclType_type_kind";
            default: return "";
        }
    }

    std::string E_SgDeclType(int64_t i, const std::string &strip) {
        std::string s = E_SgDeclType(i);
        if (s.empty())
            s = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeclType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeclType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeclType(i);
        if (retval.empty()) {
            retval = "(E_SgDeclType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeclType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeclType() {
        return stringify::E_SgDeclType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 246
namespace stringify {
    const char* E_SgTypeOfType(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeOfType_type_kind";
            default: return "";
        }
    }

    std::string E_SgTypeOfType(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeOfType(i);
        if (s.empty())
            s = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeOfType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeOfType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeOfType(i);
        if (retval.empty()) {
            retval = "(E_SgTypeOfType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeOfType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeOfType() {
        return stringify::E_SgTypeOfType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 249
namespace stringify {
    const char* E_SgTypeMatrix(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeMatrix_type_kind";
            case 1L: return "SgTypeMatrix_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeMatrix(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeMatrix(i);
        if (s.empty())
            s = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeMatrix() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeMatrix(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeMatrix(i);
        if (retval.empty()) {
            retval = "(E_SgTypeMatrix)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeMatrix::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeMatrix() {
        return stringify::E_SgTypeMatrix();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 252
namespace stringify {
    const char* E_SgTypeTuple(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeTuple_type_kind";
            case 1L: return "SgTypeTuple_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeTuple(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeTuple(i);
        if (s.empty())
            s = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeTuple() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeTuple(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeTuple(i);
        if (retval.empty()) {
            retval = "(E_SgTypeTuple)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeTuple::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeTuple() {
        return stringify::E_SgTypeTuple();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 255
namespace stringify {
    const char* E_SgTypeChar16(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar16_type_kind";
            case 1L: return "SgTypeChar16_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar16(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar16(i);
        if (s.empty())
            s = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar16() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar16(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar16(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar16)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar16::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar16() {
        return stringify::E_SgTypeChar16();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 258
namespace stringify {
    const char* E_SgTypeChar32(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeChar32_type_kind";
            case 1L: return "SgTypeChar32_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeChar32(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeChar32(i);
        if (s.empty())
            s = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeChar32() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeChar32(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeChar32(i);
        if (retval.empty()) {
            retval = "(E_SgTypeChar32)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeChar32::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeChar32() {
        return stringify::E_SgTypeChar32();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 261
namespace stringify {
    const char* E_SgTypeFloat128(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFloat128_type_kind";
            case 1L: return "SgTypeFloat128_builtin_type";
            default: return "";
        }
    }

    std::string E_SgTypeFloat128(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFloat128(i);
        if (s.empty())
            s = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFloat128() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFloat128(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFloat128(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFloat128)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFloat128::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFloat128() {
        return stringify::E_SgTypeFloat128();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 264
namespace stringify {
    const char* E_SgTypeFixed(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeFixed_type_kind";
            case 1L: return "SgTypeFixed_scale";
            case 2L: return "SgTypeFixed_fraction";
            default: return "";
        }
    }

    std::string E_SgTypeFixed(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeFixed(i);
        if (s.empty())
            s = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeFixed() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeFixed(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeFixed(i);
        if (retval.empty()) {
            retval = "(E_SgTypeFixed)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeFixed::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeFixed() {
        return stringify::E_SgTypeFixed();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 267
namespace stringify {
    const char* E_SgAutoType(int64_t i) {
        switch (i) {
            case 0L: return "SgAutoType_type_kind";
            default: return "";
        }
    }

    std::string E_SgAutoType(int64_t i, const std::string &strip) {
        std::string s = E_SgAutoType(i);
        if (s.empty())
            s = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAutoType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAutoType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAutoType(i);
        if (retval.empty()) {
            retval = "(E_SgAutoType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAutoType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAutoType() {
        return stringify::E_SgAutoType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 270
namespace stringify {
    const char* E_SgAdaAccessType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAccessType_type_kind";
            case 1L: return "SgAdaAccessType_base_type";
            default: return "";
        }
    }

    std::string E_SgAdaAccessType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAccessType(i);
        if (s.empty())
            s = "(E_SgAdaAccessType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAccessType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAccessType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAccessType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAccessType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAccessType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAccessType() {
        return stringify::E_SgAdaAccessType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 273
namespace stringify {
    const char* E_SgAdaSubtype(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSubtype_type_kind";
            case 1L: return "SgAdaSubtype_base_type";
            case 2L: return "SgAdaSubtype_constraint";
            default: return "";
        }
    }

    std::string E_SgAdaSubtype(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSubtype(i);
        if (s.empty())
            s = "(E_SgAdaSubtype)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSubtype() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSubtype(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSubtype(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSubtype)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSubtype::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSubtype() {
        return stringify::E_SgAdaSubtype();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 276
namespace stringify {
    const char* E_SgAdaDiscreteType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscreteType_type_kind";
            case 1L: return "SgAdaDiscreteType_builtin_type";
            default: return "";
        }
    }

    std::string E_SgAdaDiscreteType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscreteType(i);
        if (s.empty())
            s = "(E_SgAdaDiscreteType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscreteType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscreteType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscreteType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscreteType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscreteType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscreteType() {
        return stringify::E_SgAdaDiscreteType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 279
namespace stringify {
    const char* E_SgAdaModularType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaModularType_type_kind";
            case 1L: return "SgAdaModularType_modexpr";
            default: return "";
        }
    }

    std::string E_SgAdaModularType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaModularType(i);
        if (s.empty())
            s = "(E_SgAdaModularType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaModularType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaModularType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaModularType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaModularType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaModularType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaModularType() {
        return stringify::E_SgAdaModularType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 282
namespace stringify {
    const char* E_SgAdaDerivedType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDerivedType_type_kind";
            case 1L: return "SgAdaDerivedType_base_type";
            default: return "";
        }
    }

    std::string E_SgAdaDerivedType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDerivedType(i);
        if (s.empty())
            s = "(E_SgAdaDerivedType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDerivedType() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDerivedType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDerivedType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDerivedType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDerivedType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDerivedType() {
        return stringify::E_SgAdaDerivedType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 285
namespace stringify {
    const char* E_SgAdaSubroutineType(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSubroutineType_type_kind";
            case 1L: return "SgAdaSubroutineType_parameterList";
            case 2L: return "SgAdaSubroutineType_return_type";
            default: return "";
        }
    }

    std::string E_SgAdaSubroutineType(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSubroutineType(i);
        if (s.empty())
            s = "(E_SgAdaSubroutineType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSubroutineType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSubroutineType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSubroutineType(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSubroutineType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSubroutineType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSubroutineType() {
        return stringify::E_SgAdaSubroutineType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 288
namespace stringify {
    const char* E_SgJovialBitType(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialBitType_type_kind";
            default: return "";
        }
    }

    std::string E_SgJovialBitType(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialBitType(i);
        if (s.empty())
            s = "(E_SgJovialBitType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialBitType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialBitType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialBitType(i);
        if (retval.empty()) {
            retval = "(E_SgJovialBitType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialBitType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialBitType() {
        return stringify::E_SgJovialBitType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 291
namespace stringify {
    const char* E_SgRangeType(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeType_type_kind";
            default: return "";
        }
    }

    std::string E_SgRangeType(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeType(i);
        if (s.empty())
            s = "(E_SgRangeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeType(i);
        if (retval.empty()) {
            retval = "(E_SgRangeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeType() {
        return stringify::E_SgRangeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 294
namespace stringify {
    const char* E_SgType(int64_t i) {
        switch (i) {
            case 0L: return "SgType_type_kind";
            default: return "";
        }
    }

    std::string E_SgType(int64_t i, const std::string &strip) {
        std::string s = E_SgType(i);
        if (s.empty())
            s = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgType(i);
        if (retval.empty()) {
            retval = "(E_SgType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgType() {
        return stringify::E_SgType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 297
namespace stringify {
    const char* E_SgCommonBlockObject(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlockObject_variable_reference_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlockObject(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlockObject(i);
        if (s.empty())
            s = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlockObject() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlockObject(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlockObject(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlockObject)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlockObject::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlockObject() {
        return stringify::E_SgCommonBlockObject();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 300
namespace stringify {
    const char* E_SgInitializedName(int64_t i) {
        switch (i) {
            case 0L: return "SgInitializedName_initptr";
            default: return "";
        }
    }

    std::string E_SgInitializedName(int64_t i, const std::string &strip) {
        std::string s = E_SgInitializedName(i);
        if (s.empty())
            s = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInitializedName() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInitializedName(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInitializedName(i);
        if (retval.empty()) {
            retval = "(E_SgInitializedName)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInitializedName::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInitializedName() {
        return stringify::E_SgInitializedName();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 303
namespace stringify {
    const char* E_SgJavaMemberValuePair(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaMemberValuePair_value";
            default: return "";
        }
    }

    std::string E_SgJavaMemberValuePair(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaMemberValuePair(i);
        if (s.empty())
            s = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaMemberValuePair() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaMemberValuePair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaMemberValuePair(i);
        if (retval.empty()) {
            retval = "(E_SgJavaMemberValuePair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaMemberValuePair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaMemberValuePair() {
        return stringify::E_SgJavaMemberValuePair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 306
namespace stringify {
    const char* E_SgOmpOrderedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedClause(i);
        if (s.empty())
            s = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedClause() {
        return stringify::E_SgOmpOrderedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 309
namespace stringify {
    const char* E_SgOmpCollapseClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCollapseClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpCollapseClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCollapseClause(i);
        if (s.empty())
            s = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCollapseClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCollapseClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCollapseClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCollapseClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCollapseClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCollapseClause() {
        return stringify::E_SgOmpCollapseClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 312
namespace stringify {
    const char* E_SgOmpIfClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpIfClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpIfClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpIfClause(i);
        if (s.empty())
            s = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpIfClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpIfClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpIfClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpIfClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpIfClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpIfClause() {
        return stringify::E_SgOmpIfClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 315
namespace stringify {
    const char* E_SgOmpNumThreadsClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpNumThreadsClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpNumThreadsClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpNumThreadsClause(i);
        if (s.empty())
            s = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpNumThreadsClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpNumThreadsClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpNumThreadsClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpNumThreadsClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpNumThreadsClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpNumThreadsClause() {
        return stringify::E_SgOmpNumThreadsClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 318
namespace stringify {
    const char* E_SgOmpDeviceClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeviceClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpDeviceClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeviceClause(i);
        if (s.empty())
            s = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeviceClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeviceClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeviceClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeviceClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeviceClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeviceClause() {
        return stringify::E_SgOmpDeviceClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 321
namespace stringify {
    const char* E_SgOmpSafelenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSafelenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSafelenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSafelenClause(i);
        if (s.empty())
            s = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSafelenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSafelenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSafelenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSafelenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSafelenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSafelenClause() {
        return stringify::E_SgOmpSafelenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 324
namespace stringify {
    const char* E_SgOmpSimdlenClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdlenClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpSimdlenClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdlenClause(i);
        if (s.empty())
            s = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdlenClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdlenClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdlenClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdlenClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdlenClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdlenClause() {
        return stringify::E_SgOmpSimdlenClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 327
namespace stringify {
    const char* E_SgOmpFinalClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFinalClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpFinalClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFinalClause(i);
        if (s.empty())
            s = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFinalClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFinalClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFinalClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFinalClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFinalClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFinalClause() {
        return stringify::E_SgOmpFinalClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 330
namespace stringify {
    const char* E_SgOmpPriorityClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPriorityClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpPriorityClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPriorityClause(i);
        if (s.empty())
            s = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPriorityClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPriorityClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPriorityClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPriorityClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPriorityClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPriorityClause() {
        return stringify::E_SgOmpPriorityClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 333
namespace stringify {
    const char* E_SgOmpExpressionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpExpressionClause_expression";
            default: return "";
        }
    }

    std::string E_SgOmpExpressionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpExpressionClause(i);
        if (s.empty())
            s = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpExpressionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpExpressionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpExpressionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpExpressionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpExpressionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpExpressionClause() {
        return stringify::E_SgOmpExpressionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 336
namespace stringify {
    const char* E_SgOmpCopyprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyprivateClause() {
        return stringify::E_SgOmpCopyprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 339
namespace stringify {
    const char* E_SgOmpPrivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpPrivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpPrivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpPrivateClause(i);
        if (s.empty())
            s = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpPrivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpPrivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpPrivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpPrivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpPrivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpPrivateClause() {
        return stringify::E_SgOmpPrivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 342
namespace stringify {
    const char* E_SgOmpFirstprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFirstprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFirstprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFirstprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFirstprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFirstprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFirstprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFirstprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFirstprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFirstprivateClause() {
        return stringify::E_SgOmpFirstprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 345
namespace stringify {
    const char* E_SgOmpSharedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSharedClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpSharedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSharedClause(i);
        if (s.empty())
            s = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSharedClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSharedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSharedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSharedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSharedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSharedClause() {
        return stringify::E_SgOmpSharedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 348
namespace stringify {
    const char* E_SgOmpCopyinClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCopyinClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpCopyinClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCopyinClause(i);
        if (s.empty())
            s = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCopyinClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCopyinClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCopyinClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCopyinClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCopyinClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCopyinClause() {
        return stringify::E_SgOmpCopyinClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 351
namespace stringify {
    const char* E_SgOmpLastprivateClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLastprivateClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpLastprivateClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLastprivateClause(i);
        if (s.empty())
            s = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLastprivateClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLastprivateClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLastprivateClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLastprivateClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLastprivateClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLastprivateClause() {
        return stringify::E_SgOmpLastprivateClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 354
namespace stringify {
    const char* E_SgOmpReductionClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpReductionClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpReductionClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpReductionClause(i);
        if (s.empty())
            s = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpReductionClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpReductionClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpReductionClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpReductionClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpReductionClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpReductionClause() {
        return stringify::E_SgOmpReductionClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 357
namespace stringify {
    const char* E_SgOmpMapClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMapClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpMapClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMapClause(i);
        if (s.empty())
            s = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMapClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMapClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMapClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMapClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMapClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMapClause() {
        return stringify::E_SgOmpMapClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 360
namespace stringify {
    const char* E_SgOmpUniformClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpUniformClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpUniformClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpUniformClause(i);
        if (s.empty())
            s = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpUniformClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpUniformClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpUniformClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpUniformClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpUniformClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpUniformClause() {
        return stringify::E_SgOmpUniformClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 363
namespace stringify {
    const char* E_SgOmpAlignedClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAlignedClause_variables";
            case 1L: return "SgOmpAlignedClause_alignment";
            default: return "";
        }
    }

    std::string E_SgOmpAlignedClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAlignedClause(i);
        if (s.empty())
            s = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAlignedClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAlignedClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAlignedClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAlignedClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAlignedClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAlignedClause() {
        return stringify::E_SgOmpAlignedClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 366
namespace stringify {
    const char* E_SgOmpLinearClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpLinearClause_variables";
            case 1L: return "SgOmpLinearClause_step";
            default: return "";
        }
    }

    std::string E_SgOmpLinearClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpLinearClause(i);
        if (s.empty())
            s = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpLinearClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpLinearClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpLinearClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpLinearClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpLinearClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpLinearClause() {
        return stringify::E_SgOmpLinearClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 369
namespace stringify {
    const char* E_SgOmpDependClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDependClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpDependClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDependClause(i);
        if (s.empty())
            s = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDependClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDependClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDependClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDependClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDependClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDependClause() {
        return stringify::E_SgOmpDependClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 372
namespace stringify {
    const char* E_SgOmpVariablesClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpVariablesClause_variables";
            default: return "";
        }
    }

    std::string E_SgOmpVariablesClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpVariablesClause(i);
        if (s.empty())
            s = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpVariablesClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpVariablesClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpVariablesClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpVariablesClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpVariablesClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpVariablesClause() {
        return stringify::E_SgOmpVariablesClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 375
namespace stringify {
    const char* E_SgOmpScheduleClause(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpScheduleClause_chunk_size";
            default: return "";
        }
    }

    std::string E_SgOmpScheduleClause(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpScheduleClause(i);
        if (s.empty())
            s = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpScheduleClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpScheduleClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpScheduleClause(i);
        if (retval.empty()) {
            retval = "(E_SgOmpScheduleClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpScheduleClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpScheduleClause() {
        return stringify::E_SgOmpScheduleClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 378
namespace stringify {
    const char* E_SgLambdaCapture(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCapture_capture_variable";
            case 1L: return "SgLambdaCapture_source_closure_variable";
            case 2L: return "SgLambdaCapture_closure_variable";
            default: return "";
        }
    }

    std::string E_SgLambdaCapture(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCapture(i);
        if (s.empty())
            s = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCapture() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCapture(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCapture(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCapture)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCapture::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCapture() {
        return stringify::E_SgLambdaCapture();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 381
namespace stringify {
    const char* E_SgLambdaCaptureList(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaCaptureList_capture_list";
            default: return "";
        }
    }

    std::string E_SgLambdaCaptureList(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaCaptureList(i);
        if (s.empty())
            s = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaCaptureList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaCaptureList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaCaptureList(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaCaptureList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaCaptureList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaCaptureList() {
        return stringify::E_SgLambdaCaptureList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 384
namespace stringify {
    const char* E_SgAdaRangeConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRangeConstraint_range";
            default: return "";
        }
    }

    std::string E_SgAdaRangeConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRangeConstraint(i);
        if (s.empty())
            s = "(E_SgAdaRangeConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRangeConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRangeConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRangeConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRangeConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRangeConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRangeConstraint() {
        return stringify::E_SgAdaRangeConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 387
namespace stringify {
    const char* E_SgAdaIndexConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaIndexConstraint_indexRanges";
            default: return "";
        }
    }

    std::string E_SgAdaIndexConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaIndexConstraint(i);
        if (s.empty())
            s = "(E_SgAdaIndexConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaIndexConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaIndexConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaIndexConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaIndexConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaIndexConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaIndexConstraint() {
        return stringify::E_SgAdaIndexConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 390
namespace stringify {
    const char* E_SgAdaDigitsConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDigitsConstraint_digits";
            case 1L: return "SgAdaDigitsConstraint_subConstraint";
            default: return "";
        }
    }

    std::string E_SgAdaDigitsConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDigitsConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDigitsConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDigitsConstraint() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDigitsConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDigitsConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDigitsConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDigitsConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDigitsConstraint() {
        return stringify::E_SgAdaDigitsConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 393
namespace stringify {
    const char* E_SgAdaDeltaConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDeltaConstraint_delta";
            case 1L: return "SgAdaDeltaConstraint_subConstraint";
            default: return "";
        }
    }

    std::string E_SgAdaDeltaConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDeltaConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDeltaConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDeltaConstraint() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDeltaConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDeltaConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDeltaConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDeltaConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDeltaConstraint() {
        return stringify::E_SgAdaDeltaConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 396
namespace stringify {
    const char* E_SgAdaDiscriminantConstraint(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminantConstraint_discriminants";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminantConstraint(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminantConstraint(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminantConstraint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminantConstraint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminantConstraint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminantConstraint(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminantConstraint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminantConstraint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminantConstraint() {
        return stringify::E_SgAdaDiscriminantConstraint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 399
namespace stringify {
    const char* E_SgGlobal(int64_t i) {
        switch (i) {
            case 0L: return "SgGlobal_declarations";
            default: return "";
        }
    }

    std::string E_SgGlobal(int64_t i, const std::string &strip) {
        std::string s = E_SgGlobal(i);
        if (s.empty())
            s = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGlobal() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGlobal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGlobal(i);
        if (retval.empty()) {
            retval = "(E_SgGlobal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGlobal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGlobal() {
        return stringify::E_SgGlobal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 402
namespace stringify {
    const char* E_SgBasicBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgBasicBlock_statements";
            default: return "";
        }
    }

    std::string E_SgBasicBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgBasicBlock(i);
        if (s.empty())
            s = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBasicBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBasicBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBasicBlock(i);
        if (retval.empty()) {
            retval = "(E_SgBasicBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBasicBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBasicBlock() {
        return stringify::E_SgBasicBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 405
namespace stringify {
    const char* E_SgIfStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgIfStmt_conditional";
            case 1L: return "SgIfStmt_true_body";
            case 2L: return "SgIfStmt_false_body";
            default: return "";
        }
    }

    std::string E_SgIfStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgIfStmt(i);
        if (s.empty())
            s = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIfStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIfStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIfStmt(i);
        if (retval.empty()) {
            retval = "(E_SgIfStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIfStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIfStmt() {
        return stringify::E_SgIfStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 408
namespace stringify {
    const char* E_SgForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForStatement_for_init_stmt";
            case 1L: return "SgForStatement_test";
            case 2L: return "SgForStatement_increment";
            case 3L: return "SgForStatement_loop_body";
            case 4L: return "SgForStatement_else_body";
            default: return "";
        }
    }

    std::string E_SgForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForStatement(i);
        if (s.empty())
            s = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForStatement() {
        return stringify::E_SgForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 411
namespace stringify {
    const char* E_SgTemplateFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDefinition() {
        return stringify::E_SgTemplateFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 414
namespace stringify {
    const char* E_SgFunctionDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDefinition_body";
            default: return "";
        }
    }

    std::string E_SgFunctionDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDefinition(i);
        if (s.empty())
            s = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDefinition() {
        return stringify::E_SgFunctionDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 417
namespace stringify {
    const char* E_SgTemplateInstantiationDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDefn_members";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDefn(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDefn(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDefn() {
        return stringify::E_SgTemplateInstantiationDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 420
namespace stringify {
    const char* E_SgTemplateClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDefinition(i);
        if (s.empty())
            s = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDefinition() {
        return stringify::E_SgTemplateClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 423
namespace stringify {
    const char* E_SgClassDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDefinition_members";
            default: return "";
        }
    }

    std::string E_SgClassDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDefinition(i);
        if (s.empty())
            s = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDefinition() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgClassDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDefinition() {
        return stringify::E_SgClassDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 426
namespace stringify {
    const char* E_SgWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhileStmt_condition";
            case 1L: return "SgWhileStmt_body";
            case 2L: return "SgWhileStmt_else_body";
            default: return "";
        }
    }

    std::string E_SgWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhileStmt(i);
        if (s.empty())
            s = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhileStmt() {
        return stringify::E_SgWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 429
namespace stringify {
    const char* E_SgDoWhileStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDoWhileStmt_body";
            case 1L: return "SgDoWhileStmt_condition";
            default: return "";
        }
    }

    std::string E_SgDoWhileStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDoWhileStmt(i);
        if (s.empty())
            s = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDoWhileStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDoWhileStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDoWhileStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDoWhileStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDoWhileStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDoWhileStmt() {
        return stringify::E_SgDoWhileStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 432
namespace stringify {
    const char* E_SgSwitchStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSwitchStatement_item_selector";
            case 1L: return "SgSwitchStatement_body";
            default: return "";
        }
    }

    std::string E_SgSwitchStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSwitchStatement(i);
        if (s.empty())
            s = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSwitchStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSwitchStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSwitchStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSwitchStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSwitchStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSwitchStatement() {
        return stringify::E_SgSwitchStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 435
namespace stringify {
    const char* E_SgCatchOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchOptionStmt_condition";
            case 1L: return "SgCatchOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgCatchOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchOptionStmt(i);
        if (s.empty())
            s = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCatchOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchOptionStmt() {
        return stringify::E_SgCatchOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 438
namespace stringify {
    const char* E_SgNamespaceDefinitionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDefinitionStatement_declarations";
            default: return "";
        }
    }

    std::string E_SgNamespaceDefinitionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDefinitionStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDefinitionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDefinitionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDefinitionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDefinitionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDefinitionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDefinitionStatement() {
        return stringify::E_SgNamespaceDefinitionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 441
namespace stringify {
    const char* E_SgAssociateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssociateStatement_body";
            default: return "";
        }
    }

    std::string E_SgAssociateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssociateStatement(i);
        if (s.empty())
            s = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssociateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssociateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssociateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssociateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssociateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssociateStatement() {
        return stringify::E_SgAssociateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 444
namespace stringify {
    const char* E_SgFortranNonblockedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranNonblockedDo_initialization";
            case 1L: return "SgFortranNonblockedDo_bound";
            case 2L: return "SgFortranNonblockedDo_increment";
            case 3L: return "SgFortranNonblockedDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranNonblockedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranNonblockedDo(i);
        if (s.empty())
            s = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranNonblockedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranNonblockedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranNonblockedDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranNonblockedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranNonblockedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranNonblockedDo() {
        return stringify::E_SgFortranNonblockedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 447
namespace stringify {
    const char* E_SgFortranDo(int64_t i) {
        switch (i) {
            case 0L: return "SgFortranDo_initialization";
            case 1L: return "SgFortranDo_bound";
            case 2L: return "SgFortranDo_increment";
            case 3L: return "SgFortranDo_body";
            default: return "";
        }
    }

    std::string E_SgFortranDo(int64_t i, const std::string &strip) {
        std::string s = E_SgFortranDo(i);
        if (s.empty())
            s = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFortranDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFortranDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFortranDo(i);
        if (retval.empty()) {
            retval = "(E_SgFortranDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFortranDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFortranDo() {
        return stringify::E_SgFortranDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 450
namespace stringify {
    const char* E_SgForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForAllStatement_forall_header";
            case 1L: return "SgForAllStatement_body";
            default: return "";
        }
    }

    std::string E_SgForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForAllStatement(i);
        if (s.empty())
            s = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForAllStatement() {
        return stringify::E_SgForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 453
namespace stringify {
    const char* E_SgUpcForAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcForAllStatement_for_init_stmt";
            case 1L: return "SgUpcForAllStatement_test";
            case 2L: return "SgUpcForAllStatement_increment";
            case 3L: return "SgUpcForAllStatement_affinity";
            case 4L: return "SgUpcForAllStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgUpcForAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcForAllStatement(i);
        if (s.empty())
            s = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcForAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcForAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcForAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcForAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcForAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcForAllStatement() {
        return stringify::E_SgUpcForAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 456
namespace stringify {
    const char* E_SgCAFWithTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFWithTeamStatement_body";
            default: return "";
        }
    }

    std::string E_SgCAFWithTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFWithTeamStatement(i);
        if (s.empty())
            s = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFWithTeamStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFWithTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFWithTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCAFWithTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFWithTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFWithTeamStatement() {
        return stringify::E_SgCAFWithTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 459
namespace stringify {
    const char* E_SgJavaForEachStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaForEachStatement_element";
            case 1L: return "SgJavaForEachStatement_collection";
            case 2L: return "SgJavaForEachStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJavaForEachStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaForEachStatement(i);
        if (s.empty())
            s = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaForEachStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaForEachStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaForEachStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaForEachStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaForEachStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaForEachStatement() {
        return stringify::E_SgJavaForEachStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 462
namespace stringify {
    const char* E_SgJavaLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgJavaLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelStatement(i);
        if (s.empty())
            s = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelStatement() {
        return stringify::E_SgJavaLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 465
namespace stringify {
    const char* E_SgMatlabForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgMatlabForStatement_index";
            case 1L: return "SgMatlabForStatement_range";
            case 2L: return "SgMatlabForStatement_body";
            default: return "";
        }
    }

    std::string E_SgMatlabForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgMatlabForStatement(i);
        if (s.empty())
            s = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatlabForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatlabForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatlabForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgMatlabForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatlabForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatlabForStatement() {
        return stringify::E_SgMatlabForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 468
namespace stringify {
    const char* E_SgFunctionParameterScope(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterScope_declarations";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterScope(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterScope(i);
        if (s.empty())
            s = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterScope() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterScope(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterScope(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterScope)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterScope::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterScope() {
        return stringify::E_SgFunctionParameterScope();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 471
namespace stringify {
    const char* E_SgRangeBasedForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeBasedForStatement_iterator_declaration";
            case 1L: return "SgRangeBasedForStatement_range_declaration";
            case 2L: return "SgRangeBasedForStatement_begin_declaration";
            case 3L: return "SgRangeBasedForStatement_end_declaration";
            case 4L: return "SgRangeBasedForStatement_not_equal_expression";
            case 5L: return "SgRangeBasedForStatement_increment_expression";
            case 6L: return "SgRangeBasedForStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgRangeBasedForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeBasedForStatement(i);
        if (s.empty())
            s = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeBasedForStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeBasedForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeBasedForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRangeBasedForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeBasedForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeBasedForStatement() {
        return stringify::E_SgRangeBasedForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 474
namespace stringify {
    const char* E_SgJovialForThenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialForThenStatement_initialization";
            case 1L: return "SgJovialForThenStatement_while_expression";
            case 2L: return "SgJovialForThenStatement_by_or_then_expression";
            case 3L: return "SgJovialForThenStatement_loop_body";
            default: return "";
        }
    }

    std::string E_SgJovialForThenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialForThenStatement(i);
        if (s.empty())
            s = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialForThenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialForThenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialForThenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialForThenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialForThenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialForThenStatement() {
        return stringify::E_SgJovialForThenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 477
namespace stringify {
    const char* E_SgAdaAcceptStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAcceptStmt_parameterList";
            case 1L: return "SgAdaAcceptStmt_entry";
            case 2L: return "SgAdaAcceptStmt_index";
            case 3L: return "SgAdaAcceptStmt_body";
            default: return "";
        }
    }

    std::string E_SgAdaAcceptStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAcceptStmt(i);
        if (s.empty())
            s = "(E_SgAdaAcceptStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAcceptStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAcceptStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAcceptStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAcceptStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAcceptStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAcceptStmt() {
        return stringify::E_SgAdaAcceptStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 480
namespace stringify {
    const char* E_SgAdaPackageSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSpec(i);
        if (s.empty())
            s = "(E_SgAdaPackageSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSpec() {
        return stringify::E_SgAdaPackageSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 483
namespace stringify {
    const char* E_SgAdaPackageBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaPackageBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageBody(i);
        if (s.empty())
            s = "(E_SgAdaPackageBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageBody() {
        return stringify::E_SgAdaPackageBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 486
namespace stringify {
    const char* E_SgAdaTaskSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSpec(i);
        if (s.empty())
            s = "(E_SgAdaTaskSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSpec() {
        return stringify::E_SgAdaTaskSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 489
namespace stringify {
    const char* E_SgAdaTaskBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaTaskBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskBody(i);
        if (s.empty())
            s = "(E_SgAdaTaskBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskBody() {
        return stringify::E_SgAdaTaskBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 492
namespace stringify {
    const char* E_SgAdaProtectedBody(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedBody_statements";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedBody(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedBody(i);
        if (s.empty())
            s = "(E_SgAdaProtectedBody)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedBody() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedBody(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedBody(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedBody)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedBody::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedBody() {
        return stringify::E_SgAdaProtectedBody();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 495
namespace stringify {
    const char* E_SgAdaProtectedSpec(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSpec_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSpec(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSpec(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSpec)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSpec() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSpec(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSpec(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSpec)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSpec::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSpec() {
        return stringify::E_SgAdaProtectedSpec();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 498
namespace stringify {
    const char* E_SgAdaGenericDefn(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericDefn_declarations";
            default: return "";
        }
    }

    std::string E_SgAdaGenericDefn(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericDefn(i);
        if (s.empty())
            s = "(E_SgAdaGenericDefn)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericDefn() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericDefn(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericDefn(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericDefn)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericDefn::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericDefn() {
        return stringify::E_SgAdaGenericDefn();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 501
namespace stringify {
    const char* E_SgFunctionParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterList_args";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterList(i);
        if (s.empty())
            s = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterList() {
        return stringify::E_SgFunctionParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 504
namespace stringify {
    const char* E_SgTemplateVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgTemplateVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgTemplateVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateVariableDeclaration() {
        return stringify::E_SgTemplateVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 507
namespace stringify {
    const char* E_SgVariableDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDeclaration_baseTypeDefiningDeclaration";
            case 1L: return "SgVariableDeclaration_variables";
            default: return "";
        }
    }

    std::string E_SgVariableDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDeclaration(i);
        if (s.empty())
            s = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDeclaration() {
        return stringify::E_SgVariableDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 510
namespace stringify {
    const char* E_SgVariableDefinition(int64_t i) {
        switch (i) {
            case 0L: return "SgVariableDefinition_vardefn";
            case 1L: return "SgVariableDefinition_bitfield";
            default: return "";
        }
    }

    std::string E_SgVariableDefinition(int64_t i, const std::string &strip) {
        std::string s = E_SgVariableDefinition(i);
        if (s.empty())
            s = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVariableDefinition() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVariableDefinition(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVariableDefinition(i);
        if (retval.empty()) {
            retval = "(E_SgVariableDefinition)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVariableDefinition::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVariableDefinition() {
        return stringify::E_SgVariableDefinition();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 513
namespace stringify {
    const char* E_SgEnumDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumDeclaration_enumerators";
            default: return "";
        }
    }

    std::string E_SgEnumDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumDeclaration(i);
        if (s.empty())
            s = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgEnumDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumDeclaration() {
        return stringify::E_SgEnumDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 516
namespace stringify {
    const char* E_SgAsmStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmStmt_operands";
            default: return "";
        }
    }

    std::string E_SgAsmStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmStmt(i);
        if (s.empty())
            s = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsmStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmStmt() {
        return stringify::E_SgAsmStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 519
namespace stringify {
    const char* E_SgTemplateInstantiationDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDirectiveStatement_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDirectiveStatement() {
        return stringify::E_SgTemplateInstantiationDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 522
namespace stringify {
    const char* E_SgUseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUseStatement_rename_list";
            default: return "";
        }
    }

    std::string E_SgUseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUseStatement(i);
        if (s.empty())
            s = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUseStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUseStatement() {
        return stringify::E_SgUseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 525
namespace stringify {
    const char* E_SgNamespaceDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceDeclarationStatement_definition";
            default: return "";
        }
    }

    std::string E_SgNamespaceDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceDeclarationStatement() {
        return stringify::E_SgNamespaceDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 528
namespace stringify {
    const char* E_SgInterfaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInterfaceStatement_interface_body_list";
            default: return "";
        }
    }

    std::string E_SgInterfaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInterfaceStatement(i);
        if (s.empty())
            s = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInterfaceStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInterfaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInterfaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInterfaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInterfaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInterfaceStatement() {
        return stringify::E_SgInterfaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 531
namespace stringify {
    const char* E_SgCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgCommonBlock_block_list";
            default: return "";
        }
    }

    std::string E_SgCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgCommonBlock(i);
        if (s.empty())
            s = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommonBlock() {
        return stringify::E_SgCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 534
namespace stringify {
    const char* E_SgTemplateTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefDeclaration() {
        return stringify::E_SgTemplateTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 537
namespace stringify {
    const char* E_SgTemplateInstantiationTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationTypedefDeclaration() {
        return stringify::E_SgTemplateInstantiationTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 540
namespace stringify {
    const char* E_SgTypedefDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefDeclaration_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefDeclaration(i);
        if (s.empty())
            s = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefDeclaration() {
        return stringify::E_SgTypedefDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 543
namespace stringify {
    const char* E_SgStatementFunctionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementFunctionStatement_function";
            case 1L: return "SgStatementFunctionStatement_expression";
            default: return "";
        }
    }

    std::string E_SgStatementFunctionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementFunctionStatement(i);
        if (s.empty())
            s = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementFunctionStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementFunctionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementFunctionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStatementFunctionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementFunctionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementFunctionStatement() {
        return stringify::E_SgStatementFunctionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 546
namespace stringify {
    const char* E_SgCtorInitializerList(int64_t i) {
        switch (i) {
            case 0L: return "SgCtorInitializerList_ctors";
            default: return "";
        }
    }

    std::string E_SgCtorInitializerList(int64_t i, const std::string &strip) {
        std::string s = E_SgCtorInitializerList(i);
        if (s.empty())
            s = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCtorInitializerList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCtorInitializerList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCtorInitializerList(i);
        if (retval.empty()) {
            retval = "(E_SgCtorInitializerList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCtorInitializerList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCtorInitializerList() {
        return stringify::E_SgCtorInitializerList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 549
namespace stringify {
    const char* E_SgPragmaDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgPragmaDeclaration_pragma";
            default: return "";
        }
    }

    std::string E_SgPragmaDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgPragmaDeclaration(i);
        if (s.empty())
            s = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPragmaDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPragmaDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPragmaDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgPragmaDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPragmaDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPragmaDeclaration() {
        return stringify::E_SgPragmaDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 552
namespace stringify {
    const char* E_SgTemplateClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassDeclaration_definition";
            case 1L: return "SgTemplateClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassDeclaration() {
        return stringify::E_SgTemplateClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 555
namespace stringify {
    const char* E_SgTemplateInstantiationDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationDecl_definition";
            case 1L: return "SgTemplateInstantiationDecl_decoratorList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationDecl() {
        return stringify::E_SgTemplateInstantiationDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 558
namespace stringify {
    const char* E_SgDerivedTypeStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDerivedTypeStatement_definition";
            case 1L: return "SgDerivedTypeStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgDerivedTypeStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDerivedTypeStatement(i);
        if (s.empty())
            s = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDerivedTypeStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDerivedTypeStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDerivedTypeStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDerivedTypeStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDerivedTypeStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDerivedTypeStatement() {
        return stringify::E_SgDerivedTypeStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 561
namespace stringify {
    const char* E_SgModuleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleStatement_definition";
            case 1L: return "SgModuleStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgModuleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleStatement(i);
        if (s.empty())
            s = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgModuleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleStatement() {
        return stringify::E_SgModuleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 564
namespace stringify {
    const char* E_SgJavaPackageDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaPackageDeclaration_definition";
            case 1L: return "SgJavaPackageDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJavaPackageDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaPackageDeclaration(i);
        if (s.empty())
            s = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaPackageDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaPackageDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaPackageDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgJavaPackageDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaPackageDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaPackageDeclaration() {
        return stringify::E_SgJavaPackageDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 567
namespace stringify {
    const char* E_SgJovialTableStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTableStatement_definition";
            case 1L: return "SgJovialTableStatement_decoratorList";
            default: return "";
        }
    }

    std::string E_SgJovialTableStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTableStatement(i);
        if (s.empty())
            s = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTableStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTableStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTableStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTableStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTableStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTableStatement() {
        return stringify::E_SgJovialTableStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 570
namespace stringify {
    const char* E_SgClassDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgClassDeclaration_definition";
            case 1L: return "SgClassDeclaration_decoratorList";
            default: return "";
        }
    }

    std::string E_SgClassDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgClassDeclaration(i);
        if (s.empty())
            s = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgClassDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassDeclaration() {
        return stringify::E_SgClassDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 573
namespace stringify {
    const char* E_SgImplicitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImplicitStatement_variables";
            default: return "";
        }
    }

    std::string E_SgImplicitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImplicitStatement(i);
        if (s.empty())
            s = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImplicitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImplicitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImplicitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImplicitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImplicitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImplicitStatement() {
        return stringify::E_SgImplicitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 576
namespace stringify {
    const char* E_SgTemplateFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionDeclaration() {
        return stringify::E_SgTemplateFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 579
namespace stringify {
    const char* E_SgTemplateMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionDeclaration_parameterList";
            case 1L: return "SgTemplateMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgTemplateMemberFunctionDeclaration_definition";
            case 3L: return "SgTemplateMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionDeclaration() {
        return stringify::E_SgTemplateMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 582
namespace stringify {
    const char* E_SgTemplateInstantiationMemberFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationMemberFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationMemberFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationMemberFunctionDecl_definition";
            case 3L: return "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationMemberFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationMemberFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationMemberFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationMemberFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationMemberFunctionDecl() {
        return stringify::E_SgTemplateInstantiationMemberFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 585
namespace stringify {
    const char* E_SgMemberFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionDeclaration_parameterList";
            case 1L: return "SgMemberFunctionDeclaration_decoratorList";
            case 2L: return "SgMemberFunctionDeclaration_definition";
            case 3L: return "SgMemberFunctionDeclaration_CtorInitializerList";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionDeclaration() {
        return stringify::E_SgMemberFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 588
namespace stringify {
    const char* E_SgTemplateInstantiationFunctionDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateInstantiationFunctionDecl_parameterList";
            case 1L: return "SgTemplateInstantiationFunctionDecl_decoratorList";
            case 2L: return "SgTemplateInstantiationFunctionDecl_definition";
            default: return "";
        }
    }

    std::string E_SgTemplateInstantiationFunctionDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateInstantiationFunctionDecl(i);
        if (s.empty())
            s = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateInstantiationFunctionDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateInstantiationFunctionDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateInstantiationFunctionDecl(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateInstantiationFunctionDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateInstantiationFunctionDecl() {
        return stringify::E_SgTemplateInstantiationFunctionDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 591
namespace stringify {
    const char* E_SgProgramHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProgramHeaderStatement_parameterList";
            case 1L: return "SgProgramHeaderStatement_decoratorList";
            case 2L: return "SgProgramHeaderStatement_definition";
            default: return "";
        }
    }

    std::string E_SgProgramHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProgramHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProgramHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProgramHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProgramHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProgramHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProgramHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProgramHeaderStatement() {
        return stringify::E_SgProgramHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 594
namespace stringify {
    const char* E_SgProcedureHeaderStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcedureHeaderStatement_parameterList";
            case 1L: return "SgProcedureHeaderStatement_decoratorList";
            case 2L: return "SgProcedureHeaderStatement_definition";
            case 3L: return "SgProcedureHeaderStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgProcedureHeaderStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcedureHeaderStatement(i);
        if (s.empty())
            s = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcedureHeaderStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcedureHeaderStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcedureHeaderStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcedureHeaderStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcedureHeaderStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcedureHeaderStatement() {
        return stringify::E_SgProcedureHeaderStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 597
namespace stringify {
    const char* E_SgEntryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEntryStatement_parameterList";
            case 1L: return "SgEntryStatement_decoratorList";
            case 2L: return "SgEntryStatement_definition";
            case 3L: return "SgEntryStatement_result_name";
            default: return "";
        }
    }

    std::string E_SgEntryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEntryStatement(i);
        if (s.empty())
            s = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEntryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEntryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEntryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEntryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEntryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEntryStatement() {
        return stringify::E_SgEntryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 600
namespace stringify {
    const char* E_SgAdaEntryDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaEntryDecl_parameterList";
            case 1L: return "SgAdaEntryDecl_decoratorList";
            case 2L: return "SgAdaEntryDecl_definition";
            case 3L: return "SgAdaEntryDecl_entryIndex";
            case 4L: return "SgAdaEntryDecl_entryBarrier";
            default: return "";
        }
    }

    std::string E_SgAdaEntryDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaEntryDecl(i);
        if (s.empty())
            s = "(E_SgAdaEntryDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaEntryDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaEntryDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaEntryDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaEntryDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaEntryDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaEntryDecl() {
        return stringify::E_SgAdaEntryDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 603
namespace stringify {
    const char* E_SgAdaFunctionRenamingDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFunctionRenamingDecl_parameterList";
            case 1L: return "SgAdaFunctionRenamingDecl_decoratorList";
            case 2L: return "SgAdaFunctionRenamingDecl_definition";
            case 3L: return "SgAdaFunctionRenamingDecl_renamed_function";
            default: return "";
        }
    }

    std::string E_SgAdaFunctionRenamingDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFunctionRenamingDecl(i);
        if (s.empty())
            s = "(E_SgAdaFunctionRenamingDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFunctionRenamingDecl() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFunctionRenamingDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFunctionRenamingDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFunctionRenamingDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFunctionRenamingDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFunctionRenamingDecl() {
        return stringify::E_SgAdaFunctionRenamingDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 606
namespace stringify {
    const char* E_SgFunctionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionDeclaration_parameterList";
            case 1L: return "SgFunctionDeclaration_decoratorList";
            case 2L: return "SgFunctionDeclaration_definition";
            default: return "";
        }
    }

    std::string E_SgFunctionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionDeclaration(i);
        if (s.empty())
            s = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionDeclaration() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionDeclaration() {
        return stringify::E_SgFunctionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 609
namespace stringify {
    const char* E_SgIncludeDirectiveStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIncludeDirectiveStatement_headerFileBody";
            default: return "";
        }
    }

    std::string E_SgIncludeDirectiveStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIncludeDirectiveStatement(i);
        if (s.empty())
            s = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIncludeDirectiveStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIncludeDirectiveStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIncludeDirectiveStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIncludeDirectiveStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIncludeDirectiveStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIncludeDirectiveStatement() {
        return stringify::E_SgIncludeDirectiveStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 612
namespace stringify {
    const char* E_SgOmpThreadprivateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpThreadprivateStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpThreadprivateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpThreadprivateStatement(i);
        if (s.empty())
            s = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpThreadprivateStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpThreadprivateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpThreadprivateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpThreadprivateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpThreadprivateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpThreadprivateStatement() {
        return stringify::E_SgOmpThreadprivateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 615
namespace stringify {
    const char* E_SgStmtDeclarationStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgStmtDeclarationStatement_statement";
            default: return "";
        }
    }

    std::string E_SgStmtDeclarationStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgStmtDeclarationStatement(i);
        if (s.empty())
            s = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStmtDeclarationStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStmtDeclarationStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStmtDeclarationStatement(i);
        if (retval.empty()) {
            retval = "(E_SgStmtDeclarationStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStmtDeclarationStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStmtDeclarationStatement() {
        return stringify::E_SgStmtDeclarationStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 618
namespace stringify {
    const char* E_SgStaticAssertionDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgStaticAssertionDeclaration_condition";
            default: return "";
        }
    }

    std::string E_SgStaticAssertionDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgStaticAssertionDeclaration(i);
        if (s.empty())
            s = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStaticAssertionDeclaration() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStaticAssertionDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStaticAssertionDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgStaticAssertionDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStaticAssertionDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStaticAssertionDeclaration() {
        return stringify::E_SgStaticAssertionDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 621
namespace stringify {
    const char* E_SgOmpDeclareSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDeclareSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDeclareSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDeclareSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDeclareSimdStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDeclareSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDeclareSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDeclareSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDeclareSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDeclareSimdStatement() {
        return stringify::E_SgOmpDeclareSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 624
namespace stringify {
    const char* E_SgJovialOverlayDeclaration(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialOverlayDeclaration_address";
            case 1L: return "SgJovialOverlayDeclaration_overlay";
            default: return "";
        }
    }

    std::string E_SgJovialOverlayDeclaration(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialOverlayDeclaration(i);
        if (s.empty())
            s = "(E_SgJovialOverlayDeclaration)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialOverlayDeclaration() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialOverlayDeclaration(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialOverlayDeclaration(i);
        if (retval.empty()) {
            retval = "(E_SgJovialOverlayDeclaration)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialOverlayDeclaration::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialOverlayDeclaration() {
        return stringify::E_SgJovialOverlayDeclaration();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 627
namespace stringify {
    const char* E_SgAdaPackageBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaPackageBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaPackageBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageBodyDecl() {
        return stringify::E_SgAdaPackageBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 630
namespace stringify {
    const char* E_SgAdaPackageSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaPackageSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSpecDecl() {
        return stringify::E_SgAdaPackageSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 633
namespace stringify {
    const char* E_SgAdaRenamingDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRenamingDecl_renamed";
            default: return "";
        }
    }

    std::string E_SgAdaRenamingDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRenamingDecl(i);
        if (s.empty())
            s = "(E_SgAdaRenamingDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRenamingDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRenamingDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRenamingDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRenamingDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRenamingDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRenamingDecl() {
        return stringify::E_SgAdaRenamingDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 636
namespace stringify {
    const char* E_SgAdaTaskSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSpecDecl() {
        return stringify::E_SgAdaTaskSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 639
namespace stringify {
    const char* E_SgAdaTaskBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskBodyDecl() {
        return stringify::E_SgAdaTaskBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 642
namespace stringify {
    const char* E_SgAdaTaskTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskTypeDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaTaskTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaTaskTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskTypeDecl() {
        return stringify::E_SgAdaTaskTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 645
namespace stringify {
    const char* E_SgAdaProtectedSpecDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSpecDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSpecDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSpecDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSpecDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSpecDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSpecDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSpecDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSpecDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSpecDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSpecDecl() {
        return stringify::E_SgAdaProtectedSpecDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 648
namespace stringify {
    const char* E_SgAdaProtectedBodyDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedBodyDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedBodyDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedBodyDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedBodyDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedBodyDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedBodyDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedBodyDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedBodyDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedBodyDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedBodyDecl() {
        return stringify::E_SgAdaProtectedBodyDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 651
namespace stringify {
    const char* E_SgAdaProtectedTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedTypeDecl_definition";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaProtectedTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedTypeDecl() {
        return stringify::E_SgAdaProtectedTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 654
namespace stringify {
    const char* E_SgAdaRepresentationClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRepresentationClause_alignment";
            case 1L: return "SgAdaRepresentationClause_components";
            default: return "";
        }
    }

    std::string E_SgAdaRepresentationClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRepresentationClause(i);
        if (s.empty())
            s = "(E_SgAdaRepresentationClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRepresentationClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRepresentationClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRepresentationClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRepresentationClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRepresentationClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRepresentationClause() {
        return stringify::E_SgAdaRepresentationClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 657
namespace stringify {
    const char* E_SgAdaComponentClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaComponentClause_component";
            case 1L: return "SgAdaComponentClause_offset";
            case 2L: return "SgAdaComponentClause_range";
            default: return "";
        }
    }

    std::string E_SgAdaComponentClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaComponentClause(i);
        if (s.empty())
            s = "(E_SgAdaComponentClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaComponentClause() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaComponentClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaComponentClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaComponentClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaComponentClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaComponentClause() {
        return stringify::E_SgAdaComponentClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 660
namespace stringify {
    const char* E_SgAdaAttributeClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAttributeClause_attribute";
            case 1L: return "SgAdaAttributeClause_size";
            default: return "";
        }
    }

    std::string E_SgAdaAttributeClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAttributeClause(i);
        if (s.empty())
            s = "(E_SgAdaAttributeClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAttributeClause() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAttributeClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAttributeClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAttributeClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAttributeClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAttributeClause() {
        return stringify::E_SgAdaAttributeClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 663
namespace stringify {
    const char* E_SgAdaEnumRepresentationClause(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaEnumRepresentationClause_components";
            default: return "";
        }
    }

    std::string E_SgAdaEnumRepresentationClause(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaEnumRepresentationClause(i);
        if (s.empty())
            s = "(E_SgAdaEnumRepresentationClause)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaEnumRepresentationClause() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaEnumRepresentationClause(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaEnumRepresentationClause(i);
        if (retval.empty()) {
            retval = "(E_SgAdaEnumRepresentationClause)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaEnumRepresentationClause::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaEnumRepresentationClause() {
        return stringify::E_SgAdaEnumRepresentationClause();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 666
namespace stringify {
    const char* E_SgAdaGenericDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericDecl_definition";
            case 1L: return "SgAdaGenericDecl_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericDecl(i);
        if (s.empty())
            s = "(E_SgAdaGenericDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericDecl() {
        return stringify::E_SgAdaGenericDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 669
namespace stringify {
    const char* E_SgAdaFormalTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalTypeDecl_discriminants";
            default: return "";
        }
    }

    std::string E_SgAdaFormalTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaFormalTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalTypeDecl() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalTypeDecl() {
        return stringify::E_SgAdaFormalTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 672
namespace stringify {
    const char* E_SgAdaDiscriminatedTypeDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDiscriminatedTypeDecl_discriminants";
            case 1L: return "SgAdaDiscriminatedTypeDecl_discriminatedDecl";
            default: return "";
        }
    }

    std::string E_SgAdaDiscriminatedTypeDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDiscriminatedTypeDecl(i);
        if (s.empty())
            s = "(E_SgAdaDiscriminatedTypeDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDiscriminatedTypeDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDiscriminatedTypeDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDiscriminatedTypeDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDiscriminatedTypeDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDiscriminatedTypeDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDiscriminatedTypeDecl() {
        return stringify::E_SgAdaDiscriminatedTypeDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 675
namespace stringify {
    const char* E_SgAdaGenericInstanceDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericInstanceDecl_instantiatedScope";
            case 1L: return "SgAdaGenericInstanceDecl_actual_parameters";
            default: return "";
        }
    }

    std::string E_SgAdaGenericInstanceDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericInstanceDecl(i);
        if (s.empty())
            s = "(E_SgAdaGenericInstanceDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericInstanceDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericInstanceDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericInstanceDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericInstanceDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericInstanceDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericInstanceDecl() {
        return stringify::E_SgAdaGenericInstanceDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 678
namespace stringify {
    const char* E_SgAdaParameterList(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaParameterList_parameters";
            default: return "";
        }
    }

    std::string E_SgAdaParameterList(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaParameterList(i);
        if (s.empty())
            s = "(E_SgAdaParameterList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaParameterList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaParameterList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaParameterList(i);
        if (retval.empty()) {
            retval = "(E_SgAdaParameterList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaParameterList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaParameterList() {
        return stringify::E_SgAdaParameterList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 681
namespace stringify {
    const char* E_SgAdaVariantDecl(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaVariantDecl_discriminant";
            case 1L: return "SgAdaVariantDecl_variants";
            default: return "";
        }
    }

    std::string E_SgAdaVariantDecl(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaVariantDecl(i);
        if (s.empty())
            s = "(E_SgAdaVariantDecl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaVariantDecl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaVariantDecl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaVariantDecl(i);
        if (retval.empty()) {
            retval = "(E_SgAdaVariantDecl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaVariantDecl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaVariantDecl() {
        return stringify::E_SgAdaVariantDecl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 684
namespace stringify {
    const char* E_SgExprStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExprStatement_expression";
            default: return "";
        }
    }

    std::string E_SgExprStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExprStatement(i);
        if (s.empty())
            s = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExprStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprStatement() {
        return stringify::E_SgExprStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 687
namespace stringify {
    const char* E_SgLabelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelStatement_statement";
            default: return "";
        }
    }

    std::string E_SgLabelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelStatement(i);
        if (s.empty())
            s = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLabelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelStatement() {
        return stringify::E_SgLabelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 690
namespace stringify {
    const char* E_SgCaseOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgCaseOptionStmt_key";
            case 1L: return "SgCaseOptionStmt_body";
            case 2L: return "SgCaseOptionStmt_key_range_end";
            default: return "";
        }
    }

    std::string E_SgCaseOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgCaseOptionStmt(i);
        if (s.empty())
            s = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCaseOptionStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCaseOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCaseOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgCaseOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCaseOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCaseOptionStmt() {
        return stringify::E_SgCaseOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 693
namespace stringify {
    const char* E_SgTryStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgTryStmt_body";
            case 1L: return "SgTryStmt_catch_statement_seq_root";
            case 2L: return "SgTryStmt_else_body";
            case 3L: return "SgTryStmt_finally_body";
            default: return "";
        }
    }

    std::string E_SgTryStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgTryStmt(i);
        if (s.empty())
            s = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTryStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTryStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTryStmt(i);
        if (retval.empty()) {
            retval = "(E_SgTryStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTryStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTryStmt() {
        return stringify::E_SgTryStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 696
namespace stringify {
    const char* E_SgDefaultOptionStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgDefaultOptionStmt_body";
            default: return "";
        }
    }

    std::string E_SgDefaultOptionStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgDefaultOptionStmt(i);
        if (s.empty())
            s = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDefaultOptionStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDefaultOptionStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDefaultOptionStmt(i);
        if (retval.empty()) {
            retval = "(E_SgDefaultOptionStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDefaultOptionStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDefaultOptionStmt() {
        return stringify::E_SgDefaultOptionStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 699
namespace stringify {
    const char* E_SgReturnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgReturnStmt_expression";
            default: return "";
        }
    }

    std::string E_SgReturnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgReturnStmt(i);
        if (s.empty())
            s = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReturnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReturnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReturnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgReturnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReturnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReturnStmt() {
        return stringify::E_SgReturnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 702
namespace stringify {
    const char* E_SgSpawnStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgSpawnStmt_the_func";
            default: return "";
        }
    }

    std::string E_SgSpawnStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgSpawnStmt(i);
        if (s.empty())
            s = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpawnStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpawnStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpawnStmt(i);
        if (retval.empty()) {
            retval = "(E_SgSpawnStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpawnStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpawnStmt() {
        return stringify::E_SgSpawnStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 705
namespace stringify {
    const char* E_SgForInitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgForInitStatement_init_stmt";
            default: return "";
        }
    }

    std::string E_SgForInitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgForInitStatement(i);
        if (s.empty())
            s = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgForInitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgForInitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgForInitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgForInitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgForInitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgForInitStatement() {
        return stringify::E_SgForInitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 708
namespace stringify {
    const char* E_SgCatchStatementSeq(int64_t i) {
        switch (i) {
            case 0L: return "SgCatchStatementSeq_catch_statement_seq";
            default: return "";
        }
    }

    std::string E_SgCatchStatementSeq(int64_t i, const std::string &strip) {
        std::string s = E_SgCatchStatementSeq(i);
        if (s.empty())
            s = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCatchStatementSeq() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCatchStatementSeq(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCatchStatementSeq(i);
        if (retval.empty()) {
            retval = "(E_SgCatchStatementSeq)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCatchStatementSeq::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCatchStatementSeq() {
        return stringify::E_SgCatchStatementSeq();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 711
namespace stringify {
    const char* E_SgProcessControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgProcessControlStatement_code";
            case 1L: return "SgProcessControlStatement_quiet";
            default: return "";
        }
    }

    std::string E_SgProcessControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgProcessControlStatement(i);
        if (s.empty())
            s = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgProcessControlStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgProcessControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgProcessControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgProcessControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgProcessControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgProcessControlStatement() {
        return stringify::E_SgProcessControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 714
namespace stringify {
    const char* E_SgPrintStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgPrintStatement_io_stmt_list";
            case 1L: return "SgPrintStatement_unit";
            case 2L: return "SgPrintStatement_iostat";
            case 3L: return "SgPrintStatement_err";
            case 4L: return "SgPrintStatement_iomsg";
            case 5L: return "SgPrintStatement_format";
            default: return "";
        }
    }

    std::string E_SgPrintStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgPrintStatement(i);
        if (s.empty())
            s = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPrintStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPrintStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPrintStatement(i);
        if (retval.empty()) {
            retval = "(E_SgPrintStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPrintStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPrintStatement() {
        return stringify::E_SgPrintStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 717
namespace stringify {
    const char* E_SgReadStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgReadStatement_io_stmt_list";
            case 1L: return "SgReadStatement_unit";
            case 2L: return "SgReadStatement_iostat";
            case 3L: return "SgReadStatement_err";
            case 4L: return "SgReadStatement_iomsg";
            case 5L: return "SgReadStatement_format";
            case 6L: return "SgReadStatement_namelist";
            case 7L: return "SgReadStatement_advance";
            case 8L: return "SgReadStatement_asynchronous";
            case 9L: return "SgReadStatement_blank";
            case 10L: return "SgReadStatement_decimal";
            case 11L: return "SgReadStatement_delim";
            case 12L: return "SgReadStatement_end";
            case 13L: return "SgReadStatement_eor";
            case 14L: return "SgReadStatement_id";
            case 15L: return "SgReadStatement_pad";
            case 16L: return "SgReadStatement_pos";
            case 17L: return "SgReadStatement_rec";
            case 18L: return "SgReadStatement_round";
            case 19L: return "SgReadStatement_sign";
            case 20L: return "SgReadStatement_size";
            default: return "";
        }
    }

    std::string E_SgReadStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgReadStatement(i);
        if (s.empty())
            s = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReadStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReadStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReadStatement(i);
        if (retval.empty()) {
            retval = "(E_SgReadStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReadStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReadStatement() {
        return stringify::E_SgReadStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 720
namespace stringify {
    const char* E_SgWriteStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWriteStatement_io_stmt_list";
            case 1L: return "SgWriteStatement_unit";
            case 2L: return "SgWriteStatement_iostat";
            case 3L: return "SgWriteStatement_err";
            case 4L: return "SgWriteStatement_iomsg";
            case 5L: return "SgWriteStatement_format";
            case 6L: return "SgWriteStatement_namelist";
            case 7L: return "SgWriteStatement_advance";
            case 8L: return "SgWriteStatement_asynchronous";
            case 9L: return "SgWriteStatement_blank";
            case 10L: return "SgWriteStatement_decimal";
            case 11L: return "SgWriteStatement_delim";
            case 12L: return "SgWriteStatement_end";
            case 13L: return "SgWriteStatement_eor";
            case 14L: return "SgWriteStatement_id";
            case 15L: return "SgWriteStatement_pad";
            case 16L: return "SgWriteStatement_pos";
            case 17L: return "SgWriteStatement_rec";
            case 18L: return "SgWriteStatement_round";
            case 19L: return "SgWriteStatement_sign";
            case 20L: return "SgWriteStatement_size";
            default: return "";
        }
    }

    std::string E_SgWriteStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWriteStatement(i);
        if (s.empty())
            s = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWriteStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWriteStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWriteStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWriteStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWriteStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWriteStatement() {
        return stringify::E_SgWriteStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 723
namespace stringify {
    const char* E_SgOpenStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOpenStatement_io_stmt_list";
            case 1L: return "SgOpenStatement_unit";
            case 2L: return "SgOpenStatement_iostat";
            case 3L: return "SgOpenStatement_err";
            case 4L: return "SgOpenStatement_iomsg";
            case 5L: return "SgOpenStatement_file";
            case 6L: return "SgOpenStatement_status";
            case 7L: return "SgOpenStatement_access";
            case 8L: return "SgOpenStatement_form";
            case 9L: return "SgOpenStatement_recl";
            case 10L: return "SgOpenStatement_blank";
            case 11L: return "SgOpenStatement_position";
            case 12L: return "SgOpenStatement_action";
            case 13L: return "SgOpenStatement_delim";
            case 14L: return "SgOpenStatement_pad";
            case 15L: return "SgOpenStatement_round";
            case 16L: return "SgOpenStatement_sign";
            case 17L: return "SgOpenStatement_asynchronous";
            default: return "";
        }
    }

    std::string E_SgOpenStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOpenStatement(i);
        if (s.empty())
            s = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOpenStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOpenStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOpenStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOpenStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOpenStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOpenStatement() {
        return stringify::E_SgOpenStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 726
namespace stringify {
    const char* E_SgCloseStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgCloseStatement_io_stmt_list";
            case 1L: return "SgCloseStatement_unit";
            case 2L: return "SgCloseStatement_iostat";
            case 3L: return "SgCloseStatement_err";
            case 4L: return "SgCloseStatement_iomsg";
            case 5L: return "SgCloseStatement_status";
            default: return "";
        }
    }

    std::string E_SgCloseStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgCloseStatement(i);
        if (s.empty())
            s = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCloseStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCloseStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCloseStatement(i);
        if (retval.empty()) {
            retval = "(E_SgCloseStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCloseStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCloseStatement() {
        return stringify::E_SgCloseStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 729
namespace stringify {
    const char* E_SgInquireStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgInquireStatement_io_stmt_list";
            case 1L: return "SgInquireStatement_unit";
            case 2L: return "SgInquireStatement_iostat";
            case 3L: return "SgInquireStatement_err";
            case 4L: return "SgInquireStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgInquireStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgInquireStatement(i);
        if (s.empty())
            s = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgInquireStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgInquireStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgInquireStatement(i);
        if (retval.empty()) {
            retval = "(E_SgInquireStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgInquireStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgInquireStatement() {
        return stringify::E_SgInquireStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 732
namespace stringify {
    const char* E_SgFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgFlushStatement_io_stmt_list";
            case 1L: return "SgFlushStatement_unit";
            case 2L: return "SgFlushStatement_iostat";
            case 3L: return "SgFlushStatement_err";
            case 4L: return "SgFlushStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgFlushStatement(i);
        if (s.empty())
            s = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFlushStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFlushStatement() {
        return stringify::E_SgFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 735
namespace stringify {
    const char* E_SgBackspaceStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgBackspaceStatement_io_stmt_list";
            case 1L: return "SgBackspaceStatement_unit";
            case 2L: return "SgBackspaceStatement_iostat";
            case 3L: return "SgBackspaceStatement_err";
            case 4L: return "SgBackspaceStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgBackspaceStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgBackspaceStatement(i);
        if (s.empty())
            s = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBackspaceStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBackspaceStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBackspaceStatement(i);
        if (retval.empty()) {
            retval = "(E_SgBackspaceStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBackspaceStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBackspaceStatement() {
        return stringify::E_SgBackspaceStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 738
namespace stringify {
    const char* E_SgRewindStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgRewindStatement_io_stmt_list";
            case 1L: return "SgRewindStatement_unit";
            case 2L: return "SgRewindStatement_iostat";
            case 3L: return "SgRewindStatement_err";
            case 4L: return "SgRewindStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgRewindStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgRewindStatement(i);
        if (s.empty())
            s = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRewindStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRewindStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRewindStatement(i);
        if (retval.empty()) {
            retval = "(E_SgRewindStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRewindStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRewindStatement() {
        return stringify::E_SgRewindStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 741
namespace stringify {
    const char* E_SgEndfileStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgEndfileStatement_io_stmt_list";
            case 1L: return "SgEndfileStatement_unit";
            case 2L: return "SgEndfileStatement_iostat";
            case 3L: return "SgEndfileStatement_err";
            case 4L: return "SgEndfileStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgEndfileStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgEndfileStatement(i);
        if (s.empty())
            s = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEndfileStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEndfileStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEndfileStatement(i);
        if (retval.empty()) {
            retval = "(E_SgEndfileStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEndfileStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEndfileStatement() {
        return stringify::E_SgEndfileStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 744
namespace stringify {
    const char* E_SgWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWaitStatement_io_stmt_list";
            case 1L: return "SgWaitStatement_unit";
            case 2L: return "SgWaitStatement_iostat";
            case 3L: return "SgWaitStatement_err";
            case 4L: return "SgWaitStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWaitStatement(i);
        if (s.empty())
            s = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWaitStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWaitStatement() {
        return stringify::E_SgWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 747
namespace stringify {
    const char* E_SgIOStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgIOStatement_io_stmt_list";
            case 1L: return "SgIOStatement_unit";
            case 2L: return "SgIOStatement_iostat";
            case 3L: return "SgIOStatement_err";
            case 4L: return "SgIOStatement_iomsg";
            default: return "";
        }
    }

    std::string E_SgIOStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgIOStatement(i);
        if (s.empty())
            s = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOStatement(i);
        if (retval.empty()) {
            retval = "(E_SgIOStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOStatement() {
        return stringify::E_SgIOStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 750
namespace stringify {
    const char* E_SgWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWhereStatement_condition";
            case 1L: return "SgWhereStatement_body";
            case 2L: return "SgWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWhereStatement(i);
        if (s.empty())
            s = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhereStatement() {
        return stringify::E_SgWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 753
namespace stringify {
    const char* E_SgElseWhereStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgElseWhereStatement_condition";
            case 1L: return "SgElseWhereStatement_body";
            case 2L: return "SgElseWhereStatement_elsewhere";
            default: return "";
        }
    }

    std::string E_SgElseWhereStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgElseWhereStatement(i);
        if (s.empty())
            s = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElseWhereStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElseWhereStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElseWhereStatement(i);
        if (retval.empty()) {
            retval = "(E_SgElseWhereStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElseWhereStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElseWhereStatement() {
        return stringify::E_SgElseWhereStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 756
namespace stringify {
    const char* E_SgNullifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgNullifyStatement_pointer_list";
            default: return "";
        }
    }

    std::string E_SgNullifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgNullifyStatement(i);
        if (s.empty())
            s = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNullifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNullifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNullifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgNullifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNullifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNullifyStatement() {
        return stringify::E_SgNullifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 759
namespace stringify {
    const char* E_SgArithmeticIfStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgArithmeticIfStatement_conditional";
            default: return "";
        }
    }

    std::string E_SgArithmeticIfStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgArithmeticIfStatement(i);
        if (s.empty())
            s = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArithmeticIfStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArithmeticIfStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArithmeticIfStatement(i);
        if (retval.empty()) {
            retval = "(E_SgArithmeticIfStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArithmeticIfStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArithmeticIfStatement() {
        return stringify::E_SgArithmeticIfStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 762
namespace stringify {
    const char* E_SgAssignStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignStatement_value";
            default: return "";
        }
    }

    std::string E_SgAssignStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignStatement(i);
        if (s.empty())
            s = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignStatement() {
        return stringify::E_SgAssignStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 765
namespace stringify {
    const char* E_SgComputedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgComputedGotoStatement_labelList";
            case 1L: return "SgComputedGotoStatement_label_index";
            default: return "";
        }
    }

    std::string E_SgComputedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgComputedGotoStatement(i);
        if (s.empty())
            s = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComputedGotoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComputedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComputedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgComputedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComputedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComputedGotoStatement() {
        return stringify::E_SgComputedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 768
namespace stringify {
    const char* E_SgAssignedGotoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignedGotoStatement_targets";
            default: return "";
        }
    }

    std::string E_SgAssignedGotoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignedGotoStatement(i);
        if (s.empty())
            s = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignedGotoStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignedGotoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignedGotoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAssignedGotoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignedGotoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignedGotoStatement() {
        return stringify::E_SgAssignedGotoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 771
namespace stringify {
    const char* E_SgAllocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgAllocateStatement_expr_list";
            case 1L: return "SgAllocateStatement_stat_expression";
            case 2L: return "SgAllocateStatement_errmsg_expression";
            case 3L: return "SgAllocateStatement_source_expression";
            default: return "";
        }
    }

    std::string E_SgAllocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgAllocateStatement(i);
        if (s.empty())
            s = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAllocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAllocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAllocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgAllocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAllocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAllocateStatement() {
        return stringify::E_SgAllocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 774
namespace stringify {
    const char* E_SgDeallocateStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgDeallocateStatement_expr_list";
            case 1L: return "SgDeallocateStatement_stat_expression";
            case 2L: return "SgDeallocateStatement_errmsg_expression";
            default: return "";
        }
    }

    std::string E_SgDeallocateStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgDeallocateStatement(i);
        if (s.empty())
            s = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeallocateStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeallocateStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeallocateStatement(i);
        if (retval.empty()) {
            retval = "(E_SgDeallocateStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeallocateStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeallocateStatement() {
        return stringify::E_SgDeallocateStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 777
namespace stringify {
    const char* E_SgUpcNotifyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcNotifyStatement_notify_expression";
            default: return "";
        }
    }

    std::string E_SgUpcNotifyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcNotifyStatement(i);
        if (s.empty())
            s = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcNotifyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcNotifyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcNotifyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcNotifyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcNotifyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcNotifyStatement() {
        return stringify::E_SgUpcNotifyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 780
namespace stringify {
    const char* E_SgUpcWaitStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcWaitStatement_wait_expression";
            default: return "";
        }
    }

    std::string E_SgUpcWaitStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcWaitStatement(i);
        if (s.empty())
            s = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcWaitStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcWaitStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcWaitStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcWaitStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcWaitStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcWaitStatement() {
        return stringify::E_SgUpcWaitStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 783
namespace stringify {
    const char* E_SgUpcBarrierStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBarrierStatement_barrier_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBarrierStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBarrierStatement(i);
        if (s.empty())
            s = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBarrierStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBarrierStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBarrierStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBarrierStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBarrierStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBarrierStatement() {
        return stringify::E_SgUpcBarrierStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 786
namespace stringify {
    const char* E_SgOmpFlushStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpFlushStatement_variables";
            default: return "";
        }
    }

    std::string E_SgOmpFlushStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpFlushStatement(i);
        if (s.empty())
            s = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpFlushStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpFlushStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpFlushStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpFlushStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpFlushStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpFlushStatement() {
        return stringify::E_SgOmpFlushStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 789
namespace stringify {
    const char* E_SgOmpMasterStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpMasterStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpMasterStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpMasterStatement(i);
        if (s.empty())
            s = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpMasterStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpMasterStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpMasterStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpMasterStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpMasterStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpMasterStatement() {
        return stringify::E_SgOmpMasterStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 792
namespace stringify {
    const char* E_SgOmpOrderedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpOrderedStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpOrderedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpOrderedStatement(i);
        if (s.empty())
            s = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpOrderedStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpOrderedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpOrderedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpOrderedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpOrderedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpOrderedStatement() {
        return stringify::E_SgOmpOrderedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 795
namespace stringify {
    const char* E_SgOmpCriticalStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpCriticalStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpCriticalStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpCriticalStatement(i);
        if (s.empty())
            s = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpCriticalStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpCriticalStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpCriticalStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpCriticalStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpCriticalStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpCriticalStatement() {
        return stringify::E_SgOmpCriticalStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 798
namespace stringify {
    const char* E_SgOmpSectionStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpSectionStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionStatement() {
        return stringify::E_SgOmpSectionStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 801
namespace stringify {
    const char* E_SgOmpWorkshareStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpWorkshareStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpWorkshareStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpWorkshareStatement(i);
        if (s.empty())
            s = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpWorkshareStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpWorkshareStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpWorkshareStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpWorkshareStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpWorkshareStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpWorkshareStatement() {
        return stringify::E_SgOmpWorkshareStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 804
namespace stringify {
    const char* E_SgOmpParallelStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpParallelStatement_body";
            case 1L: return "SgOmpParallelStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpParallelStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpParallelStatement(i);
        if (s.empty())
            s = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpParallelStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpParallelStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpParallelStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpParallelStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpParallelStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpParallelStatement() {
        return stringify::E_SgOmpParallelStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 807
namespace stringify {
    const char* E_SgOmpSingleStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSingleStatement_body";
            case 1L: return "SgOmpSingleStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSingleStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSingleStatement(i);
        if (s.empty())
            s = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSingleStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSingleStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSingleStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSingleStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSingleStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSingleStatement() {
        return stringify::E_SgOmpSingleStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 810
namespace stringify {
    const char* E_SgOmpAtomicStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpAtomicStatement_body";
            case 1L: return "SgOmpAtomicStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpAtomicStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpAtomicStatement(i);
        if (s.empty())
            s = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpAtomicStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpAtomicStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpAtomicStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpAtomicStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpAtomicStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpAtomicStatement() {
        return stringify::E_SgOmpAtomicStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 813
namespace stringify {
    const char* E_SgOmpTaskStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTaskStatement_body";
            case 1L: return "SgOmpTaskStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTaskStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTaskStatement(i);
        if (s.empty())
            s = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTaskStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTaskStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTaskStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTaskStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTaskStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTaskStatement() {
        return stringify::E_SgOmpTaskStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 816
namespace stringify {
    const char* E_SgOmpForStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForStatement_body";
            case 1L: return "SgOmpForStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForStatement(i);
        if (s.empty())
            s = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForStatement() {
        return stringify::E_SgOmpForStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 819
namespace stringify {
    const char* E_SgOmpDoStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpDoStatement_body";
            case 1L: return "SgOmpDoStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpDoStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpDoStatement(i);
        if (s.empty())
            s = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpDoStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpDoStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpDoStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpDoStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpDoStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpDoStatement() {
        return stringify::E_SgOmpDoStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 822
namespace stringify {
    const char* E_SgOmpSectionsStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSectionsStatement_body";
            case 1L: return "SgOmpSectionsStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSectionsStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSectionsStatement(i);
        if (s.empty())
            s = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSectionsStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSectionsStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSectionsStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSectionsStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSectionsStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSectionsStatement() {
        return stringify::E_SgOmpSectionsStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 825
namespace stringify {
    const char* E_SgOmpTargetStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetStatement_body";
            case 1L: return "SgOmpTargetStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetStatement() {
        return stringify::E_SgOmpTargetStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 828
namespace stringify {
    const char* E_SgOmpTargetDataStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpTargetDataStatement_body";
            case 1L: return "SgOmpTargetDataStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpTargetDataStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpTargetDataStatement(i);
        if (s.empty())
            s = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpTargetDataStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpTargetDataStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpTargetDataStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpTargetDataStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpTargetDataStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpTargetDataStatement() {
        return stringify::E_SgOmpTargetDataStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 831
namespace stringify {
    const char* E_SgOmpSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpSimdStatement_body";
            case 1L: return "SgOmpSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpSimdStatement() {
        return stringify::E_SgOmpSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 834
namespace stringify {
    const char* E_SgOmpForSimdStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpForSimdStatement_body";
            case 1L: return "SgOmpForSimdStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpForSimdStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpForSimdStatement(i);
        if (s.empty())
            s = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpForSimdStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpForSimdStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpForSimdStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpForSimdStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpForSimdStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpForSimdStatement() {
        return stringify::E_SgOmpForSimdStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 837
namespace stringify {
    const char* E_SgOmpClauseBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpClauseBodyStatement_body";
            case 1L: return "SgOmpClauseBodyStatement_clauses";
            default: return "";
        }
    }

    std::string E_SgOmpClauseBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpClauseBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpClauseBodyStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpClauseBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpClauseBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpClauseBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpClauseBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpClauseBodyStatement() {
        return stringify::E_SgOmpClauseBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 840
namespace stringify {
    const char* E_SgOmpBodyStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgOmpBodyStatement_body";
            default: return "";
        }
    }

    std::string E_SgOmpBodyStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgOmpBodyStatement(i);
        if (s.empty())
            s = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOmpBodyStatement() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOmpBodyStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOmpBodyStatement(i);
        if (retval.empty()) {
            retval = "(E_SgOmpBodyStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOmpBodyStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOmpBodyStatement() {
        return stringify::E_SgOmpBodyStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 843
namespace stringify {
    const char* E_SgWithStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgWithStatement_expression";
            case 1L: return "SgWithStatement_body";
            default: return "";
        }
    }

    std::string E_SgWithStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgWithStatement(i);
        if (s.empty())
            s = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWithStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWithStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWithStatement(i);
        if (retval.empty()) {
            retval = "(E_SgWithStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWithStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWithStatement() {
        return stringify::E_SgWithStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 846
namespace stringify {
    const char* E_SgPythonPrintStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonPrintStmt_destination";
            case 1L: return "SgPythonPrintStmt_values";
            default: return "";
        }
    }

    std::string E_SgPythonPrintStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonPrintStmt(i);
        if (s.empty())
            s = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonPrintStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonPrintStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonPrintStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonPrintStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonPrintStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonPrintStmt() {
        return stringify::E_SgPythonPrintStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 849
namespace stringify {
    const char* E_SgAssertStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAssertStmt_test";
            case 1L: return "SgAssertStmt_exception_argument";
            default: return "";
        }
    }

    std::string E_SgAssertStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAssertStmt(i);
        if (s.empty())
            s = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssertStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssertStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssertStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAssertStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssertStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssertStmt() {
        return stringify::E_SgAssertStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 852
namespace stringify {
    const char* E_SgExecStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgExecStatement_executable";
            case 1L: return "SgExecStatement_globals";
            case 2L: return "SgExecStatement_locals";
            default: return "";
        }
    }

    std::string E_SgExecStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgExecStatement(i);
        if (s.empty())
            s = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExecStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExecStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExecStatement(i);
        if (retval.empty()) {
            retval = "(E_SgExecStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExecStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExecStatement() {
        return stringify::E_SgExecStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 855
namespace stringify {
    const char* E_SgPythonGlobalStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgPythonGlobalStmt_names";
            default: return "";
        }
    }

    std::string E_SgPythonGlobalStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgPythonGlobalStmt(i);
        if (s.empty())
            s = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPythonGlobalStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPythonGlobalStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPythonGlobalStmt(i);
        if (retval.empty()) {
            retval = "(E_SgPythonGlobalStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPythonGlobalStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPythonGlobalStmt() {
        return stringify::E_SgPythonGlobalStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 858
namespace stringify {
    const char* E_SgJavaSynchronizedStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSynchronizedStatement_expression";
            case 1L: return "SgJavaSynchronizedStatement_body";
            default: return "";
        }
    }

    std::string E_SgJavaSynchronizedStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSynchronizedStatement(i);
        if (s.empty())
            s = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSynchronizedStatement() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSynchronizedStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSynchronizedStatement(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSynchronizedStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSynchronizedStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSynchronizedStatement() {
        return stringify::E_SgJavaSynchronizedStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 861
namespace stringify {
    const char* E_SgAsyncStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAsyncStmt_body";
            default: return "";
        }
    }

    std::string E_SgAsyncStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAsyncStmt(i);
        if (s.empty())
            s = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsyncStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsyncStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsyncStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAsyncStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsyncStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsyncStmt() {
        return stringify::E_SgAsyncStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 864
namespace stringify {
    const char* E_SgFinishStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishStmt_body";
            default: return "";
        }
    }

    std::string E_SgFinishStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishStmt(i);
        if (s.empty())
            s = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishStmt(i);
        if (retval.empty()) {
            retval = "(E_SgFinishStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishStmt() {
        return stringify::E_SgFinishStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 867
namespace stringify {
    const char* E_SgAtStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtStmt_expression";
            case 1L: return "SgAtStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtStmt(i);
        if (s.empty())
            s = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtStmt() {
        return stringify::E_SgAtStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 870
namespace stringify {
    const char* E_SgAtomicStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAtomicStmt_body";
            default: return "";
        }
    }

    std::string E_SgAtomicStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAtomicStmt(i);
        if (s.empty())
            s = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtomicStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtomicStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtomicStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAtomicStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtomicStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtomicStmt() {
        return stringify::E_SgAtomicStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 873
namespace stringify {
    const char* E_SgWhenStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgWhenStmt_expression";
            case 1L: return "SgWhenStmt_body";
            default: return "";
        }
    }

    std::string E_SgWhenStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgWhenStmt(i);
        if (s.empty())
            s = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgWhenStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgWhenStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgWhenStmt(i);
        if (retval.empty()) {
            retval = "(E_SgWhenStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgWhenStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgWhenStmt() {
        return stringify::E_SgWhenStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 876
namespace stringify {
    const char* E_SgSyncAllStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncAllStatement_stat";
            case 1L: return "SgSyncAllStatement_err_msg";
            case 2L: return "SgSyncAllStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncAllStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncAllStatement(i);
        if (s.empty())
            s = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncAllStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncAllStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncAllStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncAllStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncAllStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncAllStatement() {
        return stringify::E_SgSyncAllStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 879
namespace stringify {
    const char* E_SgSyncImagesStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncImagesStatement_stat";
            case 1L: return "SgSyncImagesStatement_err_msg";
            case 2L: return "SgSyncImagesStatement_acquired_lock";
            case 3L: return "SgSyncImagesStatement_image_set";
            default: return "";
        }
    }

    std::string E_SgSyncImagesStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncImagesStatement(i);
        if (s.empty())
            s = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncImagesStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncImagesStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncImagesStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncImagesStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncImagesStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncImagesStatement() {
        return stringify::E_SgSyncImagesStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 882
namespace stringify {
    const char* E_SgSyncMemoryStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncMemoryStatement_stat";
            case 1L: return "SgSyncMemoryStatement_err_msg";
            case 2L: return "SgSyncMemoryStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgSyncMemoryStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncMemoryStatement(i);
        if (s.empty())
            s = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncMemoryStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncMemoryStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncMemoryStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncMemoryStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncMemoryStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncMemoryStatement() {
        return stringify::E_SgSyncMemoryStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 885
namespace stringify {
    const char* E_SgSyncTeamStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgSyncTeamStatement_stat";
            case 1L: return "SgSyncTeamStatement_err_msg";
            case 2L: return "SgSyncTeamStatement_acquired_lock";
            case 3L: return "SgSyncTeamStatement_team_value";
            default: return "";
        }
    }

    std::string E_SgSyncTeamStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgSyncTeamStatement(i);
        if (s.empty())
            s = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSyncTeamStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSyncTeamStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSyncTeamStatement(i);
        if (retval.empty()) {
            retval = "(E_SgSyncTeamStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSyncTeamStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSyncTeamStatement() {
        return stringify::E_SgSyncTeamStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 888
namespace stringify {
    const char* E_SgLockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgLockStatement_stat";
            case 1L: return "SgLockStatement_err_msg";
            case 2L: return "SgLockStatement_acquired_lock";
            case 3L: return "SgLockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgLockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgLockStatement(i);
        if (s.empty())
            s = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgLockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLockStatement() {
        return stringify::E_SgLockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 891
namespace stringify {
    const char* E_SgUnlockStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgUnlockStatement_stat";
            case 1L: return "SgUnlockStatement_err_msg";
            case 2L: return "SgUnlockStatement_acquired_lock";
            case 3L: return "SgUnlockStatement_lock_variable";
            default: return "";
        }
    }

    std::string E_SgUnlockStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgUnlockStatement(i);
        if (s.empty())
            s = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnlockStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnlockStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnlockStatement(i);
        if (retval.empty()) {
            retval = "(E_SgUnlockStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnlockStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnlockStatement() {
        return stringify::E_SgUnlockStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 894
namespace stringify {
    const char* E_SgImageControlStatement(int64_t i) {
        switch (i) {
            case 0L: return "SgImageControlStatement_stat";
            case 1L: return "SgImageControlStatement_err_msg";
            case 2L: return "SgImageControlStatement_acquired_lock";
            default: return "";
        }
    }

    std::string E_SgImageControlStatement(int64_t i, const std::string &strip) {
        std::string s = E_SgImageControlStatement(i);
        if (s.empty())
            s = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImageControlStatement() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImageControlStatement(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImageControlStatement(i);
        if (retval.empty()) {
            retval = "(E_SgImageControlStatement)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImageControlStatement::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImageControlStatement() {
        return stringify::E_SgImageControlStatement();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 897
namespace stringify {
    const char* E_SgAdaExitStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaExitStmt_condition";
            default: return "";
        }
    }

    std::string E_SgAdaExitStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaExitStmt(i);
        if (s.empty())
            s = "(E_SgAdaExitStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaExitStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaExitStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaExitStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaExitStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaExitStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaExitStmt() {
        return stringify::E_SgAdaExitStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 900
namespace stringify {
    const char* E_SgAdaDelayStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaDelayStmt_time";
            default: return "";
        }
    }

    std::string E_SgAdaDelayStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaDelayStmt(i);
        if (s.empty())
            s = "(E_SgAdaDelayStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaDelayStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaDelayStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaDelayStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaDelayStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaDelayStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaDelayStmt() {
        return stringify::E_SgAdaDelayStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 903
namespace stringify {
    const char* E_SgAdaLoopStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaLoopStmt_body";
            default: return "";
        }
    }

    std::string E_SgAdaLoopStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaLoopStmt(i);
        if (s.empty())
            s = "(E_SgAdaLoopStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaLoopStmt() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaLoopStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaLoopStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaLoopStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaLoopStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaLoopStmt() {
        return stringify::E_SgAdaLoopStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 906
namespace stringify {
    const char* E_SgAdaSelectStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSelectStmt_select_path";
            case 1L: return "SgAdaSelectStmt_or_path";
            case 2L: return "SgAdaSelectStmt_else_path";
            case 3L: return "SgAdaSelectStmt_abort_path";
            default: return "";
        }
    }

    std::string E_SgAdaSelectStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSelectStmt(i);
        if (s.empty())
            s = "(E_SgAdaSelectStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSelectStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSelectStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSelectStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSelectStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSelectStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSelectStmt() {
        return stringify::E_SgAdaSelectStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 909
namespace stringify {
    const char* E_SgAdaSelectAlternativeStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaSelectAlternativeStmt_body";
            case 1L: return "SgAdaSelectAlternativeStmt_guard";
            case 2L: return "SgAdaSelectAlternativeStmt_next";
            default: return "";
        }
    }

    std::string E_SgAdaSelectAlternativeStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaSelectAlternativeStmt(i);
        if (s.empty())
            s = "(E_SgAdaSelectAlternativeStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaSelectAlternativeStmt() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaSelectAlternativeStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaSelectAlternativeStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaSelectAlternativeStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaSelectAlternativeStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaSelectAlternativeStmt() {
        return stringify::E_SgAdaSelectAlternativeStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 912
namespace stringify {
    const char* E_SgAdaUnscopedBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaUnscopedBlock_statements";
            default: return "";
        }
    }

    std::string E_SgAdaUnscopedBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaUnscopedBlock(i);
        if (s.empty())
            s = "(E_SgAdaUnscopedBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaUnscopedBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaUnscopedBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaUnscopedBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAdaUnscopedBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaUnscopedBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaUnscopedBlock() {
        return stringify::E_SgAdaUnscopedBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 915
namespace stringify {
    const char* E_SgAdaVariantWhenStmt(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaVariantWhenStmt_choices";
            case 1L: return "SgAdaVariantWhenStmt_components";
            default: return "";
        }
    }

    std::string E_SgAdaVariantWhenStmt(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaVariantWhenStmt(i);
        if (s.empty())
            s = "(E_SgAdaVariantWhenStmt)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaVariantWhenStmt() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaVariantWhenStmt(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaVariantWhenStmt(i);
        if (retval.empty()) {
            retval = "(E_SgAdaVariantWhenStmt)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaVariantWhenStmt::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaVariantWhenStmt() {
        return stringify::E_SgAdaVariantWhenStmt();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 918
namespace stringify {
    const char* E_SgExpressionRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgExpressionRoot_operand_i";
            default: return "";
        }
    }

    std::string E_SgExpressionRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgExpressionRoot(i);
        if (s.empty())
            s = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExpressionRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExpressionRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExpressionRoot(i);
        if (retval.empty()) {
            retval = "(E_SgExpressionRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExpressionRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExpressionRoot() {
        return stringify::E_SgExpressionRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 921
namespace stringify {
    const char* E_SgMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusOp() {
        return stringify::E_SgMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 924
namespace stringify {
    const char* E_SgUnaryAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryAddOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryAddOp(i);
        if (s.empty())
            s = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryAddOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryAddOp() {
        return stringify::E_SgUnaryAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 927
namespace stringify {
    const char* E_SgNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotOp(i);
        if (s.empty())
            s = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotOp() {
        return stringify::E_SgNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 930
namespace stringify {
    const char* E_SgPointerDerefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerDerefExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerDerefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerDerefExp(i);
        if (s.empty())
            s = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerDerefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerDerefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerDerefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerDerefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerDerefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerDerefExp() {
        return stringify::E_SgPointerDerefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 933
namespace stringify {
    const char* E_SgAddressOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddressOfOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddressOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddressOfOp(i);
        if (s.empty())
            s = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddressOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddressOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddressOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddressOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddressOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddressOfOp() {
        return stringify::E_SgAddressOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 936
namespace stringify {
    const char* E_SgMinusMinusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusMinusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusMinusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusMinusOp(i);
        if (s.empty())
            s = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusMinusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusMinusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusMinusOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusMinusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusMinusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusMinusOp() {
        return stringify::E_SgMinusMinusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 939
namespace stringify {
    const char* E_SgPlusPlusOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusPlusOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusPlusOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusPlusOp(i);
        if (s.empty())
            s = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusPlusOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusPlusOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusPlusOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusPlusOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusPlusOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusPlusOp() {
        return stringify::E_SgPlusPlusOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 942
namespace stringify {
    const char* E_SgBitComplementOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitComplementOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitComplementOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitComplementOp(i);
        if (s.empty())
            s = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitComplementOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitComplementOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitComplementOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitComplementOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitComplementOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitComplementOp() {
        return stringify::E_SgBitComplementOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 945
namespace stringify {
    const char* E_SgCastExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCastExp_operand_i";
            default: return "";
        }
    }

    std::string E_SgCastExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCastExp(i);
        if (s.empty())
            s = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCastExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCastExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCastExp(i);
        if (retval.empty()) {
            retval = "(E_SgCastExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCastExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCastExp() {
        return stringify::E_SgCastExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 948
namespace stringify {
    const char* E_SgThrowOp(int64_t i) {
        switch (i) {
            case 0L: return "SgThrowOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgThrowOp(int64_t i, const std::string &strip) {
        std::string s = E_SgThrowOp(i);
        if (s.empty())
            s = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgThrowOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgThrowOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgThrowOp(i);
        if (retval.empty()) {
            retval = "(E_SgThrowOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgThrowOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgThrowOp() {
        return stringify::E_SgThrowOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 951
namespace stringify {
    const char* E_SgRealPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRealPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgRealPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRealPartOp(i);
        if (s.empty())
            s = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRealPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRealPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRealPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgRealPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRealPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRealPartOp() {
        return stringify::E_SgRealPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 954
namespace stringify {
    const char* E_SgImagPartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgImagPartOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgImagPartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgImagPartOp(i);
        if (s.empty())
            s = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImagPartOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImagPartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImagPartOp(i);
        if (retval.empty()) {
            retval = "(E_SgImagPartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImagPartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImagPartOp() {
        return stringify::E_SgImagPartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 957
namespace stringify {
    const char* E_SgConjugateOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConjugateOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgConjugateOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConjugateOp(i);
        if (s.empty())
            s = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConjugateOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConjugateOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConjugateOp(i);
        if (retval.empty()) {
            retval = "(E_SgConjugateOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConjugateOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConjugateOp() {
        return stringify::E_SgConjugateOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 960
namespace stringify {
    const char* E_SgUserDefinedUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedUnaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedUnaryOp() {
        return stringify::E_SgUserDefinedUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 963
namespace stringify {
    const char* E_SgMatrixTransposeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixTransposeOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgMatrixTransposeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixTransposeOp(i);
        if (s.empty())
            s = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixTransposeOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixTransposeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixTransposeOp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixTransposeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixTransposeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixTransposeOp() {
        return stringify::E_SgMatrixTransposeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 966
namespace stringify {
    const char* E_SgAbsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAbsOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgAbsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAbsOp(i);
        if (s.empty())
            s = "(E_SgAbsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAbsOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAbsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAbsOp(i);
        if (retval.empty()) {
            retval = "(E_SgAbsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAbsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAbsOp() {
        return stringify::E_SgAbsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 969
namespace stringify {
    const char* E_SgUnaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUnaryOp_operand_i";
            default: return "";
        }
    }

    std::string E_SgUnaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUnaryOp(i);
        if (s.empty())
            s = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUnaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnaryOp() {
        return stringify::E_SgUnaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 972
namespace stringify {
    const char* E_SgArrowExp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowExp_lhs_operand_i";
            case 1L: return "SgArrowExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowExp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowExp(i);
        if (s.empty())
            s = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowExp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowExp() {
        return stringify::E_SgArrowExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 975
namespace stringify {
    const char* E_SgDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotExp_lhs_operand_i";
            case 1L: return "SgDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotExp(i);
        if (s.empty())
            s = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotExp() {
        return stringify::E_SgDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 978
namespace stringify {
    const char* E_SgDotStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotStarOp_lhs_operand_i";
            case 1L: return "SgDotStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotStarOp(i);
        if (s.empty())
            s = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgDotStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotStarOp() {
        return stringify::E_SgDotStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 981
namespace stringify {
    const char* E_SgArrowStarOp(int64_t i) {
        switch (i) {
            case 0L: return "SgArrowStarOp_lhs_operand_i";
            case 1L: return "SgArrowStarOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgArrowStarOp(int64_t i, const std::string &strip) {
        std::string s = E_SgArrowStarOp(i);
        if (s.empty())
            s = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgArrowStarOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgArrowStarOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgArrowStarOp(i);
        if (retval.empty()) {
            retval = "(E_SgArrowStarOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgArrowStarOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgArrowStarOp() {
        return stringify::E_SgArrowStarOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 984
namespace stringify {
    const char* E_SgEqualityOp(int64_t i) {
        switch (i) {
            case 0L: return "SgEqualityOp_lhs_operand_i";
            case 1L: return "SgEqualityOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgEqualityOp(int64_t i, const std::string &strip) {
        std::string s = E_SgEqualityOp(i);
        if (s.empty())
            s = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEqualityOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEqualityOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEqualityOp(i);
        if (retval.empty()) {
            retval = "(E_SgEqualityOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEqualityOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEqualityOp() {
        return stringify::E_SgEqualityOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 987
namespace stringify {
    const char* E_SgLessThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessThanOp_lhs_operand_i";
            case 1L: return "SgLessThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessThanOp(i);
        if (s.empty())
            s = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessThanOp() {
        return stringify::E_SgLessThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 990
namespace stringify {
    const char* E_SgGreaterThanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterThanOp_lhs_operand_i";
            case 1L: return "SgGreaterThanOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterThanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterThanOp(i);
        if (s.empty())
            s = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterThanOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterThanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterThanOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterThanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterThanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterThanOp() {
        return stringify::E_SgGreaterThanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 993
namespace stringify {
    const char* E_SgNotEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNotEqualOp_lhs_operand_i";
            case 1L: return "SgNotEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNotEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNotEqualOp(i);
        if (s.empty())
            s = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNotEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNotEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNotEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgNotEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNotEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNotEqualOp() {
        return stringify::E_SgNotEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 996
namespace stringify {
    const char* E_SgLessOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLessOrEqualOp_lhs_operand_i";
            case 1L: return "SgLessOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLessOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLessOrEqualOp(i);
        if (s.empty())
            s = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLessOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLessOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLessOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgLessOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLessOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLessOrEqualOp() {
        return stringify::E_SgLessOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 999
namespace stringify {
    const char* E_SgGreaterOrEqualOp(int64_t i) {
        switch (i) {
            case 0L: return "SgGreaterOrEqualOp_lhs_operand_i";
            case 1L: return "SgGreaterOrEqualOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgGreaterOrEqualOp(int64_t i, const std::string &strip) {
        std::string s = E_SgGreaterOrEqualOp(i);
        if (s.empty())
            s = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgGreaterOrEqualOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgGreaterOrEqualOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgGreaterOrEqualOp(i);
        if (retval.empty()) {
            retval = "(E_SgGreaterOrEqualOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgGreaterOrEqualOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgGreaterOrEqualOp() {
        return stringify::E_SgGreaterOrEqualOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1002
namespace stringify {
    const char* E_SgAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAddOp_lhs_operand_i";
            case 1L: return "SgAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAddOp(i);
        if (s.empty())
            s = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAddOp() {
        return stringify::E_SgAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1005
namespace stringify {
    const char* E_SgSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSubtractOp_lhs_operand_i";
            case 1L: return "SgSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSubtractOp(i);
        if (s.empty())
            s = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubtractOp() {
        return stringify::E_SgSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1008
namespace stringify {
    const char* E_SgMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultiplyOp_lhs_operand_i";
            case 1L: return "SgMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultiplyOp(i);
        if (s.empty())
            s = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultiplyOp() {
        return stringify::E_SgMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1011
namespace stringify {
    const char* E_SgDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivideOp_lhs_operand_i";
            case 1L: return "SgDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivideOp(i);
        if (s.empty())
            s = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivideOp() {
        return stringify::E_SgDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1014
namespace stringify {
    const char* E_SgIntegerDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideOp() {
        return stringify::E_SgIntegerDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1017
namespace stringify {
    const char* E_SgModOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModOp_lhs_operand_i";
            case 1L: return "SgModOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModOp(i);
        if (s.empty())
            s = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModOp(i);
        if (retval.empty()) {
            retval = "(E_SgModOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModOp() {
        return stringify::E_SgModOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1020
namespace stringify {
    const char* E_SgAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndOp_lhs_operand_i";
            case 1L: return "SgAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndOp(i);
        if (s.empty())
            s = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndOp() {
        return stringify::E_SgAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1023
namespace stringify {
    const char* E_SgOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgOrOp_lhs_operand_i";
            case 1L: return "SgOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgOrOp(i);
        if (s.empty())
            s = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgOrOp() {
        return stringify::E_SgOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1026
namespace stringify {
    const char* E_SgBitXorOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitXorOp_lhs_operand_i";
            case 1L: return "SgBitXorOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitXorOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitXorOp(i);
        if (s.empty())
            s = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitXorOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitXorOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitXorOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitXorOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitXorOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitXorOp() {
        return stringify::E_SgBitXorOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1029
namespace stringify {
    const char* E_SgBitAndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitAndOp_lhs_operand_i";
            case 1L: return "SgBitAndOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitAndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitAndOp(i);
        if (s.empty())
            s = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitAndOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitAndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitAndOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitAndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitAndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitAndOp() {
        return stringify::E_SgBitAndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1032
namespace stringify {
    const char* E_SgBitOrOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitOrOp_lhs_operand_i";
            case 1L: return "SgBitOrOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitOrOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitOrOp(i);
        if (s.empty())
            s = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitOrOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitOrOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitOrOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitOrOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitOrOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitOrOp() {
        return stringify::E_SgBitOrOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1035
namespace stringify {
    const char* E_SgBitEqvOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBitEqvOp_lhs_operand_i";
            case 1L: return "SgBitEqvOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBitEqvOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBitEqvOp(i);
        if (s.empty())
            s = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBitEqvOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBitEqvOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBitEqvOp(i);
        if (retval.empty()) {
            retval = "(E_SgBitEqvOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBitEqvOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBitEqvOp() {
        return stringify::E_SgBitEqvOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1038
namespace stringify {
    const char* E_SgCommaOpExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCommaOpExp_lhs_operand_i";
            case 1L: return "SgCommaOpExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCommaOpExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCommaOpExp(i);
        if (s.empty())
            s = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCommaOpExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCommaOpExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCommaOpExp(i);
        if (retval.empty()) {
            retval = "(E_SgCommaOpExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCommaOpExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCommaOpExp() {
        return stringify::E_SgCommaOpExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1041
namespace stringify {
    const char* E_SgLshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftOp_lhs_operand_i";
            case 1L: return "SgLshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftOp(i);
        if (s.empty())
            s = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftOp() {
        return stringify::E_SgLshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1044
namespace stringify {
    const char* E_SgRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftOp_lhs_operand_i";
            case 1L: return "SgRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftOp(i);
        if (s.empty())
            s = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftOp() {
        return stringify::E_SgRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1047
namespace stringify {
    const char* E_SgPntrArrRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgPntrArrRefExp_lhs_operand_i";
            case 1L: return "SgPntrArrRefExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPntrArrRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgPntrArrRefExp(i);
        if (s.empty())
            s = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPntrArrRefExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPntrArrRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPntrArrRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgPntrArrRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPntrArrRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPntrArrRefExp() {
        return stringify::E_SgPntrArrRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1050
namespace stringify {
    const char* E_SgScopeOp(int64_t i) {
        switch (i) {
            case 0L: return "SgScopeOp_lhs_operand_i";
            case 1L: return "SgScopeOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgScopeOp(int64_t i, const std::string &strip) {
        std::string s = E_SgScopeOp(i);
        if (s.empty())
            s = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgScopeOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgScopeOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgScopeOp(i);
        if (retval.empty()) {
            retval = "(E_SgScopeOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgScopeOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgScopeOp() {
        return stringify::E_SgScopeOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1053
namespace stringify {
    const char* E_SgAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignOp_lhs_operand_i";
            case 1L: return "SgAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignOp(i);
        if (s.empty())
            s = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignOp() {
        return stringify::E_SgAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1056
namespace stringify {
    const char* E_SgExponentiationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationOp_lhs_operand_i";
            case 1L: return "SgExponentiationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationOp(i);
        if (s.empty())
            s = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationOp() {
        return stringify::E_SgExponentiationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1059
namespace stringify {
    const char* E_SgJavaUnsignedRshiftOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftOp() {
        return stringify::E_SgJavaUnsignedRshiftOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1062
namespace stringify {
    const char* E_SgConcatenationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgConcatenationOp_lhs_operand_i";
            case 1L: return "SgConcatenationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgConcatenationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgConcatenationOp(i);
        if (s.empty())
            s = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConcatenationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConcatenationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConcatenationOp(i);
        if (retval.empty()) {
            retval = "(E_SgConcatenationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConcatenationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConcatenationOp() {
        return stringify::E_SgConcatenationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1065
namespace stringify {
    const char* E_SgPointerAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPointerAssignOp_lhs_operand_i";
            case 1L: return "SgPointerAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPointerAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPointerAssignOp(i);
        if (s.empty())
            s = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPointerAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPointerAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPointerAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPointerAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPointerAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPointerAssignOp() {
        return stringify::E_SgPointerAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1068
namespace stringify {
    const char* E_SgUserDefinedBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgUserDefinedBinaryOp_lhs_operand_i";
            case 1L: return "SgUserDefinedBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgUserDefinedBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgUserDefinedBinaryOp(i);
        if (s.empty())
            s = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUserDefinedBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUserDefinedBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUserDefinedBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgUserDefinedBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUserDefinedBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUserDefinedBinaryOp() {
        return stringify::E_SgUserDefinedBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1071
namespace stringify {
    const char* E_SgPlusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPlusAssignOp_lhs_operand_i";
            case 1L: return "SgPlusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPlusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPlusAssignOp(i);
        if (s.empty())
            s = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPlusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPlusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPlusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgPlusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPlusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPlusAssignOp() {
        return stringify::E_SgPlusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1074
namespace stringify {
    const char* E_SgMinusAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMinusAssignOp_lhs_operand_i";
            case 1L: return "SgMinusAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMinusAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMinusAssignOp(i);
        if (s.empty())
            s = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMinusAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMinusAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMinusAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMinusAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMinusAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMinusAssignOp() {
        return stringify::E_SgMinusAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1077
namespace stringify {
    const char* E_SgAndAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAndAssignOp_lhs_operand_i";
            case 1L: return "SgAndAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAndAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAndAssignOp(i);
        if (s.empty())
            s = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAndAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAndAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAndAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgAndAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAndAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAndAssignOp() {
        return stringify::E_SgAndAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1080
namespace stringify {
    const char* E_SgIorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIorAssignOp_lhs_operand_i";
            case 1L: return "SgIorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIorAssignOp(i);
        if (s.empty())
            s = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIorAssignOp() {
        return stringify::E_SgIorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1083
namespace stringify {
    const char* E_SgMultAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMultAssignOp_lhs_operand_i";
            case 1L: return "SgMultAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMultAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMultAssignOp(i);
        if (s.empty())
            s = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMultAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMultAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMultAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgMultAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMultAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMultAssignOp() {
        return stringify::E_SgMultAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1086
namespace stringify {
    const char* E_SgDivAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgDivAssignOp_lhs_operand_i";
            case 1L: return "SgDivAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDivAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgDivAssignOp(i);
        if (s.empty())
            s = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDivAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDivAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDivAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgDivAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDivAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDivAssignOp() {
        return stringify::E_SgDivAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1089
namespace stringify {
    const char* E_SgModAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgModAssignOp_lhs_operand_i";
            case 1L: return "SgModAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgModAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgModAssignOp(i);
        if (s.empty())
            s = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgModAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModAssignOp() {
        return stringify::E_SgModAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1092
namespace stringify {
    const char* E_SgXorAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgXorAssignOp_lhs_operand_i";
            case 1L: return "SgXorAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgXorAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgXorAssignOp(i);
        if (s.empty())
            s = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgXorAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgXorAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgXorAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgXorAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgXorAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgXorAssignOp() {
        return stringify::E_SgXorAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1095
namespace stringify {
    const char* E_SgLshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLshiftAssignOp_lhs_operand_i";
            case 1L: return "SgLshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgLshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLshiftAssignOp() {
        return stringify::E_SgLshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1098
namespace stringify {
    const char* E_SgRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRshiftAssignOp() {
        return stringify::E_SgRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1101
namespace stringify {
    const char* E_SgJavaUnsignedRshiftAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaUnsignedRshiftAssignOp_lhs_operand_i";
            case 1L: return "SgJavaUnsignedRshiftAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgJavaUnsignedRshiftAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaUnsignedRshiftAssignOp(i);
        if (s.empty())
            s = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaUnsignedRshiftAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaUnsignedRshiftAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaUnsignedRshiftAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaUnsignedRshiftAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaUnsignedRshiftAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaUnsignedRshiftAssignOp() {
        return stringify::E_SgJavaUnsignedRshiftAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1104
namespace stringify {
    const char* E_SgIntegerDivideAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIntegerDivideAssignOp_lhs_operand_i";
            case 1L: return "SgIntegerDivideAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIntegerDivideAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIntegerDivideAssignOp(i);
        if (s.empty())
            s = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIntegerDivideAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIntegerDivideAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIntegerDivideAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgIntegerDivideAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIntegerDivideAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIntegerDivideAssignOp() {
        return stringify::E_SgIntegerDivideAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1107
namespace stringify {
    const char* E_SgExponentiationAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgExponentiationAssignOp_lhs_operand_i";
            case 1L: return "SgExponentiationAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgExponentiationAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgExponentiationAssignOp(i);
        if (s.empty())
            s = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExponentiationAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExponentiationAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExponentiationAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgExponentiationAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExponentiationAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExponentiationAssignOp() {
        return stringify::E_SgExponentiationAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1110
namespace stringify {
    const char* E_SgCompoundAssignOp(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundAssignOp_lhs_operand_i";
            case 1L: return "SgCompoundAssignOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgCompoundAssignOp(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundAssignOp(i);
        if (s.empty())
            s = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundAssignOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundAssignOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundAssignOp(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundAssignOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundAssignOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundAssignOp() {
        return stringify::E_SgCompoundAssignOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1113
namespace stringify {
    const char* E_SgMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgMembershipOp_lhs_operand_i";
            case 1L: return "SgMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgMembershipOp(i);
        if (s.empty())
            s = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMembershipOp() {
        return stringify::E_SgMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1116
namespace stringify {
    const char* E_SgSpaceshipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSpaceshipOp_lhs_operand_i";
            case 1L: return "SgSpaceshipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgSpaceshipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSpaceshipOp(i);
        if (s.empty())
            s = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSpaceshipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSpaceshipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSpaceshipOp(i);
        if (retval.empty()) {
            retval = "(E_SgSpaceshipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSpaceshipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSpaceshipOp() {
        return stringify::E_SgSpaceshipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1119
namespace stringify {
    const char* E_SgNonMembershipOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNonMembershipOp_lhs_operand_i";
            case 1L: return "SgNonMembershipOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgNonMembershipOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNonMembershipOp(i);
        if (s.empty())
            s = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonMembershipOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonMembershipOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonMembershipOp(i);
        if (retval.empty()) {
            retval = "(E_SgNonMembershipOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonMembershipOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonMembershipOp() {
        return stringify::E_SgNonMembershipOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1122
namespace stringify {
    const char* E_SgIsOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsOp_lhs_operand_i";
            case 1L: return "SgIsOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsOp(i);
        if (s.empty())
            s = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsOp() {
        return stringify::E_SgIsOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1125
namespace stringify {
    const char* E_SgIsNotOp(int64_t i) {
        switch (i) {
            case 0L: return "SgIsNotOp_lhs_operand_i";
            case 1L: return "SgIsNotOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgIsNotOp(int64_t i, const std::string &strip) {
        std::string s = E_SgIsNotOp(i);
        if (s.empty())
            s = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIsNotOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIsNotOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIsNotOp(i);
        if (retval.empty()) {
            retval = "(E_SgIsNotOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIsNotOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIsNotOp() {
        return stringify::E_SgIsNotOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1128
namespace stringify {
    const char* E_SgDotDotExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDotDotExp_lhs_operand_i";
            case 1L: return "SgDotDotExp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgDotDotExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDotDotExp(i);
        if (s.empty())
            s = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDotDotExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDotDotExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDotDotExp(i);
        if (retval.empty()) {
            retval = "(E_SgDotDotExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDotDotExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDotDotExp() {
        return stringify::E_SgDotDotExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1131
namespace stringify {
    const char* E_SgElementwiseMultiplyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseMultiplyOp_lhs_operand_i";
            case 1L: return "SgElementwiseMultiplyOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseMultiplyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseMultiplyOp(i);
        if (s.empty())
            s = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseMultiplyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseMultiplyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseMultiplyOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseMultiplyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseMultiplyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseMultiplyOp() {
        return stringify::E_SgElementwiseMultiplyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1134
namespace stringify {
    const char* E_SgElementwisePowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwisePowerOp_lhs_operand_i";
            case 1L: return "SgElementwisePowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwisePowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwisePowerOp(i);
        if (s.empty())
            s = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwisePowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwisePowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwisePowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwisePowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwisePowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwisePowerOp() {
        return stringify::E_SgElementwisePowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1137
namespace stringify {
    const char* E_SgElementwiseLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseLeftDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseLeftDivideOp() {
        return stringify::E_SgElementwiseLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1140
namespace stringify {
    const char* E_SgElementwiseDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseDivideOp_lhs_operand_i";
            case 1L: return "SgElementwiseDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseDivideOp(i);
        if (s.empty())
            s = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseDivideOp() {
        return stringify::E_SgElementwiseDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1143
namespace stringify {
    const char* E_SgElementwiseAddOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseAddOp_lhs_operand_i";
            case 1L: return "SgElementwiseAddOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseAddOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseAddOp(i);
        if (s.empty())
            s = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseAddOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseAddOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseAddOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseAddOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseAddOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseAddOp() {
        return stringify::E_SgElementwiseAddOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1146
namespace stringify {
    const char* E_SgElementwiseSubtractOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseSubtractOp_lhs_operand_i";
            case 1L: return "SgElementwiseSubtractOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseSubtractOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseSubtractOp(i);
        if (s.empty())
            s = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseSubtractOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseSubtractOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseSubtractOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseSubtractOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseSubtractOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseSubtractOp() {
        return stringify::E_SgElementwiseSubtractOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1149
namespace stringify {
    const char* E_SgElementwiseOp(int64_t i) {
        switch (i) {
            case 0L: return "SgElementwiseOp_lhs_operand_i";
            case 1L: return "SgElementwiseOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgElementwiseOp(int64_t i, const std::string &strip) {
        std::string s = E_SgElementwiseOp(i);
        if (s.empty())
            s = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgElementwiseOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgElementwiseOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgElementwiseOp(i);
        if (retval.empty()) {
            retval = "(E_SgElementwiseOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgElementwiseOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgElementwiseOp() {
        return stringify::E_SgElementwiseOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1152
namespace stringify {
    const char* E_SgPowerOp(int64_t i) {
        switch (i) {
            case 0L: return "SgPowerOp_lhs_operand_i";
            case 1L: return "SgPowerOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgPowerOp(int64_t i, const std::string &strip) {
        std::string s = E_SgPowerOp(i);
        if (s.empty())
            s = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgPowerOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgPowerOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgPowerOp(i);
        if (retval.empty()) {
            retval = "(E_SgPowerOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgPowerOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgPowerOp() {
        return stringify::E_SgPowerOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1155
namespace stringify {
    const char* E_SgLeftDivideOp(int64_t i) {
        switch (i) {
            case 0L: return "SgLeftDivideOp_lhs_operand_i";
            case 1L: return "SgLeftDivideOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgLeftDivideOp(int64_t i, const std::string &strip) {
        std::string s = E_SgLeftDivideOp(i);
        if (s.empty())
            s = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLeftDivideOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLeftDivideOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLeftDivideOp(i);
        if (retval.empty()) {
            retval = "(E_SgLeftDivideOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLeftDivideOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLeftDivideOp() {
        return stringify::E_SgLeftDivideOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1158
namespace stringify {
    const char* E_SgRemOp(int64_t i) {
        switch (i) {
            case 0L: return "SgRemOp_lhs_operand_i";
            case 1L: return "SgRemOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgRemOp(int64_t i, const std::string &strip) {
        std::string s = E_SgRemOp(i);
        if (s.empty())
            s = "(E_SgRemOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRemOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRemOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRemOp(i);
        if (retval.empty()) {
            retval = "(E_SgRemOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRemOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRemOp() {
        return stringify::E_SgRemOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1161
namespace stringify {
    const char* E_SgReplicationOp(int64_t i) {
        switch (i) {
            case 0L: return "SgReplicationOp_lhs_operand_i";
            case 1L: return "SgReplicationOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgReplicationOp(int64_t i, const std::string &strip) {
        std::string s = E_SgReplicationOp(i);
        if (s.empty())
            s = "(E_SgReplicationOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgReplicationOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgReplicationOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgReplicationOp(i);
        if (retval.empty()) {
            retval = "(E_SgReplicationOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgReplicationOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgReplicationOp() {
        return stringify::E_SgReplicationOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1164
namespace stringify {
    const char* E_SgAtOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAtOp_lhs_operand_i";
            case 1L: return "SgAtOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgAtOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAtOp(i);
        if (s.empty())
            s = "(E_SgAtOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtOp(i);
        if (retval.empty()) {
            retval = "(E_SgAtOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtOp() {
        return stringify::E_SgAtOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1167
namespace stringify {
    const char* E_SgBinaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgBinaryOp_lhs_operand_i";
            case 1L: return "SgBinaryOp_rhs_operand_i";
            default: return "";
        }
    }

    std::string E_SgBinaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgBinaryOp(i);
        if (s.empty())
            s = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBinaryOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBinaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBinaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgBinaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBinaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBinaryOp() {
        return stringify::E_SgBinaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1170
namespace stringify {
    const char* E_SgListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgListExp(i);
        if (s.empty())
            s = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListExp(i);
        if (retval.empty()) {
            retval = "(E_SgListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListExp() {
        return stringify::E_SgListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1173
namespace stringify {
    const char* E_SgTupleExp(int64_t i) {
        switch (i) {
            case 0L: return "SgTupleExp_expressions";
            default: return "";
        }
    }

    std::string E_SgTupleExp(int64_t i, const std::string &strip) {
        std::string s = E_SgTupleExp(i);
        if (s.empty())
            s = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTupleExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTupleExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTupleExp(i);
        if (retval.empty()) {
            retval = "(E_SgTupleExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTupleExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTupleExp() {
        return stringify::E_SgTupleExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1176
namespace stringify {
    const char* E_SgMatrixExp(int64_t i) {
        switch (i) {
            case 0L: return "SgMatrixExp_expressions";
            default: return "";
        }
    }

    std::string E_SgMatrixExp(int64_t i, const std::string &strip) {
        std::string s = E_SgMatrixExp(i);
        if (s.empty())
            s = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMatrixExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMatrixExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMatrixExp(i);
        if (retval.empty()) {
            retval = "(E_SgMatrixExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMatrixExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMatrixExp() {
        return stringify::E_SgMatrixExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1179
namespace stringify {
    const char* E_SgExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgExprListExp(i);
        if (s.empty())
            s = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgExprListExp() {
        return stringify::E_SgExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1182
namespace stringify {
    const char* E_SgComplexVal(int64_t i) {
        switch (i) {
            case 0L: return "SgComplexVal_real_value";
            case 1L: return "SgComplexVal_imaginary_value";
            default: return "";
        }
    }

    std::string E_SgComplexVal(int64_t i, const std::string &strip) {
        std::string s = E_SgComplexVal(i);
        if (s.empty())
            s = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComplexVal() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComplexVal(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComplexVal(i);
        if (retval.empty()) {
            retval = "(E_SgComplexVal)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComplexVal::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComplexVal() {
        return stringify::E_SgComplexVal();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1185
namespace stringify {
    const char* E_SgCudaKernelCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelCallExp_function";
            case 1L: return "SgCudaKernelCallExp_args";
            case 2L: return "SgCudaKernelCallExp_exec_config";
            default: return "";
        }
    }

    std::string E_SgCudaKernelCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelCallExp(i);
        if (s.empty())
            s = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelCallExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelCallExp() {
        return stringify::E_SgCudaKernelCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1188
namespace stringify {
    const char* E_SgFunctionCallExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionCallExp_function";
            case 1L: return "SgFunctionCallExp_args";
            default: return "";
        }
    }

    std::string E_SgFunctionCallExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionCallExp(i);
        if (s.empty())
            s = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionCallExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionCallExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionCallExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionCallExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionCallExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionCallExp() {
        return stringify::E_SgFunctionCallExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1191
namespace stringify {
    const char* E_SgCallExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCallExpression_function";
            case 1L: return "SgCallExpression_args";
            default: return "";
        }
    }

    std::string E_SgCallExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCallExpression(i);
        if (s.empty())
            s = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCallExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCallExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCallExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCallExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCallExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCallExpression() {
        return stringify::E_SgCallExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1194
namespace stringify {
    const char* E_SgSizeOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgSizeOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgSizeOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgSizeOfOp(i);
        if (s.empty())
            s = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSizeOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSizeOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSizeOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgSizeOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSizeOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSizeOfOp() {
        return stringify::E_SgSizeOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1197
namespace stringify {
    const char* E_SgUpcLocalsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcLocalsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcLocalsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcLocalsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcLocalsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcLocalsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcLocalsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcLocalsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcLocalsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcLocalsizeofExpression() {
        return stringify::E_SgUpcLocalsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1200
namespace stringify {
    const char* E_SgUpcBlocksizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcBlocksizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcBlocksizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcBlocksizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcBlocksizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcBlocksizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcBlocksizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcBlocksizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcBlocksizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcBlocksizeofExpression() {
        return stringify::E_SgUpcBlocksizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1203
namespace stringify {
    const char* E_SgUpcElemsizeofExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgUpcElemsizeofExpression_expression";
            default: return "";
        }
    }

    std::string E_SgUpcElemsizeofExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgUpcElemsizeofExpression(i);
        if (s.empty())
            s = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUpcElemsizeofExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUpcElemsizeofExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUpcElemsizeofExpression(i);
        if (retval.empty()) {
            retval = "(E_SgUpcElemsizeofExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUpcElemsizeofExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUpcElemsizeofExpression() {
        return stringify::E_SgUpcElemsizeofExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1206
namespace stringify {
    const char* E_SgJavaInstanceOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaInstanceOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgJavaInstanceOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaInstanceOfOp(i);
        if (s.empty())
            s = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaInstanceOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaInstanceOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaInstanceOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgJavaInstanceOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaInstanceOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaInstanceOfOp() {
        return stringify::E_SgJavaInstanceOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1209
namespace stringify {
    const char* E_SgTypeIdOp(int64_t i) {
        switch (i) {
            case 0L: return "SgTypeIdOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgTypeIdOp(int64_t i, const std::string &strip) {
        std::string s = E_SgTypeIdOp(i);
        if (s.empty())
            s = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypeIdOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypeIdOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypeIdOp(i);
        if (retval.empty()) {
            retval = "(E_SgTypeIdOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypeIdOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypeIdOp() {
        return stringify::E_SgTypeIdOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1212
namespace stringify {
    const char* E_SgConditionalExp(int64_t i) {
        switch (i) {
            case 0L: return "SgConditionalExp_conditional_exp";
            case 1L: return "SgConditionalExp_true_exp";
            case 2L: return "SgConditionalExp_false_exp";
            default: return "";
        }
    }

    std::string E_SgConditionalExp(int64_t i, const std::string &strip) {
        std::string s = E_SgConditionalExp(i);
        if (s.empty())
            s = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConditionalExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConditionalExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConditionalExp(i);
        if (retval.empty()) {
            retval = "(E_SgConditionalExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConditionalExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConditionalExp() {
        return stringify::E_SgConditionalExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1215
namespace stringify {
    const char* E_SgNewExp(int64_t i) {
        switch (i) {
            case 0L: return "SgNewExp_placement_args";
            case 1L: return "SgNewExp_constructor_args";
            case 2L: return "SgNewExp_builtin_args";
            default: return "";
        }
    }

    std::string E_SgNewExp(int64_t i, const std::string &strip) {
        std::string s = E_SgNewExp(i);
        if (s.empty())
            s = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNewExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNewExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNewExp(i);
        if (retval.empty()) {
            retval = "(E_SgNewExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNewExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNewExp() {
        return stringify::E_SgNewExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1218
namespace stringify {
    const char* E_SgDeleteExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDeleteExp_variable";
            default: return "";
        }
    }

    std::string E_SgDeleteExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDeleteExp(i);
        if (s.empty())
            s = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDeleteExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDeleteExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDeleteExp(i);
        if (retval.empty()) {
            retval = "(E_SgDeleteExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDeleteExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDeleteExp() {
        return stringify::E_SgDeleteExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1221
namespace stringify {
    const char* E_SgAggregateInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAggregateInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgAggregateInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAggregateInitializer(i);
        if (s.empty())
            s = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAggregateInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAggregateInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAggregateInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAggregateInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAggregateInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAggregateInitializer() {
        return stringify::E_SgAggregateInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1224
namespace stringify {
    const char* E_SgCompoundInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgCompoundInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgCompoundInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgCompoundInitializer(i);
        if (s.empty())
            s = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCompoundInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCompoundInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCompoundInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgCompoundInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCompoundInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCompoundInitializer() {
        return stringify::E_SgCompoundInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1227
namespace stringify {
    const char* E_SgConstructorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgConstructorInitializer_args";
            default: return "";
        }
    }

    std::string E_SgConstructorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgConstructorInitializer(i);
        if (s.empty())
            s = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgConstructorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgConstructorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgConstructorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgConstructorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgConstructorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgConstructorInitializer() {
        return stringify::E_SgConstructorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1230
namespace stringify {
    const char* E_SgAssignInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAssignInitializer_operand_i";
            default: return "";
        }
    }

    std::string E_SgAssignInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAssignInitializer(i);
        if (s.empty())
            s = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAssignInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAssignInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAssignInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAssignInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAssignInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAssignInitializer() {
        return stringify::E_SgAssignInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1233
namespace stringify {
    const char* E_SgDesignatedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgDesignatedInitializer_designatorList";
            case 1L: return "SgDesignatedInitializer_memberInit";
            default: return "";
        }
    }

    std::string E_SgDesignatedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgDesignatedInitializer(i);
        if (s.empty())
            s = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDesignatedInitializer() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDesignatedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDesignatedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgDesignatedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDesignatedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDesignatedInitializer() {
        return stringify::E_SgDesignatedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1236
namespace stringify {
    const char* E_SgBracedInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgBracedInitializer_initializers";
            default: return "";
        }
    }

    std::string E_SgBracedInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgBracedInitializer(i);
        if (s.empty())
            s = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgBracedInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgBracedInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgBracedInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgBracedInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgBracedInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgBracedInitializer() {
        return stringify::E_SgBracedInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1239
namespace stringify {
    const char* E_SgAdaAncestorInitializer(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAncestorInitializer_ancestor";
            default: return "";
        }
    }

    std::string E_SgAdaAncestorInitializer(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAncestorInitializer(i);
        if (s.empty())
            s = "(E_SgAdaAncestorInitializer)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAncestorInitializer() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAncestorInitializer(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAncestorInitializer(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAncestorInitializer)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAncestorInitializer::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAncestorInitializer() {
        return stringify::E_SgAdaAncestorInitializer();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1242
namespace stringify {
    const char* E_SgVarArgStartOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOp_lhs_operand";
            case 1L: return "SgVarArgStartOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOp() {
        return stringify::E_SgVarArgStartOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1245
namespace stringify {
    const char* E_SgVarArgOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgOp(i);
        if (s.empty())
            s = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgOp() {
        return stringify::E_SgVarArgOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1248
namespace stringify {
    const char* E_SgVarArgEndOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgEndOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgEndOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgEndOp(i);
        if (s.empty())
            s = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgEndOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgEndOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgEndOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgEndOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgEndOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgEndOp() {
        return stringify::E_SgVarArgEndOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1251
namespace stringify {
    const char* E_SgVarArgCopyOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgCopyOp_lhs_operand";
            case 1L: return "SgVarArgCopyOp_rhs_operand";
            default: return "";
        }
    }

    std::string E_SgVarArgCopyOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgCopyOp(i);
        if (s.empty())
            s = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgCopyOp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgCopyOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgCopyOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgCopyOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgCopyOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgCopyOp() {
        return stringify::E_SgVarArgCopyOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1254
namespace stringify {
    const char* E_SgVarArgStartOneOperandOp(int64_t i) {
        switch (i) {
            case 0L: return "SgVarArgStartOneOperandOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgVarArgStartOneOperandOp(int64_t i, const std::string &strip) {
        std::string s = E_SgVarArgStartOneOperandOp(i);
        if (s.empty())
            s = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgVarArgStartOneOperandOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgVarArgStartOneOperandOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgVarArgStartOneOperandOp(i);
        if (retval.empty()) {
            retval = "(E_SgVarArgStartOneOperandOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgVarArgStartOneOperandOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgVarArgStartOneOperandOp() {
        return stringify::E_SgVarArgStartOneOperandOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1257
namespace stringify {
    const char* E_SgSubscriptExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgSubscriptExpression_lowerBound";
            case 1L: return "SgSubscriptExpression_upperBound";
            case 2L: return "SgSubscriptExpression_stride";
            default: return "";
        }
    }

    std::string E_SgSubscriptExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgSubscriptExpression(i);
        if (s.empty())
            s = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSubscriptExpression() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSubscriptExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSubscriptExpression(i);
        if (retval.empty()) {
            retval = "(E_SgSubscriptExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSubscriptExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSubscriptExpression() {
        return stringify::E_SgSubscriptExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1260
namespace stringify {
    const char* E_SgImpliedDo(int64_t i) {
        switch (i) {
            case 0L: return "SgImpliedDo_do_var_initialization";
            case 1L: return "SgImpliedDo_last_val";
            case 2L: return "SgImpliedDo_increment";
            case 3L: return "SgImpliedDo_object_list";
            default: return "";
        }
    }

    std::string E_SgImpliedDo(int64_t i, const std::string &strip) {
        std::string s = E_SgImpliedDo(i);
        if (s.empty())
            s = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgImpliedDo() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgImpliedDo(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgImpliedDo(i);
        if (retval.empty()) {
            retval = "(E_SgImpliedDo)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgImpliedDo::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgImpliedDo() {
        return stringify::E_SgImpliedDo();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1263
namespace stringify {
    const char* E_SgIOItemExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgIOItemExpression_io_item";
            default: return "";
        }
    }

    std::string E_SgIOItemExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgIOItemExpression(i);
        if (s.empty())
            s = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgIOItemExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgIOItemExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgIOItemExpression(i);
        if (retval.empty()) {
            retval = "(E_SgIOItemExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgIOItemExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgIOItemExpression() {
        return stringify::E_SgIOItemExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1266
namespace stringify {
    const char* E_SgStatementExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgStatementExpression_statement";
            default: return "";
        }
    }

    std::string E_SgStatementExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgStatementExpression(i);
        if (s.empty())
            s = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStatementExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStatementExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStatementExpression(i);
        if (retval.empty()) {
            retval = "(E_SgStatementExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStatementExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStatementExpression() {
        return stringify::E_SgStatementExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1269
namespace stringify {
    const char* E_SgAsmOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOp_expression";
            default: return "";
        }
    }

    std::string E_SgAsmOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOp(i);
        if (s.empty())
            s = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOp() {
        return stringify::E_SgAsmOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1272
namespace stringify {
    const char* E_SgActualArgumentExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgActualArgumentExpression_expression";
            default: return "";
        }
    }

    std::string E_SgActualArgumentExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgActualArgumentExpression(i);
        if (s.empty())
            s = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgActualArgumentExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgActualArgumentExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgActualArgumentExpression(i);
        if (retval.empty()) {
            retval = "(E_SgActualArgumentExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgActualArgumentExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgActualArgumentExpression() {
        return stringify::E_SgActualArgumentExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1275
namespace stringify {
    const char* E_SgUnknownArrayOrFunctionReference(int64_t i) {
        switch (i) {
            case 0L: return "SgUnknownArrayOrFunctionReference_named_reference";
            case 1L: return "SgUnknownArrayOrFunctionReference_expression_list";
            default: return "";
        }
    }

    std::string E_SgUnknownArrayOrFunctionReference(int64_t i, const std::string &strip) {
        std::string s = E_SgUnknownArrayOrFunctionReference(i);
        if (s.empty())
            s = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgUnknownArrayOrFunctionReference() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgUnknownArrayOrFunctionReference(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgUnknownArrayOrFunctionReference(i);
        if (retval.empty()) {
            retval = "(E_SgUnknownArrayOrFunctionReference)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgUnknownArrayOrFunctionReference() {
        return stringify::E_SgUnknownArrayOrFunctionReference();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1278
namespace stringify {
    const char* E_SgCAFCoExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgCAFCoExpression_referData";
            default: return "";
        }
    }

    std::string E_SgCAFCoExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgCAFCoExpression(i);
        if (s.empty())
            s = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCAFCoExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCAFCoExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCAFCoExpression(i);
        if (retval.empty()) {
            retval = "(E_SgCAFCoExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCAFCoExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCAFCoExpression() {
        return stringify::E_SgCAFCoExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1281
namespace stringify {
    const char* E_SgCudaKernelExecConfig(int64_t i) {
        switch (i) {
            case 0L: return "SgCudaKernelExecConfig_grid";
            case 1L: return "SgCudaKernelExecConfig_blocks";
            case 2L: return "SgCudaKernelExecConfig_shared";
            case 3L: return "SgCudaKernelExecConfig_stream";
            default: return "";
        }
    }

    std::string E_SgCudaKernelExecConfig(int64_t i, const std::string &strip) {
        std::string s = E_SgCudaKernelExecConfig(i);
        if (s.empty())
            s = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgCudaKernelExecConfig() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgCudaKernelExecConfig(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgCudaKernelExecConfig(i);
        if (retval.empty()) {
            retval = "(E_SgCudaKernelExecConfig)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgCudaKernelExecConfig::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgCudaKernelExecConfig() {
        return stringify::E_SgCudaKernelExecConfig();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1284
namespace stringify {
    const char* E_SgLambdaRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaRefExp_functionDeclaration";
            default: return "";
        }
    }

    std::string E_SgLambdaRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaRefExp(i);
        if (s.empty())
            s = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaRefExp() {
        return stringify::E_SgLambdaRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1287
namespace stringify {
    const char* E_SgDictionaryExp(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryExp_key_datum_pairs";
            default: return "";
        }
    }

    std::string E_SgDictionaryExp(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryExp(i);
        if (s.empty())
            s = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryExp(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryExp() {
        return stringify::E_SgDictionaryExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1290
namespace stringify {
    const char* E_SgKeyDatumPair(int64_t i) {
        switch (i) {
            case 0L: return "SgKeyDatumPair_key";
            case 1L: return "SgKeyDatumPair_datum";
            default: return "";
        }
    }

    std::string E_SgKeyDatumPair(int64_t i, const std::string &strip) {
        std::string s = E_SgKeyDatumPair(i);
        if (s.empty())
            s = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgKeyDatumPair() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgKeyDatumPair(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgKeyDatumPair(i);
        if (retval.empty()) {
            retval = "(E_SgKeyDatumPair)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgKeyDatumPair::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgKeyDatumPair() {
        return stringify::E_SgKeyDatumPair();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1293
namespace stringify {
    const char* E_SgComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgComprehension_target";
            case 1L: return "SgComprehension_iter";
            case 2L: return "SgComprehension_filters";
            default: return "";
        }
    }

    std::string E_SgComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgComprehension(i);
        if (s.empty())
            s = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgComprehension() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgComprehension() {
        return stringify::E_SgComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1296
namespace stringify {
    const char* E_SgListComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgListComprehension_element";
            case 1L: return "SgListComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgListComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgListComprehension(i);
        if (s.empty())
            s = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgListComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgListComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgListComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgListComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgListComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgListComprehension() {
        return stringify::E_SgListComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1299
namespace stringify {
    const char* E_SgSetComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgSetComprehension_element";
            case 1L: return "SgSetComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgSetComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgSetComprehension(i);
        if (s.empty())
            s = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgSetComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgSetComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgSetComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgSetComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgSetComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgSetComprehension() {
        return stringify::E_SgSetComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1302
namespace stringify {
    const char* E_SgDictionaryComprehension(int64_t i) {
        switch (i) {
            case 0L: return "SgDictionaryComprehension_element";
            case 1L: return "SgDictionaryComprehension_generators";
            default: return "";
        }
    }

    std::string E_SgDictionaryComprehension(int64_t i, const std::string &strip) {
        std::string s = E_SgDictionaryComprehension(i);
        if (s.empty())
            s = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgDictionaryComprehension() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgDictionaryComprehension(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgDictionaryComprehension(i);
        if (retval.empty()) {
            retval = "(E_SgDictionaryComprehension)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgDictionaryComprehension::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgDictionaryComprehension() {
        return stringify::E_SgDictionaryComprehension();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1305
namespace stringify {
    const char* E_SgNaryBooleanOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryBooleanOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryBooleanOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryBooleanOp(i);
        if (s.empty())
            s = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryBooleanOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryBooleanOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryBooleanOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryBooleanOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryBooleanOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryBooleanOp() {
        return stringify::E_SgNaryBooleanOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1308
namespace stringify {
    const char* E_SgNaryComparisonOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryComparisonOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryComparisonOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryComparisonOp(i);
        if (s.empty())
            s = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryComparisonOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryComparisonOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryComparisonOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryComparisonOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryComparisonOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryComparisonOp() {
        return stringify::E_SgNaryComparisonOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1311
namespace stringify {
    const char* E_SgNaryOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNaryOp_operands";
            default: return "";
        }
    }

    std::string E_SgNaryOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNaryOp(i);
        if (s.empty())
            s = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNaryOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNaryOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNaryOp(i);
        if (retval.empty()) {
            retval = "(E_SgNaryOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNaryOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNaryOp() {
        return stringify::E_SgNaryOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1314
namespace stringify {
    const char* E_SgStringConversion(int64_t i) {
        switch (i) {
            case 0L: return "SgStringConversion_expression";
            default: return "";
        }
    }

    std::string E_SgStringConversion(int64_t i, const std::string &strip) {
        std::string s = E_SgStringConversion(i);
        if (s.empty())
            s = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgStringConversion() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgStringConversion(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgStringConversion(i);
        if (retval.empty()) {
            retval = "(E_SgStringConversion)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgStringConversion::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgStringConversion() {
        return stringify::E_SgStringConversion();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1317
namespace stringify {
    const char* E_SgYieldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgYieldExpression_value";
            default: return "";
        }
    }

    std::string E_SgYieldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgYieldExpression(i);
        if (s.empty())
            s = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgYieldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgYieldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgYieldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgYieldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgYieldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgYieldExpression() {
        return stringify::E_SgYieldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1320
namespace stringify {
    const char* E_SgAlignOfOp(int64_t i) {
        switch (i) {
            case 0L: return "SgAlignOfOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgAlignOfOp(int64_t i, const std::string &strip) {
        std::string s = E_SgAlignOfOp(i);
        if (s.empty())
            s = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAlignOfOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAlignOfOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAlignOfOp(i);
        if (retval.empty()) {
            retval = "(E_SgAlignOfOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAlignOfOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAlignOfOp() {
        return stringify::E_SgAlignOfOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1323
namespace stringify {
    const char* E_SgRangeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgRangeExp_start";
            case 1L: return "SgRangeExp_end";
            case 2L: return "SgRangeExp_stride";
            default: return "";
        }
    }

    std::string E_SgRangeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgRangeExp(i);
        if (s.empty())
            s = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRangeExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRangeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRangeExp(i);
        if (retval.empty()) {
            retval = "(E_SgRangeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRangeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRangeExp() {
        return stringify::E_SgRangeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1326
namespace stringify {
    const char* E_SgJavaSingleMemberAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaSingleMemberAnnotation_value";
            default: return "";
        }
    }

    std::string E_SgJavaSingleMemberAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaSingleMemberAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaSingleMemberAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaSingleMemberAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaSingleMemberAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaSingleMemberAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaSingleMemberAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaSingleMemberAnnotation() {
        return stringify::E_SgJavaSingleMemberAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1329
namespace stringify {
    const char* E_SgJavaNormalAnnotation(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaNormalAnnotation_value_pair_list";
            default: return "";
        }
    }

    std::string E_SgJavaNormalAnnotation(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaNormalAnnotation(i);
        if (s.empty())
            s = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaNormalAnnotation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaNormalAnnotation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaNormalAnnotation(i);
        if (retval.empty()) {
            retval = "(E_SgJavaNormalAnnotation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaNormalAnnotation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaNormalAnnotation() {
        return stringify::E_SgJavaNormalAnnotation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1332
namespace stringify {
    const char* E_SgFunctionParameterRefExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionParameterRefExp_parameter_expression";
            default: return "";
        }
    }

    std::string E_SgFunctionParameterRefExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionParameterRefExp(i);
        if (s.empty())
            s = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionParameterRefExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionParameterRefExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionParameterRefExp(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionParameterRefExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionParameterRefExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionParameterRefExp() {
        return stringify::E_SgFunctionParameterRefExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1335
namespace stringify {
    const char* E_SgLambdaExp(int64_t i) {
        switch (i) {
            case 0L: return "SgLambdaExp_lambda_capture_list";
            case 1L: return "SgLambdaExp_lambda_closure_class";
            case 2L: return "SgLambdaExp_lambda_function";
            default: return "";
        }
    }

    std::string E_SgLambdaExp(int64_t i, const std::string &strip) {
        std::string s = E_SgLambdaExp(i);
        if (s.empty())
            s = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLambdaExp() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLambdaExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLambdaExp(i);
        if (retval.empty()) {
            retval = "(E_SgLambdaExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLambdaExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLambdaExp() {
        return stringify::E_SgLambdaExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1338
namespace stringify {
    const char* E_SgHereExp(int64_t i) {
        switch (i) {
            case 0L: return "SgHereExp_expression";
            default: return "";
        }
    }

    std::string E_SgHereExp(int64_t i, const std::string &strip) {
        std::string s = E_SgHereExp(i);
        if (s.empty())
            s = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgHereExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgHereExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgHereExp(i);
        if (retval.empty()) {
            retval = "(E_SgHereExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgHereExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgHereExp() {
        return stringify::E_SgHereExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1341
namespace stringify {
    const char* E_SgAtExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAtExp_expression";
            case 1L: return "SgAtExp_body";
            default: return "";
        }
    }

    std::string E_SgAtExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAtExp(i);
        if (s.empty())
            s = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAtExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAtExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAtExp(i);
        if (retval.empty()) {
            retval = "(E_SgAtExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAtExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAtExp() {
        return stringify::E_SgAtExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1344
namespace stringify {
    const char* E_SgFinishExp(int64_t i) {
        switch (i) {
            case 0L: return "SgFinishExp_expression";
            case 1L: return "SgFinishExp_body";
            default: return "";
        }
    }

    std::string E_SgFinishExp(int64_t i, const std::string &strip) {
        std::string s = E_SgFinishExp(i);
        if (s.empty())
            s = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFinishExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFinishExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFinishExp(i);
        if (retval.empty()) {
            retval = "(E_SgFinishExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFinishExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFinishExp() {
        return stringify::E_SgFinishExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1347
namespace stringify {
    const char* E_SgNoexceptOp(int64_t i) {
        switch (i) {
            case 0L: return "SgNoexceptOp_operand_expr";
            default: return "";
        }
    }

    std::string E_SgNoexceptOp(int64_t i, const std::string &strip) {
        std::string s = E_SgNoexceptOp(i);
        if (s.empty())
            s = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNoexceptOp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNoexceptOp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNoexceptOp(i);
        if (retval.empty()) {
            retval = "(E_SgNoexceptOp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNoexceptOp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNoexceptOp() {
        return stringify::E_SgNoexceptOp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1350
namespace stringify {
    const char* E_SgFoldExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgFoldExpression_operands";
            default: return "";
        }
    }

    std::string E_SgFoldExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgFoldExpression(i);
        if (s.empty())
            s = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFoldExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFoldExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFoldExpression(i);
        if (retval.empty()) {
            retval = "(E_SgFoldExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFoldExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFoldExpression() {
        return stringify::E_SgFoldExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1353
namespace stringify {
    const char* E_SgAwaitExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAwaitExpression_value";
            default: return "";
        }
    }

    std::string E_SgAwaitExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAwaitExpression(i);
        if (s.empty())
            s = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAwaitExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAwaitExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAwaitExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAwaitExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAwaitExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAwaitExpression() {
        return stringify::E_SgAwaitExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1356
namespace stringify {
    const char* E_SgChooseExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgChooseExpression_value";
            default: return "";
        }
    }

    std::string E_SgChooseExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgChooseExpression(i);
        if (s.empty())
            s = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgChooseExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgChooseExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgChooseExpression(i);
        if (retval.empty()) {
            retval = "(E_SgChooseExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgChooseExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgChooseExpression() {
        return stringify::E_SgChooseExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1359
namespace stringify {
    const char* E_SgAdaAttributeExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaAttributeExp_object";
            case 1L: return "SgAdaAttributeExp_args";
            default: return "";
        }
    }

    std::string E_SgAdaAttributeExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaAttributeExp(i);
        if (s.empty())
            s = "(E_SgAdaAttributeExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaAttributeExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaAttributeExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaAttributeExp(i);
        if (retval.empty()) {
            retval = "(E_SgAdaAttributeExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaAttributeExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaAttributeExp() {
        return stringify::E_SgAdaAttributeExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1362
namespace stringify {
    const char* E_SgJovialTablePresetExp(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialTablePresetExp_preset_list";
            default: return "";
        }
    }

    std::string E_SgJovialTablePresetExp(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialTablePresetExp(i);
        if (s.empty())
            s = "(E_SgJovialTablePresetExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialTablePresetExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialTablePresetExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialTablePresetExp(i);
        if (retval.empty()) {
            retval = "(E_SgJovialTablePresetExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialTablePresetExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialTablePresetExp() {
        return stringify::E_SgJovialTablePresetExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1365
namespace stringify {
    const char* E_SgJovialPresetPositionExp(int64_t i) {
        switch (i) {
            case 0L: return "SgJovialPresetPositionExp_indices";
            case 1L: return "SgJovialPresetPositionExp_value";
            default: return "";
        }
    }

    std::string E_SgJovialPresetPositionExp(int64_t i, const std::string &strip) {
        std::string s = E_SgJovialPresetPositionExp(i);
        if (s.empty())
            s = "(E_SgJovialPresetPositionExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJovialPresetPositionExp() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJovialPresetPositionExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJovialPresetPositionExp(i);
        if (retval.empty()) {
            retval = "(E_SgJovialPresetPositionExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJovialPresetPositionExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJovialPresetPositionExp() {
        return stringify::E_SgJovialPresetPositionExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1368
namespace stringify {
    const char* E_SgNonrealSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNonrealSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgNonrealSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNonrealSymbol(i);
        if (s.empty())
            s = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNonrealSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNonrealSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNonrealSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNonrealSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNonrealSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNonrealSymbol() {
        return stringify::E_SgNonrealSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1371
namespace stringify {
    const char* E_SgTemplateMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateMemberFunctionSymbol() {
        return stringify::E_SgTemplateMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1374
namespace stringify {
    const char* E_SgMemberFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgMemberFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgMemberFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgMemberFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgMemberFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgMemberFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgMemberFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgMemberFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgMemberFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgMemberFunctionSymbol() {
        return stringify::E_SgMemberFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1377
namespace stringify {
    const char* E_SgTemplateFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateFunctionSymbol() {
        return stringify::E_SgTemplateFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1380
namespace stringify {
    const char* E_SgRenameSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgRenameSymbol_declaration";
            case 1L: return "SgRenameSymbol_original_symbol";
            default: return "";
        }
    }

    std::string E_SgRenameSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgRenameSymbol(i);
        if (s.empty())
            s = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgRenameSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgRenameSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgRenameSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgRenameSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgRenameSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgRenameSymbol() {
        return stringify::E_SgRenameSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1383
namespace stringify {
    const char* E_SgAdaInheritedFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaInheritedFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaInheritedFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaInheritedFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgAdaInheritedFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaInheritedFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaInheritedFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaInheritedFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaInheritedFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaInheritedFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaInheritedFunctionSymbol() {
        return stringify::E_SgAdaInheritedFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1386
namespace stringify {
    const char* E_SgFunctionSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgFunctionSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgFunctionSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgFunctionSymbol(i);
        if (s.empty())
            s = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgFunctionSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgFunctionSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgFunctionSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgFunctionSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgFunctionSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgFunctionSymbol() {
        return stringify::E_SgFunctionSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1389
namespace stringify {
    const char* E_SgTemplateClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateClassSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateClassSymbol() {
        return stringify::E_SgTemplateClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1392
namespace stringify {
    const char* E_SgClassSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgClassSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgClassSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgClassSymbol(i);
        if (s.empty())
            s = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgClassSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgClassSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgClassSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgClassSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgClassSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgClassSymbol() {
        return stringify::E_SgClassSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1395
namespace stringify {
    const char* E_SgTemplateSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateSymbol() {
        return stringify::E_SgTemplateSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1398
namespace stringify {
    const char* E_SgEnumSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgEnumSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgEnumSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgEnumSymbol(i);
        if (s.empty())
            s = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgEnumSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgEnumSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgEnumSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgEnumSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgEnumSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgEnumSymbol() {
        return stringify::E_SgEnumSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1401
namespace stringify {
    const char* E_SgTemplateTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTemplateTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTemplateTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTemplateTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTemplateTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTemplateTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTemplateTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTemplateTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTemplateTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTemplateTypedefSymbol() {
        return stringify::E_SgTemplateTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1404
namespace stringify {
    const char* E_SgTypedefSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgTypedefSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgTypedefSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgTypedefSymbol(i);
        if (s.empty())
            s = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgTypedefSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgTypedefSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgTypedefSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgTypedefSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgTypedefSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgTypedefSymbol() {
        return stringify::E_SgTypedefSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1407
namespace stringify {
    const char* E_SgLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgLabelSymbol(i);
        if (s.empty())
            s = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgLabelSymbol() {
        return stringify::E_SgLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1410
namespace stringify {
    const char* E_SgNamespaceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgNamespaceSymbol_declaration";
            case 1L: return "SgNamespaceSymbol_aliasDeclaration";
            default: return "";
        }
    }

    std::string E_SgNamespaceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgNamespaceSymbol(i);
        if (s.empty())
            s = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgNamespaceSymbol() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgNamespaceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgNamespaceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgNamespaceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgNamespaceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgNamespaceSymbol() {
        return stringify::E_SgNamespaceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1413
namespace stringify {
    const char* E_SgModuleSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgModuleSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgModuleSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgModuleSymbol(i);
        if (s.empty())
            s = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgModuleSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgModuleSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgModuleSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgModuleSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgModuleSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgModuleSymbol() {
        return stringify::E_SgModuleSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1416
namespace stringify {
    const char* E_SgAliasSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAliasSymbol_alias";
            default: return "";
        }
    }

    std::string E_SgAliasSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAliasSymbol(i);
        if (s.empty())
            s = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAliasSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAliasSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAliasSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAliasSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAliasSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAliasSymbol() {
        return stringify::E_SgAliasSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1419
namespace stringify {
    const char* E_SgJavaLabelSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgJavaLabelSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgJavaLabelSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgJavaLabelSymbol(i);
        if (s.empty())
            s = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgJavaLabelSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgJavaLabelSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgJavaLabelSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgJavaLabelSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgJavaLabelSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgJavaLabelSymbol() {
        return stringify::E_SgJavaLabelSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1422
namespace stringify {
    const char* E_SgAdaPackageSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaPackageSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaPackageSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaPackageSymbol(i);
        if (s.empty())
            s = "(E_SgAdaPackageSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaPackageSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaPackageSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaPackageSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaPackageSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaPackageSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaPackageSymbol() {
        return stringify::E_SgAdaPackageSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1425
namespace stringify {
    const char* E_SgAdaTaskSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaTaskSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaTaskSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaTaskSymbol(i);
        if (s.empty())
            s = "(E_SgAdaTaskSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaTaskSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaTaskSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaTaskSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaTaskSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaTaskSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaTaskSymbol() {
        return stringify::E_SgAdaTaskSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1428
namespace stringify {
    const char* E_SgAdaProtectedSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaProtectedSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaProtectedSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaProtectedSymbol(i);
        if (s.empty())
            s = "(E_SgAdaProtectedSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaProtectedSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaProtectedSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaProtectedSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaProtectedSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaProtectedSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaProtectedSymbol() {
        return stringify::E_SgAdaProtectedSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1431
namespace stringify {
    const char* E_SgAdaRenamingSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaRenamingSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaRenamingSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaRenamingSymbol(i);
        if (s.empty())
            s = "(E_SgAdaRenamingSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaRenamingSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaRenamingSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaRenamingSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaRenamingSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaRenamingSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaRenamingSymbol() {
        return stringify::E_SgAdaRenamingSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1434
namespace stringify {
    const char* E_SgAdaGenericSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericSymbol(i);
        if (s.empty())
            s = "(E_SgAdaGenericSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericSymbol() {
        return stringify::E_SgAdaGenericSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1437
namespace stringify {
    const char* E_SgAdaGenericInstanceSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaGenericInstanceSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaGenericInstanceSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaGenericInstanceSymbol(i);
        if (s.empty())
            s = "(E_SgAdaGenericInstanceSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaGenericInstanceSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaGenericInstanceSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaGenericInstanceSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaGenericInstanceSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaGenericInstanceSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaGenericInstanceSymbol() {
        return stringify::E_SgAdaGenericInstanceSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1440
namespace stringify {
    const char* E_SgAdaFormalPackageSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAdaFormalPackageSymbol_declaration";
            default: return "";
        }
    }

    std::string E_SgAdaFormalPackageSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAdaFormalPackageSymbol(i);
        if (s.empty())
            s = "(E_SgAdaFormalPackageSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAdaFormalPackageSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAdaFormalPackageSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAdaFormalPackageSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAdaFormalPackageSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAdaFormalPackageSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAdaFormalPackageSymbol() {
        return stringify::E_SgAdaFormalPackageSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1443
namespace stringify {
    const char* E_SgAsmCilMetadataHeap(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMetadataHeap_AssemblyTable";
            case 1L: return "SgAsmCilMetadataHeap_AssemblyOSTable";
            case 2L: return "SgAsmCilMetadataHeap_AssemblyProcessorTable";
            case 3L: return "SgAsmCilMetadataHeap_AssemblyRefTable";
            case 4L: return "SgAsmCilMetadataHeap_AssemblyRefOSTable";
            case 5L: return "SgAsmCilMetadataHeap_AssemblyRefProcessorTable";
            case 6L: return "SgAsmCilMetadataHeap_ClassLayoutTable";
            case 7L: return "SgAsmCilMetadataHeap_ConstantTable";
            case 8L: return "SgAsmCilMetadataHeap_CustomAttributeTable";
            case 9L: return "SgAsmCilMetadataHeap_DeclSecurityTable";
            case 10L: return "SgAsmCilMetadataHeap_EventTable";
            case 11L: return "SgAsmCilMetadataHeap_EventMapTable";
            case 12L: return "SgAsmCilMetadataHeap_ExportedTypeTable";
            case 13L: return "SgAsmCilMetadataHeap_FieldTable";
            case 14L: return "SgAsmCilMetadataHeap_FieldLayoutTable";
            case 15L: return "SgAsmCilMetadataHeap_FieldMarshalTable";
            case 16L: return "SgAsmCilMetadataHeap_FieldRVATable";
            case 17L: return "SgAsmCilMetadataHeap_FileTable";
            case 18L: return "SgAsmCilMetadataHeap_GenericParamTable";
            case 19L: return "SgAsmCilMetadataHeap_GenericParamConstraintTable";
            case 20L: return "SgAsmCilMetadataHeap_ImplMapTable";
            case 21L: return "SgAsmCilMetadataHeap_InterfaceImplTable";
            case 22L: return "SgAsmCilMetadataHeap_ManifestResourceTable";
            case 23L: return "SgAsmCilMetadataHeap_MemberRefTable";
            case 24L: return "SgAsmCilMetadataHeap_MethodDefTable";
            case 25L: return "SgAsmCilMetadataHeap_MethodImplTable";
            case 26L: return "SgAsmCilMetadataHeap_MethodSemanticsTable";
            case 27L: return "SgAsmCilMetadataHeap_MethodSpecTable";
            case 28L: return "SgAsmCilMetadataHeap_ModuleTable";
            case 29L: return "SgAsmCilMetadataHeap_ModuleRefTable";
            case 30L: return "SgAsmCilMetadataHeap_NestedClassTable";
            case 31L: return "SgAsmCilMetadataHeap_ParamTable";
            case 32L: return "SgAsmCilMetadataHeap_PropertyTable";
            case 33L: return "SgAsmCilMetadataHeap_PropertyMapTable";
            case 34L: return "SgAsmCilMetadataHeap_StandAloneSigTable";
            case 35L: return "SgAsmCilMetadataHeap_TypeDefTable";
            case 36L: return "SgAsmCilMetadataHeap_TypeRefTable";
            case 37L: return "SgAsmCilMetadataHeap_TypeSpecTable";
            default: return "";
        }
    }

    std::string E_SgAsmCilMetadataHeap(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMetadataHeap(i);
        if (s.empty())
            s = "(E_SgAsmCilMetadataHeap)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMetadataHeap() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L
        };
        static const std::vector<int64_t> retval(values, values + 38);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMetadataHeap(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMetadataHeap(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMetadataHeap)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMetadataHeap::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMetadataHeap() {
        return stringify::E_SgAsmCilMetadataHeap();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1446
namespace stringify {
    const char* E_SgAsmCilAssemblyOSTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyOSTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyOSTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyOSTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyOSTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyOSTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyOSTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyOSTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyOSTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyOSTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyOSTable() {
        return stringify::E_SgAsmCilAssemblyOSTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1449
namespace stringify {
    const char* E_SgAsmCilAssemblyProcessorTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyProcessorTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyProcessorTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyProcessorTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyProcessorTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyProcessorTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyProcessorTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyProcessorTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyProcessorTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyProcessorTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyProcessorTable() {
        return stringify::E_SgAsmCilAssemblyProcessorTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1452
namespace stringify {
    const char* E_SgAsmCilAssemblyRefOSTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefOSTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefOSTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefOSTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefOSTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefOSTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefOSTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefOSTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefOSTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefOSTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefOSTable() {
        return stringify::E_SgAsmCilAssemblyRefOSTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1455
namespace stringify {
    const char* E_SgAsmCilAssemblyRefProcessorTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefProcessorTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefProcessorTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefProcessorTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefProcessorTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefProcessorTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefProcessorTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefProcessorTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefProcessorTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefProcessorTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefProcessorTable() {
        return stringify::E_SgAsmCilAssemblyRefProcessorTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1458
namespace stringify {
    const char* E_SgAsmCilAssemblyRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyRefTable() {
        return stringify::E_SgAsmCilAssemblyRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1461
namespace stringify {
    const char* E_SgAsmCilAssemblyTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilAssemblyTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilAssemblyTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilAssemblyTable(i);
        if (s.empty())
            s = "(E_SgAsmCilAssemblyTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilAssemblyTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilAssemblyTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilAssemblyTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilAssemblyTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilAssemblyTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilAssemblyTable() {
        return stringify::E_SgAsmCilAssemblyTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1464
namespace stringify {
    const char* E_SgAsmCilClassLayoutTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilClassLayoutTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilClassLayoutTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilClassLayoutTable(i);
        if (s.empty())
            s = "(E_SgAsmCilClassLayoutTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilClassLayoutTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilClassLayoutTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilClassLayoutTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilClassLayoutTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilClassLayoutTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilClassLayoutTable() {
        return stringify::E_SgAsmCilClassLayoutTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1467
namespace stringify {
    const char* E_SgAsmCilConstantTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilConstantTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilConstantTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilConstantTable(i);
        if (s.empty())
            s = "(E_SgAsmCilConstantTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilConstantTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilConstantTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilConstantTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilConstantTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilConstantTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilConstantTable() {
        return stringify::E_SgAsmCilConstantTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1470
namespace stringify {
    const char* E_SgAsmCilCustomAttributeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilCustomAttributeTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilCustomAttributeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilCustomAttributeTable(i);
        if (s.empty())
            s = "(E_SgAsmCilCustomAttributeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilCustomAttributeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilCustomAttributeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilCustomAttributeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilCustomAttributeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilCustomAttributeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilCustomAttributeTable() {
        return stringify::E_SgAsmCilCustomAttributeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1473
namespace stringify {
    const char* E_SgAsmCilDeclSecurityTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilDeclSecurityTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilDeclSecurityTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilDeclSecurityTable(i);
        if (s.empty())
            s = "(E_SgAsmCilDeclSecurityTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilDeclSecurityTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilDeclSecurityTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilDeclSecurityTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilDeclSecurityTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilDeclSecurityTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilDeclSecurityTable() {
        return stringify::E_SgAsmCilDeclSecurityTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1476
namespace stringify {
    const char* E_SgAsmCilEventMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilEventMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilEventMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilEventMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilEventMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilEventMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilEventMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilEventMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilEventMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilEventMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilEventMapTable() {
        return stringify::E_SgAsmCilEventMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1479
namespace stringify {
    const char* E_SgAsmCilEventTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilEventTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilEventTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilEventTable(i);
        if (s.empty())
            s = "(E_SgAsmCilEventTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilEventTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilEventTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilEventTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilEventTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilEventTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilEventTable() {
        return stringify::E_SgAsmCilEventTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1482
namespace stringify {
    const char* E_SgAsmCilExportedTypeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilExportedTypeTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilExportedTypeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilExportedTypeTable(i);
        if (s.empty())
            s = "(E_SgAsmCilExportedTypeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilExportedTypeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilExportedTypeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilExportedTypeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilExportedTypeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilExportedTypeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilExportedTypeTable() {
        return stringify::E_SgAsmCilExportedTypeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1485
namespace stringify {
    const char* E_SgAsmCilFieldLayoutTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldLayoutTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldLayoutTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldLayoutTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldLayoutTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldLayoutTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldLayoutTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldLayoutTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldLayoutTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldLayoutTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldLayoutTable() {
        return stringify::E_SgAsmCilFieldLayoutTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1488
namespace stringify {
    const char* E_SgAsmCilFieldMarshalTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldMarshalTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldMarshalTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldMarshalTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldMarshalTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldMarshalTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldMarshalTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldMarshalTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldMarshalTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldMarshalTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldMarshalTable() {
        return stringify::E_SgAsmCilFieldMarshalTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1491
namespace stringify {
    const char* E_SgAsmCilFieldRVATable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldRVATable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldRVATable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldRVATable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldRVATable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldRVATable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldRVATable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldRVATable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldRVATable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldRVATable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldRVATable() {
        return stringify::E_SgAsmCilFieldRVATable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1494
namespace stringify {
    const char* E_SgAsmCilFieldTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFieldTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFieldTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFieldTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFieldTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFieldTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFieldTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFieldTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFieldTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFieldTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFieldTable() {
        return stringify::E_SgAsmCilFieldTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1497
namespace stringify {
    const char* E_SgAsmCilFileTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilFileTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilFileTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilFileTable(i);
        if (s.empty())
            s = "(E_SgAsmCilFileTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilFileTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilFileTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilFileTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilFileTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilFileTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilFileTable() {
        return stringify::E_SgAsmCilFileTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1500
namespace stringify {
    const char* E_SgAsmCilGenericParamConstraintTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilGenericParamConstraintTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilGenericParamConstraintTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilGenericParamConstraintTable(i);
        if (s.empty())
            s = "(E_SgAsmCilGenericParamConstraintTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilGenericParamConstraintTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilGenericParamConstraintTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilGenericParamConstraintTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilGenericParamConstraintTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilGenericParamConstraintTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilGenericParamConstraintTable() {
        return stringify::E_SgAsmCilGenericParamConstraintTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1503
namespace stringify {
    const char* E_SgAsmCilGenericParamTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilGenericParamTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilGenericParamTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilGenericParamTable(i);
        if (s.empty())
            s = "(E_SgAsmCilGenericParamTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilGenericParamTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilGenericParamTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilGenericParamTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilGenericParamTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilGenericParamTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilGenericParamTable() {
        return stringify::E_SgAsmCilGenericParamTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1506
namespace stringify {
    const char* E_SgAsmCilImplMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilImplMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilImplMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilImplMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilImplMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilImplMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilImplMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilImplMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilImplMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilImplMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilImplMapTable() {
        return stringify::E_SgAsmCilImplMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1509
namespace stringify {
    const char* E_SgAsmCilInterfaceImplTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilInterfaceImplTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilInterfaceImplTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilInterfaceImplTable(i);
        if (s.empty())
            s = "(E_SgAsmCilInterfaceImplTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilInterfaceImplTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilInterfaceImplTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilInterfaceImplTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilInterfaceImplTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilInterfaceImplTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilInterfaceImplTable() {
        return stringify::E_SgAsmCilInterfaceImplTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1512
namespace stringify {
    const char* E_SgAsmCilManifestResourceTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilManifestResourceTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilManifestResourceTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilManifestResourceTable(i);
        if (s.empty())
            s = "(E_SgAsmCilManifestResourceTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilManifestResourceTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilManifestResourceTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilManifestResourceTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilManifestResourceTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilManifestResourceTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilManifestResourceTable() {
        return stringify::E_SgAsmCilManifestResourceTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1515
namespace stringify {
    const char* E_SgAsmCilMemberRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMemberRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMemberRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMemberRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMemberRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMemberRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMemberRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMemberRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMemberRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMemberRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMemberRefTable() {
        return stringify::E_SgAsmCilMemberRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1518
namespace stringify {
    const char* E_SgAsmCilMethodDefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodDefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodDefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodDefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodDefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodDefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodDefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodDefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodDefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodDefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodDefTable() {
        return stringify::E_SgAsmCilMethodDefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1521
namespace stringify {
    const char* E_SgAsmCilMethodImplTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodImplTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodImplTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodImplTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodImplTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodImplTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodImplTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodImplTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodImplTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodImplTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodImplTable() {
        return stringify::E_SgAsmCilMethodImplTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1524
namespace stringify {
    const char* E_SgAsmCilMethodSemanticsTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodSemanticsTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodSemanticsTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodSemanticsTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodSemanticsTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodSemanticsTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodSemanticsTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodSemanticsTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodSemanticsTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodSemanticsTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodSemanticsTable() {
        return stringify::E_SgAsmCilMethodSemanticsTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1527
namespace stringify {
    const char* E_SgAsmCilMethodSpecTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMethodSpecTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilMethodSpecTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMethodSpecTable(i);
        if (s.empty())
            s = "(E_SgAsmCilMethodSpecTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMethodSpecTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMethodSpecTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMethodSpecTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMethodSpecTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMethodSpecTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMethodSpecTable() {
        return stringify::E_SgAsmCilMethodSpecTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1530
namespace stringify {
    const char* E_SgAsmCilModuleRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilModuleRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilModuleRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilModuleRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilModuleRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilModuleRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilModuleRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilModuleRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilModuleRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilModuleRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilModuleRefTable() {
        return stringify::E_SgAsmCilModuleRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1533
namespace stringify {
    const char* E_SgAsmCilModuleTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilModuleTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilModuleTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilModuleTable(i);
        if (s.empty())
            s = "(E_SgAsmCilModuleTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilModuleTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilModuleTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilModuleTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilModuleTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilModuleTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilModuleTable() {
        return stringify::E_SgAsmCilModuleTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1536
namespace stringify {
    const char* E_SgAsmCilNestedClassTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilNestedClassTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilNestedClassTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilNestedClassTable(i);
        if (s.empty())
            s = "(E_SgAsmCilNestedClassTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilNestedClassTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilNestedClassTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilNestedClassTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilNestedClassTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilNestedClassTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilNestedClassTable() {
        return stringify::E_SgAsmCilNestedClassTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1539
namespace stringify {
    const char* E_SgAsmCilParamTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilParamTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilParamTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilParamTable(i);
        if (s.empty())
            s = "(E_SgAsmCilParamTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilParamTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilParamTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilParamTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilParamTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilParamTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilParamTable() {
        return stringify::E_SgAsmCilParamTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1542
namespace stringify {
    const char* E_SgAsmCilPropertyMapTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilPropertyMapTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilPropertyMapTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilPropertyMapTable(i);
        if (s.empty())
            s = "(E_SgAsmCilPropertyMapTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilPropertyMapTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilPropertyMapTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilPropertyMapTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilPropertyMapTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilPropertyMapTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilPropertyMapTable() {
        return stringify::E_SgAsmCilPropertyMapTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1545
namespace stringify {
    const char* E_SgAsmCilPropertyTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilPropertyTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilPropertyTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilPropertyTable(i);
        if (s.empty())
            s = "(E_SgAsmCilPropertyTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilPropertyTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilPropertyTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilPropertyTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilPropertyTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilPropertyTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilPropertyTable() {
        return stringify::E_SgAsmCilPropertyTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1548
namespace stringify {
    const char* E_SgAsmCilStandAloneSigTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilStandAloneSigTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilStandAloneSigTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilStandAloneSigTable(i);
        if (s.empty())
            s = "(E_SgAsmCilStandAloneSigTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilStandAloneSigTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilStandAloneSigTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilStandAloneSigTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilStandAloneSigTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilStandAloneSigTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilStandAloneSigTable() {
        return stringify::E_SgAsmCilStandAloneSigTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1551
namespace stringify {
    const char* E_SgAsmCilTypeDefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeDefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeDefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeDefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeDefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeDefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeDefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeDefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeDefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeDefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeDefTable() {
        return stringify::E_SgAsmCilTypeDefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1554
namespace stringify {
    const char* E_SgAsmCilTypeRefTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeRefTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeRefTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeRefTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeRefTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeRefTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeRefTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeRefTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeRefTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeRefTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeRefTable() {
        return stringify::E_SgAsmCilTypeRefTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1557
namespace stringify {
    const char* E_SgAsmCilTypeSpecTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilTypeSpecTable_elements";
            default: return "";
        }
    }

    std::string E_SgAsmCilTypeSpecTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilTypeSpecTable(i);
        if (s.empty())
            s = "(E_SgAsmCilTypeSpecTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilTypeSpecTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilTypeSpecTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilTypeSpecTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilTypeSpecTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilTypeSpecTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilTypeSpecTable() {
        return stringify::E_SgAsmCilTypeSpecTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1560
namespace stringify {
    const char* E_SgAsmCilMetadataRoot(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilMetadataRoot_Streams";
            default: return "";
        }
    }

    std::string E_SgAsmCilMetadataRoot(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilMetadataRoot(i);
        if (s.empty())
            s = "(E_SgAsmCilMetadataRoot)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilMetadataRoot() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilMetadataRoot(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilMetadataRoot(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilMetadataRoot)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilMetadataRoot::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilMetadataRoot() {
        return stringify::E_SgAsmCilMetadataRoot();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1563
namespace stringify {
    const char* E_SgAsmCoffSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolList() {
        return stringify::E_SgAsmCoffSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1566
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnitList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnitList_cu_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnitList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnitList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnitList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnitList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnitList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnitList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnitList() {
        return stringify::E_SgAsmDwarfCompilationUnitList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1569
namespace stringify {
    const char* E_SgAsmDwarfArrayType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfArrayType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfArrayType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfArrayType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfArrayType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfArrayType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfArrayType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfArrayType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfArrayType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfArrayType() {
        return stringify::E_SgAsmDwarfArrayType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1572
namespace stringify {
    const char* E_SgAsmDwarfClassType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfClassType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfClassType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfClassType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfClassType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfClassType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfClassType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfClassType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfClassType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfClassType() {
        return stringify::E_SgAsmDwarfClassType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1575
namespace stringify {
    const char* E_SgAsmDwarfCommonBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCommonBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCommonBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCommonBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCommonBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCommonBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCommonBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCommonBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCommonBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCommonBlock() {
        return stringify::E_SgAsmDwarfCommonBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1578
namespace stringify {
    const char* E_SgAsmDwarfCompilationUnit(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfCompilationUnit_line_info";
            case 1L: return "SgAsmDwarfCompilationUnit_language_constructs";
            case 2L: return "SgAsmDwarfCompilationUnit_macro_info";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfCompilationUnit(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfCompilationUnit(i);
        if (s.empty())
            s = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfCompilationUnit() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfCompilationUnit(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfCompilationUnit(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfCompilationUnit)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfCompilationUnit::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfCompilationUnit() {
        return stringify::E_SgAsmDwarfCompilationUnit();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1581
namespace stringify {
    const char* E_SgAsmDwarfEnumerationType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfEnumerationType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfEnumerationType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfEnumerationType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfEnumerationType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfEnumerationType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfEnumerationType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfEnumerationType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfEnumerationType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfEnumerationType() {
        return stringify::E_SgAsmDwarfEnumerationType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1584
namespace stringify {
    const char* E_SgAsmDwarfInlinedSubroutine(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfInlinedSubroutine_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfInlinedSubroutine(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfInlinedSubroutine(i);
        if (s.empty())
            s = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfInlinedSubroutine() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfInlinedSubroutine(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfInlinedSubroutine(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfInlinedSubroutine)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfInlinedSubroutine() {
        return stringify::E_SgAsmDwarfInlinedSubroutine();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1587
namespace stringify {
    const char* E_SgAsmDwarfLexicalBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLexicalBlock_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLexicalBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLexicalBlock(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLexicalBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLexicalBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLexicalBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLexicalBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLexicalBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLexicalBlock() {
        return stringify::E_SgAsmDwarfLexicalBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1590
namespace stringify {
    const char* E_SgAsmDwarfNamespace(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfNamespace_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfNamespace(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfNamespace(i);
        if (s.empty())
            s = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfNamespace() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfNamespace(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfNamespace(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfNamespace)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfNamespace::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfNamespace() {
        return stringify::E_SgAsmDwarfNamespace();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1593
namespace stringify {
    const char* E_SgAsmDwarfStructureType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfStructureType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfStructureType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfStructureType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfStructureType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfStructureType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfStructureType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfStructureType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfStructureType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfStructureType() {
        return stringify::E_SgAsmDwarfStructureType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1596
namespace stringify {
    const char* E_SgAsmDwarfSubprogram(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubprogram_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubprogram(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubprogram(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubprogram() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubprogram(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubprogram(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubprogram)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubprogram::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubprogram() {
        return stringify::E_SgAsmDwarfSubprogram();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1599
namespace stringify {
    const char* E_SgAsmDwarfSubroutineType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfSubroutineType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfSubroutineType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfSubroutineType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfSubroutineType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfSubroutineType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfSubroutineType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfSubroutineType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfSubroutineType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfSubroutineType() {
        return stringify::E_SgAsmDwarfSubroutineType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1602
namespace stringify {
    const char* E_SgAsmDwarfUnionType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfUnionType_body";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfUnionType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfUnionType(i);
        if (s.empty())
            s = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfUnionType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfUnionType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfUnionType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfUnionType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfUnionType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfUnionType() {
        return stringify::E_SgAsmDwarfUnionType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1605
namespace stringify {
    const char* E_SgAsmDwarfConstructList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfConstructList_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfConstructList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfConstructList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfConstructList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfConstructList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfConstructList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfConstructList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfConstructList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfConstructList() {
        return stringify::E_SgAsmDwarfConstructList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1608
namespace stringify {
    const char* E_SgAsmDwarfLineList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfLineList_line_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfLineList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfLineList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfLineList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfLineList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfLineList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfLineList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfLineList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfLineList() {
        return stringify::E_SgAsmDwarfLineList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1611
namespace stringify {
    const char* E_SgAsmDwarfMacroList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDwarfMacroList_macro_list";
            default: return "";
        }
    }

    std::string E_SgAsmDwarfMacroList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDwarfMacroList(i);
        if (s.empty())
            s = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDwarfMacroList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDwarfMacroList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDwarfMacroList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDwarfMacroList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDwarfMacroList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDwarfMacroList() {
        return stringify::E_SgAsmDwarfMacroList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1614
namespace stringify {
    const char* E_SgAsmElfDynamicEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicEntry() {
        return stringify::E_SgAsmElfDynamicEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1617
namespace stringify {
    const char* E_SgAsmElfEHFrameEntryCI(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameEntryCI_fd_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameEntryCI(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameEntryCI(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameEntryCI() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameEntryCI(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameEntryCI(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameEntryCI)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameEntryCI() {
        return stringify::E_SgAsmElfEHFrameEntryCI();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1620
namespace stringify {
    const char* E_SgAsmElfNoteEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteEntry_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteEntry() {
        return stringify::E_SgAsmElfNoteEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1623
namespace stringify {
    const char* E_SgAsmElfRelocEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocEntryList() {
        return stringify::E_SgAsmElfRelocEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1626
namespace stringify {
    const char* E_SgAsmElfSegmentTableEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSegmentTableEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSegmentTableEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSegmentTableEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSegmentTableEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSegmentTableEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSegmentTableEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSegmentTableEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSegmentTableEntryList() {
        return stringify::E_SgAsmElfSegmentTableEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1629
namespace stringify {
    const char* E_SgAsmElfSymbolList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolList_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolList() {
        return stringify::E_SgAsmElfSymbolList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1632
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAux() {
        return stringify::E_SgAsmElfSymverDefinedAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1635
namespace stringify {
    const char* E_SgAsmElfSymverDefinedAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedAuxList() {
        return stringify::E_SgAsmElfSymverDefinedAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1638
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntry() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntry() {
        return stringify::E_SgAsmElfSymverDefinedEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1641
namespace stringify {
    const char* E_SgAsmElfSymverDefinedEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedEntryList() {
        return stringify::E_SgAsmElfSymverDefinedEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1644
namespace stringify {
    const char* E_SgAsmElfSymverEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverEntryList() {
        return stringify::E_SgAsmElfSymverEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1647
namespace stringify {
    const char* E_SgAsmElfSymverNeededAux(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAux_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAux(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAux(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAux() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAux(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAux(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAux)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAux::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAux() {
        return stringify::E_SgAsmElfSymverNeededAux();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1650
namespace stringify {
    const char* E_SgAsmElfSymverNeededAuxList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededAuxList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededAuxList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededAuxList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededAuxList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededAuxList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededAuxList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededAuxList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededAuxList() {
        return stringify::E_SgAsmElfSymverNeededAuxList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1653
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntry_fileName";
            case 1L: return "SgAsmElfSymverNeededEntry_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntry(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntry() {
        return stringify::E_SgAsmElfSymverNeededEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1656
namespace stringify {
    const char* E_SgAsmElfSymverNeededEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededEntryList_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededEntryList(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededEntryList() {
        return stringify::E_SgAsmElfSymverNeededEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1659
namespace stringify {
    const char* E_SgAsmGenericDLL(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericDLL_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericDLL(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericDLL(i);
        if (s.empty())
            s = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericDLL() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericDLL(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericDLL(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericDLL)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericDLL::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericDLL() {
        return stringify::E_SgAsmGenericDLL();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1662
namespace stringify {
    const char* E_SgAsmGenericFile(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFile_dwarfInfo";
            case 1L: return "SgAsmGenericFile_headers";
            case 2L: return "SgAsmGenericFile_holes";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFile(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFile(i);
        if (s.empty())
            s = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFile() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFile(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFile(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFile)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFile::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFile() {
        return stringify::E_SgAsmGenericFile();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1665
namespace stringify {
    const char* E_SgAsmGenericHeaderList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeaderList_headers";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeaderList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeaderList(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeaderList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeaderList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeaderList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeaderList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeaderList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeaderList() {
        return stringify::E_SgAsmGenericHeaderList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1668
namespace stringify {
    const char* E_SgAsmCliHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCliHeader_metadataRoot";
            default: return "";
        }
    }

    std::string E_SgAsmCliHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCliHeader(i);
        if (s.empty())
            s = "(E_SgAsmCliHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCliHeader() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCliHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCliHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCliHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCliHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCliHeader() {
        return stringify::E_SgAsmCliHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1671
namespace stringify {
    const char* E_SgAsmCoffSymbolTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbolTable_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbolTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbolTable(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbolTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbolTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbolTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbolTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbolTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbolTable() {
        return stringify::E_SgAsmCoffSymbolTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1674
namespace stringify {
    const char* E_SgAsmElfDynamicSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfDynamicSection_sectionEntry";
            case 1L: return "SgAsmElfDynamicSection_segmentEntry";
            case 2L: return "SgAsmElfDynamicSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfDynamicSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfDynamicSection(i);
        if (s.empty())
            s = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfDynamicSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfDynamicSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfDynamicSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfDynamicSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfDynamicSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfDynamicSection() {
        return stringify::E_SgAsmElfDynamicSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1677
namespace stringify {
    const char* E_SgAsmElfEHFrameSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfEHFrameSection_sectionEntry";
            case 1L: return "SgAsmElfEHFrameSection_segmentEntry";
            case 2L: return "SgAsmElfEHFrameSection_ci_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfEHFrameSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfEHFrameSection(i);
        if (s.empty())
            s = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfEHFrameSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfEHFrameSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfEHFrameSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfEHFrameSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfEHFrameSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfEHFrameSection() {
        return stringify::E_SgAsmElfEHFrameSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1680
namespace stringify {
    const char* E_SgAsmElfNoteSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfNoteSection_sectionEntry";
            case 1L: return "SgAsmElfNoteSection_segmentEntry";
            case 2L: return "SgAsmElfNoteSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfNoteSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfNoteSection(i);
        if (s.empty())
            s = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfNoteSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfNoteSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfNoteSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfNoteSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfNoteSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfNoteSection() {
        return stringify::E_SgAsmElfNoteSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1683
namespace stringify {
    const char* E_SgAsmElfRelocSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfRelocSection_sectionEntry";
            case 1L: return "SgAsmElfRelocSection_segmentEntry";
            case 2L: return "SgAsmElfRelocSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfRelocSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfRelocSection(i);
        if (s.empty())
            s = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfRelocSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfRelocSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfRelocSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfRelocSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfRelocSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfRelocSection() {
        return stringify::E_SgAsmElfRelocSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1686
namespace stringify {
    const char* E_SgAsmElfStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfStringSection_sectionEntry";
            case 1L: return "SgAsmElfStringSection_segmentEntry";
            default: return "";
        }
    }

    std::string E_SgAsmElfStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfStringSection(i);
        if (s.empty())
            s = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfStringSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfStringSection() {
        return stringify::E_SgAsmElfStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1689
namespace stringify {
    const char* E_SgAsmElfSymbolSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbolSection_sectionEntry";
            case 1L: return "SgAsmElfSymbolSection_segmentEntry";
            case 2L: return "SgAsmElfSymbolSection_symbols";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbolSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbolSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbolSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbolSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbolSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbolSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbolSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbolSection() {
        return stringify::E_SgAsmElfSymbolSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1692
namespace stringify {
    const char* E_SgAsmElfSymverDefinedSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverDefinedSection_sectionEntry";
            case 1L: return "SgAsmElfSymverDefinedSection_segmentEntry";
            case 2L: return "SgAsmElfSymverDefinedSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverDefinedSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverDefinedSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverDefinedSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverDefinedSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverDefinedSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverDefinedSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverDefinedSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverDefinedSection() {
        return stringify::E_SgAsmElfSymverDefinedSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1695
namespace stringify {
    const char* E_SgAsmElfSymverNeededSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverNeededSection_sectionEntry";
            case 1L: return "SgAsmElfSymverNeededSection_segmentEntry";
            case 2L: return "SgAsmElfSymverNeededSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverNeededSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverNeededSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverNeededSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverNeededSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverNeededSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverNeededSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverNeededSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverNeededSection() {
        return stringify::E_SgAsmElfSymverNeededSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1698
namespace stringify {
    const char* E_SgAsmElfSymverSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymverSection_sectionEntry";
            case 1L: return "SgAsmElfSymverSection_segmentEntry";
            case 2L: return "SgAsmElfSymverSection_entries";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymverSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymverSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymverSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymverSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymverSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymverSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymverSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymverSection() {
        return stringify::E_SgAsmElfSymverSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1701
namespace stringify {
    const char* E_SgAsmElfSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSection_sectionEntry";
            case 1L: return "SgAsmElfSection_segmentEntry";
            default: return "";
        }
    }

    std::string E_SgAsmElfSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSection(i);
        if (s.empty())
            s = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSection() {
        return stringify::E_SgAsmElfSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1704
namespace stringify {
    const char* E_SgAsmDOSFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmDOSFileHeader_executableFormat";
            case 1L: return "SgAsmDOSFileHeader_dlls";
            case 2L: return "SgAsmDOSFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmDOSFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmDOSFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmDOSFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmDOSFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmDOSFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmDOSFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmDOSFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmDOSFileHeader() {
        return stringify::E_SgAsmDOSFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1707
namespace stringify {
    const char* E_SgAsmElfFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfFileHeader_executableFormat";
            case 1L: return "SgAsmElfFileHeader_dlls";
            case 2L: return "SgAsmElfFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmElfFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfFileHeader() {
        return stringify::E_SgAsmElfFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1710
namespace stringify {
    const char* E_SgAsmJvmFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmFileHeader_executableFormat";
            case 1L: return "SgAsmJvmFileHeader_dlls";
            case 2L: return "SgAsmJvmFileHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmJvmFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmJvmFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmFileHeader() {
        return stringify::E_SgAsmJvmFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1713
namespace stringify {
    const char* E_SgAsmLEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEFileHeader_executableFormat";
            case 1L: return "SgAsmLEFileHeader_dlls";
            case 2L: return "SgAsmLEFileHeader_sections";
            case 3L: return "SgAsmLEFileHeader_dos2Header";
            case 4L: return "SgAsmLEFileHeader_pageTable";
            case 5L: return "SgAsmLEFileHeader_residentNameTable";
            case 6L: return "SgAsmLEFileHeader_nonresidentNameTable";
            case 7L: return "SgAsmLEFileHeader_entryTable";
            case 8L: return "SgAsmLEFileHeader_relocationTable";
            default: return "";
        }
    }

    std::string E_SgAsmLEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEFileHeader() {
        return stringify::E_SgAsmLEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1716
namespace stringify {
    const char* E_SgAsmNEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEFileHeader_executableFormat";
            case 1L: return "SgAsmNEFileHeader_dlls";
            case 2L: return "SgAsmNEFileHeader_sections";
            case 3L: return "SgAsmNEFileHeader_dos2Header";
            case 4L: return "SgAsmNEFileHeader_residentNameTable";
            case 5L: return "SgAsmNEFileHeader_nonresidentNameTable";
            case 6L: return "SgAsmNEFileHeader_moduleTable";
            case 7L: return "SgAsmNEFileHeader_entryTable";
            default: return "";
        }
    }

    std::string E_SgAsmNEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEFileHeader() {
        return stringify::E_SgAsmNEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1719
namespace stringify {
    const char* E_SgAsmPEFileHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEFileHeader_executableFormat";
            case 1L: return "SgAsmPEFileHeader_dlls";
            case 2L: return "SgAsmPEFileHeader_sections";
            case 3L: return "SgAsmPEFileHeader_rvaSizePairs";
            default: return "";
        }
    }

    std::string E_SgAsmPEFileHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEFileHeader(i);
        if (s.empty())
            s = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEFileHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEFileHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEFileHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEFileHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEFileHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEFileHeader() {
        return stringify::E_SgAsmPEFileHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1722
namespace stringify {
    const char* E_SgAsmGenericHeader(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericHeader_executableFormat";
            case 1L: return "SgAsmGenericHeader_dlls";
            case 2L: return "SgAsmGenericHeader_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericHeader(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericHeader(i);
        if (s.empty())
            s = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericHeader() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericHeader(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericHeader(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericHeader)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericHeader::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericHeader() {
        return stringify::E_SgAsmGenericHeader();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1725
namespace stringify {
    const char* E_SgAsmJvmAttributeTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmAttributeTable_attributes";
            default: return "";
        }
    }

    std::string E_SgAsmJvmAttributeTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmAttributeTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmAttributeTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmAttributeTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmAttributeTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmAttributeTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmAttributeTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmAttributeTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmAttributeTable() {
        return stringify::E_SgAsmJvmAttributeTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1728
namespace stringify {
    const char* E_SgAsmJvmFieldTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmFieldTable_fields";
            default: return "";
        }
    }

    std::string E_SgAsmJvmFieldTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmFieldTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmFieldTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmFieldTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmFieldTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmFieldTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmFieldTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmFieldTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmFieldTable() {
        return stringify::E_SgAsmJvmFieldTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1731
namespace stringify {
    const char* E_SgAsmJvmMethodTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmMethodTable_methods";
            default: return "";
        }
    }

    std::string E_SgAsmJvmMethodTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmMethodTable(i);
        if (s.empty())
            s = "(E_SgAsmJvmMethodTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmMethodTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmMethodTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmMethodTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmMethodTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmMethodTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmMethodTable() {
        return stringify::E_SgAsmJvmMethodTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1734
namespace stringify {
    const char* E_SgAsmLEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryTable() {
        return stringify::E_SgAsmLEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1737
namespace stringify {
    const char* E_SgAsmLEPageTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEPageTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEPageTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEPageTable(i);
        if (s.empty())
            s = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEPageTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEPageTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEPageTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEPageTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEPageTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEPageTable() {
        return stringify::E_SgAsmLEPageTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1740
namespace stringify {
    const char* E_SgAsmLERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLERelocTable() {
        return stringify::E_SgAsmLERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1743
namespace stringify {
    const char* E_SgAsmLESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLESection_sectionTableEntry";
            default: return "";
        }
    }

    std::string E_SgAsmLESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLESection(i);
        if (s.empty())
            s = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLESection() {
        return stringify::E_SgAsmLESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1746
namespace stringify {
    const char* E_SgAsmNEEntryTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEEntryTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNEEntryTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEEntryTable(i);
        if (s.empty())
            s = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEEntryTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEEntryTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEEntryTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEEntryTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEEntryTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEEntryTable() {
        return stringify::E_SgAsmNEEntryTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1749
namespace stringify {
    const char* E_SgAsmNEModuleTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNEModuleTable_strtab";
            default: return "";
        }
    }

    std::string E_SgAsmNEModuleTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNEModuleTable(i);
        if (s.empty())
            s = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNEModuleTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNEModuleTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNEModuleTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNEModuleTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNEModuleTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNEModuleTable() {
        return stringify::E_SgAsmNEModuleTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1752
namespace stringify {
    const char* E_SgAsmNERelocTable(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNERelocTable_entries";
            default: return "";
        }
    }

    std::string E_SgAsmNERelocTable(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNERelocTable(i);
        if (s.empty())
            s = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNERelocTable() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNERelocTable(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNERelocTable(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNERelocTable)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNERelocTable::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNERelocTable() {
        return stringify::E_SgAsmNERelocTable();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1755
namespace stringify {
    const char* E_SgAsmNESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNESection_sectionTableEntry";
            case 1L: return "SgAsmNESection_relocationTable";
            default: return "";
        }
    }

    std::string E_SgAsmNESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNESection(i);
        if (s.empty())
            s = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNESection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNESection() {
        return stringify::E_SgAsmNESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1758
namespace stringify {
    const char* E_SgAsmPEExportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportSection_section_entry";
            case 1L: return "SgAsmPEExportSection_exportDirectory";
            case 2L: return "SgAsmPEExportSection_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportSection() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportSection() {
        return stringify::E_SgAsmPEExportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1761
namespace stringify {
    const char* E_SgAsmPEImportSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportSection_section_entry";
            case 1L: return "SgAsmPEImportSection_importDirectories";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportSection(i);
        if (s.empty())
            s = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportSection() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportSection() {
        return stringify::E_SgAsmPEImportSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1764
namespace stringify {
    const char* E_SgAsmPEStringSection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEStringSection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPEStringSection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEStringSection(i);
        if (s.empty())
            s = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEStringSection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEStringSection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEStringSection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEStringSection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEStringSection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEStringSection() {
        return stringify::E_SgAsmPEStringSection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1767
namespace stringify {
    const char* E_SgAsmPESection(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPESection_section_entry";
            default: return "";
        }
    }

    std::string E_SgAsmPESection(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPESection(i);
        if (s.empty())
            s = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPESection() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPESection(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPESection(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPESection)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPESection::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPESection() {
        return stringify::E_SgAsmPESection();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1770
namespace stringify {
    const char* E_SgAsmGenericSectionList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSectionList_sections";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSectionList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSectionList(i);
        if (s.empty())
            s = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSectionList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSectionList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSectionList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSectionList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSectionList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSectionList() {
        return stringify::E_SgAsmGenericSectionList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1773
namespace stringify {
    const char* E_SgAsmCoffSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCoffSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmCoffSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCoffSymbol(i);
        if (s.empty())
            s = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCoffSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCoffSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCoffSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCoffSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCoffSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCoffSymbol() {
        return stringify::E_SgAsmCoffSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1776
namespace stringify {
    const char* E_SgAsmElfSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmElfSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmElfSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmElfSymbol(i);
        if (s.empty())
            s = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmElfSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmElfSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmElfSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmElfSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmElfSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmElfSymbol() {
        return stringify::E_SgAsmElfSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1779
namespace stringify {
    const char* E_SgAsmGenericSymbol(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericSymbol_name";
            default: return "";
        }
    }

    std::string E_SgAsmGenericSymbol(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericSymbol(i);
        if (s.empty())
            s = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericSymbol() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericSymbol(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericSymbol(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericSymbol)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericSymbol::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericSymbol() {
        return stringify::E_SgAsmGenericSymbol();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1782
namespace stringify {
    const char* E_SgAsmLEEntryPoint(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmLEEntryPoint_entries";
            default: return "";
        }
    }

    std::string E_SgAsmLEEntryPoint(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmLEEntryPoint(i);
        if (s.empty())
            s = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmLEEntryPoint() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmLEEntryPoint(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmLEEntryPoint(i);
        if (retval.empty()) {
            retval = "(E_SgAsmLEEntryPoint)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmLEEntryPoint::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmLEEntryPoint() {
        return stringify::E_SgAsmLEEntryPoint();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1785
namespace stringify {
    const char* E_SgAsmPEExportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportDirectory_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportDirectory() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportDirectory() {
        return stringify::E_SgAsmPEExportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1788
namespace stringify {
    const char* E_SgAsmPEExportEntry(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntry_name";
            case 1L: return "SgAsmPEExportEntry_forwarder";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntry(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntry(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntry() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntry(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntry() {
        return stringify::E_SgAsmPEExportEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1791
namespace stringify {
    const char* E_SgAsmPEExportEntryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEExportEntryList_exports";
            default: return "";
        }
    }

    std::string E_SgAsmPEExportEntryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEExportEntryList(i);
        if (s.empty())
            s = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEExportEntryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEExportEntryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEExportEntryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEExportEntryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEExportEntryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEExportEntryList() {
        return stringify::E_SgAsmPEExportEntryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1794
namespace stringify {
    const char* E_SgAsmPEImportDirectory(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectory_dllName";
            case 1L: return "SgAsmPEImportDirectory_imports";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectory(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectory(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectory() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectory(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectory(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectory)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectory::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectory() {
        return stringify::E_SgAsmPEImportDirectory();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1797
namespace stringify {
    const char* E_SgAsmPEImportDirectoryList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportDirectoryList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportDirectoryList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportDirectoryList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportDirectoryList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportDirectoryList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportDirectoryList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportDirectoryList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportDirectoryList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportDirectoryList() {
        return stringify::E_SgAsmPEImportDirectoryList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1800
namespace stringify {
    const char* E_SgAsmPEImportItem(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItem_name";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItem(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItem(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItem() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItem(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItem(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItem)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItem::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItem() {
        return stringify::E_SgAsmPEImportItem();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1803
namespace stringify {
    const char* E_SgAsmPEImportItemList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPEImportItemList_vector";
            default: return "";
        }
    }

    std::string E_SgAsmPEImportItemList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPEImportItemList(i);
        if (s.empty())
            s = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPEImportItemList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPEImportItemList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPEImportItemList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPEImportItemList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPEImportItemList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPEImportItemList() {
        return stringify::E_SgAsmPEImportItemList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1806
namespace stringify {
    const char* E_SgAsmPERVASizePairList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPERVASizePairList_pairs";
            default: return "";
        }
    }

    std::string E_SgAsmPERVASizePairList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPERVASizePairList(i);
        if (s.empty())
            s = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPERVASizePairList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPERVASizePairList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPERVASizePairList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPERVASizePairList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPERVASizePairList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPERVASizePairList() {
        return stringify::E_SgAsmPERVASizePairList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1809
namespace stringify {
    const char* E_SgAsmBinaryAdd(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAdd_lhs";
            case 1L: return "SgAsmBinaryAdd_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAdd(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAdd(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAdd() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAdd(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAdd(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAdd)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAdd::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAdd() {
        return stringify::E_SgAsmBinaryAdd();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1812
namespace stringify {
    const char* E_SgAsmBinaryAsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryAsr_lhs";
            case 1L: return "SgAsmBinaryAsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryAsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryAsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryAsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryAsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryAsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryAsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryAsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryAsr() {
        return stringify::E_SgAsmBinaryAsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1815
namespace stringify {
    const char* E_SgAsmBinaryConcat(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryConcat_lhs";
            case 1L: return "SgAsmBinaryConcat_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryConcat(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryConcat(i);
        if (s.empty())
            s = "(E_SgAsmBinaryConcat)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryConcat() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryConcat(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryConcat(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryConcat)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryConcat::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryConcat() {
        return stringify::E_SgAsmBinaryConcat();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1818
namespace stringify {
    const char* E_SgAsmBinaryDivide(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryDivide_lhs";
            case 1L: return "SgAsmBinaryDivide_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryDivide(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryDivide(i);
        if (s.empty())
            s = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryDivide() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryDivide(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryDivide(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryDivide)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryDivide::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryDivide() {
        return stringify::E_SgAsmBinaryDivide();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1821
namespace stringify {
    const char* E_SgAsmBinaryLsl(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsl_lhs";
            case 1L: return "SgAsmBinaryLsl_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsl(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsl(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsl(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsl() {
        return stringify::E_SgAsmBinaryLsl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1824
namespace stringify {
    const char* E_SgAsmBinaryLsr(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryLsr_lhs";
            case 1L: return "SgAsmBinaryLsr_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryLsr(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryLsr(i);
        if (s.empty())
            s = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryLsr() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryLsr(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryLsr(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryLsr)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryLsr::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryLsr() {
        return stringify::E_SgAsmBinaryLsr();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1827
namespace stringify {
    const char* E_SgAsmBinaryMod(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMod_lhs";
            case 1L: return "SgAsmBinaryMod_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMod(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMod(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMod() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMod(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMod(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMod)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMod::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMod() {
        return stringify::E_SgAsmBinaryMod();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1830
namespace stringify {
    const char* E_SgAsmBinaryMsl(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMsl_lhs";
            case 1L: return "SgAsmBinaryMsl_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMsl(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMsl(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMsl)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMsl() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMsl(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMsl(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMsl)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMsl::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMsl() {
        return stringify::E_SgAsmBinaryMsl();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1833
namespace stringify {
    const char* E_SgAsmBinaryMultiply(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryMultiply_lhs";
            case 1L: return "SgAsmBinaryMultiply_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryMultiply(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryMultiply(i);
        if (s.empty())
            s = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryMultiply() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryMultiply(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryMultiply(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryMultiply)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryMultiply::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryMultiply() {
        return stringify::E_SgAsmBinaryMultiply();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1836
namespace stringify {
    const char* E_SgAsmBinaryPostupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryPostupdate_lhs";
            case 1L: return "SgAsmBinaryPostupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryPostupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryPostupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryPostupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryPostupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryPostupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryPostupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryPostupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryPostupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryPostupdate() {
        return stringify::E_SgAsmBinaryPostupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1839
namespace stringify {
    const char* E_SgAsmBinaryPreupdate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryPreupdate_lhs";
            case 1L: return "SgAsmBinaryPreupdate_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryPreupdate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryPreupdate(i);
        if (s.empty())
            s = "(E_SgAsmBinaryPreupdate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryPreupdate() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryPreupdate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryPreupdate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryPreupdate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryPreupdate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryPreupdate() {
        return stringify::E_SgAsmBinaryPreupdate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1842
namespace stringify {
    const char* E_SgAsmBinaryRor(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryRor_lhs";
            case 1L: return "SgAsmBinaryRor_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryRor(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryRor(i);
        if (s.empty())
            s = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryRor() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryRor(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryRor(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryRor)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryRor::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryRor() {
        return stringify::E_SgAsmBinaryRor();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1845
namespace stringify {
    const char* E_SgAsmBinarySubtract(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinarySubtract_lhs";
            case 1L: return "SgAsmBinarySubtract_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinarySubtract(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinarySubtract(i);
        if (s.empty())
            s = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinarySubtract() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinarySubtract(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinarySubtract(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinarySubtract)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinarySubtract::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinarySubtract() {
        return stringify::E_SgAsmBinarySubtract();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1848
namespace stringify {
    const char* E_SgAsmBinaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBinaryExpression_lhs";
            case 1L: return "SgAsmBinaryExpression_rhs";
            default: return "";
        }
    }

    std::string E_SgAsmBinaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBinaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBinaryExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBinaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBinaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBinaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBinaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBinaryExpression() {
        return stringify::E_SgAsmBinaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1851
namespace stringify {
    const char* E_SgAsmCommonSubExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCommonSubExpression_subexpression";
            default: return "";
        }
    }

    std::string E_SgAsmCommonSubExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCommonSubExpression(i);
        if (s.empty())
            s = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCommonSubExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCommonSubExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCommonSubExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCommonSubExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCommonSubExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCommonSubExpression() {
        return stringify::E_SgAsmCommonSubExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1854
namespace stringify {
    const char* E_SgAsmExprListExp(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmExprListExp_expressions";
            default: return "";
        }
    }

    std::string E_SgAsmExprListExp(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmExprListExp(i);
        if (s.empty())
            s = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmExprListExp() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmExprListExp(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmExprListExp(i);
        if (retval.empty()) {
            retval = "(E_SgAsmExprListExp)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmExprListExp::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmExprListExp() {
        return stringify::E_SgAsmExprListExp();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1857
namespace stringify {
    const char* E_SgAsmMemoryReferenceExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMemoryReferenceExpression_address";
            case 1L: return "SgAsmMemoryReferenceExpression_segment";
            default: return "";
        }
    }

    std::string E_SgAsmMemoryReferenceExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMemoryReferenceExpression(i);
        if (s.empty())
            s = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMemoryReferenceExpression() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMemoryReferenceExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMemoryReferenceExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMemoryReferenceExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMemoryReferenceExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMemoryReferenceExpression() {
        return stringify::E_SgAsmMemoryReferenceExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1860
namespace stringify {
    const char* E_SgAsmRegisterNames(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRegisterNames_registers";
            default: return "";
        }
    }

    std::string E_SgAsmRegisterNames(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRegisterNames(i);
        if (s.empty())
            s = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRegisterNames() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRegisterNames(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRegisterNames(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRegisterNames)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRegisterNames::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRegisterNames() {
        return stringify::E_SgAsmRegisterNames();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1863
namespace stringify {
    const char* E_SgAsmRiscOperation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmRiscOperation_operands";
            default: return "";
        }
    }

    std::string E_SgAsmRiscOperation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmRiscOperation(i);
        if (s.empty())
            s = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmRiscOperation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmRiscOperation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmRiscOperation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmRiscOperation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmRiscOperation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmRiscOperation() {
        return stringify::E_SgAsmRiscOperation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1866
namespace stringify {
    const char* E_SgAsmUnaryMinus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryMinus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryMinus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryMinus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryMinus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryMinus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryMinus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryMinus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryMinus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryMinus() {
        return stringify::E_SgAsmUnaryMinus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1869
namespace stringify {
    const char* E_SgAsmUnaryPlus(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryPlus_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryPlus(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryPlus(i);
        if (s.empty())
            s = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryPlus() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryPlus(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryPlus(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryPlus)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryPlus::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryPlus() {
        return stringify::E_SgAsmUnaryPlus();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1872
namespace stringify {
    const char* E_SgAsmUnaryRrx(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryRrx_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryRrx(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryRrx(i);
        if (s.empty())
            s = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryRrx() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryRrx(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryRrx(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryRrx)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryRrx::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryRrx() {
        return stringify::E_SgAsmUnaryRrx();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1875
namespace stringify {
    const char* E_SgAsmUnarySignedExtend(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnarySignedExtend_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnarySignedExtend(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnarySignedExtend(i);
        if (s.empty())
            s = "(E_SgAsmUnarySignedExtend)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnarySignedExtend() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnarySignedExtend(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnarySignedExtend(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnarySignedExtend)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnarySignedExtend::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnarySignedExtend() {
        return stringify::E_SgAsmUnarySignedExtend();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1878
namespace stringify {
    const char* E_SgAsmUnaryTruncate(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryTruncate_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryTruncate(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryTruncate(i);
        if (s.empty())
            s = "(E_SgAsmUnaryTruncate)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryTruncate() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryTruncate(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryTruncate(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryTruncate)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryTruncate::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryTruncate() {
        return stringify::E_SgAsmUnaryTruncate();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1881
namespace stringify {
    const char* E_SgAsmUnaryUnsignedExtend(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryUnsignedExtend_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryUnsignedExtend(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryUnsignedExtend(i);
        if (s.empty())
            s = "(E_SgAsmUnaryUnsignedExtend)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryUnsignedExtend() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryUnsignedExtend(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryUnsignedExtend(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryUnsignedExtend)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryUnsignedExtend::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryUnsignedExtend() {
        return stringify::E_SgAsmUnaryUnsignedExtend();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1884
namespace stringify {
    const char* E_SgAsmUnaryExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUnaryExpression_operand";
            default: return "";
        }
    }

    std::string E_SgAsmUnaryExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUnaryExpression(i);
        if (s.empty())
            s = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUnaryExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUnaryExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUnaryExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUnaryExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUnaryExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUnaryExpression() {
        return stringify::E_SgAsmUnaryExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1887
namespace stringify {
    const char* E_SgAsmFloatValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFloatValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmFloatValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFloatValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFloatValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFloatValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFloatValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFloatValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFloatValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFloatValueExpression() {
        return stringify::E_SgAsmFloatValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1890
namespace stringify {
    const char* E_SgAsmIntegerValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmIntegerValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmIntegerValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmIntegerValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmIntegerValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmIntegerValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmIntegerValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmIntegerValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmIntegerValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmIntegerValueExpression() {
        return stringify::E_SgAsmIntegerValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1893
namespace stringify {
    const char* E_SgAsmConstantExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmConstantExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmConstantExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmConstantExpression(i);
        if (s.empty())
            s = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmConstantExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmConstantExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmConstantExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmConstantExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmConstantExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmConstantExpression() {
        return stringify::E_SgAsmConstantExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1896
namespace stringify {
    const char* E_SgAsmValueExpression(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmValueExpression_unfoldedExpression";
            default: return "";
        }
    }

    std::string E_SgAsmValueExpression(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmValueExpression(i);
        if (s.empty())
            s = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmValueExpression() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmValueExpression(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmValueExpression(i);
        if (retval.empty()) {
            retval = "(E_SgAsmValueExpression)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmValueExpression::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmValueExpression() {
        return stringify::E_SgAsmValueExpression();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1899
namespace stringify {
    const char* E_SgAsmGenericFileList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmGenericFileList_files";
            default: return "";
        }
    }

    std::string E_SgAsmGenericFileList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmGenericFileList(i);
        if (s.empty())
            s = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmGenericFileList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmGenericFileList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmGenericFileList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmGenericFileList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmGenericFileList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmGenericFileList() {
        return stringify::E_SgAsmGenericFileList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1902
namespace stringify {
    const char* E_SgAsmInterpretation(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretation_globalBlock";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretation(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretation(i);
        if (s.empty())
            s = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretation() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretation(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretation(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretation)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretation::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretation() {
        return stringify::E_SgAsmInterpretation();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1905
namespace stringify {
    const char* E_SgAsmInterpretationList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInterpretationList_interpretations";
            default: return "";
        }
    }

    std::string E_SgAsmInterpretationList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInterpretationList(i);
        if (s.empty())
            s = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInterpretationList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInterpretationList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInterpretationList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInterpretationList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInterpretationList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInterpretationList() {
        return stringify::E_SgAsmInterpretationList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1908
namespace stringify {
    const char* E_SgAsmJvmField(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmField_attribute_table";
            default: return "";
        }
    }

    std::string E_SgAsmJvmField(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmField(i);
        if (s.empty())
            s = "(E_SgAsmJvmField)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmField() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmField(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmField(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmField)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmField::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmField() {
        return stringify::E_SgAsmJvmField();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1911
namespace stringify {
    const char* E_SgAsmJvmMethod(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmMethod_attribute_table";
            default: return "";
        }
    }

    std::string E_SgAsmJvmMethod(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmMethod(i);
        if (s.empty())
            s = "(E_SgAsmJvmMethod)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmMethod() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmMethod(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmMethod(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmMethod)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmMethod::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmMethod() {
        return stringify::E_SgAsmJvmMethod();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1914
namespace stringify {
    const char* E_SgAsmOperandList(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmOperandList_operands";
            default: return "";
        }
    }

    std::string E_SgAsmOperandList(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmOperandList(i);
        if (s.empty())
            s = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmOperandList() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmOperandList(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmOperandList(i);
        if (retval.empty()) {
            retval = "(E_SgAsmOperandList)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmOperandList::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmOperandList() {
        return stringify::E_SgAsmOperandList();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1917
namespace stringify {
    const char* E_SgAsmBlock(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmBlock_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmBlock(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmBlock(i);
        if (s.empty())
            s = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmBlock() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmBlock(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmBlock(i);
        if (retval.empty()) {
            retval = "(E_SgAsmBlock)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmBlock::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmBlock() {
        return stringify::E_SgAsmBlock();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1920
namespace stringify {
    const char* E_SgAsmCilInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmCilInstruction_operandList";
            case 1L: return "SgAsmCilInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmCilInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmCilInstruction(i);
        if (s.empty())
            s = "(E_SgAsmCilInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmCilInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmCilInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmCilInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmCilInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmCilInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmCilInstruction() {
        return stringify::E_SgAsmCilInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1923
namespace stringify {
    const char* E_SgAsmJvmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmJvmInstruction_operandList";
            case 1L: return "SgAsmJvmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmJvmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmJvmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmJvmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmJvmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmJvmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmJvmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmJvmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmJvmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmJvmInstruction() {
        return stringify::E_SgAsmJvmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1926
namespace stringify {
    const char* E_SgAsmM68kInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmM68kInstruction_operandList";
            case 1L: return "SgAsmM68kInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmM68kInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmM68kInstruction(i);
        if (s.empty())
            s = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmM68kInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmM68kInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmM68kInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmM68kInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmM68kInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmM68kInstruction() {
        return stringify::E_SgAsmM68kInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1929
namespace stringify {
    const char* E_SgAsmMipsInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmMipsInstruction_operandList";
            case 1L: return "SgAsmMipsInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmMipsInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmMipsInstruction(i);
        if (s.empty())
            s = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmMipsInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmMipsInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmMipsInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmMipsInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmMipsInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmMipsInstruction() {
        return stringify::E_SgAsmMipsInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1932
namespace stringify {
    const char* E_SgAsmNullInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmNullInstruction_operandList";
            case 1L: return "SgAsmNullInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmNullInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmNullInstruction(i);
        if (s.empty())
            s = "(E_SgAsmNullInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmNullInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmNullInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmNullInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmNullInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmNullInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmNullInstruction() {
        return stringify::E_SgAsmNullInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1935
namespace stringify {
    const char* E_SgAsmPowerpcInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPowerpcInstruction_operandList";
            case 1L: return "SgAsmPowerpcInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmPowerpcInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPowerpcInstruction(i);
        if (s.empty())
            s = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPowerpcInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPowerpcInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPowerpcInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPowerpcInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPowerpcInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPowerpcInstruction() {
        return stringify::E_SgAsmPowerpcInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1938
namespace stringify {
    const char* E_SgAsmUserInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmUserInstruction_operandList";
            case 1L: return "SgAsmUserInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmUserInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmUserInstruction(i);
        if (s.empty())
            s = "(E_SgAsmUserInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmUserInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmUserInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmUserInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmUserInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmUserInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmUserInstruction() {
        return stringify::E_SgAsmUserInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1941
namespace stringify {
    const char* E_SgAsmX86Instruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmX86Instruction_operandList";
            case 1L: return "SgAsmX86Instruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmX86Instruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmX86Instruction(i);
        if (s.empty())
            s = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmX86Instruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmX86Instruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmX86Instruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmX86Instruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmX86Instruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmX86Instruction() {
        return stringify::E_SgAsmX86Instruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1944
namespace stringify {
    const char* E_SgAsmInstruction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmInstruction_operandList";
            case 1L: return "SgAsmInstruction_semantics";
            default: return "";
        }
    }

    std::string E_SgAsmInstruction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmInstruction(i);
        if (s.empty())
            s = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmInstruction() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmInstruction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmInstruction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmInstruction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmInstruction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmInstruction() {
        return stringify::E_SgAsmInstruction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1947
namespace stringify {
    const char* E_SgAsmFunction(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmFunction_statementList";
            default: return "";
        }
    }

    std::string E_SgAsmFunction(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmFunction(i);
        if (s.empty())
            s = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmFunction() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmFunction(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmFunction(i);
        if (retval.empty()) {
            retval = "(E_SgAsmFunction)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmFunction::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmFunction() {
        return stringify::E_SgAsmFunction();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h line 1950
namespace stringify {
    const char* E_SgAsmPointerType(int64_t i) {
        switch (i) {
            case 0L: return "SgAsmPointerType_subtype";
            default: return "";
        }
    }

    std::string E_SgAsmPointerType(int64_t i, const std::string &strip) {
        std::string s = E_SgAsmPointerType(i);
        if (s.empty())
            s = "(E_SgAsmPointerType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& E_SgAsmPointerType() {
        static const int64_t values[] = {
            0L
        };
        static const std::vector<int64_t> retval(values, values + 1);
        return retval;
    }

}

namespace Rose {
    std::string stringifyE_SgAsmPointerType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::E_SgAsmPointerType(i);
        if (retval.empty()) {
            retval = "(E_SgAsmPointerType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "E_SgAsmPointerType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyE_SgAsmPointerType() {
        return stringify::E_SgAsmPointerType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarVariants.h line 10
namespace stringify {
    const char* Cxx_GrammarVariants(int64_t i) {
        switch (i) {
            case 1L: return "AccessModifierTag";
            case 2L: return "ACTUAL_ARGUMENT_EXPRESSION";
            case 3L: return "ABS_OP";
            case 4L: return "T_ADA_ACCESS_TYPE";
            case 5L: return "ADA_ACCEPT_STMT";
            case 6L: return "ADA_DELAY_STMT";
            case 7L: return "ADA_ENTRY_DECL_STMT";
            case 8L: return "ADA_EXIT_STMT";
            case 9L: return "T_ADA_DISCRETE_TYPE";
            case 10L: return "ADA_FLOAT_VAL";
            case 11L: return "ADA_LOOP_STMT";
            case 12L: return "ADA_PACKAGE_BODY";
            case 13L: return "ADA_PACKAGE_BODY_DECL_STMT";
            case 14L: return "ADA_PACKAGE_SPEC";
            case 15L: return "ADA_PACKAGE_SPEC_DECL_STMT";
            case 16L: return "ADA_PACKAGE_SYMBOL";
            case 17L: return "AdaRangeConstraintTag";
            case 18L: return "ADA_RENAMING_DECL_STMT";
            case 19L: return "T_ADA_SUBTYPE";
            case 20L: return "ADA_TASK_BODY";
            case 21L: return "ADA_TASK_BODY_DECL_STMT";
            case 22L: return "ADA_TASK_SPEC";
            case 23L: return "ADA_TASK_SPEC_DECL_STMT";
            case 24L: return "ADA_TASK_SYMBOL";
            case 25L: return "ADA_TASK_REF";
            case 26L: return "T_ADA_TASK_TYPE";
            case 27L: return "ADA_TASK_TYPE_DECL_STMT";
            case 28L: return "AdaTypeConstraintTag";
            case 29L: return "ADD_OP";
            case 30L: return "ADDRESS_OP";
            case 31L: return "AGGREGATE_INIT";
            case 32L: return "ALIAS_SYMBOL";
            case 33L: return "TEMP_Allocate_Statement";
            case 34L: return "AND_ASSIGN_OP";
            case 35L: return "AND_OP";
            case 36L: return "TEMP_Arithmetic_If_Statement";
            case 37L: return "T_ARRAY";
            case 38L: return "POINTST_OP";
            case 39L: return "ARROWSTAR_OP";
            case 46L: return "AsmBasicStringTag";
            case 47L: return "AsmBinaryAddTag";
            case 50L: return "AsmBinaryAsrTag";
            case 51L: return "AsmBinaryDivideTag";
            case 52L: return "AsmBinaryExpressionTag";
            case 53L: return "AsmBinaryLslTag";
            case 54L: return "AsmBinaryLsrTag";
            case 55L: return "AsmBinaryModTag";
            case 56L: return "AsmBinaryMslTag";
            case 57L: return "AsmBinaryMultiplyTag";
            case 58L: return "AsmBinaryRorTag";
            case 59L: return "AsmBinarySubtractTag";
            case 62L: return "AsmBlockTag";
            case 63L: return "AsmCoffStrtabTag";
            case 64L: return "AsmCoffSymbolTag";
            case 65L: return "AsmCoffSymbolListTag";
            case 66L: return "AsmCoffSymbolTableTag";
            case 67L: return "AsmCommonSubExpressionTag";
            case 68L: return "AsmControlFlagsExpressionTag";
            case 69L: return "AsmConstantExpressionTag";
            case 70L: return "AsmDOSExtendedHeaderTag";
            case 71L: return "AsmDOSFileHeaderTag";
            case 72L: return "AsmSynthesizedDataStructureDeclarationTag";
            case 73L: return "AsmSynthesizedDeclarationTag";
            case 74L: return "AsmDirectRegisterExpressionTag";
            case 75L: return "AsmDwarfAccessDeclarationTag";
            case 76L: return "AsmDwarfArrayTypeTag";
            case 77L: return "AsmDwarfBaseTypeTag";
            case 78L: return "AsmDwarfCatchBlockTag";
            case 79L: return "AsmDwarfClassTemplateTag";
            case 80L: return "AsmDwarfClassTypeTag";
            case 81L: return "AsmDwarfCommonBlockTag";
            case 82L: return "AsmDwarfCommonInclusionTag";
            case 83L: return "AsmDwarfCompilationUnitTag";
            case 84L: return "AsmDwarfCompilationUnitListTag";
            case 85L: return "AsmDwarfConditionTag";
            case 86L: return "AsmDwarfConstTypeTag";
            case 87L: return "AsmDwarfConstantTag";
            case 88L: return "AsmDwarfConstructTag";
            case 89L: return "AsmDwarfConstructListTag";
            case 90L: return "AsmDwarfDwarfProcedureTag";
            case 91L: return "AsmDwarfEntryPointTag";
            case 92L: return "AsmDwarfEnumerationTypeTag";
            case 93L: return "AsmDwarfEnumeratorTag";
            case 94L: return "AsmDwarfFileTypeTag";
            case 95L: return "AsmDwarfFormalParameterTag";
            case 96L: return "AsmDwarfFormatLabelTag";
            case 97L: return "AsmDwarfFriendTag";
            case 98L: return "AsmDwarfFunctionTemplateTag";
            case 99L: return "AsmDwarfImportedDeclarationTag";
            case 100L: return "AsmDwarfImportedModuleTag";
            case 101L: return "AsmDwarfImportedUnitTag";
            case 102L: return "AsmDwarfInformationTag";
            case 103L: return "AsmDwarfInheritanceTag";
            case 104L: return "AsmDwarfInlinedSubroutineTag";
            case 105L: return "AsmDwarfInterfaceTypeTag";
            case 106L: return "AsmDwarfLabelTag";
            case 107L: return "AsmDwarfLexicalBlockTag";
            case 108L: return "AsmDwarfLineTag";
            case 109L: return "AsmDwarfLineListTag";
            case 110L: return "AsmDwarfMacroTag";
            case 111L: return "AsmDwarfMacroListTag";
            case 112L: return "AsmDwarfMemberTag";
            case 113L: return "AsmDwarfModuleTag";
            case 114L: return "AsmDwarfMutableTypeTag";
            case 115L: return "AsmDwarfNamelistTag";
            case 116L: return "AsmDwarfNamelistItemTag";
            case 117L: return "AsmDwarfNamespaceTag";
            case 118L: return "AsmDwarfPackedTypeTag";
            case 119L: return "AsmDwarfPartialUnitTag";
            case 120L: return "AsmDwarfPointerTypeTag";
            case 121L: return "AsmDwarfPtrToMemberTypeTag";
            case 122L: return "AsmDwarfReferenceTypeTag";
            case 123L: return "AsmDwarfRestrictTypeTag";
            case 124L: return "AsmDwarfSetTypeTag";
            case 125L: return "AsmDwarfSharedTypeTag";
            case 126L: return "AsmDwarfStringTypeTag";
            case 127L: return "AsmDwarfStructureTypeTag";
            case 128L: return "AsmDwarfSubprogramTag";
            case 129L: return "AsmDwarfSubrangeTypeTag";
            case 130L: return "AsmDwarfSubroutineTypeTag";
            case 131L: return "AsmDwarfTemplateTypeParameterTag";
            case 132L: return "AsmDwarfTemplateValueParameterTag";
            case 133L: return "AsmDwarfThrownTypeTag";
            case 134L: return "AsmDwarfTryBlockTag";
            case 135L: return "AsmDwarfTypedefTag";
            case 136L: return "AsmDwarfUnionTypeTag";
            case 137L: return "AsmDwarfUnknownConstructTag";
            case 138L: return "AsmDwarfUnspecifiedParametersTag";
            case 139L: return "AsmDwarfUnspecifiedTypeTag";
            case 140L: return "AsmDwarfUpcRelaxedTypeTag";
            case 141L: return "AsmDwarfUpcSharedTypeTag";
            case 142L: return "AsmDwarfUpcStrictTypeTag";
            case 143L: return "AsmDwarfVariableTag";
            case 144L: return "AsmDwarfVariantTag";
            case 145L: return "AsmDwarfVariantPartTag";
            case 146L: return "AsmDwarfVolatileTypeTag";
            case 147L: return "AsmDwarfWithStmtTag";
            case 148L: return "AsmElfDynamicEntryTag";
            case 149L: return "AsmElfDynamicEntryListTag";
            case 150L: return "AsmElfDynamicSectionTag";
            case 151L: return "AsmElfEHFrameEntryCITag";
            case 152L: return "AsmElfEHFrameEntryCIListTag";
            case 153L: return "AsmElfEHFrameEntryFDTag";
            case 154L: return "AsmElfEHFrameEntryFDListTag";
            case 155L: return "AsmElfEHFrameSectionTag";
            case 156L: return "AsmElfFileHeaderTag";
            case 157L: return "AsmElfNoteEntryTag";
            case 158L: return "AsmElfNoteEntryListTag";
            case 159L: return "AsmElfNoteSectionTag";
            case 160L: return "AsmElfRelocEntryTag";
            case 161L: return "AsmElfRelocEntryListTag";
            case 162L: return "AsmElfRelocSectionTag";
            case 163L: return "AsmElfSectionTag";
            case 164L: return "AsmElfSectionTableTag";
            case 165L: return "AsmElfSectionTableEntryTag";
            case 166L: return "AsmElfSegmentTableTag";
            case 167L: return "AsmElfSegmentTableEntryTag";
            case 168L: return "AsmElfSegmentTableEntryListTag";
            case 169L: return "AsmElfStringSectionTag";
            case 170L: return "AsmElfStrtabTag";
            case 171L: return "AsmElfSymbolTag";
            case 172L: return "AsmElfSymbolListTag";
            case 173L: return "AsmElfSymbolSectionTag";
            case 174L: return "AsmElfSymverDefinedAuxTag";
            case 175L: return "AsmElfSymverDefinedAuxListTag";
            case 176L: return "AsmElfSymverDefinedEntryTag";
            case 177L: return "AsmElfSymverDefinedEntryListTag";
            case 178L: return "AsmElfSymverDefinedSectionTag";
            case 179L: return "AsmElfSymverEntryTag";
            case 180L: return "AsmElfSymverEntryListTag";
            case 181L: return "AsmElfSymverNeededAuxTag";
            case 182L: return "AsmElfSymverNeededAuxListTag";
            case 183L: return "AsmElfSymverNeededEntryTag";
            case 184L: return "AsmElfSymverNeededEntryListTag";
            case 185L: return "AsmElfSymverNeededSectionTag";
            case 186L: return "AsmElfSymverSectionTag";
            case 187L: return "AsmExecutableFileFormatTag";
            case 188L: return "AsmExprListExpTag";
            case 189L: return "AsmExpressionTag";
            case 190L: return "AsmSynthesizedFieldDeclarationTag";
            case 191L: return "AsmFloatTypeTag";
            case 192L: return "AsmFloatValueExpressionTag";
            case 193L: return "AsmFunctionTag";
            case 194L: return "AsmGenericDLLTag";
            case 195L: return "AsmGenericDLLListTag";
            case 196L: return "AsmGenericFileTag";
            case 197L: return "AsmGenericFileListTag";
            case 198L: return "AsmGenericFormatTag";
            case 199L: return "AsmGenericHeaderTag";
            case 200L: return "AsmGenericHeaderListTag";
            case 201L: return "AsmGenericSectionTag";
            case 202L: return "AsmGenericSectionListTag";
            case 203L: return "AsmGenericStringTag";
            case 204L: return "AsmGenericStrtabTag";
            case 205L: return "AsmGenericSymbolTag";
            case 206L: return "AsmGenericSymbolListTag";
            case 207L: return "AsmIndirectRegisterExpressionTag";
            case 208L: return "AsmInstructionTag";
            case 209L: return "AsmIntegerValueExpressionTag";
            case 210L: return "AsmIntegerTypeTag";
            case 211L: return "AsmInterpretationTag";
            case 212L: return "AsmInterpretationListTag";
            case 213L: return "AsmJvmAttributeTag";
            case 214L: return "AsmJvmCodeAttributeTag";
            case 215L: return "AsmJvmMethodTag";
            case 216L: return "AsmJvmConstantPoolTag";
            case 217L: return "AsmJvmConstantPoolEntryTag";
            case 218L: return "AsmJvmConstantValueTag";
            case 219L: return "AsmJvmInstructionTag";
            case 220L: return "AsmJvmFileHeaderTag";
            case 221L: return "AsmJvmNodeTag";
            case 222L: return "AsmJvmSignatureTag";
            case 223L: return "AsmJvmSourceFileTag";
            case 224L: return "AsmLEEntryPointTag";
            case 225L: return "AsmLEEntryTableTag";
            case 226L: return "AsmLEFileHeaderTag";
            case 227L: return "AsmLENameTableTag";
            case 228L: return "AsmLEPageTableTag";
            case 229L: return "AsmLEPageTableEntryTag";
            case 230L: return "AsmLERelocTableTag";
            case 231L: return "AsmLESectionTag";
            case 232L: return "AsmLESectionTableTag";
            case 233L: return "AsmLESectionTableEntryTag";
            case 234L: return "AsmM68kInstructionTag";
            case 235L: return "AsmMemoryReferenceExpressionTag";
            case 236L: return "AsmMipsInstructionTag";
            case 237L: return "AsmNEEntryPointTag";
            case 238L: return "AsmNEEntryTableTag";
            case 239L: return "AsmNEFileHeaderTag";
            case 240L: return "AsmNEModuleTableTag";
            case 241L: return "AsmNENameTableTag";
            case 242L: return "AsmNERelocEntryTag";
            case 243L: return "AsmNERelocTableTag";
            case 244L: return "AsmNESectionTag";
            case 245L: return "AsmNESectionTableTag";
            case 246L: return "AsmNESectionTableEntryTag";
            case 247L: return "AsmNEStringTableTag";
            case 248L: return "AsmNodeTag";
            case 249L: return "ASM_OP";
            case 250L: return "AsmOperandListTag";
            case 251L: return "AsmPEExportDirectoryTag";
            case 252L: return "AsmPEExportEntryTag";
            case 253L: return "AsmPEExportEntryListTag";
            case 254L: return "AsmPEExportSectionTag";
            case 255L: return "AsmPEFileHeaderTag";
            case 256L: return "AsmPEImportDirectoryTag";
            case 257L: return "AsmPEImportDirectoryListTag";
            case 258L: return "AsmPEImportItemTag";
            case 259L: return "AsmPEImportItemListTag";
            case 260L: return "AsmPEImportSectionTag";
            case 261L: return "AsmPERVASizePairTag";
            case 262L: return "AsmPERVASizePairListTag";
            case 263L: return "AsmPESectionTag";
            case 264L: return "AsmPESectionTableTag";
            case 265L: return "AsmPESectionTableEntryTag";
            case 266L: return "AsmPEStringSectionTag";
            case 267L: return "AsmPowerpcInstructionTag";
            case 268L: return "AsmRegisterNamesTag";
            case 269L: return "AsmRegisterReferenceExpressionTag";
            case 270L: return "AsmRiscOperationTag";
            case 271L: return "AsmScalarTypeTag";
            case 272L: return "AsmStatementTag";
            case 273L: return "AsmStaticDataTag";
            case 274L: return "ASM_STMT";
            case 275L: return "AsmStoredStringTag";
            case 276L: return "AsmStringStorageTag";
            case 277L: return "AsmTypeTag";
            case 278L: return "AsmUnaryExpressionTag";
            case 279L: return "AsmUnaryMinusTag";
            case 280L: return "AsmUnaryPlusTag";
            case 281L: return "AsmUnaryRrxTag";
            case 282L: return "AsmUnarySignedExtendTag";
            case 283L: return "AsmUnaryUnsignedExtendTag";
            case 284L: return "AsmUnaryTruncateTag";
            case 285L: return "AsmValueExpressionTag";
            case 286L: return "AsmVectorTypeTag";
            case 287L: return "AsmX86InstructionTag";
            case 288L: return "BINARY_ADDRESS_SYMBOL";
            case 289L: return "BINARY_DATA_SYMBOL";
            case 290L: return "ASSERT_STMT";
            case 291L: return "ASSIGN_INIT";
            case 292L: return "ASSIGN_OP";
            case 293L: return "TEMP_Assign_Statement";
            case 294L: return "TEMP_Assigned_Goto_Statement";
            case 295L: return "TEMP_Associate_Statement";
            case 296L: return "TEMP_AsteriskShapeExp";
            case 297L: return "AT_OP";
            case 298L: return "AttributeTag";
            case 299L: return "TEMP_Attribute_Specification_Statement";
            case 300L: return "T_AUTO";
            case 301L: return "AWAIT_EXPR";
            case 302L: return "BACKSPACE_STATEMENT";
            case 303L: return "BaseClassTag";
            case 304L: return "ExpBaseClassTag";
            case 305L: return "BaseClassModifierTag";
            case 306L: return "BASIC_BLOCK_STMT";
            case 307L: return "BidirectionalGraphTag";
            case 308L: return "BinaryCompositeTag";
            case 309L: return "BINARY_EXPRESSION";
            case 310L: return "BITAND_OP";
            case 311L: return "BitAttributeTag";
            case 312L: return "BIT_COMPLEMENT_OP";
            case 313L: return "BITEQV_OP";
            case 314L: return "BITOR_OP";
            case 315L: return "BITXOR_OP";
            case 316L: return "TEMP_Block_Data_Statement";
            case 317L: return "BOOL_VAL";
            case 318L: return "BREAK_STMT";
            case 319L: return "BRACED_INIT";
            case 320L: return "CPP_DIRECTIVE_STMT";
            case 321L: return "CASE_STMT";
            case 322L: return "CAST_OP";
            case 323L: return "CATCH_STMT";
            case 324L: return "CATCH_STATEMENT_SEQ";
            case 325L: return "CHAR_VAL";
            case 326L: return "CHAR16_VAL";
            case 327L: return "CHAR32_VAL";
            case 328L: return "CHOOSE_EXPR";
            case 329L: return "ClassDecl_attrTag";
            case 330L: return "CLASS_DECL_STMT";
            case 331L: return "CLASS_DEFN_STMT";
            case 332L: return "CLASSNAME_REF";
            case 333L: return "CLASS_NAME";
            case 334L: return "T_CLASS";
            case 335L: return "C_LINKAGE_DECLARATION_STMT";
            case 336L: return "C_LINKAGE_END_STMT";
            case 337L: return "C_LINKAGE_START_STMT";
            case 338L: return "CLOSE_STATEMENT";
            case 339L: return "TEMP_ColonShapeExp";
            case 340L: return "COMMA_OP";
            case 341L: return "COMMON_BLOCK";
            case 342L: return "TEMP_CommonBlockObject";
            case 343L: return "COMMON_SYMBOL";
            case 344L: return "COMPLEX_VAL";
            case 345L: return "COMPREHENSION";
            case 347L: return "COMPOUND_ASSIGN_OP";
            case 348L: return "COMPOUND_INIT";
            case 349L: return "COMPOUND_LITERAL";
            case 350L: return "TEMP_Computed_Goto_Statement";
            case 351L: return "CONCATENATION_OP";
            case 352L: return "EXPR_CONDITIONAL";
            case 353L: return "CONJUGATE_OP";
            case 354L: return "ConstVolatileModifierTag";
            case 355L: return "CONSTRUCTOR_INIT";
            case 356L: return "TEMP_Contains_Statement";
            case 357L: return "CONTINUE_STMT";
            case 358L: return "CTOR_INITIALIZER_LIST";
            case 359L: return "TEMP_DataStatementGroup";
            case 360L: return "TEMP_DataStatementObject";
            case 361L: return "TEMP_DataStatementValue";
            case 362L: return "DEAD_IF_DIRECTIVE_STMT";
            case 363L: return "TEMP_Deallocate_Statement";
            case 364L: return "DeclarationModifierTag";
            case 365L: return "DECLARATION_SCOPE";
            case 366L: return "DECL_STMT";
            case 367L: return "T_DECLTYPE";
            case 368L: return "DEFAULT_STMT";
            case 369L: return "DEFAULT_NAME";
            case 370L: return "DEFINE_DIRECTIVE_STMT";
            case 371L: return "DELETE_OP";
            case 372L: return "TEMP_Derived_Type_Statement";
            case 373L: return "DESIGNATED_INITIALIZER";
            case 374L: return "DICTIONARY_COMPREHENSION";
            case 375L: return "DICT_EXP";
            case 376L: return "TEMP_DimensionObject";
            case 378L: return "DirectedGraphEdgeTag";
            case 380L: return "DirectoryTag";
            case 381L: return "DirectoryListTag";
            case 382L: return "DIV_ASSIGN_OP";
            case 383L: return "DIV_OP";
            case 384L: return "DO_WHILE_STMT";
            case 385L: return "RECORD_REF";
            case 386L: return "DOTSTAR_OP";
            case 387L: return "DOUBLE_VAL";
            case 388L: return "ElaboratedTypeModifierTag";
            case 389L: return "ELEMENT_WISE_OP";
            case 390L: return "ELEMENT_ADD_OP";
            case 391L: return "ELEMENT_DIVIDE_OP";
            case 392L: return "ELEMENT_LEFT_DIVIDE_OP";
            case 393L: return "ELEMENT_MULT_OP";
            case 394L: return "ELEMENT_POWER_OP";
            case 395L: return "ELEMENT_SUBTRACT_OP";
            case 396L: return "ELSE_DIRECTIVE_STMT";
            case 397L: return "TEMP_Else_Where_Statement";
            case 398L: return "ELSEIF_DIRECTIVE_STMT";
            case 399L: return "EMPTY_DECLARATION_STMT";
            case 400L: return "EMPTY_DIRECTIVE_STMT";
            case 401L: return "ENDFILE_STATEMENT";
            case 402L: return "ENDIF_DIRECTIVE_STMT";
            case 403L: return "ENTRY_STMT";
            case 404L: return "ENUM_DECL_STMT";
            case 405L: return "FIELD_NAME";
            case 406L: return "ENUM_NAME";
            case 407L: return "T_ENUM";
            case 408L: return "ENUM_VAL";
            case 409L: return "EQ_OP";
            case 410L: return "TEMP_Equivalence_Statement";
            case 411L: return "ERROR_DIRECTIVE_STMT";
            case 412L: return "EXEC_STMT";
            case 413L: return "EXPONENTIATION_OP";
            case 414L: return "EXP_ASSIGN_OP";
            case 415L: return "EXPR_LIST";
            case 416L: return "EXPR_STMT";
            case 417L: return "ExpressionTag";
            case 418L: return "EXPRESSION_ROOT";
            case 419L: return "FileTag";
            case 420L: return "FileListTag";
            case 421L: return "FLOAT_VAL";
            case 422L: return "FLOAT_128_VAL";
            case 423L: return "FLOAT_80_VAL";
            case 424L: return "FOLD_EXPR";
            case 425L: return "FLUSH_STATEMENT";
            case 426L: return "FOR_ALL_STMT";
            case 427L: return "FOR_INIT_STMT";
            case 428L: return "FOR_STMT";
            case 429L: return "TEMP_FormatItem";
            case 430L: return "TEMP_FormatItemList";
            case 431L: return "FORMAT_STATEMENT";
            case 432L: return "FORTRAN_DO";
            case 433L: return "TEMP_Fortran_Include_Line";
            case 434L: return "FORTRAN_NONBLOCKED_DO";
            case 435L: return "FuncDecl_attrTag";
            case 436L: return "FUNC_CALL";
            case 437L: return "FUNC_DECL_STMT";
            case 438L: return "FUNC_DEFN_STMT";
            case 439L: return "FUNCTION_PARAMETER_SCOPE";
            case 440L: return "FunctionModifierTag";
            case 441L: return "FUNCTION_PARAMETER_LIST";
            case 442L: return "FUNCTION_PARAMETER_REF_EXP";
            case 443L: return "T_FUNCTION_PARAMETER_TYPE_LIST";
            case 444L: return "FUNCTION_REF";
            case 445L: return "FUNCTION_NAME";
            case 446L: return "T_FUNCTION";
            case 447L: return "FUNCTYPE_NAME";
            case 448L: return "FUNC_TBL_STMT";
            case 449L: return "TYPE_TABLE";
            case 450L: return "GLOBAL_STMT";
            case 451L: return "GOTO_STMT";
            case 452L: return "GraphTag";
            case 453L: return "GraphEdgeTag";
            case 454L: return "GraphEdgeListTag";
            case 455L: return "GraphNodeTag";
            case 456L: return "GraphNodeListTag";
            case 457L: return "GE_OP";
            case 458L: return "GT_OP";
            case 459L: return "IO_ITEM_EXPR";
            case 460L: return "IO_STATEMENT";
            case 461L: return "IDENT_DIRECTIVE_STMT";
            case 462L: return "IF_DIRECTIVE_STMT";
            case 463L: return "IF_STMT";
            case 464L: return "IFDEF_DIRECTIVE_STMT";
            case 465L: return "IFNDEF_DIRECTIVE_STMT";
            case 466L: return "IMAGE_CONTROL_STATEMENT";
            case 467L: return "IMAG_PART_OP";
            case 468L: return "TEMP_Implicit_Statement";
            case 469L: return "IMPLIED_DO";
            case 470L: return "TEMP_Import_Statement";
            case 471L: return "IncidenceDirectedGraphTag";
            case 472L: return "IncidenceUndirectedGraphTag";
            case 473L: return "INCLUDE_DIRECTIVE_STMT";
            case 474L: return "IncludeFileTag";
            case 475L: return "INCLUDE_NEXT_DIRECTIVE_STMT";
            case 476L: return "InitializedNameTag";
            case 477L: return "EXPR_INIT";
            case 478L: return "INQUIRE_STATEMENT";
            case 479L: return "IntKeyedBidirectionalGraphTag";
            case 480L: return "INT_VAL";
            case 481L: return "INTEGER_DIV_OP";
            case 482L: return "IDIV_ASSIGN_OP";
            case 483L: return "TEMP_Interface_Body";
            case 484L: return "TEMP_Header_File_Body";
            case 485L: return "HeaderFileReportTag";
            case 486L: return "INTERFACE_STATEMENT";
            case 487L: return "INTERFACE_SYMBOL";
            case 488L: return "INTRINSIC_SYMBOL";
            case 489L: return "IS_OP";
            case 490L: return "IS_NOT_OP";
            case 491L: return "IOR_ASSIGN_OP";
            case 492L: return "T_JOVIAL_BIT";
            case 493L: return "JovialBitValTag";
            case 494L: return "T_JOVIAL_TABLE";
            case 495L: return "JOVIAL_COMPOOL_STATEMENT";
            case 496L: return "JOVIAL_FOR_THEN_STATEMENT";
            case 497L: return "JOVIAL_DEFINE_DECLARATION";
            case 498L: return "JOVIAL_DIRECTIVE_STATEMENT";
            case 499L: return "JOVIAL_OVERLAY_DECLARATION";
            case 500L: return "JOVIAL_PRESET_POSITION_EXP";
            case 501L: return "JOVIAL_TABLE_PRESET_EXP";
            case 502L: return "TEMP_Jovial_Table_Statement";
            case 503L: return "KEY_DATUM_PAIR";
            case 504L: return "EXEC_CONF";
            case 505L: return "KERN_CALL";
            case 506L: return "LABEL_REF";
            case 507L: return "LABEL_STMT";
            case 508L: return "JAVA_LABEL_STMT";
            case 509L: return "LABEL_NAME";
            case 510L: return "JAVA_LABEL_NAME";
            case 511L: return "LambdaCaptureTag";
            case 512L: return "LambdaCaptureListTag";
            case 513L: return "LAMBDA_EXP";
            case 514L: return "LAMBDA_REF_EXP";
            case 515L: return "LEFT_DIVIDE_OP";
            case 516L: return "LE_OP";
            case 517L: return "LT_OP";
            case 518L: return "LINE_DIRECTIVE_STMT";
            case 519L: return "LINEMARKER_DIRECTIVE_STMT";
            case 520L: return "LinkageModifierTag";
            case 521L: return "LIST_COMPREHENSION";
            case 522L: return "LIST_EXP";
            case 523L: return "LocatedNodeTag";
            case 524L: return "LocatedNodeSupportTag";
            case 525L: return "LONG_DOUBLE_VAL";
            case 526L: return "LONG_INT_VAL";
            case 527L: return "LONG_LONG_INT_VAL";
            case 528L: return "LSHIFT_ASSIGN_OP";
            case 529L: return "LSHIFT_OP";
            case 530L: return "MAGIC_COLON_EXP";
            case 531L: return "MATRIX_EXP";
            case 532L: return "MATRIX_TRANSPOSE_OP";
            case 533L: return "MATLAB_FOR_STATEMENT";
            case 534L: return "MFUNC_DECL_STMT";
            case 535L: return "MEMBER_FUNCTION_REF";
            case 536L: return "MEMBER_FUNC_NAME";
            case 537L: return "T_MEMBERFUNCTION";
            case 538L: return "MEMBERSHIP_OP";
            case 539L: return "MS_ATTRIBUTE_DECL_STMT";
            case 540L: return "MINUS_ASSIGN_OP";
            case 541L: return "MINUSMINUS_OP";
            case 542L: return "UNARY_MINUS_OP";
            case 543L: return "MOD_ASSIGN_OP";
            case 544L: return "MOD_OP";
            case 545L: return "ModifierTag";
            case 546L: return "ModifierNodesTag";
            case 547L: return "T_MODIFIER";
            case 548L: return "MODULE_STATEMENT";
            case 549L: return "MODULE_SYMBOL";
            case 550L: return "MULT_ASSIGN_OP";
            case 551L: return "MULT_OP";
            case 552L: return "NameTag";
            case 553L: return "TEMP_Name_Group";
            case 554L: return "T_NAME";
            case 555L: return "TEMP_Namelist_Statement";
            case 556L: return "NAMESPACE_ALIAS_DECLARATION_STMT";
            case 557L: return "NAMESPACE_DECLARATION_STMT";
            case 558L: return "NAMESPACE_DEFINITION_STMT";
            case 559L: return "NAMESPACE_NAME";
            case 560L: return "NARY_EXPRESSION";
            case 561L: return "NARY_BOOLEAN_OP";
            case 562L: return "NARY_COMPARISON_OP";
            case 563L: return "NEW_OP";
            case 564L: return "NodeTag";
            case 565L: return "NOEXCEPT_OP";
            case 566L: return "NE_OP";
            case 567L: return "NOT_OP";
            case 568L: return "NON_MEMBERSHIP_OP";
            case 569L: return "NONREAL_DECL";
            case 570L: return "NONREAL_REF";
            case 571L: return "NONREAL_SYMBOL";
            case 572L: return "T_NONREAL";
            case 573L: return "NonrealBaseClassTag";
            case 574L: return "NULL_EXPR";
            case 575L: return "NULLPTR_VAL";
            case 576L: return "NULL_STMT";
            case 577L: return "TEMP_Nullify_Statement";
            case 578L: return "OMP_ATOMIC_STMT";
            case 579L: return "OMP_BARRIER_STMT";
            case 580L: return "OMP_CRITICAL_STMT";
            case 581L: return "OMP_CLAUSEBODY_STMT";
            case 582L: return "OMP_BODY_STMT";
            case 583L: return "OMP_DO_STMT";
            case 584L: return "OMP_FLUSH_STMT";
            case 585L: return "OMP_DECLARE_SIMD_STMT";
            case 586L: return "OMP_FOR_STMT";
            case 587L: return "OMP_FOR_SIMD_STMT";
            case 588L: return "OMP_MASTER_STMT";
            case 589L: return "OMP_ORDERED_STMT";
            case 590L: return "OMP_PARALLEL_STMT";
            case 591L: return "OMP_SECTION_STMT";
            case 592L: return "OMP_SECTIONS_STMT";
            case 593L: return "OMP_SINGLE_STMT";
            case 594L: return "OMP_TASK_STMT";
            case 595L: return "OMP_TASKWAIT_STMT";
            case 596L: return "OMP_THREADPRIVATE_STMT";
            case 597L: return "OMP_WORKSHARE_STMT";
            case 598L: return "OMP_TARGET_STMT";
            case 599L: return "OMP_TARGET_DATA_STMT";
            case 600L: return "OMP_SIMD_STMT";
            case 601L: return "OmpClauseTag";
            case 602L: return "OmpBeginClauseTag";
            case 603L: return "OmpCollapseClauseTag";
            case 604L: return "OmpCopyinClauseTag";
            case 605L: return "OmpCopyprivateClauseTag";
            case 606L: return "OmpDefaultClauseTag";
            case 607L: return "OmpEndClauseTag";
            case 608L: return "OmpExpressionClauseTag";
            case 609L: return "OmpFirstprivateClauseTag";
            case 610L: return "OmpIfClauseTag";
            case 611L: return "OmpFinalClauseTag";
            case 612L: return "OmpPriorityClauseTag";
            case 613L: return "OmpIfDeviceTag";
            case 614L: return "OmpLastprivateClauseTag";
            case 615L: return "OmpNowaitClauseTag";
            case 616L: return "OmpNumThreadsClauseTag";
            case 617L: return "OmpOrderedClauseTag";
            case 618L: return "OmpPrivateClauseTag";
            case 619L: return "OmpReductionClauseTag";
            case 620L: return "OmpScheduleClauseTag";
            case 621L: return "OmpSharedClauseTag";
            case 622L: return "OmpUntiedClauseTag";
            case 623L: return "OmpMergeableClauseTag";
            case 624L: return "OmpVariablesClauseTag";
            case 625L: return "OmpMapClauseTag";
            case 626L: return "OmpSafelenTag";
            case 627L: return "OmpSimdlenTag";
            case 628L: return "OmpLinearClauseTag";
            case 629L: return "OmpUniformClauseTag";
            case 630L: return "OmpAlignedClauseTag";
            case 631L: return "OmpProcBindClauseTag";
            case 632L: return "OmpAtomicClauseTag";
            case 633L: return "OmpInbranchClauseTag";
            case 634L: return "OmpNotinbranchClauseTag";
            case 635L: return "OmpDependClauseTag";
            case 636L: return "OPENCL_ACCESS_MODE";
            case 637L: return "OPEN_STATEMENT";
            case 638L: return "OptionsTag";
            case 639L: return "OR_OP";
            case 640L: return "PARAMETER_STATEMENT";
            case 641L: return "T_PARTIAL_FUNCTION_MODIFIER";
            case 642L: return "T_PARTIAL_FUNCTION";
            case 643L: return "PASS_STATEMENT";
            case 644L: return "PLUS_ASSIGN_OP";
            case 645L: return "PLUSPLUS_OP";
            case 646L: return "ARRAY_OP";
            case 647L: return "POINTER_ASSIGN_OP";
            case 648L: return "DEREF_OP";
            case 649L: return "T_MEMBER_POINTER";
            case 650L: return "T_POINTER";
            case 651L: return "POWER_OP";
            case 652L: return "PragmaTag";
            case 653L: return "PRAGMA_DECL";
            case 654L: return "PRINT_STATEMENT";
            case 655L: return "PROCEDURE_HEADER_STMT";
            case 656L: return "PROGRAM_HEADER_STMT";
            case 657L: return "ProjectTag";
            case 658L: return "PSEUDO_DESTRUCTOR_REF";
            case 659L: return "PYTHON_GLOBAL_STMT";
            case 660L: return "PYTHON_PRINT_STMT";
            case 661L: return "QualifiedNameTag";
            case 662L: return "T_QUALIFIED_NAME";
            case 663L: return "RANGE_EXP";
            case 664L: return "RANGE_BASED_FOR_STMT";
            case 665L: return "READ_STATEMENT";
            case 666L: return "REAL_PART_OP";
            case 667L: return "TYPE_REF";
            case 668L: return "T_REFERENCE";
            case 669L: return "REM_OP";
            case 670L: return "TEMP_Rename_Pair";
            case 671L: return "RENAME_SYMBOL";
            case 672L: return "REPLICATION_OP";
            case 673L: return "RETURN_STMT";
            case 674L: return "REWIND_STATEMENT";
            case 675L: return "RSHIFT_ASSIGN_OP";
            case 676L: return "RSHIFT_OP";
            case 677L: return "T_RVALUE_REFERENCE";
            case 678L: return "JAVA_UNSIGNED_RSHIFT_ASSIGN_OP";
            case 679L: return "JAVA_UNSIGNED_RSHIFT_OP";
            case 680L: return "SCOPE_OP";
            case 681L: return "SCOPE_STMT";
            case 682L: return "TEMP_Sequence_Statement";
            case 683L: return "SET_COMPREHENSION";
            case 684L: return "SHORT_VAL";
            case 685L: return "SIZEOF_OP";
            case 686L: return "ALIGNOF_OP";
            case 687L: return "JAVA_INSTANCEOF_OP";
            case 688L: return "SourceFileTag";
            case 689L: return "SPACESHIP_OP";
            case 690L: return "SPAWN_STMT";
            case 691L: return "SYNC_ALL_STATEMENT";
            case 692L: return "SYNC_IMAGES_STATEMENT";
            case 693L: return "SYNC_MEMORY_STATEMENT";
            case 694L: return "SYNC_TEAM_STATEMENT";
            case 695L: return "LOCK_STATEMENT";
            case 696L: return "UNLOCK_STATEMENT";
            case 697L: return "JAVE_THROW_STMT";
            case 698L: return "JAVA_FOREACH_STMT";
            case 699L: return "JAVA_SYNC_STMT";
            case 700L: return "T_JAVA_PARAM";
            case 701L: return "T_JAVA_WILD";
            case 702L: return "PROCESS_CONTROL_STATEMENT";
            case 703L: return "SpecialFunctionModifierTag";
            case 704L: return "StatementTag";
            case 705L: return "STATIC_ASSERTION_DECLARATION";
            case 706L: return "STMT_DECL_STMT";
            case 707L: return "STMT_EXPR";
            case 708L: return "TEMP_Statement_Function_Statement";
            case 709L: return "StorageModifierTag";
            case 710L: return "STR_CONV";
            case 711L: return "StringKeyedBidirectionalGraphTag";
            case 712L: return "STRING_VAL";
            case 713L: return "StructureModifierTag";
            case 714L: return "SUBSCRIPT_EXPR";
            case 715L: return "SUBT_OP";
            case 716L: return "SupportTag";
            case 717L: return "SWITCH_STMT";
            case 718L: return "SymbolTag";
            case 719L: return "SymbolTableTag";
            case 720L: return "TemplateArgumentTag";
            case 721L: return "TemplateArgumentListTag";
            case 722L: return "TEMPLATE_DECL_STMT";
            case 723L: return "TEMPLATE_CLASS_DECL_STMT";
            case 724L: return "TEMPLATE_CLASS_NAME";
            case 725L: return "TEMPLATE_FUNCTION_DECL_STMT";
            case 726L: return "TEMPLATE_FUNCTION_REF";
            case 727L: return "TEMPLATE_FUNC_NAME";
            case 728L: return "TEMPLATE_MEMBER_FUNCTION_DECL_STMT";
            case 729L: return "TEMPLATE_MEMBER_FUNCTION_REF";
            case 730L: return "TEMPLATE_MEMBER_FUNC_NAME";
            case 731L: return "TEMPLATE_TYPEDEF_DECL_STMT";
            case 732L: return "TEMPLATE_TYPEDEF_NAME";
            case 733L: return "TEMPLATE_VARIABLE_DECL_STMT";
            case 734L: return "TEMPLATE_VARIABLE_NAME";
            case 735L: return "TEMPLATE_CLASS_DEF_STMT";
            case 736L: return "TEMPLATE_FUNCTION_DEF_STMT";
            case 737L: return "TEMPLATE_INST_DECL_STMT";
            case 738L: return "TEMPLATE_INST_DEFN_STMT";
            case 739L: return "TEMPLATE_INST_DIRECTIVE_STMT";
            case 740L: return "TEMPLATE_INST_FUNCTION_DECL_STMT";
            case 741L: return "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT";
            case 742L: return "TEMPLATE_INST_TYPEDEF_DECL_STMT";
            case 743L: return "TemplateParameterTag";
            case 744L: return "TEMPLATE_PARAMETER_VAL";
            case 745L: return "TemplateParameterListTag";
            case 746L: return "TEMPLATE_NAME";
            case 747L: return "T_TEMPLATE";
            case 748L: return "THIS_NODE";
            case 749L: return "TYPE_TRAIT_BUILTIN_OPERATOR";
            case 750L: return "SUPER_NODE";
            case 751L: return "THROW_OP";
            case 752L: return "TOKEN";
            case 753L: return "TRY_STMT";
            case 754L: return "TUPLE_EXP";
            case 755L: return "TypeTag";
            case 756L: return "T_BOOL";
            case 757L: return "T_CHAR";
            case 758L: return "T_CHAR16";
            case 759L: return "T_CHAR32";
            case 760L: return "T_COMPLEX";
            case 761L: return "T_DEFAULT";
            case 762L: return "TYPE_EXPRESSION";
            case 763L: return "T_LABEL";
            case 764L: return "T_DOUBLE";
            case 765L: return "T_ELLIPSE";
            case 766L: return "T_FIXED";
            case 767L: return "T_FLOAT";
            case 768L: return "T_FLOAT128";
            case 769L: return "T_FLOAT80";
            case 770L: return "T_GLOBAL_VOID";
            case 771L: return "TYPEID_OP";
            case 772L: return "T_IMAGINARY";
            case 773L: return "T_INT";
            case 774L: return "T_LONG";
            case 775L: return "T_LONG_DOUBLE";
            case 776L: return "T_LONG_LONG";
            case 777L: return "TypeModifierTag";
            case 778L: return "T_MATRIX";
            case 779L: return "T_TUPLE";
            case 780L: return "T_NULLPTR";
            case 781L: return "T_TYPEOF_TYPE";
            case 782L: return "T_SHORT";
            case 783L: return "T_SIGNED_128BIT_INTEGER";
            case 784L: return "T_SIGNED_CHAR";
            case 785L: return "T_SIGNED_INT";
            case 786L: return "T_SIGNED_LONG";
            case 787L: return "T_SIGNED_LONG_LONG";
            case 788L: return "T_SIGNED_SHORT";
            case 789L: return "T_STRING";
            case 790L: return "T_UNKNOWN";
            case 791L: return "T_UNSIGNED_128BIT_INTEGER";
            case 792L: return "T_UNSIGNED_CHAR";
            case 793L: return "T_UNSIGNED_INT";
            case 794L: return "T_UNSIGNED_LONG";
            case 795L: return "T_UNSIGNED_LONG_LONG";
            case 796L: return "T_UNSIGNED_SHORT";
            case 797L: return "T_VOID";
            case 798L: return "T_WCHAR";
            case 799L: return "TYPEDEF_STMT";
            case 800L: return "T_TYPEDEF_SEQ";
            case 801L: return "TYPEDEF_NAME";
            case 802L: return "T_TYPEDEF";
            case 803L: return "UPC_AccessModifierTag";
            case 804L: return "UNARY_ADD_OP";
            case 805L: return "UNARY_EXPRESSION";
            case 806L: return "UNDEF_DIRECTIVE_STMT";
            case 807L: return "UndirectedGraphEdgeTag";
            case 808L: return "TEMP_UnknownArrayOrFunctionReference";
            case 809L: return "UnknownFileTag";
            case 811L: return "Unparse_InfoTag";
            case 812L: return "UNSIGNED_CHAR_VAL";
            case 813L: return "UNSIGNED_INT_VAL";
            case 814L: return "UNSIGNED_LONG_LONG_INT_VAL";
            case 815L: return "UNSIGNED_LONG_INT_VAL";
            case 816L: return "UNSIGNED_SHORT_VAL";
            case 817L: return "UPC_BARRIER_STMT";
            case 818L: return "UPC_BLOCK_SIZEOF_EXPR";
            case 819L: return "UPC_ELEM_SIZEOF_EXPR";
            case 820L: return "UPC_FENCE_STMT";
            case 821L: return "UPC_FORALL_STMT";
            case 822L: return "UPC_LOCAL_SIZEOF_EXPR";
            case 823L: return "UPC_MYTHREAD";
            case 824L: return "UPC_NOTIFY_STMT";
            case 825L: return "UPC_THREADS";
            case 826L: return "UPC_WAIT_STMT";
            case 827L: return "USE_STATEMENT";
            case 828L: return "USER_DEFINED_BINARY_OP";
            case 829L: return "USER_DEFINED_UNARY_OP";
            case 830L: return "USING_DECLARATION_STMT";
            case 831L: return "USING_DIRECTIVE_STMT";
            case 832L: return "ValueExpTag";
            case 833L: return "VA_COPY_OP";
            case 834L: return "VA_END_OP";
            case 835L: return "VA_OP";
            case 836L: return "VA_START_ONE_OPERAND_OP";
            case 837L: return "VA_START_OP";
            case 838L: return "VAR_REF";
            case 839L: return "VAR_DECL_STMT";
            case 840L: return "VAR_DEFN_STMT";
            case 841L: return "VARIABLE_NAME";
            case 842L: return "VARIANT_EXPR";
            case 843L: return "VARIANT_STMT";
            case 844L: return "VOID_VAL";
            case 845L: return "WAIT_STATEMENT";
            case 846L: return "WARNING_DIRECTIVE_STMT";
            case 847L: return "WITH_STATEMENT";
            case 848L: return "WCHAR_VAL";
            case 849L: return "TEMP_Where_Statement";
            case 850L: return "WHILE_STMT";
            case 851L: return "WRITE_STATEMENT";
            case 852L: return "XOR_ASSIGN_OP";
            case 853L: return "YIELD_EXP";
            case 854L: return "_File_InfoTag";
            case 855L: return "T_CAFTEAM";
            case 856L: return "WITHTEAM_STMT";
            case 857L: return "COARRAY_REF_EXPR";
            case 858L: return "CALL_EXPRESSION";
            case 859L: return "T_CRAY_POINTER";
            case 860L: return "TEMP_JavaImportStatement";
            case 861L: return "TEMP_JavaPackageDeclaration";
            case 862L: return "TEMP_JavaPackageStatement";
            case 863L: return "JavaImportStatementListTag";
            case 864L: return "JavaClassDeclarationListTag";
            case 865L: return "JavaMemberValuePairTag";
            case 866L: return "JAVA_ANNOTATION";
            case 867L: return "JAVA_MARKER_ANNOTATION";
            case 868L: return "JAVA_SINGLE_MEMBER_ANNOTATION";
            case 869L: return "JAVA_NORMAL_ANNOTATION";
            case 870L: return "JAVA_TYPE_EXPRESSION";
            case 871L: return "T_JAVA_QUALIFIED";
            case 872L: return "CLASS_NODE";
            case 873L: return "T_JAVA_UNION";
            case 874L: return "T_JAVA_PARAMETER";
            case 875L: return "ASYNC_STMT";
            case 876L: return "FINISH_STMT";
            case 877L: return "AT_STMT";
            case 878L: return "ATOMIC_STMT";
            case 880L: return "WHEN_STMT";
            case 881L: return "ATEXP_NODE";
            case 882L: return "FINISHEXP_NODE";
            case 883L: return "HERE_NODE";
            case 884L: return "DOTDOT_NODE";
            case 885L: return "AsmNullInstructionTag";
            case 886L: return "ADA_COMPONENT_CLAUSE";
            case 887L: return "AdaIndexConstraintTag";
            case 888L: return "T_ADA_MODULAR_TYPE";
            case 889L: return "ADA_REPRESENTATION_CLAUSE";
            case 890L: return "ADA_FUNCTION_RENAMING_DECL_STMT";
            case 891L: return "ADA_SELECT_STMT";
            case 892L: return "ADA_SELECT_ALTERNATIVE_STMT";
            case 893L: return "ADA_TERMINATE_STMT";
            case 895L: return "AsmAarch32CoprocessorTag";
            case 896L: return "ADA_ATTRIBUTE_CLAUSE";
            case 897L: return "AsmBinaryConcatTag";
            case 898L: return "AsmByteOrderTag";
            case 899L: return "T_ADA_DERIVED_TYPE";
            case 900L: return "ADA_ATTRIBUTE_EXP";
            case 901L: return "ADA_ENUM_REPRESENTATION_CLAUSE";
            case 902L: return "AsmBinaryPreupdateTag";
            case 903L: return "AsmBinaryPostupdateTag";
            case 904L: return "ADA_OTHERS_EXPR";
            case 905L: return "ADA_RENAMING_SYMBOL";
            case 906L: return "ADA_RENAMING_REF";
            case 907L: return "ADA_GENERIC_DECL";
            case 908L: return "ADA_GENERIC_DEFN";
            case 909L: return "T_ADA_FORMAL_TYPE";
            case 910L: return "ADA_GENERIC_SYMBOL";
            case 911L: return "ADA_FORMAL_TYPE_DECL_STMT";
            case 912L: return "ADA_UNIT_REF";
            case 913L: return "ADA_DISCRIMINATED_TYPE_DECL";
            case 914L: return "T_ADA_DISCRIMINATED_TYPE";
            case 915L: return "AdaDiscriminantConstraintTag";
            case 916L: return "ADA_GENERIC_INSTANCE_DECL";
            case 917L: return "ADA_UNSCOPED_BLOCK";
            case 918L: return "ADA_INHERITED_FUNCTION_SYMBOL";
            case 919L: return "ADA_PROTECTED_BODY";
            case 920L: return "ADA_PROTECTED_BODY_DECL_STMT";
            case 921L: return "ADA_PROTECTED_SPEC";
            case 922L: return "ADA_PROTECTED_SPEC_DECL_STMT";
            case 923L: return "ADA_PROTECTED_SYMBOL";
            case 924L: return "ADA_PROTECTED_REF";
            case 925L: return "T_ADA_PROTECTED_TYPE";
            case 926L: return "ADA_PROTECTED_TYPE_DECL_STMT";
            case 927L: return "AdaDigitsConstraintTag";
            case 928L: return "ADA_ANCESTOR_INIT";
            case 929L: return "AdaDeltaConstraintTag";
            case 930L: return "T_ADA_SUBROUTINE_TYPE";
            case 931L: return "ADA_GENERIC_INSTANCE_SYMBOL";
            case 932L: return "ADA_FORMAL_PACKAGE_DECL_STMT";
            case 933L: return "ADA_FORMAL_PACAKGE_SYMBOL";
            case 934L: return "AsmJvmAttributeTableTag";
            case 935L: return "AsmJvmMethodTableTag";
            case 936L: return "AsmJvmFieldTag";
            case 937L: return "AsmJvmFieldTableTag";
            case 938L: return "AsmJvmExceptionHandlerTag";
            case 939L: return "AsmJvmExceptionTableTag";
            case 940L: return "AsmJvmClassTag";
            case 941L: return "AsmJvmLineNumberEntryTag";
            case 942L: return "AsmJvmLineNumberTableTag";
            case 943L: return "AsmJvmInnerClassesEntryTag";
            case 944L: return "AsmJvmInnerClassesTag";
            case 945L: return "AsmCilInstructionTag";
            case 946L: return "AsmStackExpressionTag";
            case 947L: return "AsmJvmEnclosingMethodTag";
            case 948L: return "AdaNullConstraintTag";
            case 949L: return "AsmJvmModuleMainClassTag";
            case 950L: return "AsmInstructionListTag";
            case 951L: return "AsmCilNodeTag";
            case 952L: return "AsmCilAssemblyTag";
            case 953L: return "AsmCilAssemblyOSTag";
            case 954L: return "AsmCilAssemblyProcessorTag";
            case 955L: return "AsmCilAssemblyRefTag";
            case 956L: return "AsmCilAssemblyRefOSTag";
            case 957L: return "AsmCilAssemblyRefProcessorTag";
            case 958L: return "AsmCilClassLayoutTag";
            case 959L: return "AsmCilConstantTag";
            case 960L: return "AsmCilCustomAttributeTag";
            case 961L: return "AsmCilDeclSecurityTag";
            case 962L: return "AsmCilEventTag";
            case 963L: return "AsmCilEventMapTag";
            case 964L: return "AsmCilExportedTypeTag";
            case 965L: return "AsmCilFieldTag";
            case 966L: return "AsmCilFieldLayoutTag";
            case 967L: return "AsmCilFieldMarshalTag";
            case 968L: return "AsmCilFieldRVATag";
            case 969L: return "AsmCilFileTag";
            case 970L: return "AsmCilGenericParamTag";
            case 971L: return "AsmCilGenericParamConstraintTag";
            case 972L: return "AsmCilImplMapTag";
            case 973L: return "AsmCilInterfaceImplTag";
            case 974L: return "AsmCilManifestResourceTag";
            case 975L: return "AsmCilMemberRefTag";
            case 976L: return "AsmCilMethodDefTag";
            case 977L: return "AsmCilMethodImplTag";
            case 978L: return "AsmCilMethodSemanticsTag";
            case 979L: return "AsmCilMethodSpecTag";
            case 980L: return "AsmCilModuleTag";
            case 981L: return "AsmCilModuleRefTag";
            case 982L: return "AsmCilNestedClassTag";
            case 983L: return "AsmCilParamTag";
            case 984L: return "AsmCilPropertyTag";
            case 985L: return "AsmCilPropertyMapTag";
            case 986L: return "AsmCilStandAloneSigTag";
            case 987L: return "AsmCilTypeDefTag";
            case 988L: return "AsmCilTypeRefTag";
            case 989L: return "AsmCilTypeSpecTag";
            case 990L: return "ADA_PARAMETER_LIST";
            case 991L: return "AsmCilMetadataTag";
            case 992L: return "AsmCilMetadataRootTag";
            case 993L: return "AsmCilDataStreamTag";
            case 994L: return "AsmCilMetadataHeapTag";
            case 995L: return "AsmCilUint8HeapTag";
            case 996L: return "AsmCilUint32HeapTag";
            case 997L: return "AsmCliHeaderTag";
            case 998L: return "ADA_VARIANT_DECL_STATEMENT";
            case 999L: return "ADA_VARIANT_WHEN_STMT";
            case 1000L: return "AsmCilAssemblyTableTag";
            case 1001L: return "AsmCilAssemblyOSTableTag";
            case 1002L: return "AsmCilAssemblyProcessorTableTag";
            case 1003L: return "AsmCilAssemblyRefTableTag";
            case 1004L: return "AsmCilAssemblyRefOSTableTag";
            case 1005L: return "AsmCilAssemblyRefProcessorTableTag";
            case 1006L: return "AsmCilClassLayoutTableTag";
            case 1007L: return "AsmCilConstantTableTag";
            case 1008L: return "AsmCilCustomAttributeTableTag";
            case 1009L: return "AsmCilDeclSecurityTableTag";
            case 1010L: return "AsmCilEventTableTag";
            case 1011L: return "AsmCilEventMapTableTag";
            case 1012L: return "AsmCilExportedTypeTableTag";
            case 1013L: return "AsmCilFieldTableTag";
            case 1014L: return "AsmCilFieldLayoutTableTag";
            case 1015L: return "AsmCilFieldMarshalTableTag";
            case 1016L: return "AsmCilFieldRVATableTag";
            case 1017L: return "AsmCilFileTableTag";
            case 1018L: return "AsmCilGenericParamTableTag";
            case 1019L: return "AsmCilGenericParamConstraintTableTag";
            case 1020L: return "AsmCilImplMapTableTag";
            case 1021L: return "AsmCilInterfaceImplTableTag";
            case 1022L: return "AsmCilManifestResourceTableTag";
            case 1023L: return "AsmCilMemberRefTableTag";
            case 1024L: return "AsmCilMethodDefTableTag";
            case 1025L: return "AsmCilMethodImplTableTag";
            case 1026L: return "AsmCilMethodSemanticsTableTag";
            case 1027L: return "AsmCilMethodSpecTableTag";
            case 1028L: return "AsmCilModuleTableTag";
            case 1029L: return "AsmCilModuleRefTableTag";
            case 1030L: return "AsmCilNestedClassTableTag";
            case 1031L: return "AsmCilParamTableTag";
            case 1032L: return "AsmCilPropertyTableTag";
            case 1033L: return "AsmCilPropertyMapTableTag";
            case 1034L: return "AsmCilStandAloneSigTableTag";
            case 1035L: return "AsmCilTypeDefTableTag";
            case 1036L: return "AsmCilTypeRefTableTag";
            case 1037L: return "AsmCilTypeSpecTableTag";
            case 1038L: return "JvmCompositeTag";
            case 1039L: return "FORTRAN_CONTINUE_STMT";
            case 1040L: return "AsmJvmStackMapTableTag";
            case 1041L: return "AsmJvmStackMapFrameTag";
            case 1042L: return "AsmJvmStackMapVerificationTypeTag";
            case 1043L: return "AsmJvmBootstrapMethodTag";
            case 1044L: return "AsmJvmBootstrapMethodsTag";
            case 1045L: return "AsmJvmExceptionsTag";
            case 1046L: return "AsmJvmNestMembersTag";
            case 1047L: return "AsmJvmNestHostTag";
            case 1048L: return "JOVIAL_LABEL_DECLARATION";
            case 1049L: return "AsmJvmLocalVariableEntryTag";
            case 1050L: return "AsmJvmLocalVariableTableTag";
            case 1051L: return "AsmJvmLocalVariableTypeEntryTag";
            case 1052L: return "AsmJvmLocalVariableTypeTableTag";
            case 1053L: return "AsmUserInstructionTag";
            case 1054L: return "AsmJvmMethodParametersTag";
            case 1055L: return "AsmJvmMethodParametersEntryTag";
            case 1056L: return "AsmVoidTypeTag";
            case 1057L: return "AsmPointerTypeTag";
            case 1059L: return "T_RANGE_TYPE";
            case 1060L: return "AsmCilExceptionDataTag";
            case 1061L: return "AsmCilMethodDataTag";
            case 1063L: return "Cxx_Grammar_UNKNOWN_GRAMMAR";
            case 1064L: return "Cxx_Grammar_LAST_TAG";
            default: return "";
        }
    }

    std::string Cxx_GrammarVariants(int64_t i, const std::string &strip) {
        std::string s = Cxx_GrammarVariants(i);
        if (s.empty())
            s = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Cxx_GrammarVariants() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            46L,
            47L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            378L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1059L,
            1060L,
            1061L,
            1063L,
            1064L
        };
        static const std::vector<int64_t> retval(values, values + 1046);
        return retval;
    }

}

namespace Rose {
    std::string stringifyCxx_GrammarVariants(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Cxx_GrammarVariants(i);
        if (retval.empty()) {
            retval = "(Cxx_GrammarVariants)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Cxx_GrammarVariants::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyCxx_GrammarVariants() {
        return stringify::Cxx_GrammarVariants();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_GrammarVariants.h line 1060
namespace stringify {
    const char* VariantT(int64_t i) {
        switch (i) {
            case 1L: return "V_SgAccessModifier";
            case 2L: return "V_SgActualArgumentExpression";
            case 3L: return "V_SgAbsOp";
            case 4L: return "V_SgAdaAccessType";
            case 5L: return "V_SgAdaAcceptStmt";
            case 6L: return "V_SgAdaDelayStmt";
            case 7L: return "V_SgAdaEntryDecl";
            case 8L: return "V_SgAdaExitStmt";
            case 9L: return "V_SgAdaDiscreteType";
            case 10L: return "V_SgAdaFloatVal";
            case 11L: return "V_SgAdaLoopStmt";
            case 12L: return "V_SgAdaPackageBody";
            case 13L: return "V_SgAdaPackageBodyDecl";
            case 14L: return "V_SgAdaPackageSpec";
            case 15L: return "V_SgAdaPackageSpecDecl";
            case 16L: return "V_SgAdaPackageSymbol";
            case 17L: return "V_SgAdaRangeConstraint";
            case 18L: return "V_SgAdaRenamingDecl";
            case 19L: return "V_SgAdaSubtype";
            case 20L: return "V_SgAdaTaskBody";
            case 21L: return "V_SgAdaTaskBodyDecl";
            case 22L: return "V_SgAdaTaskSpec";
            case 23L: return "V_SgAdaTaskSpecDecl";
            case 24L: return "V_SgAdaTaskSymbol";
            case 25L: return "V_SgAdaTaskRefExp";
            case 26L: return "V_SgAdaTaskType";
            case 27L: return "V_SgAdaTaskTypeDecl";
            case 28L: return "V_SgAdaTypeConstraint";
            case 29L: return "V_SgAddOp";
            case 30L: return "V_SgAddressOfOp";
            case 31L: return "V_SgAggregateInitializer";
            case 32L: return "V_SgAliasSymbol";
            case 33L: return "V_SgAllocateStatement";
            case 34L: return "V_SgAndAssignOp";
            case 35L: return "V_SgAndOp";
            case 36L: return "V_SgArithmeticIfStatement";
            case 37L: return "V_SgArrayType";
            case 38L: return "V_SgArrowExp";
            case 39L: return "V_SgArrowStarOp";
            case 46L: return "V_SgAsmBasicString";
            case 47L: return "V_SgAsmBinaryAdd";
            case 50L: return "V_SgAsmBinaryAsr";
            case 51L: return "V_SgAsmBinaryDivide";
            case 52L: return "V_SgAsmBinaryExpression";
            case 53L: return "V_SgAsmBinaryLsl";
            case 54L: return "V_SgAsmBinaryLsr";
            case 55L: return "V_SgAsmBinaryMod";
            case 56L: return "V_SgAsmBinaryMsl";
            case 57L: return "V_SgAsmBinaryMultiply";
            case 58L: return "V_SgAsmBinaryRor";
            case 59L: return "V_SgAsmBinarySubtract";
            case 62L: return "V_SgAsmBlock";
            case 63L: return "V_SgAsmCoffStrtab";
            case 64L: return "V_SgAsmCoffSymbol";
            case 65L: return "V_SgAsmCoffSymbolList";
            case 66L: return "V_SgAsmCoffSymbolTable";
            case 67L: return "V_SgAsmCommonSubExpression";
            case 68L: return "V_SgAsmControlFlagsExpression";
            case 69L: return "V_SgAsmConstantExpression";
            case 70L: return "V_SgAsmDOSExtendedHeader";
            case 71L: return "V_SgAsmDOSFileHeader";
            case 72L: return "V_SgAsmSynthesizedDataStructureDeclaration";
            case 73L: return "V_SgAsmSynthesizedDeclaration";
            case 74L: return "V_SgAsmDirectRegisterExpression";
            case 75L: return "V_SgAsmDwarfAccessDeclaration";
            case 76L: return "V_SgAsmDwarfArrayType";
            case 77L: return "V_SgAsmDwarfBaseType";
            case 78L: return "V_SgAsmDwarfCatchBlock";
            case 79L: return "V_SgAsmDwarfClassTemplate";
            case 80L: return "V_SgAsmDwarfClassType";
            case 81L: return "V_SgAsmDwarfCommonBlock";
            case 82L: return "V_SgAsmDwarfCommonInclusion";
            case 83L: return "V_SgAsmDwarfCompilationUnit";
            case 84L: return "V_SgAsmDwarfCompilationUnitList";
            case 85L: return "V_SgAsmDwarfCondition";
            case 86L: return "V_SgAsmDwarfConstType";
            case 87L: return "V_SgAsmDwarfConstant";
            case 88L: return "V_SgAsmDwarfConstruct";
            case 89L: return "V_SgAsmDwarfConstructList";
            case 90L: return "V_SgAsmDwarfDwarfProcedure";
            case 91L: return "V_SgAsmDwarfEntryPoint";
            case 92L: return "V_SgAsmDwarfEnumerationType";
            case 93L: return "V_SgAsmDwarfEnumerator";
            case 94L: return "V_SgAsmDwarfFileType";
            case 95L: return "V_SgAsmDwarfFormalParameter";
            case 96L: return "V_SgAsmDwarfFormatLabel";
            case 97L: return "V_SgAsmDwarfFriend";
            case 98L: return "V_SgAsmDwarfFunctionTemplate";
            case 99L: return "V_SgAsmDwarfImportedDeclaration";
            case 100L: return "V_SgAsmDwarfImportedModule";
            case 101L: return "V_SgAsmDwarfImportedUnit";
            case 102L: return "V_SgAsmDwarfInformation";
            case 103L: return "V_SgAsmDwarfInheritance";
            case 104L: return "V_SgAsmDwarfInlinedSubroutine";
            case 105L: return "V_SgAsmDwarfInterfaceType";
            case 106L: return "V_SgAsmDwarfLabel";
            case 107L: return "V_SgAsmDwarfLexicalBlock";
            case 108L: return "V_SgAsmDwarfLine";
            case 109L: return "V_SgAsmDwarfLineList";
            case 110L: return "V_SgAsmDwarfMacro";
            case 111L: return "V_SgAsmDwarfMacroList";
            case 112L: return "V_SgAsmDwarfMember";
            case 113L: return "V_SgAsmDwarfModule";
            case 114L: return "V_SgAsmDwarfMutableType";
            case 115L: return "V_SgAsmDwarfNamelist";
            case 116L: return "V_SgAsmDwarfNamelistItem";
            case 117L: return "V_SgAsmDwarfNamespace";
            case 118L: return "V_SgAsmDwarfPackedType";
            case 119L: return "V_SgAsmDwarfPartialUnit";
            case 120L: return "V_SgAsmDwarfPointerType";
            case 121L: return "V_SgAsmDwarfPtrToMemberType";
            case 122L: return "V_SgAsmDwarfReferenceType";
            case 123L: return "V_SgAsmDwarfRestrictType";
            case 124L: return "V_SgAsmDwarfSetType";
            case 125L: return "V_SgAsmDwarfSharedType";
            case 126L: return "V_SgAsmDwarfStringType";
            case 127L: return "V_SgAsmDwarfStructureType";
            case 128L: return "V_SgAsmDwarfSubprogram";
            case 129L: return "V_SgAsmDwarfSubrangeType";
            case 130L: return "V_SgAsmDwarfSubroutineType";
            case 131L: return "V_SgAsmDwarfTemplateTypeParameter";
            case 132L: return "V_SgAsmDwarfTemplateValueParameter";
            case 133L: return "V_SgAsmDwarfThrownType";
            case 134L: return "V_SgAsmDwarfTryBlock";
            case 135L: return "V_SgAsmDwarfTypedef";
            case 136L: return "V_SgAsmDwarfUnionType";
            case 137L: return "V_SgAsmDwarfUnknownConstruct";
            case 138L: return "V_SgAsmDwarfUnspecifiedParameters";
            case 139L: return "V_SgAsmDwarfUnspecifiedType";
            case 140L: return "V_SgAsmDwarfUpcRelaxedType";
            case 141L: return "V_SgAsmDwarfUpcSharedType";
            case 142L: return "V_SgAsmDwarfUpcStrictType";
            case 143L: return "V_SgAsmDwarfVariable";
            case 144L: return "V_SgAsmDwarfVariant";
            case 145L: return "V_SgAsmDwarfVariantPart";
            case 146L: return "V_SgAsmDwarfVolatileType";
            case 147L: return "V_SgAsmDwarfWithStmt";
            case 148L: return "V_SgAsmElfDynamicEntry";
            case 149L: return "V_SgAsmElfDynamicEntryList";
            case 150L: return "V_SgAsmElfDynamicSection";
            case 151L: return "V_SgAsmElfEHFrameEntryCI";
            case 152L: return "V_SgAsmElfEHFrameEntryCIList";
            case 153L: return "V_SgAsmElfEHFrameEntryFD";
            case 154L: return "V_SgAsmElfEHFrameEntryFDList";
            case 155L: return "V_SgAsmElfEHFrameSection";
            case 156L: return "V_SgAsmElfFileHeader";
            case 157L: return "V_SgAsmElfNoteEntry";
            case 158L: return "V_SgAsmElfNoteEntryList";
            case 159L: return "V_SgAsmElfNoteSection";
            case 160L: return "V_SgAsmElfRelocEntry";
            case 161L: return "V_SgAsmElfRelocEntryList";
            case 162L: return "V_SgAsmElfRelocSection";
            case 163L: return "V_SgAsmElfSection";
            case 164L: return "V_SgAsmElfSectionTable";
            case 165L: return "V_SgAsmElfSectionTableEntry";
            case 166L: return "V_SgAsmElfSegmentTable";
            case 167L: return "V_SgAsmElfSegmentTableEntry";
            case 168L: return "V_SgAsmElfSegmentTableEntryList";
            case 169L: return "V_SgAsmElfStringSection";
            case 170L: return "V_SgAsmElfStrtab";
            case 171L: return "V_SgAsmElfSymbol";
            case 172L: return "V_SgAsmElfSymbolList";
            case 173L: return "V_SgAsmElfSymbolSection";
            case 174L: return "V_SgAsmElfSymverDefinedAux";
            case 175L: return "V_SgAsmElfSymverDefinedAuxList";
            case 176L: return "V_SgAsmElfSymverDefinedEntry";
            case 177L: return "V_SgAsmElfSymverDefinedEntryList";
            case 178L: return "V_SgAsmElfSymverDefinedSection";
            case 179L: return "V_SgAsmElfSymverEntry";
            case 180L: return "V_SgAsmElfSymverEntryList";
            case 181L: return "V_SgAsmElfSymverNeededAux";
            case 182L: return "V_SgAsmElfSymverNeededAuxList";
            case 183L: return "V_SgAsmElfSymverNeededEntry";
            case 184L: return "V_SgAsmElfSymverNeededEntryList";
            case 185L: return "V_SgAsmElfSymverNeededSection";
            case 186L: return "V_SgAsmElfSymverSection";
            case 187L: return "V_SgAsmExecutableFileFormat";
            case 188L: return "V_SgAsmExprListExp";
            case 189L: return "V_SgAsmExpression";
            case 190L: return "V_SgAsmSynthesizedFieldDeclaration";
            case 191L: return "V_SgAsmFloatType";
            case 192L: return "V_SgAsmFloatValueExpression";
            case 193L: return "V_SgAsmFunction";
            case 194L: return "V_SgAsmGenericDLL";
            case 195L: return "V_SgAsmGenericDLLList";
            case 196L: return "V_SgAsmGenericFile";
            case 197L: return "V_SgAsmGenericFileList";
            case 198L: return "V_SgAsmGenericFormat";
            case 199L: return "V_SgAsmGenericHeader";
            case 200L: return "V_SgAsmGenericHeaderList";
            case 201L: return "V_SgAsmGenericSection";
            case 202L: return "V_SgAsmGenericSectionList";
            case 203L: return "V_SgAsmGenericString";
            case 204L: return "V_SgAsmGenericStrtab";
            case 205L: return "V_SgAsmGenericSymbol";
            case 206L: return "V_SgAsmGenericSymbolList";
            case 207L: return "V_SgAsmIndirectRegisterExpression";
            case 208L: return "V_SgAsmInstruction";
            case 209L: return "V_SgAsmIntegerValueExpression";
            case 210L: return "V_SgAsmIntegerType";
            case 211L: return "V_SgAsmInterpretation";
            case 212L: return "V_SgAsmInterpretationList";
            case 213L: return "V_SgAsmJvmAttribute";
            case 214L: return "V_SgAsmJvmCodeAttribute";
            case 215L: return "V_SgAsmJvmMethod";
            case 216L: return "V_SgAsmJvmConstantPool";
            case 217L: return "V_SgAsmJvmConstantPoolEntry";
            case 218L: return "V_SgAsmJvmConstantValue";
            case 219L: return "V_SgAsmJvmInstruction";
            case 220L: return "V_SgAsmJvmFileHeader";
            case 221L: return "V_SgAsmJvmNode";
            case 222L: return "V_SgAsmJvmSignature";
            case 223L: return "V_SgAsmJvmSourceFile";
            case 224L: return "V_SgAsmLEEntryPoint";
            case 225L: return "V_SgAsmLEEntryTable";
            case 226L: return "V_SgAsmLEFileHeader";
            case 227L: return "V_SgAsmLENameTable";
            case 228L: return "V_SgAsmLEPageTable";
            case 229L: return "V_SgAsmLEPageTableEntry";
            case 230L: return "V_SgAsmLERelocTable";
            case 231L: return "V_SgAsmLESection";
            case 232L: return "V_SgAsmLESectionTable";
            case 233L: return "V_SgAsmLESectionTableEntry";
            case 234L: return "V_SgAsmM68kInstruction";
            case 235L: return "V_SgAsmMemoryReferenceExpression";
            case 236L: return "V_SgAsmMipsInstruction";
            case 237L: return "V_SgAsmNEEntryPoint";
            case 238L: return "V_SgAsmNEEntryTable";
            case 239L: return "V_SgAsmNEFileHeader";
            case 240L: return "V_SgAsmNEModuleTable";
            case 241L: return "V_SgAsmNENameTable";
            case 242L: return "V_SgAsmNERelocEntry";
            case 243L: return "V_SgAsmNERelocTable";
            case 244L: return "V_SgAsmNESection";
            case 245L: return "V_SgAsmNESectionTable";
            case 246L: return "V_SgAsmNESectionTableEntry";
            case 247L: return "V_SgAsmNEStringTable";
            case 248L: return "V_SgAsmNode";
            case 249L: return "V_SgAsmOp";
            case 250L: return "V_SgAsmOperandList";
            case 251L: return "V_SgAsmPEExportDirectory";
            case 252L: return "V_SgAsmPEExportEntry";
            case 253L: return "V_SgAsmPEExportEntryList";
            case 254L: return "V_SgAsmPEExportSection";
            case 255L: return "V_SgAsmPEFileHeader";
            case 256L: return "V_SgAsmPEImportDirectory";
            case 257L: return "V_SgAsmPEImportDirectoryList";
            case 258L: return "V_SgAsmPEImportItem";
            case 259L: return "V_SgAsmPEImportItemList";
            case 260L: return "V_SgAsmPEImportSection";
            case 261L: return "V_SgAsmPERVASizePair";
            case 262L: return "V_SgAsmPERVASizePairList";
            case 263L: return "V_SgAsmPESection";
            case 264L: return "V_SgAsmPESectionTable";
            case 265L: return "V_SgAsmPESectionTableEntry";
            case 266L: return "V_SgAsmPEStringSection";
            case 267L: return "V_SgAsmPowerpcInstruction";
            case 268L: return "V_SgAsmRegisterNames";
            case 269L: return "V_SgAsmRegisterReferenceExpression";
            case 270L: return "V_SgAsmRiscOperation";
            case 271L: return "V_SgAsmScalarType";
            case 272L: return "V_SgAsmStatement";
            case 273L: return "V_SgAsmStaticData";
            case 274L: return "V_SgAsmStmt";
            case 275L: return "V_SgAsmStoredString";
            case 276L: return "V_SgAsmStringStorage";
            case 277L: return "V_SgAsmType";
            case 278L: return "V_SgAsmUnaryExpression";
            case 279L: return "V_SgAsmUnaryMinus";
            case 280L: return "V_SgAsmUnaryPlus";
            case 281L: return "V_SgAsmUnaryRrx";
            case 282L: return "V_SgAsmUnarySignedExtend";
            case 283L: return "V_SgAsmUnaryUnsignedExtend";
            case 284L: return "V_SgAsmUnaryTruncate";
            case 285L: return "V_SgAsmValueExpression";
            case 286L: return "V_SgAsmVectorType";
            case 287L: return "V_SgAsmX86Instruction";
            case 288L: return "V_SgAsmBinaryAddressSymbol";
            case 289L: return "V_SgAsmBinaryDataSymbol";
            case 290L: return "V_SgAssertStmt";
            case 291L: return "V_SgAssignInitializer";
            case 292L: return "V_SgAssignOp";
            case 293L: return "V_SgAssignStatement";
            case 294L: return "V_SgAssignedGotoStatement";
            case 295L: return "V_SgAssociateStatement";
            case 296L: return "V_SgAsteriskShapeExp";
            case 297L: return "V_SgAtOp";
            case 298L: return "V_SgAttribute";
            case 299L: return "V_SgAttributeSpecificationStatement";
            case 300L: return "V_SgAutoType";
            case 301L: return "V_SgAwaitExpression";
            case 302L: return "V_SgBackspaceStatement";
            case 303L: return "V_SgBaseClass";
            case 304L: return "V_SgExpBaseClass";
            case 305L: return "V_SgBaseClassModifier";
            case 306L: return "V_SgBasicBlock";
            case 307L: return "V_SgBidirectionalGraph";
            case 308L: return "V_SgBinaryComposite";
            case 309L: return "V_SgBinaryOp";
            case 310L: return "V_SgBitAndOp";
            case 311L: return "V_SgBitAttribute";
            case 312L: return "V_SgBitComplementOp";
            case 313L: return "V_SgBitEqvOp";
            case 314L: return "V_SgBitOrOp";
            case 315L: return "V_SgBitXorOp";
            case 316L: return "V_SgBlockDataStatement";
            case 317L: return "V_SgBoolValExp";
            case 318L: return "V_SgBreakStmt";
            case 319L: return "V_SgBracedInitializer";
            case 320L: return "V_SgC_PreprocessorDirectiveStatement";
            case 321L: return "V_SgCaseOptionStmt";
            case 322L: return "V_SgCastExp";
            case 323L: return "V_SgCatchOptionStmt";
            case 324L: return "V_SgCatchStatementSeq";
            case 325L: return "V_SgCharVal";
            case 326L: return "V_SgChar16Val";
            case 327L: return "V_SgChar32Val";
            case 328L: return "V_SgChooseExpression";
            case 329L: return "V_SgClassDecl_attr";
            case 330L: return "V_SgClassDeclaration";
            case 331L: return "V_SgClassDefinition";
            case 332L: return "V_SgClassNameRefExp";
            case 333L: return "V_SgClassSymbol";
            case 334L: return "V_SgClassType";
            case 335L: return "V_SgClinkageDeclarationStatement";
            case 336L: return "V_SgClinkageEndStatement";
            case 337L: return "V_SgClinkageStartStatement";
            case 338L: return "V_SgCloseStatement";
            case 339L: return "V_SgColonShapeExp";
            case 340L: return "V_SgCommaOpExp";
            case 341L: return "V_SgCommonBlock";
            case 342L: return "V_SgCommonBlockObject";
            case 343L: return "V_SgCommonSymbol";
            case 344L: return "V_SgComplexVal";
            case 345L: return "V_SgComprehension";
            case 347L: return "V_SgCompoundAssignOp";
            case 348L: return "V_SgCompoundInitializer";
            case 349L: return "V_SgCompoundLiteralExp";
            case 350L: return "V_SgComputedGotoStatement";
            case 351L: return "V_SgConcatenationOp";
            case 352L: return "V_SgConditionalExp";
            case 353L: return "V_SgConjugateOp";
            case 354L: return "V_SgConstVolatileModifier";
            case 355L: return "V_SgConstructorInitializer";
            case 356L: return "V_SgContainsStatement";
            case 357L: return "V_SgContinueStmt";
            case 358L: return "V_SgCtorInitializerList";
            case 359L: return "V_SgDataStatementGroup";
            case 360L: return "V_SgDataStatementObject";
            case 361L: return "V_SgDataStatementValue";
            case 362L: return "V_SgDeadIfDirectiveStatement";
            case 363L: return "V_SgDeallocateStatement";
            case 364L: return "V_SgDeclarationModifier";
            case 365L: return "V_SgDeclarationScope";
            case 366L: return "V_SgDeclarationStatement";
            case 367L: return "V_SgDeclType";
            case 368L: return "V_SgDefaultOptionStmt";
            case 369L: return "V_SgDefaultSymbol";
            case 370L: return "V_SgDefineDirectiveStatement";
            case 371L: return "V_SgDeleteExp";
            case 372L: return "V_SgDerivedTypeStatement";
            case 373L: return "V_SgDesignatedInitializer";
            case 374L: return "V_SgDictionaryComprehension";
            case 375L: return "V_SgDictionaryExp";
            case 376L: return "V_SgDimensionObject";
            case 378L: return "V_SgDirectedGraphEdge";
            case 380L: return "V_SgDirectory";
            case 381L: return "V_SgDirectoryList";
            case 382L: return "V_SgDivAssignOp";
            case 383L: return "V_SgDivideOp";
            case 384L: return "V_SgDoWhileStmt";
            case 385L: return "V_SgDotExp";
            case 386L: return "V_SgDotStarOp";
            case 387L: return "V_SgDoubleVal";
            case 388L: return "V_SgElaboratedTypeModifier";
            case 389L: return "V_SgElementwiseOp";
            case 390L: return "V_SgElementwiseAddOp";
            case 391L: return "V_SgElementwiseDivideOp";
            case 392L: return "V_SgElementwiseLeftDivideOp";
            case 393L: return "V_SgElementwiseMultiplyOp";
            case 394L: return "V_SgElementwisePowerOp";
            case 395L: return "V_SgElementwiseSubtractOp";
            case 396L: return "V_SgElseDirectiveStatement";
            case 397L: return "V_SgElseWhereStatement";
            case 398L: return "V_SgElseifDirectiveStatement";
            case 399L: return "V_SgEmptyDeclaration";
            case 400L: return "V_SgEmptyDirectiveStatement";
            case 401L: return "V_SgEndfileStatement";
            case 402L: return "V_SgEndifDirectiveStatement";
            case 403L: return "V_SgEntryStatement";
            case 404L: return "V_SgEnumDeclaration";
            case 405L: return "V_SgEnumFieldSymbol";
            case 406L: return "V_SgEnumSymbol";
            case 407L: return "V_SgEnumType";
            case 408L: return "V_SgEnumVal";
            case 409L: return "V_SgEqualityOp";
            case 410L: return "V_SgEquivalenceStatement";
            case 411L: return "V_SgErrorDirectiveStatement";
            case 412L: return "V_SgExecStatement";
            case 413L: return "V_SgExponentiationOp";
            case 414L: return "V_SgExponentiationAssignOp";
            case 415L: return "V_SgExprListExp";
            case 416L: return "V_SgExprStatement";
            case 417L: return "V_SgExpression";
            case 418L: return "V_SgExpressionRoot";
            case 419L: return "V_SgFile";
            case 420L: return "V_SgFileList";
            case 421L: return "V_SgFloatVal";
            case 422L: return "V_SgFloat128Val";
            case 423L: return "V_SgFloat80Val";
            case 424L: return "V_SgFoldExpression";
            case 425L: return "V_SgFlushStatement";
            case 426L: return "V_SgForAllStatement";
            case 427L: return "V_SgForInitStatement";
            case 428L: return "V_SgForStatement";
            case 429L: return "V_SgFormatItem";
            case 430L: return "V_SgFormatItemList";
            case 431L: return "V_SgFormatStatement";
            case 432L: return "V_SgFortranDo";
            case 433L: return "V_SgFortranIncludeLine";
            case 434L: return "V_SgFortranNonblockedDo";
            case 435L: return "V_SgFuncDecl_attr";
            case 436L: return "V_SgFunctionCallExp";
            case 437L: return "V_SgFunctionDeclaration";
            case 438L: return "V_SgFunctionDefinition";
            case 439L: return "V_SgFunctionParameterScope";
            case 440L: return "V_SgFunctionModifier";
            case 441L: return "V_SgFunctionParameterList";
            case 442L: return "V_SgFunctionParameterRefExp";
            case 443L: return "V_SgFunctionParameterTypeList";
            case 444L: return "V_SgFunctionRefExp";
            case 445L: return "V_SgFunctionSymbol";
            case 446L: return "V_SgFunctionType";
            case 447L: return "V_SgFunctionTypeSymbol";
            case 448L: return "V_SgFunctionTypeTable";
            case 449L: return "V_SgTypeTable";
            case 450L: return "V_SgGlobal";
            case 451L: return "V_SgGotoStatement";
            case 452L: return "V_SgGraph";
            case 453L: return "V_SgGraphEdge";
            case 454L: return "V_SgGraphEdgeList";
            case 455L: return "V_SgGraphNode";
            case 456L: return "V_SgGraphNodeList";
            case 457L: return "V_SgGreaterOrEqualOp";
            case 458L: return "V_SgGreaterThanOp";
            case 459L: return "V_SgIOItemExpression";
            case 460L: return "V_SgIOStatement";
            case 461L: return "V_SgIdentDirectiveStatement";
            case 462L: return "V_SgIfDirectiveStatement";
            case 463L: return "V_SgIfStmt";
            case 464L: return "V_SgIfdefDirectiveStatement";
            case 465L: return "V_SgIfndefDirectiveStatement";
            case 466L: return "V_SgImageControlStatement";
            case 467L: return "V_SgImagPartOp";
            case 468L: return "V_SgImplicitStatement";
            case 469L: return "V_SgImpliedDo";
            case 470L: return "V_SgImportStatement";
            case 471L: return "V_SgIncidenceDirectedGraph";
            case 472L: return "V_SgIncidenceUndirectedGraph";
            case 473L: return "V_SgIncludeDirectiveStatement";
            case 474L: return "V_SgIncludeFile";
            case 475L: return "V_SgIncludeNextDirectiveStatement";
            case 476L: return "V_SgInitializedName";
            case 477L: return "V_SgInitializer";
            case 478L: return "V_SgInquireStatement";
            case 479L: return "V_SgIntKeyedBidirectionalGraph";
            case 480L: return "V_SgIntVal";
            case 481L: return "V_SgIntegerDivideOp";
            case 482L: return "V_SgIntegerDivideAssignOp";
            case 483L: return "V_SgInterfaceBody";
            case 484L: return "V_SgHeaderFileBody";
            case 485L: return "V_SgHeaderFileReport";
            case 486L: return "V_SgInterfaceStatement";
            case 487L: return "V_SgInterfaceSymbol";
            case 488L: return "V_SgIntrinsicSymbol";
            case 489L: return "V_SgIsOp";
            case 490L: return "V_SgIsNotOp";
            case 491L: return "V_SgIorAssignOp";
            case 492L: return "V_SgJovialBitType";
            case 493L: return "V_SgJovialBitVal";
            case 494L: return "V_SgJovialTableType";
            case 495L: return "V_SgJovialCompoolStatement";
            case 496L: return "V_SgJovialForThenStatement";
            case 497L: return "V_SgJovialDefineDeclaration";
            case 498L: return "V_SgJovialDirectiveStatement";
            case 499L: return "V_SgJovialOverlayDeclaration";
            case 500L: return "V_SgJovialPresetPositionExp";
            case 501L: return "V_SgJovialTablePresetExp";
            case 502L: return "V_SgJovialTableStatement";
            case 503L: return "V_SgKeyDatumPair";
            case 504L: return "V_SgCudaKernelExecConfig";
            case 505L: return "V_SgCudaKernelCallExp";
            case 506L: return "V_SgLabelRefExp";
            case 507L: return "V_SgLabelStatement";
            case 508L: return "V_SgJavaLabelStatement";
            case 509L: return "V_SgLabelSymbol";
            case 510L: return "V_SgJavaLabelSymbol";
            case 511L: return "V_SgLambdaCapture";
            case 512L: return "V_SgLambdaCaptureList";
            case 513L: return "V_SgLambdaExp";
            case 514L: return "V_SgLambdaRefExp";
            case 515L: return "V_SgLeftDivideOp";
            case 516L: return "V_SgLessOrEqualOp";
            case 517L: return "V_SgLessThanOp";
            case 518L: return "V_SgLineDirectiveStatement";
            case 519L: return "V_SgLinemarkerDirectiveStatement";
            case 520L: return "V_SgLinkageModifier";
            case 521L: return "V_SgListComprehension";
            case 522L: return "V_SgListExp";
            case 523L: return "V_SgLocatedNode";
            case 524L: return "V_SgLocatedNodeSupport";
            case 525L: return "V_SgLongDoubleVal";
            case 526L: return "V_SgLongIntVal";
            case 527L: return "V_SgLongLongIntVal";
            case 528L: return "V_SgLshiftAssignOp";
            case 529L: return "V_SgLshiftOp";
            case 530L: return "V_SgMagicColonExp";
            case 531L: return "V_SgMatrixExp";
            case 532L: return "V_SgMatrixTransposeOp";
            case 533L: return "V_SgMatlabForStatement";
            case 534L: return "V_SgMemberFunctionDeclaration";
            case 535L: return "V_SgMemberFunctionRefExp";
            case 536L: return "V_SgMemberFunctionSymbol";
            case 537L: return "V_SgMemberFunctionType";
            case 538L: return "V_SgMembershipOp";
            case 539L: return "V_SgMicrosoftAttributeDeclaration";
            case 540L: return "V_SgMinusAssignOp";
            case 541L: return "V_SgMinusMinusOp";
            case 542L: return "V_SgMinusOp";
            case 543L: return "V_SgModAssignOp";
            case 544L: return "V_SgModOp";
            case 545L: return "V_SgModifier";
            case 546L: return "V_SgModifierNodes";
            case 547L: return "V_SgModifierType";
            case 548L: return "V_SgModuleStatement";
            case 549L: return "V_SgModuleSymbol";
            case 550L: return "V_SgMultAssignOp";
            case 551L: return "V_SgMultiplyOp";
            case 552L: return "V_SgName";
            case 553L: return "V_SgNameGroup";
            case 554L: return "V_SgNamedType";
            case 555L: return "V_SgNamelistStatement";
            case 556L: return "V_SgNamespaceAliasDeclarationStatement";
            case 557L: return "V_SgNamespaceDeclarationStatement";
            case 558L: return "V_SgNamespaceDefinitionStatement";
            case 559L: return "V_SgNamespaceSymbol";
            case 560L: return "V_SgNaryOp";
            case 561L: return "V_SgNaryBooleanOp";
            case 562L: return "V_SgNaryComparisonOp";
            case 563L: return "V_SgNewExp";
            case 564L: return "V_SgNode";
            case 565L: return "V_SgNoexceptOp";
            case 566L: return "V_SgNotEqualOp";
            case 567L: return "V_SgNotOp";
            case 568L: return "V_SgNonMembershipOp";
            case 569L: return "V_SgNonrealDecl";
            case 570L: return "V_SgNonrealRefExp";
            case 571L: return "V_SgNonrealSymbol";
            case 572L: return "V_SgNonrealType";
            case 573L: return "V_SgNonrealBaseClass";
            case 574L: return "V_SgNullExpression";
            case 575L: return "V_SgNullptrValExp";
            case 576L: return "V_SgNullStatement";
            case 577L: return "V_SgNullifyStatement";
            case 578L: return "V_SgOmpAtomicStatement";
            case 579L: return "V_SgOmpBarrierStatement";
            case 580L: return "V_SgOmpCriticalStatement";
            case 581L: return "V_SgOmpClauseBodyStatement";
            case 582L: return "V_SgOmpBodyStatement";
            case 583L: return "V_SgOmpDoStatement";
            case 584L: return "V_SgOmpFlushStatement";
            case 585L: return "V_SgOmpDeclareSimdStatement";
            case 586L: return "V_SgOmpForStatement";
            case 587L: return "V_SgOmpForSimdStatement";
            case 588L: return "V_SgOmpMasterStatement";
            case 589L: return "V_SgOmpOrderedStatement";
            case 590L: return "V_SgOmpParallelStatement";
            case 591L: return "V_SgOmpSectionStatement";
            case 592L: return "V_SgOmpSectionsStatement";
            case 593L: return "V_SgOmpSingleStatement";
            case 594L: return "V_SgOmpTaskStatement";
            case 595L: return "V_SgOmpTaskwaitStatement";
            case 596L: return "V_SgOmpThreadprivateStatement";
            case 597L: return "V_SgOmpWorkshareStatement";
            case 598L: return "V_SgOmpTargetStatement";
            case 599L: return "V_SgOmpTargetDataStatement";
            case 600L: return "V_SgOmpSimdStatement";
            case 601L: return "V_SgOmpClause";
            case 602L: return "V_SgOmpBeginClause";
            case 603L: return "V_SgOmpCollapseClause";
            case 604L: return "V_SgOmpCopyinClause";
            case 605L: return "V_SgOmpCopyprivateClause";
            case 606L: return "V_SgOmpDefaultClause";
            case 607L: return "V_SgOmpEndClause";
            case 608L: return "V_SgOmpExpressionClause";
            case 609L: return "V_SgOmpFirstprivateClause";
            case 610L: return "V_SgOmpIfClause";
            case 611L: return "V_SgOmpFinalClause";
            case 612L: return "V_SgOmpPriorityClause";
            case 613L: return "V_SgOmpDeviceClause";
            case 614L: return "V_SgOmpLastprivateClause";
            case 615L: return "V_SgOmpNowaitClause";
            case 616L: return "V_SgOmpNumThreadsClause";
            case 617L: return "V_SgOmpOrderedClause";
            case 618L: return "V_SgOmpPrivateClause";
            case 619L: return "V_SgOmpReductionClause";
            case 620L: return "V_SgOmpScheduleClause";
            case 621L: return "V_SgOmpSharedClause";
            case 622L: return "V_SgOmpUntiedClause";
            case 623L: return "V_SgOmpMergeableClause";
            case 624L: return "V_SgOmpVariablesClause";
            case 625L: return "V_SgOmpMapClause";
            case 626L: return "V_SgOmpSafelenClause";
            case 627L: return "V_SgOmpSimdlenClause";
            case 628L: return "V_SgOmpLinearClause";
            case 629L: return "V_SgOmpUniformClause";
            case 630L: return "V_SgOmpAlignedClause";
            case 631L: return "V_SgOmpProcBindClause";
            case 632L: return "V_SgOmpAtomicClause";
            case 633L: return "V_SgOmpInbranchClause";
            case 634L: return "V_SgOmpNotinbranchClause";
            case 635L: return "V_SgOmpDependClause";
            case 636L: return "V_SgOpenclAccessModeModifier";
            case 637L: return "V_SgOpenStatement";
            case 638L: return "V_SgOptions";
            case 639L: return "V_SgOrOp";
            case 640L: return "V_SgParameterStatement";
            case 641L: return "V_SgPartialFunctionModifierType";
            case 642L: return "V_SgPartialFunctionType";
            case 643L: return "V_SgPassStatement";
            case 644L: return "V_SgPlusAssignOp";
            case 645L: return "V_SgPlusPlusOp";
            case 646L: return "V_SgPntrArrRefExp";
            case 647L: return "V_SgPointerAssignOp";
            case 648L: return "V_SgPointerDerefExp";
            case 649L: return "V_SgPointerMemberType";
            case 650L: return "V_SgPointerType";
            case 651L: return "V_SgPowerOp";
            case 652L: return "V_SgPragma";
            case 653L: return "V_SgPragmaDeclaration";
            case 654L: return "V_SgPrintStatement";
            case 655L: return "V_SgProcedureHeaderStatement";
            case 656L: return "V_SgProgramHeaderStatement";
            case 657L: return "V_SgProject";
            case 658L: return "V_SgPseudoDestructorRefExp";
            case 659L: return "V_SgPythonGlobalStmt";
            case 660L: return "V_SgPythonPrintStmt";
            case 661L: return "V_SgQualifiedName";
            case 662L: return "V_SgQualifiedNameType";
            case 663L: return "V_SgRangeExp";
            case 664L: return "V_SgRangeBasedForStatement";
            case 665L: return "V_SgReadStatement";
            case 666L: return "V_SgRealPartOp";
            case 667L: return "V_SgRefExp";
            case 668L: return "V_SgReferenceType";
            case 669L: return "V_SgRemOp";
            case 670L: return "V_SgRenamePair";
            case 671L: return "V_SgRenameSymbol";
            case 672L: return "V_SgReplicationOp";
            case 673L: return "V_SgReturnStmt";
            case 674L: return "V_SgRewindStatement";
            case 675L: return "V_SgRshiftAssignOp";
            case 676L: return "V_SgRshiftOp";
            case 677L: return "V_SgRvalueReferenceType";
            case 678L: return "V_SgJavaUnsignedRshiftAssignOp";
            case 679L: return "V_SgJavaUnsignedRshiftOp";
            case 680L: return "V_SgScopeOp";
            case 681L: return "V_SgScopeStatement";
            case 682L: return "V_SgSequenceStatement";
            case 683L: return "V_SgSetComprehension";
            case 684L: return "V_SgShortVal";
            case 685L: return "V_SgSizeOfOp";
            case 686L: return "V_SgAlignOfOp";
            case 687L: return "V_SgJavaInstanceOfOp";
            case 688L: return "V_SgSourceFile";
            case 689L: return "V_SgSpaceshipOp";
            case 690L: return "V_SgSpawnStmt";
            case 691L: return "V_SgSyncAllStatement";
            case 692L: return "V_SgSyncImagesStatement";
            case 693L: return "V_SgSyncMemoryStatement";
            case 694L: return "V_SgSyncTeamStatement";
            case 695L: return "V_SgLockStatement";
            case 696L: return "V_SgUnlockStatement";
            case 697L: return "V_SgJavaThrowStatement";
            case 698L: return "V_SgJavaForEachStatement";
            case 699L: return "V_SgJavaSynchronizedStatement";
            case 700L: return "V_SgJavaParameterizedType";
            case 701L: return "V_SgJavaWildcardType";
            case 702L: return "V_SgProcessControlStatement";
            case 703L: return "V_SgSpecialFunctionModifier";
            case 704L: return "V_SgStatement";
            case 705L: return "V_SgStaticAssertionDeclaration";
            case 706L: return "V_SgStmtDeclarationStatement";
            case 707L: return "V_SgStatementExpression";
            case 708L: return "V_SgStatementFunctionStatement";
            case 709L: return "V_SgStorageModifier";
            case 710L: return "V_SgStringConversion";
            case 711L: return "V_SgStringKeyedBidirectionalGraph";
            case 712L: return "V_SgStringVal";
            case 713L: return "V_SgStructureModifier";
            case 714L: return "V_SgSubscriptExpression";
            case 715L: return "V_SgSubtractOp";
            case 716L: return "V_SgSupport";
            case 717L: return "V_SgSwitchStatement";
            case 718L: return "V_SgSymbol";
            case 719L: return "V_SgSymbolTable";
            case 720L: return "V_SgTemplateArgument";
            case 721L: return "V_SgTemplateArgumentList";
            case 722L: return "V_SgTemplateDeclaration";
            case 723L: return "V_SgTemplateClassDeclaration";
            case 724L: return "V_SgTemplateClassSymbol";
            case 725L: return "V_SgTemplateFunctionDeclaration";
            case 726L: return "V_SgTemplateFunctionRefExp";
            case 727L: return "V_SgTemplateFunctionSymbol";
            case 728L: return "V_SgTemplateMemberFunctionDeclaration";
            case 729L: return "V_SgTemplateMemberFunctionRefExp";
            case 730L: return "V_SgTemplateMemberFunctionSymbol";
            case 731L: return "V_SgTemplateTypedefDeclaration";
            case 732L: return "V_SgTemplateTypedefSymbol";
            case 733L: return "V_SgTemplateVariableDeclaration";
            case 734L: return "V_SgTemplateVariableSymbol";
            case 735L: return "V_SgTemplateClassDefinition";
            case 736L: return "V_SgTemplateFunctionDefinition";
            case 737L: return "V_SgTemplateInstantiationDecl";
            case 738L: return "V_SgTemplateInstantiationDefn";
            case 739L: return "V_SgTemplateInstantiationDirectiveStatement";
            case 740L: return "V_SgTemplateInstantiationFunctionDecl";
            case 741L: return "V_SgTemplateInstantiationMemberFunctionDecl";
            case 742L: return "V_SgTemplateInstantiationTypedefDeclaration";
            case 743L: return "V_SgTemplateParameter";
            case 744L: return "V_SgTemplateParameterVal";
            case 745L: return "V_SgTemplateParameterList";
            case 746L: return "V_SgTemplateSymbol";
            case 747L: return "V_SgTemplateType";
            case 748L: return "V_SgThisExp";
            case 749L: return "V_SgTypeTraitBuiltinOperator";
            case 750L: return "V_SgSuperExp";
            case 751L: return "V_SgThrowOp";
            case 752L: return "V_SgToken";
            case 753L: return "V_SgTryStmt";
            case 754L: return "V_SgTupleExp";
            case 755L: return "V_SgType";
            case 756L: return "V_SgTypeBool";
            case 757L: return "V_SgTypeChar";
            case 758L: return "V_SgTypeChar16";
            case 759L: return "V_SgTypeChar32";
            case 760L: return "V_SgTypeComplex";
            case 761L: return "V_SgTypeDefault";
            case 762L: return "V_SgTypeExpression";
            case 763L: return "V_SgTypeLabel";
            case 764L: return "V_SgTypeDouble";
            case 765L: return "V_SgTypeEllipse";
            case 766L: return "V_SgTypeFixed";
            case 767L: return "V_SgTypeFloat";
            case 768L: return "V_SgTypeFloat128";
            case 769L: return "V_SgTypeFloat80";
            case 770L: return "V_SgTypeGlobalVoid";
            case 771L: return "V_SgTypeIdOp";
            case 772L: return "V_SgTypeImaginary";
            case 773L: return "V_SgTypeInt";
            case 774L: return "V_SgTypeLong";
            case 775L: return "V_SgTypeLongDouble";
            case 776L: return "V_SgTypeLongLong";
            case 777L: return "V_SgTypeModifier";
            case 778L: return "V_SgTypeMatrix";
            case 779L: return "V_SgTypeTuple";
            case 780L: return "V_SgTypeNullptr";
            case 781L: return "V_SgTypeOfType";
            case 782L: return "V_SgTypeShort";
            case 783L: return "V_SgTypeSigned128bitInteger";
            case 784L: return "V_SgTypeSignedChar";
            case 785L: return "V_SgTypeSignedInt";
            case 786L: return "V_SgTypeSignedLong";
            case 787L: return "V_SgTypeSignedLongLong";
            case 788L: return "V_SgTypeSignedShort";
            case 789L: return "V_SgTypeString";
            case 790L: return "V_SgTypeUnknown";
            case 791L: return "V_SgTypeUnsigned128bitInteger";
            case 792L: return "V_SgTypeUnsignedChar";
            case 793L: return "V_SgTypeUnsignedInt";
            case 794L: return "V_SgTypeUnsignedLong";
            case 795L: return "V_SgTypeUnsignedLongLong";
            case 796L: return "V_SgTypeUnsignedShort";
            case 797L: return "V_SgTypeVoid";
            case 798L: return "V_SgTypeWchar";
            case 799L: return "V_SgTypedefDeclaration";
            case 800L: return "V_SgTypedefSeq";
            case 801L: return "V_SgTypedefSymbol";
            case 802L: return "V_SgTypedefType";
            case 803L: return "V_SgUPC_AccessModifier";
            case 804L: return "V_SgUnaryAddOp";
            case 805L: return "V_SgUnaryOp";
            case 806L: return "V_SgUndefDirectiveStatement";
            case 807L: return "V_SgUndirectedGraphEdge";
            case 808L: return "V_SgUnknownArrayOrFunctionReference";
            case 809L: return "V_SgUnknownFile";
            case 811L: return "V_SgUnparse_Info";
            case 812L: return "V_SgUnsignedCharVal";
            case 813L: return "V_SgUnsignedIntVal";
            case 814L: return "V_SgUnsignedLongLongIntVal";
            case 815L: return "V_SgUnsignedLongVal";
            case 816L: return "V_SgUnsignedShortVal";
            case 817L: return "V_SgUpcBarrierStatement";
            case 818L: return "V_SgUpcBlocksizeofExpression";
            case 819L: return "V_SgUpcElemsizeofExpression";
            case 820L: return "V_SgUpcFenceStatement";
            case 821L: return "V_SgUpcForAllStatement";
            case 822L: return "V_SgUpcLocalsizeofExpression";
            case 823L: return "V_SgUpcMythread";
            case 824L: return "V_SgUpcNotifyStatement";
            case 825L: return "V_SgUpcThreads";
            case 826L: return "V_SgUpcWaitStatement";
            case 827L: return "V_SgUseStatement";
            case 828L: return "V_SgUserDefinedBinaryOp";
            case 829L: return "V_SgUserDefinedUnaryOp";
            case 830L: return "V_SgUsingDeclarationStatement";
            case 831L: return "V_SgUsingDirectiveStatement";
            case 832L: return "V_SgValueExp";
            case 833L: return "V_SgVarArgCopyOp";
            case 834L: return "V_SgVarArgEndOp";
            case 835L: return "V_SgVarArgOp";
            case 836L: return "V_SgVarArgStartOneOperandOp";
            case 837L: return "V_SgVarArgStartOp";
            case 838L: return "V_SgVarRefExp";
            case 839L: return "V_SgVariableDeclaration";
            case 840L: return "V_SgVariableDefinition";
            case 841L: return "V_SgVariableSymbol";
            case 842L: return "V_SgVariantExpression";
            case 843L: return "V_SgVariantStatement";
            case 844L: return "V_SgVoidVal";
            case 845L: return "V_SgWaitStatement";
            case 846L: return "V_SgWarningDirectiveStatement";
            case 847L: return "V_SgWithStatement";
            case 848L: return "V_SgWcharVal";
            case 849L: return "V_SgWhereStatement";
            case 850L: return "V_SgWhileStmt";
            case 851L: return "V_SgWriteStatement";
            case 852L: return "V_SgXorAssignOp";
            case 853L: return "V_SgYieldExpression";
            case 854L: return "V_Sg_File_Info";
            case 855L: return "V_SgTypeCAFTeam";
            case 856L: return "V_SgCAFWithTeamStatement";
            case 857L: return "V_SgCAFCoExpression";
            case 858L: return "V_SgCallExpression";
            case 859L: return "V_SgTypeCrayPointer";
            case 860L: return "V_SgJavaImportStatement";
            case 861L: return "V_SgJavaPackageDeclaration";
            case 862L: return "V_SgJavaPackageStatement";
            case 863L: return "V_SgJavaImportStatementList";
            case 864L: return "V_SgJavaClassDeclarationList";
            case 865L: return "V_SgJavaMemberValuePair";
            case 866L: return "V_SgJavaAnnotation";
            case 867L: return "V_SgJavaMarkerAnnotation";
            case 868L: return "V_SgJavaSingleMemberAnnotation";
            case 869L: return "V_SgJavaNormalAnnotation";
            case 870L: return "V_SgJavaTypeExpression";
            case 871L: return "V_SgJavaQualifiedType";
            case 872L: return "V_SgClassExp";
            case 873L: return "V_SgJavaUnionType";
            case 874L: return "V_SgJavaParameterType";
            case 875L: return "V_SgAsyncStmt";
            case 876L: return "V_SgFinishStmt";
            case 877L: return "V_SgAtStmt";
            case 878L: return "V_SgAtomicStmt";
            case 880L: return "V_SgWhenStmt";
            case 881L: return "V_SgAtExp";
            case 882L: return "V_SgFinishExp";
            case 883L: return "V_SgHereExp";
            case 884L: return "V_SgDotDotExp";
            case 885L: return "V_SgAsmNullInstruction";
            case 886L: return "V_SgAdaComponentClause";
            case 887L: return "V_SgAdaIndexConstraint";
            case 888L: return "V_SgAdaModularType";
            case 889L: return "V_SgAdaRepresentationClause";
            case 890L: return "V_SgAdaFunctionRenamingDecl";
            case 891L: return "V_SgAdaSelectStmt";
            case 892L: return "V_SgAdaSelectAlternativeStmt";
            case 893L: return "V_SgAdaTerminateStmt";
            case 895L: return "V_SgAsmAarch32Coprocessor";
            case 896L: return "V_SgAdaAttributeClause";
            case 897L: return "V_SgAsmBinaryConcat";
            case 898L: return "V_SgAsmByteOrder";
            case 899L: return "V_SgAdaDerivedType";
            case 900L: return "V_SgAdaAttributeExp";
            case 901L: return "V_SgAdaEnumRepresentationClause";
            case 902L: return "V_SgAsmBinaryPreupdate";
            case 903L: return "V_SgAsmBinaryPostupdate";
            case 904L: return "V_SgAdaOthersExp";
            case 905L: return "V_SgAdaRenamingSymbol";
            case 906L: return "V_SgAdaRenamingRefExp";
            case 907L: return "V_SgAdaGenericDecl";
            case 908L: return "V_SgAdaGenericDefn";
            case 909L: return "V_SgAdaFormalType";
            case 910L: return "V_SgAdaGenericSymbol";
            case 911L: return "V_SgAdaFormalTypeDecl";
            case 912L: return "V_SgAdaUnitRefExp";
            case 913L: return "V_SgAdaDiscriminatedTypeDecl";
            case 914L: return "V_SgAdaDiscriminatedType";
            case 915L: return "V_SgAdaDiscriminantConstraint";
            case 916L: return "V_SgAdaGenericInstanceDecl";
            case 917L: return "V_SgAdaUnscopedBlock";
            case 918L: return "V_SgAdaInheritedFunctionSymbol";
            case 919L: return "V_SgAdaProtectedBody";
            case 920L: return "V_SgAdaProtectedBodyDecl";
            case 921L: return "V_SgAdaProtectedSpec";
            case 922L: return "V_SgAdaProtectedSpecDecl";
            case 923L: return "V_SgAdaProtectedSymbol";
            case 924L: return "V_SgAdaProtectedRefExp";
            case 925L: return "V_SgAdaProtectedType";
            case 926L: return "V_SgAdaProtectedTypeDecl";
            case 927L: return "V_SgAdaDigitsConstraint";
            case 928L: return "V_SgAdaAncestorInitializer";
            case 929L: return "V_SgAdaDeltaConstraint";
            case 930L: return "V_SgAdaSubroutineType";
            case 931L: return "V_SgAdaGenericInstanceSymbol";
            case 932L: return "V_SgAdaFormalPackageDecl";
            case 933L: return "V_SgAdaFormalPackageSymbol";
            case 934L: return "V_SgAsmJvmAttributeTable";
            case 935L: return "V_SgAsmJvmMethodTable";
            case 936L: return "V_SgAsmJvmField";
            case 937L: return "V_SgAsmJvmFieldTable";
            case 938L: return "V_SgAsmJvmExceptionHandler";
            case 939L: return "V_SgAsmJvmExceptionTable";
            case 940L: return "V_SgAsmJvmClass";
            case 941L: return "V_SgAsmJvmLineNumberEntry";
            case 942L: return "V_SgAsmJvmLineNumberTable";
            case 943L: return "V_SgAsmJvmInnerClassesEntry";
            case 944L: return "V_SgAsmJvmInnerClasses";
            case 945L: return "V_SgAsmCilInstruction";
            case 946L: return "V_SgAsmStackExpression";
            case 947L: return "V_SgAsmJvmEnclosingMethod";
            case 948L: return "V_SgAdaNullConstraint";
            case 949L: return "V_SgAsmJvmModuleMainClass";
            case 950L: return "V_SgAsmInstructionList";
            case 951L: return "V_SgAsmCilNode";
            case 952L: return "V_SgAsmCilAssembly";
            case 953L: return "V_SgAsmCilAssemblyOS";
            case 954L: return "V_SgAsmCilAssemblyProcessor";
            case 955L: return "V_SgAsmCilAssemblyRef";
            case 956L: return "V_SgAsmCilAssemblyRefOS";
            case 957L: return "V_SgAsmCilAssemblyRefProcessor";
            case 958L: return "V_SgAsmCilClassLayout";
            case 959L: return "V_SgAsmCilConstant";
            case 960L: return "V_SgAsmCilCustomAttribute";
            case 961L: return "V_SgAsmCilDeclSecurity";
            case 962L: return "V_SgAsmCilEvent";
            case 963L: return "V_SgAsmCilEventMap";
            case 964L: return "V_SgAsmCilExportedType";
            case 965L: return "V_SgAsmCilField";
            case 966L: return "V_SgAsmCilFieldLayout";
            case 967L: return "V_SgAsmCilFieldMarshal";
            case 968L: return "V_SgAsmCilFieldRVA";
            case 969L: return "V_SgAsmCilFile";
            case 970L: return "V_SgAsmCilGenericParam";
            case 971L: return "V_SgAsmCilGenericParamConstraint";
            case 972L: return "V_SgAsmCilImplMap";
            case 973L: return "V_SgAsmCilInterfaceImpl";
            case 974L: return "V_SgAsmCilManifestResource";
            case 975L: return "V_SgAsmCilMemberRef";
            case 976L: return "V_SgAsmCilMethodDef";
            case 977L: return "V_SgAsmCilMethodImpl";
            case 978L: return "V_SgAsmCilMethodSemantics";
            case 979L: return "V_SgAsmCilMethodSpec";
            case 980L: return "V_SgAsmCilModule";
            case 981L: return "V_SgAsmCilModuleRef";
            case 982L: return "V_SgAsmCilNestedClass";
            case 983L: return "V_SgAsmCilParam";
            case 984L: return "V_SgAsmCilProperty";
            case 985L: return "V_SgAsmCilPropertyMap";
            case 986L: return "V_SgAsmCilStandAloneSig";
            case 987L: return "V_SgAsmCilTypeDef";
            case 988L: return "V_SgAsmCilTypeRef";
            case 989L: return "V_SgAsmCilTypeSpec";
            case 990L: return "V_SgAdaParameterList";
            case 991L: return "V_SgAsmCilMetadata";
            case 992L: return "V_SgAsmCilMetadataRoot";
            case 993L: return "V_SgAsmCilDataStream";
            case 994L: return "V_SgAsmCilMetadataHeap";
            case 995L: return "V_SgAsmCilUint8Heap";
            case 996L: return "V_SgAsmCilUint32Heap";
            case 997L: return "V_SgAsmCliHeader";
            case 998L: return "V_SgAdaVariantDecl";
            case 999L: return "V_SgAdaVariantWhenStmt";
            case 1000L: return "V_SgAsmCilAssemblyTable";
            case 1001L: return "V_SgAsmCilAssemblyOSTable";
            case 1002L: return "V_SgAsmCilAssemblyProcessorTable";
            case 1003L: return "V_SgAsmCilAssemblyRefTable";
            case 1004L: return "V_SgAsmCilAssemblyRefOSTable";
            case 1005L: return "V_SgAsmCilAssemblyRefProcessorTable";
            case 1006L: return "V_SgAsmCilClassLayoutTable";
            case 1007L: return "V_SgAsmCilConstantTable";
            case 1008L: return "V_SgAsmCilCustomAttributeTable";
            case 1009L: return "V_SgAsmCilDeclSecurityTable";
            case 1010L: return "V_SgAsmCilEventTable";
            case 1011L: return "V_SgAsmCilEventMapTable";
            case 1012L: return "V_SgAsmCilExportedTypeTable";
            case 1013L: return "V_SgAsmCilFieldTable";
            case 1014L: return "V_SgAsmCilFieldLayoutTable";
            case 1015L: return "V_SgAsmCilFieldMarshalTable";
            case 1016L: return "V_SgAsmCilFieldRVATable";
            case 1017L: return "V_SgAsmCilFileTable";
            case 1018L: return "V_SgAsmCilGenericParamTable";
            case 1019L: return "V_SgAsmCilGenericParamConstraintTable";
            case 1020L: return "V_SgAsmCilImplMapTable";
            case 1021L: return "V_SgAsmCilInterfaceImplTable";
            case 1022L: return "V_SgAsmCilManifestResourceTable";
            case 1023L: return "V_SgAsmCilMemberRefTable";
            case 1024L: return "V_SgAsmCilMethodDefTable";
            case 1025L: return "V_SgAsmCilMethodImplTable";
            case 1026L: return "V_SgAsmCilMethodSemanticsTable";
            case 1027L: return "V_SgAsmCilMethodSpecTable";
            case 1028L: return "V_SgAsmCilModuleTable";
            case 1029L: return "V_SgAsmCilModuleRefTable";
            case 1030L: return "V_SgAsmCilNestedClassTable";
            case 1031L: return "V_SgAsmCilParamTable";
            case 1032L: return "V_SgAsmCilPropertyTable";
            case 1033L: return "V_SgAsmCilPropertyMapTable";
            case 1034L: return "V_SgAsmCilStandAloneSigTable";
            case 1035L: return "V_SgAsmCilTypeDefTable";
            case 1036L: return "V_SgAsmCilTypeRefTable";
            case 1037L: return "V_SgAsmCilTypeSpecTable";
            case 1038L: return "V_SgJvmComposite";
            case 1039L: return "V_SgFortranContinueStmt";
            case 1040L: return "V_SgAsmJvmStackMapTable";
            case 1041L: return "V_SgAsmJvmStackMapFrame";
            case 1042L: return "V_SgAsmJvmStackMapVerificationType";
            case 1043L: return "V_SgAsmJvmBootstrapMethod";
            case 1044L: return "V_SgAsmJvmBootstrapMethods";
            case 1045L: return "V_SgAsmJvmExceptions";
            case 1046L: return "V_SgAsmJvmNestMembers";
            case 1047L: return "V_SgAsmJvmNestHost";
            case 1048L: return "V_SgJovialLabelDeclaration";
            case 1049L: return "V_SgAsmJvmLocalVariableEntry";
            case 1050L: return "V_SgAsmJvmLocalVariableTable";
            case 1051L: return "V_SgAsmJvmLocalVariableTypeEntry";
            case 1052L: return "V_SgAsmJvmLocalVariableTypeTable";
            case 1053L: return "V_SgAsmUserInstruction";
            case 1054L: return "V_SgAsmJvmMethodParameters";
            case 1055L: return "V_SgAsmJvmMethodParametersEntry";
            case 1056L: return "V_SgAsmVoidType";
            case 1057L: return "V_SgAsmPointerType";
            case 1059L: return "V_SgRangeType";
            case 1060L: return "V_SgAsmCilExceptionData";
            case 1061L: return "V_SgAsmCilMethodData";
            case 1063L: return "V_SgNumVariants";
            default: return "";
        }
    }

    std::string VariantT(int64_t i, const std::string &strip) {
        std::string s = VariantT(i);
        if (s.empty())
            s = "(VariantT)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& VariantT() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            46L,
            47L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L,
            153L,
            154L,
            155L,
            156L,
            157L,
            158L,
            159L,
            160L,
            161L,
            162L,
            163L,
            164L,
            165L,
            166L,
            167L,
            168L,
            169L,
            170L,
            171L,
            172L,
            173L,
            174L,
            175L,
            176L,
            177L,
            178L,
            179L,
            180L,
            181L,
            182L,
            183L,
            184L,
            185L,
            186L,
            187L,
            188L,
            189L,
            190L,
            191L,
            192L,
            193L,
            194L,
            195L,
            196L,
            197L,
            198L,
            199L,
            200L,
            201L,
            202L,
            203L,
            204L,
            205L,
            206L,
            207L,
            208L,
            209L,
            210L,
            211L,
            212L,
            213L,
            214L,
            215L,
            216L,
            217L,
            218L,
            219L,
            220L,
            221L,
            222L,
            223L,
            224L,
            225L,
            226L,
            227L,
            228L,
            229L,
            230L,
            231L,
            232L,
            233L,
            234L,
            235L,
            236L,
            237L,
            238L,
            239L,
            240L,
            241L,
            242L,
            243L,
            244L,
            245L,
            246L,
            247L,
            248L,
            249L,
            250L,
            251L,
            252L,
            253L,
            254L,
            255L,
            256L,
            257L,
            258L,
            259L,
            260L,
            261L,
            262L,
            263L,
            264L,
            265L,
            266L,
            267L,
            268L,
            269L,
            270L,
            271L,
            272L,
            273L,
            274L,
            275L,
            276L,
            277L,
            278L,
            279L,
            280L,
            281L,
            282L,
            283L,
            284L,
            285L,
            286L,
            287L,
            288L,
            289L,
            290L,
            291L,
            292L,
            293L,
            294L,
            295L,
            296L,
            297L,
            298L,
            299L,
            300L,
            301L,
            302L,
            303L,
            304L,
            305L,
            306L,
            307L,
            308L,
            309L,
            310L,
            311L,
            312L,
            313L,
            314L,
            315L,
            316L,
            317L,
            318L,
            319L,
            320L,
            321L,
            322L,
            323L,
            324L,
            325L,
            326L,
            327L,
            328L,
            329L,
            330L,
            331L,
            332L,
            333L,
            334L,
            335L,
            336L,
            337L,
            338L,
            339L,
            340L,
            341L,
            342L,
            343L,
            344L,
            345L,
            347L,
            348L,
            349L,
            350L,
            351L,
            352L,
            353L,
            354L,
            355L,
            356L,
            357L,
            358L,
            359L,
            360L,
            361L,
            362L,
            363L,
            364L,
            365L,
            366L,
            367L,
            368L,
            369L,
            370L,
            371L,
            372L,
            373L,
            374L,
            375L,
            376L,
            378L,
            380L,
            381L,
            382L,
            383L,
            384L,
            385L,
            386L,
            387L,
            388L,
            389L,
            390L,
            391L,
            392L,
            393L,
            394L,
            395L,
            396L,
            397L,
            398L,
            399L,
            400L,
            401L,
            402L,
            403L,
            404L,
            405L,
            406L,
            407L,
            408L,
            409L,
            410L,
            411L,
            412L,
            413L,
            414L,
            415L,
            416L,
            417L,
            418L,
            419L,
            420L,
            421L,
            422L,
            423L,
            424L,
            425L,
            426L,
            427L,
            428L,
            429L,
            430L,
            431L,
            432L,
            433L,
            434L,
            435L,
            436L,
            437L,
            438L,
            439L,
            440L,
            441L,
            442L,
            443L,
            444L,
            445L,
            446L,
            447L,
            448L,
            449L,
            450L,
            451L,
            452L,
            453L,
            454L,
            455L,
            456L,
            457L,
            458L,
            459L,
            460L,
            461L,
            462L,
            463L,
            464L,
            465L,
            466L,
            467L,
            468L,
            469L,
            470L,
            471L,
            472L,
            473L,
            474L,
            475L,
            476L,
            477L,
            478L,
            479L,
            480L,
            481L,
            482L,
            483L,
            484L,
            485L,
            486L,
            487L,
            488L,
            489L,
            490L,
            491L,
            492L,
            493L,
            494L,
            495L,
            496L,
            497L,
            498L,
            499L,
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L,
            564L,
            565L,
            566L,
            567L,
            568L,
            569L,
            570L,
            571L,
            572L,
            573L,
            574L,
            575L,
            576L,
            577L,
            578L,
            579L,
            580L,
            581L,
            582L,
            583L,
            584L,
            585L,
            586L,
            587L,
            588L,
            589L,
            590L,
            591L,
            592L,
            593L,
            594L,
            595L,
            596L,
            597L,
            598L,
            599L,
            600L,
            601L,
            602L,
            603L,
            604L,
            605L,
            606L,
            607L,
            608L,
            609L,
            610L,
            611L,
            612L,
            613L,
            614L,
            615L,
            616L,
            617L,
            618L,
            619L,
            620L,
            621L,
            622L,
            623L,
            624L,
            625L,
            626L,
            627L,
            628L,
            629L,
            630L,
            631L,
            632L,
            633L,
            634L,
            635L,
            636L,
            637L,
            638L,
            639L,
            640L,
            641L,
            642L,
            643L,
            644L,
            645L,
            646L,
            647L,
            648L,
            649L,
            650L,
            651L,
            652L,
            653L,
            654L,
            655L,
            656L,
            657L,
            658L,
            659L,
            660L,
            661L,
            662L,
            663L,
            664L,
            665L,
            666L,
            667L,
            668L,
            669L,
            670L,
            671L,
            672L,
            673L,
            674L,
            675L,
            676L,
            677L,
            678L,
            679L,
            680L,
            681L,
            682L,
            683L,
            684L,
            685L,
            686L,
            687L,
            688L,
            689L,
            690L,
            691L,
            692L,
            693L,
            694L,
            695L,
            696L,
            697L,
            698L,
            699L,
            700L,
            701L,
            702L,
            703L,
            704L,
            705L,
            706L,
            707L,
            708L,
            709L,
            710L,
            711L,
            712L,
            713L,
            714L,
            715L,
            716L,
            717L,
            718L,
            719L,
            720L,
            721L,
            722L,
            723L,
            724L,
            725L,
            726L,
            727L,
            728L,
            729L,
            730L,
            731L,
            732L,
            733L,
            734L,
            735L,
            736L,
            737L,
            738L,
            739L,
            740L,
            741L,
            742L,
            743L,
            744L,
            745L,
            746L,
            747L,
            748L,
            749L,
            750L,
            751L,
            752L,
            753L,
            754L,
            755L,
            756L,
            757L,
            758L,
            759L,
            760L,
            761L,
            762L,
            763L,
            764L,
            765L,
            766L,
            767L,
            768L,
            769L,
            770L,
            771L,
            772L,
            773L,
            774L,
            775L,
            776L,
            777L,
            778L,
            779L,
            780L,
            781L,
            782L,
            783L,
            784L,
            785L,
            786L,
            787L,
            788L,
            789L,
            790L,
            791L,
            792L,
            793L,
            794L,
            795L,
            796L,
            797L,
            798L,
            799L,
            800L,
            801L,
            802L,
            803L,
            804L,
            805L,
            806L,
            807L,
            808L,
            809L,
            811L,
            812L,
            813L,
            814L,
            815L,
            816L,
            817L,
            818L,
            819L,
            820L,
            821L,
            822L,
            823L,
            824L,
            825L,
            826L,
            827L,
            828L,
            829L,
            830L,
            831L,
            832L,
            833L,
            834L,
            835L,
            836L,
            837L,
            838L,
            839L,
            840L,
            841L,
            842L,
            843L,
            844L,
            845L,
            846L,
            847L,
            848L,
            849L,
            850L,
            851L,
            852L,
            853L,
            854L,
            855L,
            856L,
            857L,
            858L,
            859L,
            860L,
            861L,
            862L,
            863L,
            864L,
            865L,
            866L,
            867L,
            868L,
            869L,
            870L,
            871L,
            872L,
            873L,
            874L,
            875L,
            876L,
            877L,
            878L,
            880L,
            881L,
            882L,
            883L,
            884L,
            885L,
            886L,
            887L,
            888L,
            889L,
            890L,
            891L,
            892L,
            893L,
            895L,
            896L,
            897L,
            898L,
            899L,
            900L,
            901L,
            902L,
            903L,
            904L,
            905L,
            906L,
            907L,
            908L,
            909L,
            910L,
            911L,
            912L,
            913L,
            914L,
            915L,
            916L,
            917L,
            918L,
            919L,
            920L,
            921L,
            922L,
            923L,
            924L,
            925L,
            926L,
            927L,
            928L,
            929L,
            930L,
            931L,
            932L,
            933L,
            934L,
            935L,
            936L,
            937L,
            938L,
            939L,
            940L,
            941L,
            942L,
            943L,
            944L,
            945L,
            946L,
            947L,
            948L,
            949L,
            950L,
            951L,
            952L,
            953L,
            954L,
            955L,
            956L,
            957L,
            958L,
            959L,
            960L,
            961L,
            962L,
            963L,
            964L,
            965L,
            966L,
            967L,
            968L,
            969L,
            970L,
            971L,
            972L,
            973L,
            974L,
            975L,
            976L,
            977L,
            978L,
            979L,
            980L,
            981L,
            982L,
            983L,
            984L,
            985L,
            986L,
            987L,
            988L,
            989L,
            990L,
            991L,
            992L,
            993L,
            994L,
            995L,
            996L,
            997L,
            998L,
            999L,
            1000L,
            1001L,
            1002L,
            1003L,
            1004L,
            1005L,
            1006L,
            1007L,
            1008L,
            1009L,
            1010L,
            1011L,
            1012L,
            1013L,
            1014L,
            1015L,
            1016L,
            1017L,
            1018L,
            1019L,
            1020L,
            1021L,
            1022L,
            1023L,
            1024L,
            1025L,
            1026L,
            1027L,
            1028L,
            1029L,
            1030L,
            1031L,
            1032L,
            1033L,
            1034L,
            1035L,
            1036L,
            1037L,
            1038L,
            1039L,
            1040L,
            1041L,
            1042L,
            1043L,
            1044L,
            1045L,
            1046L,
            1047L,
            1048L,
            1049L,
            1050L,
            1051L,
            1052L,
            1053L,
            1054L,
            1055L,
            1056L,
            1057L,
            1059L,
            1060L,
            1061L,
            1063L
        };
        static const std::vector<int64_t> retval(values, values + 1045);
        return retval;
    }

}

namespace Rose {
    std::string stringifyVariantT(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::VariantT(i);
        if (retval.empty()) {
            retval = "(VariantT)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "VariantT::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifyVariantT() {
        return stringify::VariantT();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 4330
namespace stringify { namespace SgConstVolatileModifier {
    const char* cv_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_const";
            case 3L: return "e_volatile";
            case 4L: return "e_const_volatile";
            case 5L: return "e_java_transient";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string cv_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = cv_modifier_enum(i);
        if (s.empty())
            s = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cv_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgConstVolatileModifier_cv_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgConstVolatileModifier::cv_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgConstVolatileModifier::cv_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgConstVolatileModifier_cv_modifier_enum() {
        return stringify::SgConstVolatileModifier::cv_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 5451
namespace stringify { namespace SgStorageModifier {
    const char* storage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_extern";
            case 3L: return "e_static";
            case 4L: return "e_auto";
            case 5L: return "e_unspecified";
            case 6L: return "e_register";
            case 7L: return "e_mutable";
            case 8L: return "e_typedef";
            case 9L: return "e_asm";
            case 10L: return "e_local";
            case 11L: return "e_common";
            case 12L: return "e_associated";
            case 13L: return "e_intrinsic";
            case 14L: return "e_pointer_based";
            case 15L: return "e_contiguous";
            case 16L: return "e_cuda_global";
            case 17L: return "e_cuda_constant";
            case 18L: return "e_cuda_shared";
            case 19L: return "e_cuda_dynamic_shared";
            case 20L: return "e_cuda_device_memory";
            case 21L: return "e_cuda_managed";
            case 22L: return "e_cuda_pinned";
            case 23L: return "e_cuda_texture";
            case 24L: return "e_packing_none";
            case 25L: return "e_packing_mixed";
            case 26L: return "e_packing_dense";
            case 27L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string storage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = storage_modifier_enum(i);
        if (s.empty())
            s = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& storage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L
        };
        static const std::vector<int64_t> retval(values, values + 28);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStorageModifier_storage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStorageModifier::storage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStorageModifier::storage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStorageModifier::storage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStorageModifier_storage_modifier_enum() {
        return stringify::SgStorageModifier::storage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 6749
namespace stringify { namespace SgAccessModifier {
    const char* access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_private";
            case 2L: return "e_protected";
            case 3L: return "e_public";
            case 5L: return "e_undefined";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_modifier_enum(i);
        if (s.empty())
            s = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAccessModifier_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAccessModifier::access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAccessModifier::access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAccessModifier::access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAccessModifier_access_modifier_enum() {
        return stringify::SgAccessModifier::access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 7847
namespace stringify { namespace SgFunctionModifier {
    const char* function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_inline";
            case 3L: return "e_virtual";
            case 4L: return "e_pure_virtual";
            case 5L: return "e_explicit";
            case 7L: return "e_pure";
            case 8L: return "e_elemental";
            case 9L: return "e_recursive";
            case 10L: return "e_gnu_attribute__constructor__";
            case 11L: return "e_gnu_attribute__destructor__";
            case 12L: return "e_gnu_attribute__pure__";
            case 13L: return "e_gnu_attribute__weak__";
            case 14L: return "e_gnu_attribute__unused__";
            case 15L: return "e_gnu_attribute__used__";
            case 16L: return "e_gnu_attribute__deprecated__";
            case 17L: return "e_gnu_attribute__malloc__";
            case 18L: return "e_gnu_attribute__naked__";
            case 19L: return "e_gnu_attribute__no_instrument_function__";
            case 20L: return "e_gnu_attribute__no_check_memory_usage__";
            case 21L: return "e_gnu_attribute__noinline__";
            case 22L: return "e_gnu_attribute__always_inline__";
            case 23L: return "e_gnu_attribute__nothrow__";
            case 24L: return "e_gnu_attribute__weakref__";
            case 25L: return "e_cuda_device";
            case 26L: return "e_cuda_kernel";
            case 27L: return "e_cuda_host";
            case 28L: return "e_cuda_global_function";
            case 29L: return "e_cuda_grid_global";
            case 30L: return "e_opencl_kernel";
            case 31L: return "e_opencl_vec_type_hint";
            case 32L: return "e_opencl_work_group_size_hint";
            case 33L: return "e_opencl_work_group_size_req";
            case 34L: return "e_java_native";
            case 35L: return "e_java_synchronized";
            case 36L: return "e_java_strictfp";
            case 37L: return "e_java_initializer";
            case 38L: return "e_marked_default";
            case 39L: return "e_marked_delete";
            case 40L: return "e_reentrant";
            case 41L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = function_modifier_enum(i);
        if (s.empty())
            s = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFunctionModifier_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFunctionModifier::function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgFunctionModifier::function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFunctionModifier::function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFunctionModifier_function_modifier_enum() {
        return stringify::SgFunctionModifier::function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 9464
namespace stringify { namespace SgUPC_AccessModifier {
    const char* upc_access_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_upc_strict";
            case 3L: return "e_upc_relaxed";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string upc_access_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = upc_access_modifier_enum(i);
        if (s.empty())
            s = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& upc_access_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUPC_AccessModifier_upc_access_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUPC_AccessModifier::upc_access_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgUPC_AccessModifier::upc_access_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUPC_AccessModifier_upc_access_modifier_enum() {
        return stringify::SgUPC_AccessModifier::upc_access_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 10591
namespace stringify { namespace SgSpecialFunctionModifier {
    const char* special_function_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_constructor";
            case 3L: return "e_destructor";
            case 4L: return "e_conversion";
            case 5L: return "e_operator";
            case 6L: return "e_uld_operator";
            case 7L: return "e_lambda_entry_point";
            case 8L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string special_function_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = special_function_modifier_enum(i);
        if (s.empty())
            s = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& special_function_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgSpecialFunctionModifier_special_function_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgSpecialFunctionModifier::special_function_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgSpecialFunctionModifier::special_function_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgSpecialFunctionModifier_special_function_modifier_enum() {
        return stringify::SgSpecialFunctionModifier::special_function_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 11728
namespace stringify { namespace SgElaboratedTypeModifier {
    const char* elaborated_type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_class";
            case 3L: return "e_struct";
            case 4L: return "e_union";
            case 5L: return "e_enum";
            case 6L: return "e_typename";
            case 7L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string elaborated_type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = elaborated_type_modifier_enum(i);
        if (s.empty())
            s = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& elaborated_type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum() {
        return stringify::SgElaboratedTypeModifier::elaborated_type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 12834
namespace stringify { namespace SgLinkageModifier {
    const char* linkage_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_linkage";
            case 3L: return "e_Cpp_linkage";
            case 4L: return "e_fortran_linkage";
            case 5L: return "e_fortran90_linkage";
            case 6L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string linkage_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = linkage_modifier_enum(i);
        if (s.empty())
            s = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& linkage_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLinkageModifier_linkage_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLinkageModifier::linkage_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgLinkageModifier::linkage_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLinkageModifier_linkage_modifier_enum() {
        return stringify::SgLinkageModifier::linkage_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 13924
namespace stringify { namespace SgBaseClassModifier {
    const char* baseclass_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_virtual";
            case 3L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string baseclass_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = baseclass_modifier_enum(i);
        if (s.empty())
            s = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& baseclass_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgBaseClassModifier_baseclass_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgBaseClassModifier::baseclass_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgBaseClassModifier::baseclass_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgBaseClassModifier_baseclass_modifier_enum() {
        return stringify::SgBaseClassModifier::baseclass_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 15015
namespace stringify { namespace SgStructureModifier {
    const char* jovial_structure_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_table_structure_parallel";
            case 3L: return "e_table_structure_tight";
            case 4L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string jovial_structure_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = jovial_structure_modifier_enum(i);
        if (s.empty())
            s = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& jovial_structure_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgStructureModifier_jovial_structure_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgStructureModifier::jovial_structure_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgStructureModifier::jovial_structure_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgStructureModifier::jovial_structure_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgStructureModifier_jovial_structure_modifier_enum() {
        return stringify::SgStructureModifier::jovial_structure_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 16116
namespace stringify { namespace SgTypeModifier {
    const char* type_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_restrict";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent_in";
            case 9L: return "e_intent_out";
            case 10L: return "e_intent_inout";
            case 11L: return "e_intrinsic";
            case 12L: return "e_optional";
            case 13L: return "e_extends";
            case 14L: return "e_abstract";
            case 15L: return "e_save";
            case 16L: return "e_target";
            case 17L: return "e_value";
            case 18L: return "e_gnu_attribute__unused__";
            case 19L: return "e_gnu_attribute__packed__";
            case 20L: return "e_gnu_attribute__deprecated__";
            case 21L: return "e_gnu_attribute__transparent_union__";
            case 22L: return "e_gnu_attribute__noreturn__";
            case 23L: return "e_gnu_attribute__const__";
            case 24L: return "e_gnu_attribute__cdecl__";
            case 25L: return "e_gnu_attribute__stdcall__";
            case 26L: return "e_gnu_attribute__warn_unused_result__";
            case 27L: return "e_gnu_attribute__nonnull__";
            case 28L: return "e_gnu_attribute__sentinel__";
            case 29L: return "e_address_space__";
            case 30L: return "e_ocl_global__";
            case 31L: return "e_ocl_local__";
            case 32L: return "e_ocl_constant__";
            case 33L: return "e_vector_type__";
            case 34L: return "e_gnu_attribute__device__";
            case 35L: return "e_round";
            case 36L: return "e_truncate";
            case 37L: return "e_truncate_towards_zero";
            case 38L: return "e_aliased";
            case 39L: return "e_notnull";
            case 40L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string type_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = type_modifier_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& type_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L
        };
        static const std::vector<int64_t> retval(values, values + 41);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_type_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::type_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::type_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::type_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_type_modifier_enum() {
        return stringify::SgTypeModifier::type_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 16210
namespace stringify { namespace SgTypeModifier {
    const char* gnu_extension_machine_mode_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_extension_machine_mode_unknown";
            case 1L: return "e_gnu_extension_machine_mode_unspecified";
            case 2L: return "e_gnu_extension_machine_mode_BImode";
            case 3L: return "e_gnu_extension_machine_mode_QImode";
            case 4L: return "e_gnu_extension_machine_mode_HImode";
            case 5L: return "e_gnu_extension_machine_mode_PSImode";
            case 6L: return "e_gnu_extension_machine_mode_SImode";
            case 7L: return "e_gnu_extension_machine_mode_PDImode";
            case 8L: return "e_gnu_extension_machine_mode_DImode";
            case 9L: return "e_gnu_extension_machine_mode_TImode";
            case 10L: return "e_gnu_extension_machine_mode_OImode";
            case 11L: return "e_gnu_extension_machine_mode_QFmode";
            case 12L: return "e_gnu_extension_machine_mode_HFmode";
            case 13L: return "e_gnu_extension_machine_mode_TQFmode";
            case 14L: return "e_gnu_extension_machine_mode_SFmode";
            case 15L: return "e_gnu_extension_machine_mode_DFmode";
            case 16L: return "e_gnu_extension_machine_mode_XFmode";
            case 17L: return "e_gnu_extension_machine_mode_SDmode";
            case 18L: return "e_gnu_extension_machine_mode_DDmode";
            case 19L: return "e_gnu_extension_machine_mode_TDmode";
            case 20L: return "e_gnu_extension_machine_mode_TFmode";
            case 21L: return "e_gnu_extension_machine_mode_QQmode";
            case 22L: return "e_gnu_extension_machine_mode_HQmode";
            case 23L: return "e_gnu_extension_machine_mode_SQmode";
            case 24L: return "e_gnu_extension_machine_mode_DQmode";
            case 25L: return "e_gnu_extension_machine_mode_TQmode";
            case 26L: return "e_gnu_extension_machine_mode_UQQmode";
            case 27L: return "e_gnu_extension_machine_mode_UHQmode";
            case 28L: return "e_gnu_extension_machine_mode_USQmode";
            case 29L: return "e_gnu_extension_machine_mode_UDQmode";
            case 30L: return "e_gnu_extension_machine_mode_UTQmode";
            case 31L: return "e_gnu_extension_machine_mode_HAmode";
            case 32L: return "e_gnu_extension_machine_mode_SAmode";
            case 33L: return "e_gnu_extension_machine_mode_DAmode";
            case 34L: return "e_gnu_extension_machine_mode_TAmode";
            case 35L: return "e_gnu_extension_machine_mode_UHAmode";
            case 36L: return "e_gnu_extension_machine_mode_USAmode";
            case 37L: return "e_gnu_extension_machine_mode_UDAmode";
            case 38L: return "e_gnu_extension_machine_mode_UTAmode";
            case 39L: return "e_gnu_extension_machine_mode_CCmode";
            case 40L: return "e_gnu_extension_machine_mode_BLKmode";
            case 41L: return "e_gnu_extension_machine_mode_VOIDmode";
            case 42L: return "e_gnu_extension_machine_mode_QCmode";
            case 43L: return "e_gnu_extension_machine_mode_HCmode";
            case 44L: return "e_gnu_extension_machine_mode_SCmode";
            case 45L: return "e_gnu_extension_machine_mode_DCmode";
            case 46L: return "e_gnu_extension_machine_mode_XCmode";
            case 47L: return "e_gnu_extension_machine_mode_TCmode";
            case 48L: return "e_gnu_extension_machine_mode_CQImode";
            case 49L: return "e_gnu_extension_machine_mode_CHImode";
            case 50L: return "e_gnu_extension_machine_mode_CSImode";
            case 51L: return "e_gnu_extension_machine_mode_CDImode";
            case 52L: return "e_gnu_extension_machine_mode_CTImode";
            case 53L: return "e_gnu_extension_machine_mode_COImode";
            case 54L: return "e_last_machine_mode";
            default: return "";
        }
    }

    std::string gnu_extension_machine_mode_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_machine_mode_enum(i);
        if (s.empty())
            s = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_machine_mode_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L
        };
        static const std::vector<int64_t> retval(values, values + 55);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTypeModifier_gnu_extension_machine_mode_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTypeModifier::gnu_extension_machine_mode_enum(i);
        if (retval.empty()) {
            retval = "(SgTypeModifier::gnu_extension_machine_mode_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTypeModifier_gnu_extension_machine_mode_enum() {
        return stringify::SgTypeModifier::gnu_extension_machine_mode_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 17993
namespace stringify { namespace SgDeclarationModifier {
    const char* declaration_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_friend";
            case 3L: return "e_typedef";
            case 4L: return "e_export";
            case 5L: return "e_throw";
            case 6L: return "e_bind";
            case 7L: return "e_final";
            case 8L: return "e_override";
            case 9L: return "e_java_abstract";
            case 10L: return "e_jovial_def";
            case 11L: return "e_jovial_ref";
            case 12L: return "e_jovial_static";
            case 13L: return "e_ms_declspec_align";
            case 14L: return "e_ms_declspec_allocate";
            case 15L: return "e_ms_declspec_appdomain";
            case 16L: return "e_ms_declspec_code_seg";
            case 17L: return "e_ms_declspec_deprecated";
            case 18L: return "e_ms_declspec_dllimport";
            case 19L: return "e_ms_declspec_dllexport";
            case 20L: return "e_ms_declspec_jitintrinsic";
            case 21L: return "e_ms_declspec_naked";
            case 22L: return "e_ms_declspec_noalias";
            case 23L: return "e_ms_declspec_noinline";
            case 24L: return "e_ms_declspec_noreturn";
            case 25L: return "e_ms_declspec_nothrow";
            case 26L: return "e_ms_declspec_novtable";
            case 27L: return "e_ms_declspec_process";
            case 28L: return "e_ms_declspec_property";
            case 29L: return "e_ms_declspec_restrict";
            case 30L: return "e_ms_declspec_safebuffers";
            case 31L: return "e_ms_declspec_selectany";
            case 32L: return "e_ms_declspec_thread";
            case 33L: return "e_ms_declspec_uuid";
            case 34L: return "e_ada_abstract";
            case 35L: return "e_ada_limited";
            case 36L: return "e_ada_tagged";
            case 37L: return "e_ada_separate";
            case 38L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string declaration_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = declaration_modifier_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& declaration_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L
        };
        static const std::vector<int64_t> retval(values, values + 39);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_declaration_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::declaration_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::declaration_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_declaration_modifier_enum() {
        return stringify::SgDeclarationModifier::declaration_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 18051
namespace stringify { namespace SgDeclarationModifier {
    const char* gnu_declaration_visability_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_visibility";
            case 1L: return "e_error_visibility";
            case 2L: return "e_unspecified_visibility";
            case 3L: return "e_hidden_visibility";
            case 4L: return "e_protected_visibility";
            case 5L: return "e_internal_visibility";
            case 6L: return "e_default_visibility";
            case 7L: return "e_last_visibility_attribute";
            default: return "";
        }
    }

    std::string gnu_declaration_visability_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_declaration_visability_enum(i);
        if (s.empty())
            s = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_declaration_visability_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationModifier_gnu_declaration_visability_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationModifier::gnu_declaration_visability_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationModifier::gnu_declaration_visability_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationModifier_gnu_declaration_visability_enum() {
        return stringify::SgDeclarationModifier::gnu_declaration_visability_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 19666
namespace stringify { namespace SgOpenclAccessModeModifier {
    const char* access_mode_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_read_only";
            case 3L: return "e_write_only";
            case 4L: return "e_read_write";
            case 5L: return "e_last_modifier";
            default: return "";
        }
    }

    std::string access_mode_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = access_mode_modifier_enum(i);
        if (s.empty())
            s = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_mode_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgOpenclAccessModeModifier::access_mode_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOpenclAccessModeModifier_access_mode_modifier_enum() {
        return stringify::SgOpenclAccessModeModifier::access_mode_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 28963
namespace stringify { namespace Sg_File_Info {
    const char* classifier(int64_t i) {
        switch (i) {
            case 1L: return "e_transformation";
            case 2L: return "e_compiler_generated";
            case 4L: return "e_output_in_code_generation";
            case 8L: return "e_shared";
            case 16L: return "e_frontend_specific";
            case 32L: return "e_source_position_unavailable_in_frontend";
            case 64L: return "e_comment_or_directive";
            case 128L: return "e_token";
            case 256L: return "e_default_argument";
            case 512L: return "e_implicit_cast";
            default: return "";
        }
    }

    std::string classifier(int64_t i, const std::string &strip) {
        std::string s = classifier(i);
        if (s.empty())
            s = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& classifier() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L,
            256L,
            512L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_classifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::classifier(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::classifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::classifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_classifier() {
        return stringify::Sg_File_Info::classifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 29207
namespace stringify { namespace Sg_File_Info {
    const char* p_fileflags(int64_t i) {
        switch (i) {
            case -6L: return "BAD_FILE_ID";
            case -5L: return "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID";
            case -4L: return "COMPILER_GENERATED_FILE_ID";
            case -3L: return "TRANSFORMATION_FILE_ID";
            case -2L: return "NULL_FILE_ID";
            case -1L: return "COPY_FILE_ID";
            default: return "";
        }
    }

    std::string p_fileflags(int64_t i, const std::string &strip) {
        std::string s = p_fileflags(i);
        if (s.empty())
            s = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& p_fileflags() {
        static const int64_t values[] = {
            -6L,
            -5L,
            -4L,
            -3L,
            -2L,
            -1L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySg_File_Info_p_fileflags(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::Sg_File_Info::p_fileflags(i);
        if (retval.empty()) {
            retval = "(Sg_File_Info::p_fileflags)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "Sg_File_Info::p_fileflags::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySg_File_Info_p_fileflags() {
        return stringify::Sg_File_Info::p_fileflags();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 30641
namespace stringify { namespace SgFile {
    const char* outputFormatOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_output_format";
            case 1L: return "e_fixed_form_output_format";
            case 2L: return "e_free_form_output_format";
            default: return "";
        }
    }

    std::string outputFormatOption_enum(int64_t i, const std::string &strip) {
        std::string s = outputFormatOption_enum(i);
        if (s.empty())
            s = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& outputFormatOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_outputFormatOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::outputFormatOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::outputFormatOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::outputFormatOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_outputFormatOption_enum() {
        return stringify::SgFile::outputFormatOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 30655
namespace stringify { namespace SgFile {
    const char* languageOption_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_language";
            case 1L: return "e_default_language";
            case 2L: return "e_C_language";
            case 3L: return "e_Cxx_language";
            case 4L: return "e_Binary_language";
            case 5L: return "e_Fortran_language";
            case 6L: return "e_Java_language";
            case 7L: return "e_Jvm_language";
            case 8L: return "e_Promela_language";
            case 9L: return "e_PHP_language";
            case 10L: return "e_Python_language";
            case 11L: return "e_Csharp_language";
            case 12L: return "e_Ada_language";
            case 13L: return "e_Jovial_language";
            case 14L: return "e_last_language";
            default: return "";
        }
    }

    std::string languageOption_enum(int64_t i, const std::string &strip) {
        std::string s = languageOption_enum(i);
        if (s.empty())
            s = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& languageOption_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L
        };
        static const std::vector<int64_t> retval(values, values + 15);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_languageOption_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::languageOption_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::languageOption_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::languageOption_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_languageOption_enum() {
        return stringify::SgFile::languageOption_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 30675
namespace stringify { namespace SgFile {
    const char* standard_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default_standard";
            case 1L: return "e_c89_standard";
            case 2L: return "e_c90_standard";
            case 3L: return "e_c99_standard";
            case 4L: return "e_c11_standard";
            case 5L: return "e_c14_standard";
            case 6L: return "e_c18_standard";
            case 7L: return "e_upc_standard";
            case 8L: return "e_cxx98_standard";
            case 9L: return "e_cxx03_standard";
            case 10L: return "e_cxx11_standard";
            case 11L: return "e_cxx14_standard";
            case 12L: return "e_cxx17_standard";
            case 13L: return "e_cxx20_standard";
            case 14L: return "e_upcxx_standard";
            case 15L: return "e_f77_standard";
            case 16L: return "e_f90_standard";
            case 17L: return "e_f95_standard";
            case 18L: return "e_f03_standard";
            case 19L: return "e_f08_standard";
            case 20L: return "e_f18_standard";
            default: return "";
        }
    }

    std::string standard_enum(int64_t i, const std::string &strip) {
        std::string s = standard_enum(i);
        if (s.empty())
            s = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& standard_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L
        };
        static const std::vector<int64_t> retval(values, values + 21);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgFile_standard_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgFile::standard_enum(i);
        if (retval.empty()) {
            retval = "(SgFile::standard_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgFile::standard_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgFile_standard_enum() {
        return stringify::SgFile::standard_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 39199
namespace stringify { namespace SgProject {
    const char* template_instantiation_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_none";
            case 3L: return "e_used";
            case 4L: return "e_all";
            case 5L: return "e_local";
            case 6L: return "e_last";
            default: return "";
        }
    }

    std::string template_instantiation_enum(int64_t i, const std::string &strip) {
        std::string s = template_instantiation_enum(i);
        if (s.empty())
            s = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_instantiation_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProject_template_instantiation_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProject::template_instantiation_enum(i);
        if (retval.empty()) {
            retval = "(SgProject::template_instantiation_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProject::template_instantiation_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProject_template_instantiation_enum() {
        return stringify::SgProject::template_instantiation_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 43333
namespace stringify { namespace SgUnparse_Info {
    const char* unparse_type_num(int64_t i) {
        switch (i) {
            case 0L: return "b_enum_defaultValue";
            case 1L: return "b_isPointerToSomething";
            case 2L: return "b_isReferenceToSomething";
            case 3L: return "b_inVarDecl";
            case 4L: return "b_inArgList";
            case 5L: return "b_SkipSemiColon";
            case 6L: return "b_inEnumDecl";
            case 7L: return "b_inTemplateList";
            case 8L: return "b_SkipBaseType";
            case 9L: return "b_inAggregateInitializer";
            case 10L: return "b_isWithType";
            case 11L: return "b_inConditional";
            case 12L: return "b_SkipDefinition";
            case 13L: return "b_SkipClassSpecifier";
            case 14L: return "b_inEmbeddedDecl";
            case 15L: return "b_SkipGlobal";
            case 16L: return "b_SkipAtomic";
            case 17L: return "b_PrintName";
            case 18L: return "b_CheckAccess";
            case 19L: return "b_SkipFunctionQualifier";
            case 20L: return "b_isArrayType";
            case 21L: return "b_inRhsExpr";
            case 22L: return "b_SkipParen";
            case 23L: return "b_isTypeSecondPart";
            case 24L: return "b_isTypeFirstPart";
            case 25L: return "b_SkipInitializer";
            case 26L: return "b_SkipComments";
            case 27L: return "b_SkipCPPDirectives";
            case 28L: return "b_SkipEnumDefinition";
            case 29L: return "b_SkipFunctionDefinition";
            case 30L: return "b_SkipClassDefinition";
            case 31L: return "b_AddSemiColonAfterDeclaration";
            case 32L: return "b_SkipWhitespaces";
            case 33L: return "b_SkipBasicBlock";
            case 34L: return "b_outputClassTemplateName";
            case 35L: return "b_outputCompilerGeneratedStatements";
            case 36L: return "b_SkipConstantFoldedExpressions";
            case 37L: return "b_forceQualifiedNames";
            case 38L: return "b_SkipQualifiedNames";
            case 39L: return "b_skipCheckAccess";
            case 40L: return "b_requiresGlobalNameQualification";
            case 41L: return "b_useTypeAttributes";
            case 42L: return "b_SkipFormatting";
            case 43L: return "b_outputFortranModFile";
            case 44L: return "b_supressStrippedTypeName";
            case 45L: return "b_prefixOperator";
            case 46L: return "b_supressArrayBound";
            case 47L: return "b_supressImplicitThisOperator";
            case 48L: return "b_unparsedPartiallyUsingTokenStream";
            case 49L: return "b_skipCompilerGeneratedSubExpressions";
            case 50L: return "b_parentStatementListBeingUnparsedUsingPartialTokenSequence";
            case 51L: return "b_cxx11_initialization_list";
            case 52L: return "b_inTypedefDecl";
            case 53L: return "b_SkipNameQualification";
            case 54L: return "b_useAlternativeDefiningDeclaration";
            case 55L: return "b_usedInUparseToStringFunction";
            case 56L: return "UNPARSE_TYPE_LAST";
            default: return "";
        }
    }

    std::string unparse_type_num(int64_t i, const std::string &strip) {
        std::string s = unparse_type_num(i);
        if (s.empty())
            s = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& unparse_type_num() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L
        };
        static const std::vector<int64_t> retval(values, values + 57);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_unparse_type_num(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::unparse_type_num(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::unparse_type_num)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::unparse_type_num::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_unparse_type_num() {
        return stringify::SgUnparse_Info::unparse_type_num();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 43510
namespace stringify { namespace SgUnparse_Info {
    const char* access_attr_enum(int64_t i) {
        switch (i) {
            case 1L: return "a_unset_access";
            case 2L: return "a_private_access";
            case 3L: return "a_protected_access";
            case 4L: return "a_public_access";
            case 5L: return "a_default_access";
            default: return "";
        }
    }

    std::string access_attr_enum(int64_t i, const std::string &strip) {
        std::string s = access_attr_enum(i);
        if (s.empty())
            s = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& access_attr_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnparse_Info_access_attr_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnparse_Info::access_attr_enum(i);
        if (retval.empty()) {
            retval = "(SgUnparse_Info::access_attr_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnparse_Info::access_attr_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnparse_Info_access_attr_enum() {
        return stringify::SgUnparse_Info::access_attr_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 50091
namespace stringify { namespace SgTemplateParameter {
    const char* template_parameter_enum(int64_t i) {
        switch (i) {
            case 0L: return "parameter_undefined";
            case 1L: return "type_parameter";
            case 2L: return "nontype_parameter";
            case 3L: return "template_parameter";
            default: return "";
        }
    }

    std::string template_parameter_enum(int64_t i, const std::string &strip) {
        std::string s = template_parameter_enum(i);
        if (s.empty())
            s = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_parameter_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateParameter_template_parameter_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateParameter::template_parameter_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateParameter::template_parameter_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateParameter::template_parameter_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateParameter_template_parameter_enum() {
        return stringify::SgTemplateParameter::template_parameter_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 51268
namespace stringify { namespace SgTemplateArgument {
    const char* template_argument_enum(int64_t i) {
        switch (i) {
            case 0L: return "argument_undefined";
            case 1L: return "type_argument";
            case 2L: return "nontype_argument";
            case 3L: return "template_template_argument";
            case 4L: return "start_of_pack_expansion_argument";
            default: return "";
        }
    }

    std::string template_argument_enum(int64_t i, const std::string &strip) {
        std::string s = template_argument_enum(i);
        if (s.empty())
            s = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_argument_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateArgument_template_argument_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateArgument::template_argument_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateArgument::template_argument_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateArgument::template_argument_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateArgument_template_argument_enum() {
        return stringify::SgTemplateArgument::template_argument_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 60008
namespace stringify { namespace SgGraph {
    const char* GraphEdgeType(int64_t i) {
        switch (i) {
            case 0L: return "e_type_error";
            case 1L: return "none";
            case 2L: return "cfg";
            case 3L: return "usage";
            case 4L: return "e_last_type";
            default: return "";
        }
    }

    std::string GraphEdgeType(int64_t i, const std::string &strip) {
        std::string s = GraphEdgeType(i);
        if (s.empty())
            s = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphEdgeType() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphEdgeType(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphEdgeType(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphEdgeType)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphEdgeType::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphEdgeType() {
        return stringify::SgGraph::GraphEdgeType();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 60022
namespace stringify { namespace SgGraph {
    const char* GraphProperties(int64_t i) {
        switch (i) {
            case 0L: return "e_property_error";
            case 1L: return "name";
            case 2L: return "type";
            case 3L: return "nodest_jmp";
            case 4L: return "itself_call";
            case 5L: return "nodest_call";
            case 6L: return "interrupt";
            case 7L: return "eval";
            case 8L: return "regs";
            case 9L: return "done";
            case 10L: return "dfa_standard";
            case 11L: return "dfa_resolved_func";
            case 12L: return "dfa_unresolved_func";
            case 13L: return "dfa_variable";
            case 14L: return "dfa_conditional_def";
            case 15L: return "edgeLabel";
            case 16L: return "visitedCounter";
            case 17L: return "variable";
            case 18L: return "dfa_bufferoverflow";
            case 19L: return "e_last_property";
            default: return "";
        }
    }

    std::string GraphProperties(int64_t i, const std::string &strip) {
        std::string s = GraphProperties(i);
        if (s.empty())
            s = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& GraphProperties() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgGraphGraphProperties(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgGraph::GraphProperties(i);
        if (retval.empty()) {
            retval = "(SgGraph::GraphProperties)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgGraph::GraphProperties::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgGraphGraphProperties() {
        return stringify::SgGraph::GraphProperties();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 81271
namespace stringify { namespace SgDataStatementValue {
    const char* data_statement_value_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_explicit_list";
            case 3L: return "e_implicit_list";
            case 4L: return "e_implied_do";
            case 5L: return "e_last_initializer_form";
            default: return "";
        }
    }

    std::string data_statement_value_enum(int64_t i, const std::string &strip) {
        std::string s = data_statement_value_enum(i);
        if (s.empty())
            s = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& data_statement_value_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDataStatementValue_data_statement_value_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDataStatementValue::data_statement_value_enum(i);
        if (retval.empty()) {
            retval = "(SgDataStatementValue::data_statement_value_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDataStatementValue_data_statement_value_enum() {
        return stringify::SgDataStatementValue::data_statement_value_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 85467
namespace stringify { namespace SgType {
    const char* fortran_attribute_specifiers_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_specifier";
            case 1L: return "e_public_access";
            case 2L: return "e_private_access";
            case 3L: return "e_allocatable";
            case 4L: return "e_asynchronous";
            case 5L: return "e_bind";
            case 6L: return "e_data";
            case 7L: return "e_dimension";
            case 8L: return "e_intent";
            case 9L: return "e_optional";
            case 10L: return "e_parameter";
            case 11L: return "e_pointer";
            case 12L: return "e_protected";
            case 13L: return "e_save";
            case 14L: return "e_target";
            case 15L: return "e_value";
            case 16L: return "e_volatile";
            case 17L: return "e_last_attribute_specifier";
            default: return "";
        }
    }

    std::string fortran_attribute_specifiers_enum(int64_t i, const std::string &strip) {
        std::string s = fortran_attribute_specifiers_enum(i);
        if (s.empty())
            s = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& fortran_attribute_specifiers_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L
        };
        static const std::vector<int64_t> retval(values, values + 18);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgType_fortran_attribute_specifiers_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgType::fortran_attribute_specifiers_enum(i);
        if (retval.empty()) {
            retval = "(SgType::fortran_attribute_specifiers_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgType_fortran_attribute_specifiers_enum() {
        return stringify::SgType::fortran_attribute_specifiers_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 120854
namespace stringify { namespace SgJovialTableType {
    const char* StructureSpecifier(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_parallel";
            case 2L: return "e_tight";
            default: return "";
        }
    }

    std::string StructureSpecifier(int64_t i, const std::string &strip) {
        std::string s = StructureSpecifier(i);
        if (s.empty())
            s = "(SgJovialTableType::StructureSpecifier)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& StructureSpecifier() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialTableTypeStructureSpecifier(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialTableType::StructureSpecifier(i);
        if (retval.empty()) {
            retval = "(SgJovialTableType::StructureSpecifier)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialTableType::StructureSpecifier::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialTableTypeStructureSpecifier() {
        return stringify::SgJovialTableType::StructureSpecifier();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 135082
namespace stringify { namespace SgMemberFunctionType {
    const char* mfunc_specifier_enum(int64_t i) {
        switch (i) {
            case 1L: return "e_const";
            case 2L: return "e_volatile";
            case 4L: return "e_restrict";
            case 8L: return "e_ref_qualifier_lvalue";
            case 16L: return "e_ref_qualifier_rvalue";
            default: return "";
        }
    }

    std::string mfunc_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = mfunc_specifier_enum(i);
        if (s.empty())
            s = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& mfunc_specifier_enum() {
        static const int64_t values[] = {
            1L,
            2L,
            4L,
            8L,
            16L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgMemberFunctionType_mfunc_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgMemberFunctionType::mfunc_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgMemberFunctionType::mfunc_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgMemberFunctionType_mfunc_specifier_enum() {
        return stringify::SgMemberFunctionType::mfunc_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 171299
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Keywords(int64_t i) {
        switch (i) {
            case 0L: return "FORTRAN_ABSTRACT";
            case 1L: return "FORTRAN_ACCESS";
            case 2L: return "FORTRAN_ACTION";
            case 3L: return "FORTRAN_ALLOCATE";
            case 4L: return "FORTRAN_ALLOCATABLE";
            case 5L: return "FORTRAN_ASSIGN";
            case 6L: return "FORTRAN_ASSOCIATE";
            case 7L: return "FORTRAN_ASYNCHRONOUS";
            case 8L: return "FORTRAN_BACKSPACE";
            case 9L: return "FORTRAN_BIND";
            case 10L: return "FORTRAN_BLANK";
            case 11L: return "FORTRAN_BLOCK_DATA";
            case 12L: return "FORTRAN_CALL";
            case 13L: return "FORTRAN_CHARACTER";
            case 14L: return "FORTRAN_CLASS";
            case 15L: return "FORTRAN_CLOSE";
            case 16L: return "FORTRAN_CONTINUE";
            case 17L: return "FORTRAN_CYCLE";
            case 18L: return "FORTRAN_CASE";
            case 19L: return "FORTRAN_COMMON";
            case 20L: return "FORTRAN_COMPLEX";
            case 21L: return "FORTRAN_CONTAINS";
            case 22L: return "FORTRAN_DEALLOCATE";
            case 23L: return "FORTRAN_DATA";
            case 24L: return "FORTRAN_DEFERRED";
            case 25L: return "FORTRAN_DELIM";
            case 26L: return "FORTRAN_DIMENSION";
            case 27L: return "FORTRAN_DO";
            case 28L: return "FORTRAN_DT";
            case 29L: return "FORTRAN_DOUBLEPRECISION";
            case 30L: return "FORTRAN_ENCODING";
            case 31L: return "FORTRAN_END_CASE";
            case 32L: return "FORTRAN_ENDDO";
            case 33L: return "FORTRAN_END_FILE";
            case 34L: return "FORTRAN_END_ENUM";
            case 35L: return "FORTRAN_END_INTERFACE";
            case 36L: return "FORTRAN_END_TYPE";
            case 37L: return "FORTRAN_ERR";
            case 38L: return "FORTRAN_ERRMSG";
            case 39L: return "FORTRAN_EXIT";
            case 40L: return "FORTRAN_ELSE";
            case 41L: return "FORTRAN_ELSEWHERE";
            case 42L: return "FORTRAN_ELSEIF";
            case 43L: return "FORTRAN_ENDIF";
            case 44L: return "FORTRAN_ENTRY";
            case 45L: return "FORTRAN_END";
            case 46L: return "FORTRAN_ENUM";
            case 47L: return "FORTRAN_ENUMERATOR";
            case 48L: return "FORTRAN_EQUIVALENCE";
            case 49L: return "FORTRAN_EXTERNAL";
            case 50L: return "FORTRAN_EXTENDS";
            case 51L: return "FORTRAN_FILE";
            case 52L: return "FORTRAN_FINAL";
            case 53L: return "FORTRAN_FMT";
            case 54L: return "FORTRAN_FORALL";
            case 55L: return "FORTRAN_FORM";
            case 56L: return "FORTRAN_FORMATTED";
            case 57L: return "FORTRAN_FORMAT";
            case 58L: return "FORTRAN_FLUSH";
            case 59L: return "FORTRAN_FUNCTION";
            case 60L: return "FORTRAN_GENERIC";
            case 61L: return "FORTRAN_GOTO";
            case 62L: return "FORTRAN_ID";
            case 63L: return "FORTRAN_IF";
            case 64L: return "FORTRAN_INQUIRE";
            case 65L: return "FORTRAN_INTEGER";
            case 66L: return "FORTRAN_IOMSG";
            case 67L: return "FORTRAN_IOSTAT";
            case 68L: return "FORTRAN_IMPLICIT";
            case 69L: return "FORTRAN_IMPLICIT_NONE";
            case 70L: return "FORTRAN_IMPORT";
            case 71L: return "FORTRAN_INTERFACE";
            case 72L: return "FORTRAN_INTENT";
            case 73L: return "FORTRAN_INTRINSIC";
            case 74L: return "FORTRAN_LEN";
            case 75L: return "FORTRAN_LOGICAL";
            case 76L: return "FORTRAN_KIND";
            case 77L: return "FORTRAN_MODULE_PROC";
            case 78L: return "FORTRAN_MODULE";
            case 79L: return "FORTRAN_NON_INTRINSIC";
            case 80L: return "FORTRAN_NON_OVERRIDABLE";
            case 81L: return "FORTRAN_NULL";
            case 82L: return "FORTRAN_NULLIFY";
            case 83L: return "FORTRAN_NAMELIST";
            case 84L: return "FORTRAN_NML";
            case 85L: return "FORTRAN_NONE";
            case 86L: return "FORTRAN_NOPASS";
            case 87L: return "FORTRAN_ONLY";
            case 88L: return "FORTRAN_OPEN";
            case 89L: return "FORTRAN_OPTIONAL";
            case 90L: return "FORTRAN_PARAMETER";
            case 91L: return "FORTRAN_PASS";
            case 92L: return "FORTRAN_PAUSE";
            case 93L: return "FORTRAN_POINTER";
            case 94L: return "FORTRAN_PRINT";
            case 95L: return "FORTRAN_PRIVATE";
            case 96L: return "FORTRAN_PROCEDURE";
            case 97L: return "FORTRAN_PROGRAM";
            case 98L: return "FORTRAN_PROTECTED";
            case 99L: return "FORTRAN_READ";
            case 100L: return "FORTRAN_REAL";
            case 101L: return "FORTRAN_RETURN";
            case 102L: return "FORTRAN_REWIND";
            case 103L: return "FORTRAN_ROUND";
            case 104L: return "FORTRAN_SELECTCASE";
            case 105L: return "FORTRAN_SELECTTYPE";
            case 106L: return "FORTRAN_SEQUENCE";
            case 107L: return "FORTRAN_SAVE";
            case 108L: return "FORTRAN_SIGN";
            case 109L: return "FORTRAN_SIZE";
            case 110L: return "FORTRAN_SOURCE";
            case 111L: return "FORTRAN_STAT";
            case 112L: return "FORTRAN_STOP";
            case 113L: return "FORTRAN_SUBROUTINE";
            case 114L: return "FORTRAN_TARGET";
            case 115L: return "FORTRAN_THEN";
            case 116L: return "FORTRAN_DERIVED_DECL";
            case 117L: return "FORTRAN_TYPEIS";
            case 118L: return "FORTRAN_UNFORMATTED";
            case 119L: return "FORTRAN_UNIT";
            case 120L: return "FORTRAN_USE";
            case 121L: return "FORTRAN_VALUE";
            case 122L: return "FORTRAN_VOLATILE";
            case 123L: return "FORTRAN_WAIT";
            case 124L: return "FORTRAN_WHERE";
            case 125L: return "FORTRAN_WRITE";
            case 126L: return "FORTRAN_END_PROGRAM";
            case 127L: return "FORTRAN_END_FUNCTION";
            case 128L: return "FORTRAN_END_SUBROUTINE";
            case 129L: return "FORTRAN_END_MODULE";
            case 130L: return "FORTRAN_END_BLOCK_DATA";
            case 131L: return "FORTRAN_SUBMODULE";
            case 132L: return "FORTRAN_END_SUBMODULE";
            case 133L: return "FORTRAN_DOUBLE_COMPLEX";
            case 134L: return "FORTRAN_TYPE";
            case 135L: return "FORTRAN_ABSTRACT_INTERFACE";
            case 136L: return "FORTRAN_ERROR_STOP";
            case 137L: return "FORTRAN_CONTIGUOUS";
            case 138L: return "FORTRAN_PUBLIC";
            case 139L: return "FORTRAN_ELEMENTAL";
            case 140L: return "FORTRAN_IMPURE";
            case 141L: return "FORTRAN_PURE";
            case 142L: return "FORTRAN_RECURSIVE";
            case 143L: return "FORTRAN_INTENT_IN";
            case 144L: return "FORTRAN_INTENT_OUT";
            case 145L: return "FORTRAN_INTENT_INOUT";
            case 146L: return "FORTRAN_ASSIGNMENT";
            case 147L: return "FORTRAN_OPERATOR";
            case 148L: return "FORTRAN_READ_FORMATTED";
            case 149L: return "FORTRAN_READ_UNFORMATTED";
            case 150L: return "FORTRAN_WRITE_FORMATTED";
            case 151L: return "FORTRAN_WRITE_UNFORMATTED";
            case 152L: return "FORTRAN_UNKNOWN";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Keywords() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L,
            60L,
            61L,
            62L,
            63L,
            64L,
            65L,
            66L,
            67L,
            68L,
            69L,
            70L,
            71L,
            72L,
            73L,
            74L,
            75L,
            76L,
            77L,
            78L,
            79L,
            80L,
            81L,
            82L,
            83L,
            84L,
            85L,
            86L,
            87L,
            88L,
            89L,
            90L,
            91L,
            92L,
            93L,
            94L,
            95L,
            96L,
            97L,
            98L,
            99L,
            100L,
            101L,
            102L,
            103L,
            104L,
            105L,
            106L,
            107L,
            108L,
            109L,
            110L,
            111L,
            112L,
            113L,
            114L,
            115L,
            116L,
            117L,
            118L,
            119L,
            120L,
            121L,
            122L,
            123L,
            124L,
            125L,
            126L,
            127L,
            128L,
            129L,
            130L,
            131L,
            132L,
            133L,
            134L,
            135L,
            136L,
            137L,
            138L,
            139L,
            140L,
            141L,
            142L,
            143L,
            144L,
            145L,
            146L,
            147L,
            148L,
            149L,
            150L,
            151L,
            152L
        };
        static const std::vector<int64_t> retval(values, values + 153);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Keywords() {
        return stringify::SgToken::ROSE_Fortran_Keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 171466
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_keywords(int64_t i) {
        switch (i) {
            case 500L: return "C_CXX_ASM";
            case 501L: return "C_CXX_AUTO";
            case 502L: return "C_CXX_BOOL";
            case 503L: return "C_CXX_BREAK";
            case 504L: return "C_CXX_CASE";
            case 505L: return "C_CXX_CATCH";
            case 506L: return "C_CXX_CHAR";
            case 507L: return "C_CXX_CLASS";
            case 508L: return "C_CXX_CONST";
            case 509L: return "C_CXX_CONSTCAST";
            case 510L: return "C_CXX_CONTINUE";
            case 511L: return "C_CXX_DEFAULT";
            case 512L: return "C_CXX_DEFINED";
            case 513L: return "C_CXX_DELETE";
            case 514L: return "C_CXX_DO";
            case 515L: return "C_CXX_DOUBLE";
            case 516L: return "C_CXX_DYNAMICCAST";
            case 517L: return "C_CXX_ELSE";
            case 518L: return "C_CXX_ENUM";
            case 519L: return "C_CXX_EXPLICIT";
            case 520L: return "C_CXX_EXPORT";
            case 521L: return "C_CXX_EXTERN";
            case 522L: return "C_CXX_FALSE";
            case 523L: return "C_CXX_FLOAT";
            case 524L: return "C_CXX_FOR";
            case 525L: return "C_CXX_FRIEND";
            case 526L: return "C_CXX_GOTO";
            case 527L: return "C_CXX_IF";
            case 528L: return "C_CXX_INLINE";
            case 529L: return "C_CXX_INT";
            case 530L: return "C_CXX_LONG";
            case 531L: return "C_CXX_MUTABLE";
            case 532L: return "C_CXX_NAMESPACE";
            case 533L: return "C_CXX_NEW";
            case 534L: return "C_CXX_OPERATOR";
            case 535L: return "C_CXX_PRIVATE";
            case 536L: return "C_CXX_PROTECTED";
            case 537L: return "C_CXX_PUBLIC";
            case 538L: return "C_CXX_REGISTER";
            case 539L: return "C_CXX_REINTERPRETCAST";
            case 540L: return "C_CXX_RETURN";
            case 541L: return "C_CXX_SHORT";
            case 542L: return "C_CXX_SIGNED";
            case 543L: return "C_CXX_SIZEOF";
            case 544L: return "C_CXX_STATIC";
            case 545L: return "C_CXX_STATICCAST";
            case 546L: return "C_CXX_STRUCT";
            case 547L: return "C_CXX_SWITCH";
            case 548L: return "C_CXX_TEMPLATE";
            case 549L: return "C_CXX_THIS";
            case 550L: return "C_CXX_THROW";
            case 551L: return "C_CXX_TRY";
            case 552L: return "C_CXX_TRUE";
            case 553L: return "C_CXX_TYPEDEF";
            case 554L: return "C_CXX_TYPEID";
            case 555L: return "C_CXX_TYPENAME";
            case 556L: return "C_CXX_UNION";
            case 557L: return "C_CXX_UNSIGNED";
            case 558L: return "C_CXX_USING";
            case 559L: return "C_CXX_VIRTUAL";
            case 560L: return "C_CXX_VOID";
            case 561L: return "C_CXX_VOLATILE";
            case 562L: return "C_CXX_WCHART";
            case 563L: return "C_CXX_WHILE";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_keywords(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_keywords(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_keywords() {
        static const int64_t values[] = {
            500L,
            501L,
            502L,
            503L,
            504L,
            505L,
            506L,
            507L,
            508L,
            509L,
            510L,
            511L,
            512L,
            513L,
            514L,
            515L,
            516L,
            517L,
            518L,
            519L,
            520L,
            521L,
            522L,
            523L,
            524L,
            525L,
            526L,
            527L,
            528L,
            529L,
            530L,
            531L,
            532L,
            533L,
            534L,
            535L,
            536L,
            537L,
            538L,
            539L,
            540L,
            541L,
            542L,
            543L,
            544L,
            545L,
            546L,
            547L,
            548L,
            549L,
            550L,
            551L,
            552L,
            553L,
            554L,
            555L,
            556L,
            557L,
            558L,
            559L,
            560L,
            561L,
            562L,
            563L
        };
        static const std::vector<int64_t> retval(values, values + 64);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_keywords(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_keywords(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_keywords)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_keywords() {
        return stringify::SgToken::ROSE_C_CXX_keywords();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 171535
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Operators(int64_t i) {
        switch (i) {
            case 10000L: return "FORTRAN_INTRINSIC_PLUS";
            case 10001L: return "FORTRAN_INTRINSIC_MINUS";
            case 10002L: return "FORTRAN_INTRINSIC_POWER";
            case 10003L: return "FORTRAN_INTRINSIC_CONCAT";
            case 10004L: return "FORTRAN_INTRINSIC_TIMES";
            case 10005L: return "FORTRAN_INTRINSIC_DIVIDE";
            case 10006L: return "FORTRAN_INTRINSIC_AND";
            case 10007L: return "FORTRAN_INTRINSIC_OR";
            case 10008L: return "FORTRAN_INTRINSIC_EQV";
            case 10009L: return "FORTRAN_INTRINSIC_NEQV";
            case 10010L: return "FORTRAN_INTRINSIC_EQ";
            case 10011L: return "FORTRAN_INTRINSIC_NE";
            case 10012L: return "FORTRAN_INTRINSIC_GE";
            case 10013L: return "FORTRAN_INTRINSIC_LE";
            case 10014L: return "FORTRAN_INTRINSIC_LT";
            case 10015L: return "FORTRAN_INTRINSIC_GT";
            case 10016L: return "FORTRAN_INTRINSIC_NOT";
            case 10017L: return "FORTRAN_INTRINSIC_OLDEQ";
            case 10018L: return "FORTRAN_INTRINSIC_OLDNE";
            case 10019L: return "FORTRAN_INTRINSIC_OLDGE";
            case 10020L: return "FORTRAN_INTRINSIC_OLDLE";
            case 10021L: return "FORTRAN_INTRINSIC_OLDLT";
            case 10022L: return "FORTRAN_INTRINSIC_OLDGT";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Operators() {
        static const int64_t values[] = {
            10000L,
            10001L,
            10002L,
            10003L,
            10004L,
            10005L,
            10006L,
            10007L,
            10008L,
            10009L,
            10010L,
            10011L,
            10012L,
            10013L,
            10014L,
            10015L,
            10016L,
            10017L,
            10018L,
            10019L,
            10020L,
            10021L,
            10022L
        };
        static const std::vector<int64_t> retval(values, values + 23);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Operators() {
        return stringify::SgToken::ROSE_Fortran_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 171562
namespace stringify { namespace SgToken {
    const char* ROSE_C_CXX_Operators(int64_t i) {
        switch (i) {
            case 50000L: return "C_CXX_AND";
            case 50001L: return "C_CXX_ANDAND";
            case 50002L: return "C_CXX_ASSIGN";
            case 50003L: return "C_CXX_ANDASSIGN";
            case 50004L: return "C_CXX_OR";
            case 50005L: return "C_CXX_ORASSIGN";
            case 50006L: return "C_CXX_XOR";
            case 50007L: return "C_CXX_XORASSIGN";
            case 50008L: return "C_CXX_COMMA";
            case 50009L: return "C_CXX_COLON";
            case 50010L: return "C_CXX_DIVIDE";
            case 50011L: return "C_CXX_DIVIDEASSIGN";
            case 50012L: return "C_CXX_DOT";
            case 50013L: return "C_CXX_DOTSTAR";
            case 50014L: return "C_CXX_ELLIPSIS";
            case 50015L: return "C_CXX_EQUAL";
            case 50016L: return "C_CXX_GREATER";
            case 50017L: return "C_CXX_GREATEREQUAL";
            case 50018L: return "C_CXX_LEFTBRACE";
            case 50019L: return "C_CXX_LESS";
            case 50020L: return "C_CXX_LESSEQUAL";
            case 50021L: return "C_CXX_LEFTPAREN";
            case 50022L: return "C_CXX_LEFTBRACKET";
            case 50023L: return "C_CXX_MINUS";
            case 50024L: return "C_CXX_MINUSASSIGN";
            case 50025L: return "C_CXX_MINUSMINUS";
            case 50026L: return "C_CXX_PERCENT";
            case 50027L: return "C_CXX_PERCENTASSIGN";
            case 50028L: return "C_CXX_NOT";
            case 50029L: return "C_CXX_NOTEQUAL";
            case 50030L: return "C_CXX_OROR";
            case 50031L: return "C_CXX_PLUS";
            case 50032L: return "C_CXX_PLUSASSIGN";
            case 50033L: return "C_CXX_PLUSPLUS";
            case 50034L: return "C_CXX_ARROW";
            case 50035L: return "C_CXX_ARROWSTAR";
            case 50036L: return "C_CXX_QUESTION_MARK";
            case 50037L: return "C_CXX_RIGHTBRACE";
            case 50038L: return "C_CXX_RIGHTPAREN";
            case 50039L: return "C_CXX_RIGHTBRACKET";
            case 50040L: return "C_CXX_COLON_COLON";
            case 50041L: return "C_CXX_SEMICOLON";
            case 50042L: return "C_CXX_SHIFTLEFT";
            case 50043L: return "C_CXX_SHIFTLEFTASSIGN";
            case 50044L: return "C_CXX_SHIFTRIGHT";
            case 50045L: return "C_CXX_SHIFTRIGHTASSIGN";
            case 50046L: return "C_CXX_STAR";
            case 50047L: return "C_CXX_COMPL";
            case 50048L: return "C_CXX_STARASSIGN";
            case 50049L: return "C_CXX_POUND_POUND";
            case 50050L: return "C_CXX_POUND";
            case 50051L: return "C_CXX_AND_ALT";
            case 50052L: return "C_CXX_ANDASSIGN_ALT";
            case 50053L: return "C_CXX_OR_ALT";
            case 50054L: return "C_CXX_ORASSIGN_ALT";
            case 50055L: return "C_CXX_XOR_ALT";
            case 50056L: return "C_CXX_XORASSIGN_ALT";
            case 50057L: return "C_CXX_LEFTBRACE_ALT";
            case 50058L: return "C_CXX_LEFTBRACKET_ALT";
            case 50059L: return "C_CXX_NOT_ALT";
            case 50060L: return "C_CXX_NOTEQUAL_ALT";
            case 50061L: return "C_CXX_RIGHTBRACE_ALT";
            case 50062L: return "C_CXX_RIGHTBRACKET_ALT";
            case 50063L: return "C_CXX_COMPL_ALT";
            case 50064L: return "C_CXX_POUND_POUND_ALT";
            case 50065L: return "C_CXX_POUND_ALT";
            case 50066L: return "C_CXX_OR_TRIGRAPH";
            case 50067L: return "C_CXX_XOR_TRIGRAPH";
            case 50068L: return "C_CXX_LEFTBRACE_TRIGRAPH";
            case 50069L: return "C_CXX_LEFTBRACKET_TRIGRAPH";
            case 50070L: return "C_CXX_RIGHTBRACE_TRIGRAPH";
            case 50071L: return "C_CXX_RIGHTBRACKET_TRIGRAPH";
            case 50072L: return "C_CXX_COMPL_TRIGRAPH";
            case 50073L: return "C_CXX_POUND_POUND_TRIGRAPH";
            case 50074L: return "C_CXX_POUND_TRIGRAPH";
            default: return "";
        }
    }

    std::string ROSE_C_CXX_Operators(int64_t i, const std::string &strip) {
        std::string s = ROSE_C_CXX_Operators(i);
        if (s.empty())
            s = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_C_CXX_Operators() {
        static const int64_t values[] = {
            50000L,
            50001L,
            50002L,
            50003L,
            50004L,
            50005L,
            50006L,
            50007L,
            50008L,
            50009L,
            50010L,
            50011L,
            50012L,
            50013L,
            50014L,
            50015L,
            50016L,
            50017L,
            50018L,
            50019L,
            50020L,
            50021L,
            50022L,
            50023L,
            50024L,
            50025L,
            50026L,
            50027L,
            50028L,
            50029L,
            50030L,
            50031L,
            50032L,
            50033L,
            50034L,
            50035L,
            50036L,
            50037L,
            50038L,
            50039L,
            50040L,
            50041L,
            50042L,
            50043L,
            50044L,
            50045L,
            50046L,
            50047L,
            50048L,
            50049L,
            50050L,
            50051L,
            50052L,
            50053L,
            50054L,
            50055L,
            50056L,
            50057L,
            50058L,
            50059L,
            50060L,
            50061L,
            50062L,
            50063L,
            50064L,
            50065L,
            50066L,
            50067L,
            50068L,
            50069L,
            50070L,
            50071L,
            50072L,
            50073L,
            50074L
        };
        static const std::vector<int64_t> retval(values, values + 75);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_C_CXX_Operators(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_C_CXX_Operators(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_C_CXX_Operators)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_C_CXX_Operators() {
        return stringify::SgToken::ROSE_C_CXX_Operators();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 171642
namespace stringify { namespace SgToken {
    const char* ROSE_Fortran_Additional_Info(int64_t i) {
        switch (i) {
            case 100000L: return "FORTRAN_COMMENTS";
            case 100001L: return "FORTRAN_STRING_LITERALS";
            case 100002L: return "FORTRAN_IDENTIFIER";
            case 100003L: return "FORTRAN_UNIDENTIFIED_TOKEN";
            case 100004L: return "FORTRAN_ERROR";
            default: return "";
        }
    }

    std::string ROSE_Fortran_Additional_Info(int64_t i, const std::string &strip) {
        std::string s = ROSE_Fortran_Additional_Info(i);
        if (s.empty())
            s = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& ROSE_Fortran_Additional_Info() {
        static const int64_t values[] = {
            100000L,
            100001L,
            100002L,
            100003L,
            100004L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTokenROSE_Fortran_Additional_Info(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgToken::ROSE_Fortran_Additional_Info(i);
        if (retval.empty()) {
            retval = "(SgToken::ROSE_Fortran_Additional_Info)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTokenROSE_Fortran_Additional_Info() {
        return stringify::SgToken::ROSE_Fortran_Additional_Info();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 175028
namespace stringify { namespace SgInitializedName {
    const char* preinitialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_preinitialization";
            case 1L: return "e_virtual_base_class";
            case 2L: return "e_nonvirtual_base_class";
            case 3L: return "e_data_member";
            case 4L: return "e_delegation_constructor";
            case 5L: return "e_last_preinitialization";
            default: return "";
        }
    }

    std::string preinitialization_enum(int64_t i, const std::string &strip) {
        std::string s = preinitialization_enum(i);
        if (s.empty())
            s = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& preinitialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_preinitialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::preinitialization_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::preinitialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::preinitialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_preinitialization_enum() {
        return stringify::SgInitializedName::preinitialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 175043
namespace stringify { namespace SgInitializedName {
    const char* asm_register_name_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid_register";
            case 1L: return "e_memory_register";
            case 2L: return "e_register_a";
            case 3L: return "e_register_b";
            case 4L: return "e_register_c";
            case 5L: return "e_register_d";
            case 6L: return "e_register_si";
            case 7L: return "e_register_di";
            case 8L: return "e_register_bp";
            case 9L: return "e_register_sp";
            case 10L: return "e_register_r8";
            case 11L: return "e_register_r9";
            case 12L: return "e_register_r10";
            case 13L: return "e_register_r11";
            case 14L: return "e_register_r12";
            case 15L: return "e_register_r13";
            case 16L: return "e_register_r14";
            case 17L: return "e_register_r15";
            case 18L: return "e_register_st0";
            case 19L: return "e_register_st1";
            case 20L: return "e_register_st2";
            case 21L: return "e_register_st3";
            case 22L: return "e_register_st4";
            case 23L: return "e_register_st5";
            case 24L: return "e_register_st6";
            case 25L: return "e_register_st7";
            case 26L: return "e_register_mm0";
            case 27L: return "e_register_mm1";
            case 28L: return "e_register_mm2";
            case 29L: return "e_register_mm3";
            case 30L: return "e_register_mm4";
            case 31L: return "e_register_mm5";
            case 32L: return "e_register_mm6";
            case 33L: return "e_register_mm7";
            case 34L: return "e_register_f0";
            case 35L: return "e_register_f1";
            case 36L: return "e_register_f2";
            case 37L: return "e_register_f3";
            case 38L: return "e_register_f4";
            case 39L: return "e_register_f5";
            case 40L: return "e_register_f6";
            case 41L: return "e_register_f7";
            case 42L: return "e_register_f8";
            case 43L: return "e_register_f9";
            case 44L: return "e_register_f10";
            case 45L: return "e_register_f11";
            case 46L: return "e_register_f12";
            case 47L: return "e_register_f13";
            case 48L: return "e_register_f14";
            case 49L: return "e_register_f15";
            case 50L: return "e_register_flags";
            case 51L: return "e_register_fpsr";
            case 52L: return "e_register_dirflag";
            case 53L: return "e_register_f16";
            case 54L: return "e_register_f17";
            case 55L: return "e_register_f18";
            case 56L: return "e_register_f19";
            case 57L: return "e_register_f20";
            case 58L: return "e_unrecognized_register";
            case 59L: return "e_last_register";
            default: return "";
        }
    }

    std::string asm_register_name_enum(int64_t i, const std::string &strip) {
        std::string s = asm_register_name_enum(i);
        if (s.empty())
            s = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_register_name_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L,
            58L,
            59L
        };
        static const std::vector<int64_t> retval(values, values + 60);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_asm_register_name_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::asm_register_name_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::asm_register_name_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::asm_register_name_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_asm_register_name_enum() {
        return stringify::SgInitializedName::asm_register_name_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 175110
namespace stringify { namespace SgInitializedName {
    const char* gnu_variable_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute__weak__";
            case 1L: return "e_gnu_attribute__unused__";
            case 2L: return "e_gnu_attribute__used__";
            case 3L: return "e_gnu_attribute__deprecated__";
            case 4L: return "e_gnu_attribute__nocommon__";
            case 5L: return "e_gnu_attribute__transparent_union__";
            case 6L: return "e_gnu_attribute__weakref__";
            case 7L: return "e_gnu_attribute__packed__";
            case 8L: return "e_gnu_attribute__noreturn__";
            case 9L: return "e_gnu_attribute__noreorder__";
            case 10L: return "e_ms_declspec_parameter_appdomain";
            case 11L: return "e_ms_declspec_parameter_deprecated";
            case 12L: return "e_ms_declspec_parameter_dllimport";
            case 13L: return "e_ms_declspec_parameter_dllexport";
            case 14L: return "e_ms_declspec_parameter_novtable";
            case 15L: return "e_ms_declspec_parameter_process";
            case 16L: return "e_ms_declspec_parameter_property";
            case 17L: return "e_ms_declspec_parameter_restrict";
            case 18L: return "e_ms_declspec_parameter_selectany";
            case 19L: return "e_ms_declspec_parameter_thread";
            case 20L: return "e_ms_declspec_parameter_uuid";
            case 21L: return "e_last_gnu_variable_attribute";
            default: return "";
        }
    }

    std::string gnu_variable_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_variable_attribute_enum(i);
        if (s.empty())
            s = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_variable_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L
        };
        static const std::vector<int64_t> retval(values, values + 22);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_gnu_variable_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::gnu_variable_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::gnu_variable_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_gnu_variable_attribute_enum() {
        return stringify::SgInitializedName::gnu_variable_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 175145
namespace stringify { namespace SgInitializedName {
    const char* excess_specifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_excess_specifier_none";
            case 1L: return "e_excess_specifier_positionals";
            case 2L: return "e_excess_specifier_keywords";
            case 3L: return "e_excess_specifier_last";
            default: return "";
        }
    }

    std::string excess_specifier_enum(int64_t i, const std::string &strip) {
        std::string s = excess_specifier_enum(i);
        if (s.empty())
            s = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& excess_specifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInitializedName_excess_specifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInitializedName::excess_specifier_enum(i);
        if (retval.empty()) {
            retval = "(SgInitializedName::excess_specifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInitializedName::excess_specifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInitializedName_excess_specifier_enum() {
        return stringify::SgInitializedName::excess_specifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181602
namespace stringify { namespace SgOmpClause {
    const char* omp_default_option_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_default_unknown";
            case 1L: return "e_omp_default_none";
            case 2L: return "e_omp_default_shared";
            case 3L: return "e_omp_default_private";
            case 4L: return "e_omp_default_firstprivate";
            case 5L: return "e_omp_default_last";
            default: return "";
        }
    }

    std::string omp_default_option_enum(int64_t i, const std::string &strip) {
        std::string s = omp_default_option_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_default_option_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_default_option_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_default_option_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_default_option_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_default_option_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_default_option_enum() {
        return stringify::SgOmpClause::omp_default_option_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181614
namespace stringify { namespace SgOmpClause {
    const char* omp_schedule_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_schedule_unknown";
            case 1L: return "e_omp_schedule_static";
            case 2L: return "e_omp_schedule_dynamic";
            case 3L: return "e_omp_schedule_guided";
            case 4L: return "e_omp_schedule_auto";
            case 5L: return "e_omp_schedule_runtime";
            case 6L: return "e_omp_schedule_last";
            default: return "";
        }
    }

    std::string omp_schedule_kind_enum(int64_t i, const std::string &strip) {
        std::string s = omp_schedule_kind_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_schedule_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_schedule_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_schedule_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_schedule_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_schedule_kind_enum() {
        return stringify::SgOmpClause::omp_schedule_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181624
namespace stringify { namespace SgOmpClause {
    const char* omp_reduction_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_reduction_unknown";
            case 1L: return "e_omp_reduction_plus";
            case 2L: return "e_omp_reduction_mul";
            case 3L: return "e_omp_reduction_minus";
            case 4L: return "e_omp_reduction_bitand";
            case 5L: return "e_omp_reduction_bitor";
            case 6L: return "e_omp_reduction_bitxor";
            case 7L: return "e_omp_reduction_logand";
            case 8L: return "e_omp_reduction_logor";
            case 9L: return "e_omp_reduction_and";
            case 10L: return "e_omp_reduction_or";
            case 11L: return "e_omp_reduction_eqv";
            case 12L: return "e_omp_reduction_neqv";
            case 13L: return "e_omp_reduction_max";
            case 14L: return "e_omp_reduction_min";
            case 15L: return "e_omp_reduction_iand";
            case 16L: return "e_omp_reduction_ior";
            case 17L: return "e_omp_reduction_ieor";
            case 18L: return "e_omp_reduction_last";
            default: return "";
        }
    }

    std::string omp_reduction_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_reduction_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_reduction_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L
        };
        static const std::vector<int64_t> retval(values, values + 19);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_reduction_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_reduction_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_reduction_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_reduction_operator_enum() {
        return stringify::SgOmpClause::omp_reduction_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181652
namespace stringify { namespace SgOmpClause {
    const char* omp_dependence_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_depend_unknown";
            case 1L: return "e_omp_depend_in";
            case 2L: return "e_omp_depend_out";
            case 3L: return "e_omp_depend_inout";
            case 4L: return "e_omp_depend_last";
            default: return "";
        }
    }

    std::string omp_dependence_type_enum(int64_t i, const std::string &strip) {
        std::string s = omp_dependence_type_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_dependence_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_dependence_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_dependence_type_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_dependence_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_dependence_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_dependence_type_enum() {
        return stringify::SgOmpClause::omp_dependence_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181662
namespace stringify { namespace SgOmpClause {
    const char* omp_map_operator_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_unknown";
            case 1L: return "e_omp_map_alloc";
            case 2L: return "e_omp_map_to";
            case 3L: return "e_omp_map_from";
            case 4L: return "e_omp_map_tofrom";
            case 5L: return "e_omp_map_last";
            default: return "";
        }
    }

    std::string omp_map_operator_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_operator_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_operator_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_operator_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_operator_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_operator_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_operator_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_operator_enum() {
        return stringify::SgOmpClause::omp_map_operator_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181673
namespace stringify { namespace SgOmpClause {
    const char* omp_map_dist_data_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_map_dist_data_unknown";
            case 1L: return "e_omp_map_dist_data_duplicate";
            case 2L: return "e_omp_map_dist_data_block";
            case 3L: return "e_omp_map_dist_data_cyclic";
            case 4L: return "e_omp_map_dist_data_last";
            default: return "";
        }
    }

    std::string omp_map_dist_data_enum(int64_t i, const std::string &strip) {
        std::string s = omp_map_dist_data_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_map_dist_data_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_map_dist_data_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_map_dist_data_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_map_dist_data_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_map_dist_data_enum() {
        return stringify::SgOmpClause::omp_map_dist_data_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181683
namespace stringify { namespace SgOmpClause {
    const char* omp_proc_bind_policy_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_proc_bind_policy_unknown";
            case 1L: return "e_omp_proc_bind_policy_master";
            case 2L: return "e_omp_proc_bind_policy_close";
            case 3L: return "e_omp_proc_bind_policy_spread";
            case 4L: return "e_omp_proc_bind_policy_last";
            default: return "";
        }
    }

    std::string omp_proc_bind_policy_enum(int64_t i, const std::string &strip) {
        std::string s = omp_proc_bind_policy_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_proc_bind_policy_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_proc_bind_policy_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_proc_bind_policy_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_proc_bind_policy_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_proc_bind_policy_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_proc_bind_policy_enum() {
        return stringify::SgOmpClause::omp_proc_bind_policy_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 181692
namespace stringify { namespace SgOmpClause {
    const char* omp_atomic_clause_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_omp_atomic_clause_unknown";
            case 1L: return "e_omp_atomic_clause_read";
            case 2L: return "e_omp_atomic_clause_write";
            case 3L: return "e_omp_atomic_clause_update";
            case 4L: return "e_omp_atomic_clause_capture";
            default: return "";
        }
    }

    std::string omp_atomic_clause_enum(int64_t i, const std::string &strip) {
        std::string s = omp_atomic_clause_enum(i);
        if (s.empty())
            s = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& omp_atomic_clause_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgOmpClause_omp_atomic_clause_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgOmpClause::omp_atomic_clause_enum(i);
        if (retval.empty()) {
            retval = "(SgOmpClause::omp_atomic_clause_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgOmpClause::omp_atomic_clause_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgOmpClause_omp_atomic_clause_enum() {
        return stringify::SgOmpClause::omp_atomic_clause_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 248010
namespace stringify { namespace SgForAllStatement {
    const char* forall_statement_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_forall_statement";
            case 2L: return "e_do_concurrent_statement";
            case 3L: return "e_last_forall_statement_kind";
            default: return "";
        }
    }

    std::string forall_statement_kind_enum(int64_t i, const std::string &strip) {
        std::string s = forall_statement_kind_enum(i);
        if (s.empty())
            s = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& forall_statement_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgForAllStatement_forall_statement_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgForAllStatement::forall_statement_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgForAllStatement::forall_statement_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgForAllStatement::forall_statement_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgForAllStatement_forall_statement_kind_enum() {
        return stringify::SgForAllStatement::forall_statement_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 257790
namespace stringify { namespace SgJovialForThenStatement {
    const char* loop_statement_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_for_only_stmt";
            case 2L: return "e_for_while_stmt";
            case 3L: return "e_for_while_by_stmt";
            case 4L: return "e_for_while_then_stmt";
            case 5L: return "e_for_then_while_stmt";
            case 6L: return "e_for_by_while_stmt";
            default: return "";
        }
    }

    std::string loop_statement_type_enum(int64_t i, const std::string &strip) {
        std::string s = loop_statement_type_enum(i);
        if (s.empty())
            s = "(SgJovialForThenStatement::loop_statement_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& loop_statement_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialForThenStatement_loop_statement_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialForThenStatement::loop_statement_type_enum(i);
        if (retval.empty()) {
            retval = "(SgJovialForThenStatement::loop_statement_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialForThenStatement::loop_statement_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialForThenStatement_loop_statement_type_enum() {
        return stringify::SgJovialForThenStatement::loop_statement_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 268267
namespace stringify { namespace SgDeclarationStatement {
    const char* template_specialization_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_no_specialization";
            case 2L: return "e_partial_specialization";
            case 3L: return "e_specialization";
            case 4L: return "e_template_specialization_last";
            default: return "";
        }
    }

    std::string template_specialization_enum(int64_t i, const std::string &strip) {
        std::string s = template_specialization_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_specialization_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_template_specialization_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::template_specialization_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::template_specialization_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_template_specialization_enum() {
        return stringify::SgDeclarationStatement::template_specialization_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 268282
namespace stringify { namespace SgDeclarationStatement {
    const char* gnu_extension_visability_attribute_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_visability_unknown";
            case 1L: return "e_gnu_attribute_visability_unspecified";
            case 2L: return "e_gnu_attribute_visability_hidden";
            case 3L: return "e_gnu_attribute_visability_protected";
            case 4L: return "e_gnu_attribute_visability_internal";
            case 5L: return "e_last_gnu_visability_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_visability_attribute_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_visability_attribute_enum(i);
        if (s.empty())
            s = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_visability_attribute_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum(i);
        if (retval.empty()) {
            retval = "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum() {
        return stringify::SgDeclarationStatement::gnu_extension_visability_attribute_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 271318
namespace stringify { namespace SgVariableDeclaration {
    const char* gnu_extension_declaration_attributes_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_gnu_attribute_unknown";
            case 1L: return "e_gnu_attribute_unspecified";
            case 2L: return "e_gnu_attribute__weak__";
            case 3L: return "e_gnu_attribute__unused__";
            case 4L: return "e_gnu_attribute__deprecated__";
            case 5L: return "e_gnu_attribute__nocommon__";
            case 6L: return "e_gnu_attribute__transparent_union__";
            case 7L: return "e_last_gnu_declaration_attribute";
            default: return "";
        }
    }

    std::string gnu_extension_declaration_attributes_enum(int64_t i, const std::string &strip) {
        std::string s = gnu_extension_declaration_attributes_enum(i);
        if (s.empty())
            s = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& gnu_extension_declaration_attributes_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L
        };
        static const std::vector<int64_t> retval(values, values + 8);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum(i);
        if (retval.empty()) {
            retval = "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum() {
        return stringify::SgVariableDeclaration::gnu_extension_declaration_attributes_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 280594
namespace stringify { namespace SgAttributeSpecificationStatement {
    const char* attribute_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_attribute_spec";
            case 1L: return "e_accessStatement_private";
            case 2L: return "e_accessStatement_public";
            case 3L: return "e_allocatableStatement";
            case 4L: return "e_asynchronousStatement";
            case 5L: return "e_bindStatement";
            case 6L: return "e_dataStatement";
            case 7L: return "e_dimensionStatement";
            case 8L: return "e_externalStatement";
            case 9L: return "e_intentStatement";
            case 10L: return "e_intrinsicStatement";
            case 11L: return "e_optionalStatement";
            case 12L: return "e_parameterStatement";
            case 13L: return "e_pointerStatement";
            case 14L: return "e_protectedStatement";
            case 15L: return "e_saveStatement";
            case 16L: return "e_targetStatement";
            case 17L: return "e_valueStatement";
            case 18L: return "e_volatileStatement";
            case 19L: return "e_last_attribute_spec";
            default: return "";
        }
    }

    std::string attribute_spec_enum(int64_t i, const std::string &strip) {
        std::string s = attribute_spec_enum(i);
        if (s.empty())
            s = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& attribute_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L
        };
        static const std::vector<int64_t> retval(values, values + 20);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAttributeSpecificationStatement_attribute_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAttributeSpecificationStatement::attribute_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgAttributeSpecificationStatement::attribute_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAttributeSpecificationStatement_attribute_spec_enum() {
        return stringify::SgAttributeSpecificationStatement::attribute_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 282806
namespace stringify { namespace SgTemplateDeclaration {
    const char* template_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_template_none";
            case 1L: return "e_template_class";
            case 2L: return "e_template_m_class";
            case 3L: return "e_template_function";
            case 4L: return "e_template_m_function";
            case 5L: return "e_template_m_data";
            default: return "";
        }
    }

    std::string template_type_enum(int64_t i, const std::string &strip) {
        std::string s = template_type_enum(i);
        if (s.empty())
            s = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& template_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateDeclaration_template_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateDeclaration::template_type_enum(i);
        if (retval.empty()) {
            retval = "(SgTemplateDeclaration::template_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateDeclaration::template_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateDeclaration_template_type_enum() {
        return stringify::SgTemplateDeclaration::template_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 289242
namespace stringify { namespace SgInterfaceStatement {
    const char* generic_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_error_interface_type";
            case 1L: return "e_default_interface_type";
            case 2L: return "e_unnamed_interface_type";
            case 3L: return "e_named_interface_type";
            case 4L: return "e_operator_interface_type";
            case 5L: return "e_assignment_interface_type";
            case 6L: return "e_last_interface_type";
            default: return "";
        }
    }

    std::string generic_spec_enum(int64_t i, const std::string &strip) {
        std::string s = generic_spec_enum(i);
        if (s.empty())
            s = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& generic_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgInterfaceStatement_generic_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgInterfaceStatement::generic_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgInterfaceStatement::generic_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgInterfaceStatement_generic_spec_enum() {
        return stringify::SgInterfaceStatement::generic_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 300259
namespace stringify { namespace SgClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            case 4L: return "e_fortran_module";
            case 5L: return "e_java_interface";
            case 6L: return "e_java_enum";
            case 7L: return "e_java_parameter";
            case 8L: return "e_jovial_block";
            case 9L: return "e_jovial_table";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgClassDeclaration_class_types() {
        return stringify::SgClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 301744
namespace stringify { namespace SgTemplateClassDeclaration {
    const char* class_types(int64_t i) {
        switch (i) {
            case 0L: return "e_class";
            case 1L: return "e_struct";
            case 2L: return "e_union";
            case 3L: return "e_template_parameter";
            default: return "";
        }
    }

    std::string class_types(int64_t i, const std::string &strip) {
        std::string s = class_types(i);
        if (s.empty())
            s = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& class_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgTemplateClassDeclaration_class_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgTemplateClassDeclaration::class_types(i);
        if (retval.empty()) {
            retval = "(SgTemplateClassDeclaration::class_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgTemplateClassDeclaration::class_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgTemplateClassDeclaration_class_types() {
        return stringify::SgTemplateClassDeclaration::class_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 307028
namespace stringify { namespace SgJovialTableStatement {
    const char* WordsPerEntry(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_fixed_length";
            case 2L: return "e_variable_length";
            default: return "";
        }
    }

    std::string WordsPerEntry(int64_t i, const std::string &strip) {
        std::string s = WordsPerEntry(i);
        if (s.empty())
            s = "(SgJovialTableStatement::WordsPerEntry)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& WordsPerEntry() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialTableStatementWordsPerEntry(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialTableStatement::WordsPerEntry(i);
        if (retval.empty()) {
            retval = "(SgJovialTableStatement::WordsPerEntry)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialTableStatement::WordsPerEntry::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialTableStatementWordsPerEntry() {
        return stringify::SgJovialTableStatement::WordsPerEntry();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 308120
namespace stringify { namespace SgImplicitStatement {
    const char* implicit_spec_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_implicit_spec";
            case 1L: return "e_has_implicit_spec_list";
            case 2L: return "e_none";
            case 3L: return "e_none_external";
            case 4L: return "e_none_type";
            case 5L: return "e_none_external_and_type";
            default: return "";
        }
    }

    std::string implicit_spec_enum(int64_t i, const std::string &strip) {
        std::string s = implicit_spec_enum(i);
        if (s.empty())
            s = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& implicit_spec_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L
        };
        static const std::vector<int64_t> retval(values, values + 6);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImplicitStatement_implicit_spec_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImplicitStatement::implicit_spec_enum(i);
        if (retval.empty()) {
            retval = "(SgImplicitStatement::implicit_spec_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImplicitStatement::implicit_spec_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImplicitStatement_implicit_spec_enum() {
        return stringify::SgImplicitStatement::implicit_spec_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 320936
namespace stringify { namespace SgProcedureHeaderStatement {
    const char* subprogram_kind_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_kind";
            case 1L: return "e_function_subprogram_kind";
            case 2L: return "e_subroutine_subprogram_kind";
            case 3L: return "e_block_data_subprogram_kind";
            case 4L: return "e_last_subprogram_kind";
            default: return "";
        }
    }

    std::string subprogram_kind_enum(int64_t i, const std::string &strip) {
        std::string s = subprogram_kind_enum(i);
        if (s.empty())
            s = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& subprogram_kind_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcedureHeaderStatement_subprogram_kind_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcedureHeaderStatement::subprogram_kind_enum(i);
        if (retval.empty()) {
            retval = "(SgProcedureHeaderStatement::subprogram_kind_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcedureHeaderStatement_subprogram_kind_enum() {
        return stringify::SgProcedureHeaderStatement::subprogram_kind_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 352915
namespace stringify { namespace SgJovialDirectiveStatement {
    const char* directive_types(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_compool";
            case 2L: return "e_copy";
            case 3L: return "e_skip";
            case 4L: return "e_begin";
            case 5L: return "e_end";
            case 6L: return "e_linkage";
            case 7L: return "e_trace";
            case 8L: return "e_interference";
            case 9L: return "e_reducible";
            case 10L: return "e_nolist";
            case 11L: return "e_list";
            case 12L: return "e_eject";
            case 13L: return "e_listinv";
            case 14L: return "e_listexp";
            case 15L: return "e_base";
            case 16L: return "e_isbase";
            case 17L: return "e_drop";
            case 18L: return "e_left_right";
            case 19L: return "e_rearrange";
            case 20L: return "e_initialize";
            case 21L: return "e_order";
            case 22L: return "e_align";
            case 23L: return "e_always";
            default: return "";
        }
    }

    std::string directive_types(int64_t i, const std::string &strip) {
        std::string s = directive_types(i);
        if (s.empty())
            s = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& directive_types() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L
        };
        static const std::vector<int64_t> retval(values, values + 24);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialDirectiveStatement_directive_types(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialDirectiveStatement::directive_types(i);
        if (retval.empty()) {
            retval = "(SgJovialDirectiveStatement::directive_types)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialDirectiveStatement::directive_types::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialDirectiveStatement_directive_types() {
        return stringify::SgJovialDirectiveStatement::directive_types();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 355023
namespace stringify { namespace SgJovialLabelDeclaration {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_jovial_label_decl";
            case 2L: return "e_jovial_label_def";
            case 3L: return "e_jovial_label_ref";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgJovialLabelDeclaration::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgJovialLabelDeclaration_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgJovialLabelDeclaration::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgJovialLabelDeclaration::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgJovialLabelDeclaration::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgJovialLabelDeclaration_label_type_enum() {
        return stringify::SgJovialLabelDeclaration::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 381460
namespace stringify { namespace SgLabelStatement {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_default";
            case 1L: return "e_jovial_label_decl";
            case 2L: return "e_jovial_label_def";
            case 3L: return "e_jovial_label_ref";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelStatement::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L
        };
        static const std::vector<int64_t> retval(values, values + 4);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelStatement_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelStatement::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelStatement::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelStatement::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelStatement_label_type_enum() {
        return stringify::SgLabelStatement::label_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 395292
namespace stringify { namespace SgProcessControlStatement {
    const char* control_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_abort";
            case 2L: return "e_stop";
            case 3L: return "e_error_stop";
            case 4L: return "e_exit";
            case 5L: return "e_fail_image";
            case 6L: return "e_pause";
            case 7L: return "e_requeue";
            case 8L: return "e_requeue_with_abort";
            default: return "";
        }
    }

    std::string control_enum(int64_t i, const std::string &strip) {
        std::string s = control_enum(i);
        if (s.empty())
            s = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& control_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L
        };
        static const std::vector<int64_t> retval(values, values + 9);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgProcessControlStatement_control_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgProcessControlStatement::control_enum(i);
        if (retval.empty()) {
            retval = "(SgProcessControlStatement::control_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgProcessControlStatement::control_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgProcessControlStatement_control_enum() {
        return stringify::SgProcessControlStatement::control_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 396377
namespace stringify { namespace SgIOStatement {
    const char* io_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_read";
            case 2L: return "e_print";
            case 3L: return "e_write";
            case 4L: return "e_open";
            case 5L: return "e_close";
            case 6L: return "e_inquire";
            case 7L: return "e_backspace";
            case 8L: return "e_endfile";
            case 9L: return "e_rewind";
            case 10L: return "e_last_io_statment_kind";
            default: return "";
        }
    }

    std::string io_statement_enum(int64_t i, const std::string &strip) {
        std::string s = io_statement_enum(i);
        if (s.empty())
            s = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& io_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 11);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgIOStatement_io_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgIOStatement::io_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgIOStatement::io_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgIOStatement::io_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgIOStatement_io_statement_enum() {
        return stringify::SgIOStatement::io_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 458960
namespace stringify { namespace SgImageControlStatement {
    const char* image_control_statement_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_sync_all";
            case 2L: return "e_sync_images";
            case 3L: return "e_sync_memory";
            case 4L: return "e_sync_team";
            case 5L: return "e_change_team";
            case 6L: return "e_critical";
            case 7L: return "e_event_post";
            case 8L: return "e_event_wait";
            case 9L: return "e_form_team";
            case 10L: return "e_lock";
            case 11L: return "e_unlock";
            case 12L: return "e_last_image_control_statement";
            default: return "";
        }
    }

    std::string image_control_statement_enum(int64_t i, const std::string &strip) {
        std::string s = image_control_statement_enum(i);
        if (s.empty())
            s = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& image_control_statement_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L
        };
        static const std::vector<int64_t> retval(values, values + 13);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgImageControlStatement_image_control_statement_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgImageControlStatement::image_control_statement_enum(i);
        if (retval.empty()) {
            retval = "(SgImageControlStatement::image_control_statement_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgImageControlStatement::image_control_statement_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgImageControlStatement_image_control_statement_enum() {
        return stringify::SgImageControlStatement::image_control_statement_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 469330
namespace stringify { namespace SgAdaSelectStmt {
    const char* select_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_selective_accept";
            case 2L: return "e_asynchronous";
            case 3L: return "e_conditional_entry";
            case 4L: return "e_timed_entry";
            default: return "";
        }
    }

    std::string select_type_enum(int64_t i, const std::string &strip) {
        std::string s = select_type_enum(i);
        if (s.empty())
            s = "(SgAdaSelectStmt::select_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& select_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L
        };
        static const std::vector<int64_t> retval(values, values + 5);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAdaSelectStmt_select_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAdaSelectStmt::select_type_enum(i);
        if (retval.empty()) {
            retval = "(SgAdaSelectStmt::select_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAdaSelectStmt::select_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAdaSelectStmt_select_type_enum() {
        return stringify::SgAdaSelectStmt::select_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 475810
namespace stringify { namespace SgUnaryOp {
    const char* Sgop_mode(int64_t i) {
        switch (i) {
            case 0L: return "prefix";
            case 1L: return "postfix";
            default: return "";
        }
    }

    std::string Sgop_mode(int64_t i, const std::string &strip) {
        std::string s = Sgop_mode(i);
        if (s.empty())
            s = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& Sgop_mode() {
        static const int64_t values[] = {
            0L,
            1L
        };
        static const std::vector<int64_t> retval(values, values + 2);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgUnaryOpSgop_mode(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgUnaryOp::Sgop_mode(i);
        if (retval.empty()) {
            retval = "(SgUnaryOp::Sgop_mode)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgUnaryOp::Sgop_mode::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgUnaryOpSgop_mode() {
        return stringify::SgUnaryOp::Sgop_mode();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 485906
namespace stringify { namespace SgCastExp {
    const char* cast_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_default";
            case 2L: return "e_C_style_cast";
            case 3L: return "e_const_cast";
            case 4L: return "e_static_cast";
            case 5L: return "e_dynamic_cast";
            case 6L: return "e_reinterpret_cast";
            case 8L: return "e_safe_cast";
            case 9L: return "e_ada_type_qualification";
            case 10L: return "e_last_cast";
            default: return "";
        }
    }

    std::string cast_type_enum(int64_t i, const std::string &strip) {
        std::string s = cast_type_enum(i);
        if (s.empty())
            s = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& cast_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            8L,
            9L,
            10L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgCastExp_cast_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgCastExp::cast_type_enum(i);
        if (retval.empty()) {
            retval = "(SgCastExp::cast_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgCastExp::cast_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgCastExp_cast_type_enum() {
        return stringify::SgCastExp::cast_type_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 487171
namespace stringify { namespace SgThrowOp {
    const char* e_throw_kind(int64_t i) {
        switch (i) {
            case 0L: return "unknown_throw";
            case 1L: return "throw_expression";
            case 2L: return "rethrow";
            default: return "";
        }
    }

    std::string e_throw_kind(int64_t i, const std::string &strip) {
        std::string s = e_throw_kind(i);
        if (s.empty())
            s = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& e_throw_kind() {
        static const int64_t values[] = {
            0L,
            1L,
            2L
        };
        static const std::vector<int64_t> retval(values, values + 3);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgThrowOp_e_throw_kind(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgThrowOp::e_throw_kind(i);
        if (retval.empty()) {
            retval = "(SgThrowOp::e_throw_kind)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgThrowOp::e_throw_kind::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgThrowOp_e_throw_kind() {
        return stringify::SgThrowOp::e_throw_kind();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 637966
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_modifier_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown";
            case 1L: return "e_input";
            case 2L: return "e_output";
            case 3L: return "e_modify";
            case 4L: return "e_earlyclobber";
            case 8L: return "e_commutative";
            case 16L: return "e_ignore_next";
            case 32L: return "e_ignore_till_comma";
            case 64L: return "e_poor_choice";
            case 128L: return "e_bad_choice";
            default: return "";
        }
    }

    std::string asm_operand_modifier_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_modifier_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_modifier_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            8L,
            16L,
            32L,
            64L,
            128L
        };
        static const std::vector<int64_t> retval(values, values + 10);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_modifier_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_modifier_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_modifier_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_modifier_enum() {
        return stringify::SgAsmOp::asm_operand_modifier_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 637985
namespace stringify { namespace SgAsmOp {
    const char* asm_operand_constraint_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_invalid";
            case 1L: return "e_end_of_constraint";
            case 2L: return "e_mod_earlyclobber";
            case 3L: return "e_mod_commutative_ops";
            case 4L: return "e_mod_ignore";
            case 5L: return "e_mod_ignore_char";
            case 6L: return "e_mod_disparage_slightly";
            case 7L: return "e_mod_disparage_severely";
            case 8L: return "e_any";
            case 9L: return "e_general";
            case 10L: return "e_match_0";
            case 11L: return "e_match_1";
            case 12L: return "e_match_2";
            case 13L: return "e_match_3";
            case 14L: return "e_match_4";
            case 15L: return "e_match_5";
            case 16L: return "e_match_6";
            case 17L: return "e_match_7";
            case 18L: return "e_match_8";
            case 19L: return "e_match_9";
            case 20L: return "e_reg_integer";
            case 21L: return "e_reg_float";
            case 22L: return "e_mem_any";
            case 23L: return "e_mem_load";
            case 24L: return "e_mem_offset";
            case 25L: return "e_mem_nonoffset";
            case 26L: return "e_mem_autoinc";
            case 27L: return "e_mem_autodec";
            case 28L: return "e_imm_int";
            case 29L: return "e_imm_number";
            case 30L: return "e_imm_symbol";
            case 31L: return "e_imm_float";
            case 32L: return "e_reg_a";
            case 33L: return "e_reg_b";
            case 34L: return "e_reg_c";
            case 35L: return "e_reg_d";
            case 36L: return "e_reg_si";
            case 37L: return "e_reg_di";
            case 38L: return "e_reg_legacy";
            case 39L: return "e_reg_q";
            case 40L: return "e_reg_Q";
            case 41L: return "e_reg_ad";
            case 42L: return "e_reg_float_tos";
            case 43L: return "e_reg_float_second";
            case 44L: return "e_reg_sse";
            case 45L: return "e_reg_sse2";
            case 46L: return "e_reg_mmx";
            case 47L: return "e_imm_short_shift";
            case 48L: return "e_imm_long_shift";
            case 49L: return "e_imm_lea_shift";
            case 50L: return "e_imm_signed8";
            case 51L: return "e_imm_unsigned8";
            case 52L: return "e_imm_and_zext";
            case 53L: return "e_imm_80387";
            case 54L: return "e_imm_sse";
            case 55L: return "e_imm_sext32";
            case 56L: return "e_imm_zext32";
            case 57L: return "e_last";
            default: return "";
        }
    }

    std::string asm_operand_constraint_enum(int64_t i, const std::string &strip) {
        std::string s = asm_operand_constraint_enum(i);
        if (s.empty())
            s = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& asm_operand_constraint_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L,
            7L,
            8L,
            9L,
            10L,
            11L,
            12L,
            13L,
            14L,
            15L,
            16L,
            17L,
            18L,
            19L,
            20L,
            21L,
            22L,
            23L,
            24L,
            25L,
            26L,
            27L,
            28L,
            29L,
            30L,
            31L,
            32L,
            33L,
            34L,
            35L,
            36L,
            37L,
            38L,
            39L,
            40L,
            41L,
            42L,
            43L,
            44L,
            45L,
            46L,
            47L,
            48L,
            49L,
            50L,
            51L,
            52L,
            53L,
            54L,
            55L,
            56L,
            57L
        };
        static const std::vector<int64_t> retval(values, values + 58);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgAsmOp_asm_operand_constraint_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgAsmOp::asm_operand_constraint_enum(i);
        if (retval.empty()) {
            retval = "(SgAsmOp::asm_operand_constraint_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgAsmOp_asm_operand_constraint_enum() {
        return stringify::SgAsmOp::asm_operand_constraint_enum();
    }
}

// DO NOT EDIT -- This implementation was automatically generated for the enum defined at
// /Users/rasmussen17/ROSE/build-rose-develop/src/frontend/SageIII/Cxx_Grammar.h line 709432
namespace stringify { namespace SgLabelSymbol {
    const char* label_type_enum(int64_t i) {
        switch (i) {
            case 0L: return "e_unknown_label_type";
            case 1L: return "e_non_numeric_label_type";
            case 2L: return "e_start_label_type";
            case 3L: return "e_else_label_type";
            case 4L: return "e_end_label_type";
            case 5L: return "e_alternative_return_type";
            case 6L: return "e_last_label_type";
            default: return "";
        }
    }

    std::string label_type_enum(int64_t i, const std::string &strip) {
        std::string s = label_type_enum(i);
        if (s.empty())
            s = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        if (boost::starts_with(s, strip))
            s = s.substr(strip.size());
        return s;
    }

    const std::vector<int64_t>& label_type_enum() {
        static const int64_t values[] = {
            0L,
            1L,
            2L,
            3L,
            4L,
            5L,
            6L
        };
        static const std::vector<int64_t> retval(values, values + 7);
        return retval;
    }

}}

namespace Rose {
    std::string stringifySgLabelSymbol_label_type_enum(int64_t i, const char *strip, bool canonic) {
        std::string retval = stringify::SgLabelSymbol::label_type_enum(i);
        if (retval.empty()) {
            retval = "(SgLabelSymbol::label_type_enum)" + boost::lexical_cast<std::string>(i);
        } else {
            if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
                retval = retval.substr(strlen(strip));
            if (canonic)
                retval = "SgLabelSymbol::label_type_enum::" + retval;
        }
        return retval;
    }

    const std::vector<int64_t>& stringifySgLabelSymbol_label_type_enum() {
        return stringify::SgLabelSymbol::label_type_enum();
    }
}

