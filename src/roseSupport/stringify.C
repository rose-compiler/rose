// DO NOT EDIT -- This file was generated by /home/dquinlan/ROSE/git_rose_development/scripts/stringify.pl.

#include "stringify.h"
#include <cassert>
#include <cstdio>
#include <cstring>

namespace rose {

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AST_Graph::pointerHandling is defined at git_rose_development/src/frontend/SageIII/astVisualization/astGraph.h:13
/** Converts an enum of type AST_Graph::pointerHandling to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_pointerHandling(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "graph_NULL"; break;
        case 1: retval = "do_not_graph_NULL"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AST_Graph::pointerHandling)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::pointerHandling::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AST_Graph::traversalType is defined at git_rose_development/src/frontend/SageIII/astVisualization/astGraph.h:20
/** Converts an enum of type AST_Graph::traversalType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAST_Graph_traversalType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "memory_pool_traversal"; break;
        case 1: retval = "whole_graph_AST"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AST_Graph::traversalType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AST_Graph::traversalType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AbstractMemoryObject::IndexSet::Index_type is defined at git_rose_development/src/midend/abstractMemoryObject/memory_object_impl.h:84
/** Converts an enum of type AbstractMemoryObject::IndexSet::Index_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAbstractMemoryObjectIndexSetIndex_type(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Integer_type"; break;
        case 1: retval = "Unknown_type"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AbstractMemoryObject::IndexSet::Index_type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AbstractMemoryObject::IndexSet::Index_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmInstructionCondition is defined at git_rose_development/src/frontend/Disassemblers/armInstructionEnum.h:124
/** Converts an enum of type ArmInstructionCondition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionCondition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_cond_unknown"; break;
        case 1: retval = "arm_cond_eq"; break;
        case 2: retval = "arm_cond_ne"; break;
        case 3: retval = "arm_cond_hs"; break;
        case 4: retval = "arm_cond_lo"; break;
        case 5: retval = "arm_cond_mi"; break;
        case 6: retval = "arm_cond_pl"; break;
        case 7: retval = "arm_cond_vs"; break;
        case 8: retval = "arm_cond_vc"; break;
        case 9: retval = "arm_cond_hi"; break;
        case 10: retval = "arm_cond_ls"; break;
        case 11: retval = "arm_cond_ge"; break;
        case 12: retval = "arm_cond_lt"; break;
        case 13: retval = "arm_cond_gt"; break;
        case 14: retval = "arm_cond_le"; break;
        case 15: retval = "arm_cond_al"; break;
        case 16: retval = "arm_cond_nv"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ArmInstructionCondition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionCondition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmInstructionKind is defined at git_rose_development/src/frontend/Disassemblers/armInstructionEnum.h:19
/** Converts an enum of type ArmInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_unknown_instruction"; break;
        case 1: retval = "arm_adc"; break;
        case 2: retval = "arm_adcs"; break;
        case 3: retval = "arm_add"; break;
        case 4: retval = "arm_adds"; break;
        case 5: retval = "arm_and"; break;
        case 6: retval = "arm_ands"; break;
        case 7: retval = "arm_b"; break;
        case 8: retval = "arm_bic"; break;
        case 9: retval = "arm_bics"; break;
        case 10: retval = "arm_bkpt"; break;
        case 11: retval = "arm_bl"; break;
        case 12: retval = "arm_blx"; break;
        case 13: retval = "arm_bx"; break;
        case 14: retval = "arm_bxj"; break;
        case 15: retval = "arm_clz"; break;
        case 16: retval = "arm_cmn"; break;
        case 17: retval = "arm_cmp"; break;
        case 18: retval = "arm_eor"; break;
        case 19: retval = "arm_eors"; break;
        case 20: retval = "arm_ldm"; break;
        case 21: retval = "arm_ldmda"; break;
        case 22: retval = "arm_ldmdb"; break;
        case 23: retval = "arm_ldmia"; break;
        case 24: retval = "arm_ldmib"; break;
        case 25: retval = "arm_ldr"; break;
        case 26: retval = "arm_ldrb"; break;
        case 27: retval = "arm_ldrbt"; break;
        case 28: retval = "arm_ldrd"; break;
        case 29: retval = "arm_ldrsb"; break;
        case 30: retval = "arm_ldrsh"; break;
        case 31: retval = "arm_ldrt"; break;
        case 32: retval = "arm_ldruh"; break;
        case 33: retval = "arm_mla"; break;
        case 34: retval = "arm_mlas"; break;
        case 35: retval = "arm_mov"; break;
        case 36: retval = "arm_movs"; break;
        case 37: retval = "arm_mrs"; break;
        case 38: retval = "arm_msr"; break;
        case 39: retval = "arm_mul"; break;
        case 40: retval = "arm_muls"; break;
        case 41: retval = "arm_mvn"; break;
        case 42: retval = "arm_mvns"; break;
        case 43: retval = "arm_orr"; break;
        case 44: retval = "arm_orrs"; break;
        case 45: retval = "arm_qadd"; break;
        case 46: retval = "arm_qdadd"; break;
        case 47: retval = "arm_qdsub"; break;
        case 48: retval = "arm_qsub"; break;
        case 49: retval = "arm_rsb"; break;
        case 50: retval = "arm_rsbs"; break;
        case 51: retval = "arm_rsc"; break;
        case 52: retval = "arm_rscs"; break;
        case 53: retval = "arm_sbc"; break;
        case 54: retval = "arm_sbcs"; break;
        case 55: retval = "arm_setend"; break;
        case 56: retval = "arm_smlabb"; break;
        case 57: retval = "arm_smlabt"; break;
        case 58: retval = "arm_smlal"; break;
        case 59: retval = "arm_smlalbb"; break;
        case 60: retval = "arm_smlalbt"; break;
        case 61: retval = "arm_smlals"; break;
        case 62: retval = "arm_smlaltb"; break;
        case 63: retval = "arm_smlaltt"; break;
        case 64: retval = "arm_smlatb"; break;
        case 65: retval = "arm_smlatt"; break;
        case 66: retval = "arm_smlawb"; break;
        case 67: retval = "arm_smlawt"; break;
        case 68: retval = "arm_smluwb"; break;
        case 69: retval = "arm_smluwt"; break;
        case 70: retval = "arm_smulbb"; break;
        case 71: retval = "arm_smulbt"; break;
        case 72: retval = "arm_smull"; break;
        case 73: retval = "arm_smulls"; break;
        case 74: retval = "arm_smultb"; break;
        case 75: retval = "arm_smultt"; break;
        case 76: retval = "arm_stm"; break;
        case 77: retval = "arm_stmda"; break;
        case 78: retval = "arm_stmdb"; break;
        case 79: retval = "arm_stmia"; break;
        case 80: retval = "arm_stmib"; break;
        case 81: retval = "arm_str"; break;
        case 82: retval = "arm_strb"; break;
        case 83: retval = "arm_strbt"; break;
        case 84: retval = "arm_strd"; break;
        case 85: retval = "arm_strh"; break;
        case 86: retval = "arm_strt"; break;
        case 87: retval = "arm_sub"; break;
        case 88: retval = "arm_subs"; break;
        case 89: retval = "arm_swi"; break;
        case 90: retval = "arm_swp"; break;
        case 91: retval = "arm_teq"; break;
        case 92: retval = "arm_tst"; break;
        case 93: retval = "arm_umaal"; break;
        case 94: retval = "arm_umlal"; break;
        case 95: retval = "arm_umlals"; break;
        case 96: retval = "arm_umull"; break;
        case 97: retval = "arm_umulls"; break;
        case 98: retval = "arm_undefined"; break;
        case 99: retval = "arm_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ArmInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmProgramStatusRegister is defined at git_rose_development/src/frontend/Disassemblers/armInstructionEnum.h:13
/** Converts an enum of type ArmProgramStatusRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmProgramStatusRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_psr_current"; break;
        case 1: retval = "arm_psr_saved"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ArmProgramStatusRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmProgramStatusRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmRegisterClass is defined at git_rose_development/src/frontend/Disassemblers/armInstructionEnum.h:7
/** Converts an enum of type ArmRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_regclass_gpr"; break;
        case 1: retval = "arm_regclass_psr"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ArmRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ArmSignForExpressionUnparsing is defined at git_rose_development/src/backend/asmUnparser/AsmUnparser_compat.h:45
/** Converts an enum of type ArmSignForExpressionUnparsing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyArmSignForExpressionUnparsing(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "arm_sign_none"; break;
        case 1: retval = "arm_sign_plus"; break;
        case 2: retval = "arm_sign_minus"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ArmSignForExpressionUnparsing)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ArmSignForExpressionUnparsing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Assembler::EncodingType is defined at git_rose_development/src/frontend/Disassemblers/Assembler.h:72
/** Converts an enum of type Assembler::EncodingType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerEncodingType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ET_SHORTEST"; break;
        case 1: retval = "ET_LONGEST"; break;
        case 2: retval = "ET_MATCHES"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Assembler::EncodingType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Assembler::EncodingType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssemblerX86::MemoryReferencePattern is defined at git_rose_development/src/frontend/Disassemblers/AssemblerX86.h:383
/** Converts an enum of type AssemblerX86::MemoryReferencePattern to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86MemoryReferencePattern(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mrp_unknown"; break;
        case 1: retval = "mrp_disp"; break;
        case 2: retval = "mrp_index"; break;
        case 3: retval = "mrp_index_disp"; break;
        case 4: retval = "mrp_base"; break;
        case 5: retval = "mrp_base_disp"; break;
        case 6: retval = "mrp_base_index"; break;
        case 7: retval = "mrp_base_index_disp"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AssemblerX86::MemoryReferencePattern)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::MemoryReferencePattern::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssemblerX86::OperandDefn is defined at git_rose_development/src/frontend/Disassemblers/AssemblerX86.h:142
/** Converts an enum of type AssemblerX86::OperandDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssemblerX86OperandDefn(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "od_none"; break;
        case 1: retval = "od_AL"; break;
        case 2: retval = "od_AX"; break;
        case 3: retval = "od_EAX"; break;
        case 4: retval = "od_RAX"; break;
        case 5: retval = "od_DX"; break;
        case 6: retval = "od_CS"; break;
        case 7: retval = "od_DS"; break;
        case 8: retval = "od_ES"; break;
        case 9: retval = "od_FS"; break;
        case 10: retval = "od_GS"; break;
        case 11: retval = "od_SS"; break;
        case 12: retval = "od_rel8"; break;
        case 13: retval = "od_rel16"; break;
        case 14: retval = "od_rel32"; break;
        case 15: retval = "od_rel64"; break;
        case 16: retval = "od_ptr16_16"; break;
        case 17: retval = "od_ptr16_32"; break;
        case 18: retval = "od_ptr16_64"; break;
        case 19: retval = "od_r8"; break;
        case 20: retval = "od_r16"; break;
        case 21: retval = "od_r32"; break;
        case 22: retval = "od_r64"; break;
        case 23: retval = "od_imm8"; break;
        case 24: retval = "od_imm16"; break;
        case 25: retval = "od_imm32"; break;
        case 26: retval = "od_imm64"; break;
        case 27: retval = "od_r_m8"; break;
        case 28: retval = "od_r_m16"; break;
        case 29: retval = "od_r_m32"; break;
        case 30: retval = "od_r_m64"; break;
        case 31: retval = "od_m"; break;
        case 32: retval = "od_m8"; break;
        case 33: retval = "od_m16"; break;
        case 34: retval = "od_m32"; break;
        case 35: retval = "od_m64"; break;
        case 36: retval = "od_m128"; break;
        case 37: retval = "od_m16_16"; break;
        case 38: retval = "od_m16_32"; break;
        case 39: retval = "od_m16_64"; break;
        case 40: retval = "od_m16a16"; break;
        case 41: retval = "od_m16a32"; break;
        case 42: retval = "od_m32a32"; break;
        case 43: retval = "od_m16a64"; break;
        case 44: retval = "od_moffs8"; break;
        case 45: retval = "od_moffs16"; break;
        case 46: retval = "od_moffs32"; break;
        case 47: retval = "od_moffs64"; break;
        case 48: retval = "od_sreg"; break;
        case 49: retval = "od_m32fp"; break;
        case 50: retval = "od_m64fp"; break;
        case 51: retval = "od_m80fp"; break;
        case 52: retval = "od_st0"; break;
        case 53: retval = "od_st1"; break;
        case 54: retval = "od_st2"; break;
        case 55: retval = "od_st3"; break;
        case 56: retval = "od_st4"; break;
        case 57: retval = "od_st5"; break;
        case 58: retval = "od_st6"; break;
        case 59: retval = "od_st7"; break;
        case 60: retval = "od_sti"; break;
        case 61: retval = "od_mm"; break;
        case 62: retval = "od_mm_m32"; break;
        case 63: retval = "od_mm_m64"; break;
        case 64: retval = "od_xmm"; break;
        case 65: retval = "od_xmm_m16"; break;
        case 66: retval = "od_xmm_m32"; break;
        case 67: retval = "od_xmm_m64"; break;
        case 68: retval = "od_xmm_m128"; break;
        case 69: retval = "od_XMM0"; break;
        case 70: retval = "od_0"; break;
        case 71: retval = "od_1"; break;
        case 72: retval = "od_m80"; break;
        case 73: retval = "od_dec"; break;
        case 74: retval = "od_m80bcd"; break;
        case 75: retval = "od_m2byte"; break;
        case 76: retval = "od_m14_28byte"; break;
        case 77: retval = "od_m94_108byte"; break;
        case 78: retval = "od_m512byte"; break;
        case 79: retval = "od_r16_m16"; break;
        case 80: retval = "od_r32_m8"; break;
        case 81: retval = "od_r32_m16"; break;
        case 82: retval = "od_r64_m16"; break;
        case 83: retval = "od_CR0"; break;
        case 84: retval = "od_CR7"; break;
        case 85: retval = "od_CR8"; break;
        case 86: retval = "od_CR0CR7"; break;
        case 87: retval = "od_DR0DR7"; break;
        case 88: retval = "od_reg"; break;
        case 89: retval = "od_CL"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AssemblerX86::OperandDefn)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssemblerX86::OperandDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AssociativitySpecifier is defined at git_rose_development/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:17
/** Converts an enum of type AssociativitySpecifier to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAssociativitySpecifier(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_assoc_none"; break;
        case 1: retval = "e_assoc_right"; break;
        case 2: retval = "e_assoc_left"; break;
        case 3: retval = "e_assoc_last"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AssociativitySpecifier)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AssociativitySpecifier::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstAttribute::OwnershipPolicy is defined at git_rose_development/src/midend/astProcessing/AstAttributeMechanism.h:42
/** Converts an enum of type AstAttribute::OwnershipPolicy to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstAttributeOwnershipPolicy(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTAINER_OWNERSHIP"; break;
        case 1: retval = "NO_OWNERSHIP"; break;
        case 2: retval = "CUSTOM_OWNERSHIP"; break;
        case 3: retval = "UNKNOWN_OWNERSHIP"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AstAttribute::OwnershipPolicy)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstAttribute::OwnershipPolicy::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstAttributeDOT::DOTStyles is defined at git_rose_development/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:22
/** Converts an enum of type AstAttributeDOT::DOTStyles to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstAttributeDOT_DOTStyles(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementDOTStyles"; break;
        case 1: retval = "filled"; break;
        case 2: retval = "not_filled"; break;
        case 3: retval = "END_OF_NODE_TYPE_LIST_DOTStyles"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AstAttributeDOT::DOTStyles)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstAttributeDOT::DOTStyles::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstDisplayInfo::NodeType is defined at git_rose_development/src/roseExtensions/qtWidgets/util/AstDisplayInfo.h:15
/** Converts an enum of type AstDisplayInfo::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstDisplayInfoNodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ROOT"; break;
        case 1: retval = "INCLUDE_ROOT"; break;
        case 2: retval = "SRC_FILE"; break;
        case 3: retval = "INCLUDE_FILE"; break;
        case 4: retval = "NAMESPACE"; break;
        case 5: retval = "CLASS"; break;
        case 6: retval = "FUNCTION"; break;
        case 7: retval = "LOOP"; break;
        case 8: retval = "UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AstDisplayInfo::NodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstDisplayInfo::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstQueryNamespace::QueryDepth is defined at git_rose_development/src/midend/astQuery/astQuery.h:97
/** Converts an enum of type AstQueryNamespace::QueryDepth to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstQueryNamespaceQueryDepth(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeQueryDepth"; break;
        case 1: retval = "ChildrenOnly"; break;
        case 2: retval = "AllNodes"; break;
        case 3: retval = "ExtractTypes"; break;
        case 4: retval = "END_OF_NODE_TYPE_LIST_QUERY_DEPTH"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AstQueryNamespace::QueryDepth)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstQueryNamespace::QueryDepth::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// AstUnparseAttribute::RelativePositionType is defined at git_rose_development/src/backend/unparser/astUnparseAttribute.h:34
/** Converts an enum of type AstUnparseAttribute::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyAstUnparseAttributeRelativePositionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_defaultValue"; break;
        case 1: retval = "e_undef"; break;
        case 2: retval = "e_before"; break;
        case 3: retval = "e_after"; break;
        case 4: retval = "e_inside"; break;
        case 5: retval = "e_replace"; break;
        case 6: retval = "e_before_syntax"; break;
        case 7: retval = "e_after_syntax"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(AstUnparseAttribute::RelativePositionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "AstUnparseAttribute::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BaseGraph::BiDirNodesIterator::dirType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/Utils/BaseGraph.h:261
/** Converts an enum of type BaseGraph::BiDirNodesIterator::dirType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBaseGraphBiDirNodesIterator_dirType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Forward"; break;
        case 1: retval = "Reverse"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BaseGraph::BiDirNodesIterator::dirType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BaseGraph::BiDirNodesIterator::dirType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::AsmUnparser::Organization is defined at git_rose_development/src/backend/asmUnparser/AsmUnparser.h:251
/** Converts an enum of type BinaryAnalysis::AsmUnparser::Organization to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisAsmUnparserOrganization(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ORGANIZED_BY_AST"; break;
        case 1: retval = "ORGANIZED_BY_ADDRESS"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::AsmUnparser::Organization)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::AsmUnparser::Organization::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::BinaryDebugger::DetachMode is defined at git_rose_development/src/frontend/Disassemblers/BinaryDebugger.h:14
/** Converts an enum of type BinaryAnalysis::BinaryDebugger::DetachMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisBinaryDebuggerDetachMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "KILL"; break;
        case 1: retval = "DETACH"; break;
        case 2: retval = "CONTINUE"; break;
        case 3: retval = "NOTHING"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::BinaryDebugger::DetachMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::BinaryDebugger::DetachMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::BinaryDebugger::RegPageStatus is defined at git_rose_development/src/frontend/Disassemblers/BinaryDebugger.h:17
/** Converts an enum of type BinaryAnalysis::BinaryDebugger::RegPageStatus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisBinaryDebuggerRegPageStatus(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "REGPAGE_NONE"; break;
        case 1: retval = "REGPAGE_REGS"; break;
        case 2: retval = "REGPAGE_FPREGS"; break;
    }
    if (retval.empty()) {
        char buf[109];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::BinaryDebugger::RegPageStatus)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::BinaryDebugger::RegPageStatus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::ParameterLocation::Type is defined at git_rose_development/src/midend/binaryAnalyses/BinaryCallingConvention.h:81
/** Converts an enum of type BinaryAnalysis::CallingConvention::ParameterLocation::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionParameterLocationType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_LOCATION"; break;
        case 1: retval = "REGISTER"; break;
        case 2: retval = "STACK"; break;
        case 3: retval = "ABSOLUTE"; break;
    }
    if (retval.empty()) {
        char buf[122];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::CallingConvention::ParameterLocation::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::ParameterLocation::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackCleanup is defined at git_rose_development/src/midend/binaryAnalyses/BinaryCallingConvention.h:58
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackCleanup to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackCleanup(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CLEANUP_BY_CALLER"; break;
        case 1: retval = "CLEANUP_BY_CALLEE"; break;
        case 2: retval = "CLEANUP_UNSPECIFIED"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::CallingConvention::StackCleanup)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackCleanup::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackDirection is defined at git_rose_development/src/midend/binaryAnalyses/BinaryCallingConvention.h:52
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "GROWS_UP"; break;
        case 1: retval = "GROWS_DOWN"; break;
    }
    if (retval.empty()) {
        char buf[113];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::CallingConvention::StackDirection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::CallingConvention::StackParameterOrder is defined at git_rose_development/src/midend/binaryAnalyses/BinaryCallingConvention.h:45
/** Converts an enum of type BinaryAnalysis::CallingConvention::StackParameterOrder to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisCallingConventionStackParameterOrder(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LEFT_TO_RIGHT"; break;
        case 1: retval = "RIGHT_TO_LEFT"; break;
        case 2: retval = "ORDER_UNSPECIFIED"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::CallingConvention::StackParameterOrder)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::CallingConvention::StackParameterOrder::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Disassembler::SearchHeuristic is defined at git_rose_development/src/frontend/Disassemblers/Disassembler.h:162
/** Converts an enum of type BinaryAnalysis::Disassembler::SearchHeuristic to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerSearchHeuristic(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "SEARCH_FOLLOWING"; break;
        case 2: retval = "SEARCH_IMMEDIATE"; break;
        case 4: retval = "SEARCH_WORDS"; break;
        case 8: retval = "SEARCH_ALLBYTES"; break;
        case 16: retval = "SEARCH_UNUSED"; break;
        case 32: retval = "SEARCH_NONEXE"; break;
        case 64: retval = "SEARCH_DEADEND"; break;
        case 128: retval = "SEARCH_UNKNOWN"; break;
        case 256: retval = "SEARCH_FUNCSYMS"; break;
        case 257: retval = "SEARCH_DEFAULT"; break;
    }
    if (retval.empty()) {
        char buf[109];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Disassembler::SearchHeuristic)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Disassembler::SearchHeuristic::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerMips::Mips32::Architecture is defined at git_rose_development/src/frontend/Disassemblers/DisassemblerMips.h:32
/** Converts an enum of type BinaryAnalysis::DisassemblerMips::Mips32::Architecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerMipsMips32Architecture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Release1"; break;
        case 1: retval = "Release2"; break;
        case 2: retval = "Release3"; break;
        case 3: retval = "Micro"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::DisassemblerMips::Mips32::Architecture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerMips::Mips32::Architecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerX86::MMPrefix is defined at git_rose_development/src/frontend/Disassemblers/DisassemblerX86.h:71
/** Converts an enum of type BinaryAnalysis::DisassemblerX86::MMPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerX86MMPrefix(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mmNone"; break;
        case 1: retval = "mmF3"; break;
        case 2: retval = "mm66"; break;
        case 3: retval = "mmF2"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::DisassemblerX86::MMPrefix)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerX86::MMPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DisassemblerX86::RegisterMode is defined at git_rose_development/src/frontend/Disassemblers/DisassemblerX86.h:65
/** Converts an enum of type BinaryAnalysis::DisassemblerX86::RegisterMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDisassemblerX86RegisterMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "rmLegacyByte"; break;
        case 1: retval = "rmRexByte"; break;
        case 2: retval = "rmWord"; break;
        case 3: retval = "rmDWord"; break;
        case 4: retval = "rmQWord"; break;
        case 5: retval = "rmSegment"; break;
        case 6: retval = "rmST"; break;
        case 7: retval = "rmMM"; break;
        case 8: retval = "rmXMM"; break;
        case 9: retval = "rmControl"; break;
        case 10: retval = "rmDebug"; break;
        case 11: retval = "rmReturnNull"; break;
    }
    if (retval.empty()) {
        char buf[109];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::DisassemblerX86::RegisterMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DisassemblerX86::RegisterMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::DwarfLineMapper::Direction is defined at git_rose_development/src/midend/binaryAnalyses/DwarfLineMapper.h:16
/** Converts an enum of type BinaryAnalysis::DwarfLineMapper::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisDwarfLineMapperDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "ADDR2SRC"; break;
        case 2: retval = "SRC2ADDR"; break;
        case 3: retval = "BIDIRECTIONAL"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::DwarfLineMapper::Direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::DwarfLineMapper::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/BaseSemantics2.h:430
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2BaseSemanticsInputOutputProperty(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "IO_READ"; break;
        case 1: retval = "IO_WRITE"; break;
        case 2: retval = "IO_INIT"; break;
        case 3: retval = "IO_READ_BEFORE_WRITE"; break;
        case 4: retval = "IO_READ_AFTER_WRITE"; break;
        case 5: retval = "IO_READ_UNINITIALIZED"; break;
    }
    if (retval.empty()) {
        char buf[137];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::BaseSemantics::InputOutputProperty::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/DataFlowSemantics2.h:35
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2DataFlowSemanticsDataFlowEdgeEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CLOBBER"; break;
        case 1: retval = "AUGMENT"; break;
    }
    if (retval.empty()) {
        char buf[144];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::DataFlowSemantics::DataFlowEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/IntervalSemantics2.C:583
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2IntervalSemanticsCarry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "C_FALSE"; break;
        case 1: retval = "C_TRUE"; break;
        case 2: retval = "C_UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[127];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::IntervalSemantics::Carry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/SymbolicSemantics2.h:690
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsDefinersMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TRACK_NO_DEFINERS"; break;
        case 1: retval = "TRACK_LATEST_DEFINER"; break;
        case 2: retval = "TRACK_ALL_DEFINERS"; break;
    }
    if (retval.empty()) {
        char buf[134];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::DefinersMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/SymbolicSemantics2.h:683
/** Converts an enum of type BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemantics2SymbolicSemanticsWritersMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TRACK_NO_WRITERS"; break;
        case 1: retval = "TRACK_LATEST_WRITER"; break;
        case 2: retval = "TRACK_ALL_WRITERS"; break;
    }
    if (retval.empty()) {
        char buf[133];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics2::SymbolicSemantics::WritersMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/IntervalSemantics.h:470
/** Converts an enum of type BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemanticsIntervalSemanticsPolicyCarry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "C_FALSE"; break;
        case 1: retval = "C_TRUE"; break;
        case 2: retval = "C_UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[134];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics::IntervalSemantics::Policy::Carry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/PartialSymbolicSemantics.h:470
/** Converts an enum of type BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisInstructionSemanticsPartialSymbolicSemanticsPolicyMemRefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MRT_STACK_PTR"; break;
        case 1: retval = "MRT_FRAME_PTR"; break;
        case 2: retval = "MRT_OTHER_PTR"; break;
    }
    if (retval.empty()) {
        char buf[146];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::InstructionSemantics::PartialSymbolicSemantics::Policy::MemRefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::MagicNumber::Mechanism is defined at git_rose_development/src/midend/binaryAnalyses/BinaryMagic.h:16
/** Converts an enum of type BinaryAnalysis::MagicNumber::Mechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisMagicNumberMechanism(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FAST"; break;
        case 1: retval = "SLOW"; break;
        case 2: retval = "NONE"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::MagicNumber::Mechanism)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::MagicNumber::Mechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination is defined at git_rose_development/src/frontend/Partitioner2/Modules.h:42
/** Converts an enum of type BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2BasicBlockCallbackTermination(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTINUE_DISCOVERY"; break;
        case 1: retval = "TERMINATE_NOW"; break;
        case 2: retval = "TERMINATE_PRIOR"; break;
    }
    if (retval.empty()) {
        char buf[125];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::BasicBlockCallback::Termination::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Confidence is defined at git_rose_development/src/frontend/Partitioner2/BasicTypes.h:49
/** Converts an enum of type BinaryAnalysis::Partitioner2::Confidence to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2Confidence(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ASSUMED"; break;
        case 1: retval = "PROVED"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Confidence)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Confidence::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type is defined at git_rose_development/src/frontend/Partitioner2/DataFlow.h:28
/** Converts an enum of type BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2DataFlowDfCfgVertexType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BBLOCK"; break;
        case 1: retval = "FAKED_CALL"; break;
        case 2: retval = "FUNCRET"; break;
        case 3: retval = "INDET"; break;
    }
    if (retval.empty()) {
        char buf[121];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::DataFlow::DfCfgVertex::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::EdgeType is defined at git_rose_development/src/frontend/Partitioner2/BasicTypes.h:25
/** Converts an enum of type BinaryAnalysis::Partitioner2::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2EdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "E_NORMAL"; break;
        case 1: retval = "E_FUNCTION_CALL"; break;
        case 2: retval = "E_FUNCTION_RETURN"; break;
        case 3: retval = "E_CALL_RETURN"; break;
        case 4: retval = "E_FUNCTION_XFER"; break;
        case 5: retval = "E_USER_DEFINED"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Engine::FunctionReturnAnalysis is defined at git_rose_development/src/frontend/Partitioner2/Engine.h:156
/** Converts an enum of type BinaryAnalysis::Partitioner2::Engine::FunctionReturnAnalysis to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2EngineFunctionReturnAnalysis(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MAYRETURN_DEFAULT_YES"; break;
        case 1: retval = "MAYRETURN_DEFAULT_NO"; break;
        case 2: retval = "MAYRETURN_ALWAYS_YES"; break;
        case 3: retval = "MAYRETURN_ALWAYS_NO"; break;
    }
    if (retval.empty()) {
        char buf[124];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Engine::FunctionReturnAnalysis)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Engine::FunctionReturnAnalysis::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Engine::MemoryDataAdjustment is defined at git_rose_development/src/frontend/Partitioner2/Engine.h:110
/** Converts an enum of type BinaryAnalysis::Partitioner2::Engine::MemoryDataAdjustment to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2EngineMemoryDataAdjustment(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "DATA_IS_CONSTANT"; break;
        case 1: retval = "DATA_IS_INITIALIZED"; break;
        case 2: retval = "DATA_NO_CHANGE"; break;
    }
    if (retval.empty()) {
        char buf[122];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Engine::MemoryDataAdjustment)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Engine::MemoryDataAdjustment::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Function::Ownership is defined at git_rose_development/src/frontend/Partitioner2/Function.h:41
/** Converts an enum of type BinaryAnalysis::Partitioner2::Function::Ownership to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2FunctionOwnership(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OWN_UNOWNED"; break;
        case 1: retval = "OWN_EXPLICIT"; break;
        case 2: retval = "OWN_PROVISIONAL"; break;
    }
    if (retval.empty()) {
        char buf[113];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Function::Ownership)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Function::Ownership::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Inliner::HowInline is defined at git_rose_development/src/frontend/Partitioner2/CfgPath.h:329
/** Converts an enum of type BinaryAnalysis::Partitioner2::Inliner::HowInline to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2InlinerHowInline(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INLINE_NONE"; break;
        case 1: retval = "INLINE_NORMAL"; break;
        case 2: retval = "INLINE_USER"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Inliner::HowInline)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Inliner::HowInline::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State is defined at git_rose_development/src/frontend/Partitioner2/Partitioner.h:1183
/** Converts an enum of type BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2PartitionerMayReturnVertexInfoState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INIT"; break;
        case 1: retval = "CALCULATING"; break;
        case 2: retval = "FINISHED"; break;
    }
    if (retval.empty()) {
        char buf[133];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Partitioner::MayReturnVertexInfo::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::Reference::Granularity is defined at git_rose_development/src/frontend/Partitioner2/Reference.h:29
/** Converts an enum of type BinaryAnalysis::Partitioner2::Reference::Granularity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2ReferenceGranularity(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "EMPTY"; break;
        case 1: retval = "ADDRESS"; break;
        case 2: retval = "INSTRUCTION"; break;
        case 3: retval = "BASIC_BLOCK"; break;
        case 4: retval = "FUNCTION"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::Reference::Granularity)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::Reference::Granularity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::SemanticMemoryParadigm is defined at git_rose_development/src/frontend/Partitioner2/BasicTypes.h:55
/** Converts an enum of type BinaryAnalysis::Partitioner2::SemanticMemoryParadigm to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2SemanticMemoryParadigm(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LIST_BASED_MEMORY"; break;
        case 1: retval = "MAP_BASED_MEMORY"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::SemanticMemoryParadigm)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::SemanticMemoryParadigm::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner2::VertexType is defined at git_rose_development/src/frontend/Partitioner2/BasicTypes.h:14
/** Converts an enum of type BinaryAnalysis::Partitioner2::VertexType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitioner2VertexType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "V_BASIC_BLOCK"; break;
        case 1: retval = "V_UNDISCOVERED"; break;
        case 2: retval = "V_INDETERMINATE"; break;
        case 3: retval = "V_NONEXISTING"; break;
        case 4: retval = "V_USER_DEFINED"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner2::VertexType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner2::VertexType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum is defined at git_rose_development/src/frontend/Disassemblers/Partitioner.h:757
/** Converts an enum of type BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisPartitionerRegionStatsAnalysisEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RA_NBYTES"; break;
        case 1: retval = "RA_NINSNS"; break;
        case 2: retval = "RA_NCOVERAGE"; break;
        case 3: retval = "RA_RCOVERAGE"; break;
        case 4: retval = "RA_NSTARTS"; break;
        case 5: retval = "RA_NFAILS"; break;
        case 6: retval = "RA_RFAILS"; break;
        case 7: retval = "RA_NOVERLAPS"; break;
        case 8: retval = "RA_ROVERLAPS"; break;
        case 9: retval = "RA_NINCOMPLETE"; break;
        case 10: retval = "RA_RINCOMPLETE"; break;
        case 11: retval = "RA_NBRANCHES"; break;
        case 12: retval = "RA_RBRANCHES"; break;
        case 13: retval = "RA_NCALLS"; break;
        case 14: retval = "RA_RCALLS"; break;
        case 15: retval = "RA_NNONCALLS"; break;
        case 16: retval = "RA_RNONCALLS"; break;
        case 17: retval = "RA_NINTERNAL"; break;
        case 18: retval = "RA_RINTERNAL"; break;
        case 19: retval = "RA_NICFGEDGES"; break;
        case 20: retval = "RA_RICFGEDGES"; break;
        case 21: retval = "RA_NCOMPS"; break;
        case 22: retval = "RA_RCOMPS"; break;
        case 23: retval = "RA_NIUNIQUE"; break;
        case 24: retval = "RA_RIUNIQUE"; break;
        case 25: retval = "RA_NREGREFS"; break;
        case 26: retval = "RA_RREGREFS"; break;
        case 27: retval = "RA_REGSZ"; break;
        case 28: retval = "RA_REGVAR"; break;
        case 29: retval = "RA_NPRIV"; break;
        case 30: retval = "RA_RPRIV"; break;
        case 31: retval = "RA_NFLOAT"; break;
        case 32: retval = "RA_RFLOAT"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Partitioner::RegionStats::AnalysisEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SMTSolver::Satisfiable is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/SMTSolver.h:29
/** Converts an enum of type BinaryAnalysis::SMTSolver::Satisfiable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSMTSolverSatisfiable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SAT_NO"; break;
        case 1: retval = "SAT_YES"; break;
        case 2: retval = "SAT_UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SMTSolver::Satisfiable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SMTSolver::Satisfiable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SRecord::Type is defined at git_rose_development/src/frontend/BinaryFormats/SRecord.h:18
/** Converts an enum of type BinaryAnalysis::SRecord::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSRecordType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SREC_HEADER"; break;
        case 1: retval = "SREC_DATA16"; break;
        case 2: retval = "SREC_DATA24"; break;
        case 3: retval = "SREC_DATA32"; break;
        case 4: retval = "SREC_RESERVED"; break;
        case 5: retval = "SREC_COUNT16"; break;
        case 6: retval = "SREC_COUNT24"; break;
        case 7: retval = "SREC_START32"; break;
        case 8: retval = "SREC_START24"; break;
        case 9: retval = "SREC_START16"; break;
        case 10: retval = "SREC_NONE"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SRecord::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SRecord::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::Strings::State is defined at git_rose_development/src/midend/binaryAnalyses/BinaryString.h:194
/** Converts an enum of type BinaryAnalysis::Strings::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisStringsState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -4: retval = "ERROR_STATE"; break;
        case -3: retval = "INITIAL_STATE"; break;
        case -2: retval = "COMPLETED_STATE"; break;
        case -1: retval = "FINAL_STATE"; break;
        case 0: retval = "USER_DEFINED_0"; break;
        case 1: retval = "USER_DEFINED_1"; break;
        case 2: retval = "USER_DEFINED_2"; break;
        case 128: retval = "USER_DEFINED_MAX"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::Strings::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::Strings::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Formatter::ShowComments is defined at git_rose_development/src/midend/binaryAnalyses/BinarySymbolicExpr.h:107
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Formatter::ShowComments to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprFormatterShowComments(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CMT_SILENT"; break;
        case 1: retval = "CMT_AFTER"; break;
        case 2: retval = "CMT_INSTEAD"; break;
    }
    if (retval.empty()) {
        char buf[117];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SymbolicExpr::Formatter::ShowComments)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Formatter::ShowComments::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Leaf::LeafType is defined at git_rose_development/src/midend/binaryAnalyses/BinarySymbolicExpr.h:830
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Leaf::LeafType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprLeafLeafType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONSTANT"; break;
        case 1: retval = "BITVECTOR"; break;
        case 2: retval = "MEMORY"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SymbolicExpr::Leaf::LeafType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Leaf::LeafType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::Operator is defined at git_rose_development/src/midend/binaryAnalyses/BinarySymbolicExpr.h:47
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::Operator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprOperator(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OP_ADD"; break;
        case 1: retval = "OP_AND"; break;
        case 2: retval = "OP_ASR"; break;
        case 3: retval = "OP_BV_AND"; break;
        case 4: retval = "OP_BV_OR"; break;
        case 5: retval = "OP_BV_XOR"; break;
        case 6: retval = "OP_CONCAT"; break;
        case 7: retval = "OP_EQ"; break;
        case 8: retval = "OP_EXTRACT"; break;
        case 9: retval = "OP_INVERT"; break;
        case 10: retval = "OP_ITE"; break;
        case 11: retval = "OP_LSSB"; break;
        case 12: retval = "OP_MSSB"; break;
        case 13: retval = "OP_NE"; break;
        case 14: retval = "OP_NEGATE"; break;
        case 15: retval = "OP_NOOP"; break;
        case 16: retval = "OP_OR"; break;
        case 17: retval = "OP_READ"; break;
        case 18: retval = "OP_ROL"; break;
        case 19: retval = "OP_ROR"; break;
        case 20: retval = "OP_SDIV"; break;
        case 21: retval = "OP_SET"; break;
        case 22: retval = "OP_SEXTEND"; break;
        case 23: retval = "OP_SGE"; break;
        case 24: retval = "OP_SGT"; break;
        case 25: retval = "OP_SHL0"; break;
        case 26: retval = "OP_SHL1"; break;
        case 27: retval = "OP_SHR0"; break;
        case 28: retval = "OP_SHR1"; break;
        case 29: retval = "OP_SLE"; break;
        case 30: retval = "OP_SLT"; break;
        case 31: retval = "OP_SMOD"; break;
        case 32: retval = "OP_SMUL"; break;
        case 33: retval = "OP_UDIV"; break;
        case 34: retval = "OP_UEXTEND"; break;
        case 35: retval = "OP_UGE"; break;
        case 36: retval = "OP_UGT"; break;
        case 37: retval = "OP_ULE"; break;
        case 38: retval = "OP_ULT"; break;
        case 39: retval = "OP_UMOD"; break;
        case 40: retval = "OP_UMUL"; break;
        case 41: retval = "OP_WRITE"; break;
        case 42: retval = "OP_ZEROP"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SymbolicExpr::Operator)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::Operator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExpr::VisitAction is defined at git_rose_development/src/midend/binaryAnalyses/BinarySymbolicExpr.h:127
/** Converts an enum of type BinaryAnalysis::SymbolicExpr::VisitAction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprVisitAction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTINUE"; break;
        case 1: retval = "TRUNCATE"; break;
        case 2: retval = "TERMINATE"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SymbolicExpr::VisitAction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExpr::VisitAction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::SymbolicExprParser::Token::Type is defined at git_rose_development/src/midend/binaryAnalyses/BinarySymbolicExprParser.h:40
/** Converts an enum of type BinaryAnalysis::SymbolicExprParser::Token::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisSymbolicExprParserTokenType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NONE"; break;
        case 1: retval = "LTPAREN"; break;
        case 2: retval = "RTPAREN"; break;
        case 3: retval = "BITVECTOR"; break;
        case 4: retval = "SYMBOL"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::SymbolicExprParser::Token::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::SymbolicExprParser::Token::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::TaintedFlow::Approximation is defined at git_rose_development/src/midend/binaryAnalyses/BinaryTaintedFlow.h:30
/** Converts an enum of type BinaryAnalysis::TaintedFlow::Approximation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisTaintedFlowApproximation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UNDER_APPROXIMATE"; break;
        case 1: retval = "OVER_APPROXIMATE"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::TaintedFlow::Approximation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::TaintedFlow::Approximation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::TaintedFlow::Taintedness is defined at git_rose_development/src/midend/binaryAnalyses/BinaryTaintedFlow.h:23
/** Converts an enum of type BinaryAnalysis::TaintedFlow::Taintedness to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisTaintedFlowTaintedness(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BOTTOM"; break;
        case 1: retval = "NOT_TAINTED"; break;
        case 2: retval = "TAINTED"; break;
        case 3: retval = "TOP"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::TaintedFlow::Taintedness)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::TaintedFlow::Taintedness::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryAnalysis::YicesSolver::LinkMode is defined at git_rose_development/src/midend/binaryAnalyses/instructionSemantics/YicesSolver.h:26
/** Converts an enum of type BinaryAnalysis::YicesSolver::LinkMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryAnalysisYicesSolverLinkMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LM_NONE"; break;
        case 1: retval = "LM_LIBRARY"; break;
        case 2: retval = "LM_EXECUTABLE"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryAnalysis::YicesSolver::LinkMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryAnalysis::YicesSolver::LinkMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryLoader::ConflictResolution is defined at git_rose_development/src/frontend/BinaryLoader/BinaryLoader.h:61
/** Converts an enum of type BinaryLoader::ConflictResolution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderConflictResolution(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RESOLVE_THROW"; break;
        case 1: retval = "RESOLVE_OVERMAP"; break;
        case 2: retval = "RESOLVE_REMAP"; break;
        case 3: retval = "RESOLVE_REMAP_ABOVE"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryLoader::ConflictResolution)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::ConflictResolution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BinaryLoader::MappingContribution is defined at git_rose_development/src/frontend/BinaryLoader/BinaryLoader.h:53
/** Converts an enum of type BinaryLoader::MappingContribution to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBinaryLoaderMappingContribution(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CONTRIBUTE_NONE"; break;
        case 1: retval = "CONTRIBUTE_ADD"; break;
        case 2: retval = "CONTRIBUTE_SUB"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BinaryLoader::MappingContribution)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BinaryLoader::MappingContribution::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BooleanQuery::TypeOfQueryType is defined at git_rose_development/src/midend/astQuery/booleanQuery.h:44
/** Converts an enum of type BooleanQuery::TypeOfQueryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBooleanQueryTypeOfQueryType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableDeclaration"; break;
        case 2: retval = "Type"; break;
        case 3: retval = "FunctionDeclaration"; break;
        case 4: retval = "MemberFunctionDeclaration"; break;
        case 5: retval = "ClassDeclaration"; break;
        case 6: retval = "Argument"; break;
        case 7: retval = "Field"; break;
        case 8: retval = "UnionedField"; break;
        case 9: retval = "Struct"; break;
        case 10: retval = "ContainedInSubtreeOfType"; break;
        case 11: retval = "END_OF_BOOLEAN_QUERY_TYPE"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BooleanQuery::TypeOfQueryType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BooleanQuery::TypeOfQueryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// BuildAccessEnum is defined at git_rose_development/src/ROSETTA/src/ROSETTA_macros.h:27
/** Converts an enum of type BuildAccessEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyBuildAccessEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_ACCESS_FUNCTIONS"; break;
        case 1: retval = "BUILD_ACCESS_FUNCTIONS"; break;
        case 2: retval = "BUILD_FLAG_ACCESS_FUNCTIONS"; break;
        case 3: retval = "BUILD_LIST_ACCESS_FUNCTIONS"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(BuildAccessEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "BuildAccessEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ByteOrder::Endianness is defined at git_rose_development/src/frontend/BinaryFormats/ByteOrder.h:7
/** Converts an enum of type ByteOrder::Endianness to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyByteOrderEndianness(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ORDER_UNSPECIFIED"; break;
        case 1: retval = "ORDER_LSB"; break;
        case 2: retval = "ORDER_MSB"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ByteOrder::Endianness)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ByteOrder::Endianness::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CFG::EdgeType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CFG/CFG.h:84
/** Converts an enum of type CFG::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCFG_EdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TRUE_EDGE"; break;
        case 1: retval = "FALLTHROUGH_EDGE"; break;
        case 2: retval = "FALSE_EDGE"; break;
        case 3: retval = "BACK_EDGE"; break;
        case 4: retval = "MULTIWAY_EDGE"; break;
        case 5: retval = "BREAK_EDGE"; break;
        case 6: retval = "CONTINUE_EDGE"; break;
        case 7: retval = "RETURN_EDGE"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CFG::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CFG::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CGFunction::iterator::direction is defined at git_rose_development/src/midend/programAnalysis/genericDataflow/cfgUtils/CallGraphTraverse.h:121
/** Converts an enum of type CGFunction::iterator::direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCGFunction_iterator_direction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "fw"; break;
        case 1: retval = "bw"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CGFunction::iterator::direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CGFunction::iterator::direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CallGraph::EdgeType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CallGraph/CallGraph.h:73
/** Converts an enum of type CallGraph::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCallGraphEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NORMAL_EDGE"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CallGraph::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CallGraph::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ClangToSageTranslator::Language is defined at git_rose_development/src/frontend/CxxFrontend/Clang/clang-frontend-private.hpp:137
/** Converts an enum of type ClangToSageTranslator::Language to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyClangToSageTranslatorLanguage(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "C"; break;
        case 1: retval = "CPLUSPLUS"; break;
        case 2: retval = "OBJC"; break;
        case 3: retval = "CUDA"; break;
        case 4: retval = "OPENCL"; break;
        case 5: retval = "unknown"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ClangToSageTranslator::Language)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ClangToSageTranslator::Language::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CollectAliasRelations::COLOR is defined at git_rose_development/src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h:278
/** Converts an enum of type CollectAliasRelations::COLOR to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCollectAliasRelationsCOLOR(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "WHITE"; break;
        case 1: retval = "GREY"; break;
        case 2: retval = "BLACK"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CollectAliasRelations::COLOR)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CollectAliasRelations::COLOR::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CollectAliasRelations::TRAVERSAL_TYPE is defined at git_rose_development/src/midend/programAnalysis/VirtualFunctionAnalysis/IntraProcAliasAnalysis.h:279
/** Converts an enum of type CollectAliasRelations::TRAVERSAL_TYPE to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCollectAliasRelationsTRAVERSAL_TYPE(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TOPOLOGICAL"; break;
        case 1: retval = "NON_TOPOLOGICAL"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CollectAliasRelations::TRAVERSAL_TYPE)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CollectAliasRelations::TRAVERSAL_TYPE::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CompilerOutputWidget::PatternType is defined at git_rose_development/src/roseExtensions/qtWidgets/TaskSystem/CompilerOutputWidget.h:25
/** Converts an enum of type CompilerOutputWidget::PatternType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCompilerOutputWidgetPatternType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Unknown"; break;
        case 1: retval = "Warning"; break;
        case 2: retval = "Error"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CompilerOutputWidget::PatternType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CompilerOutputWidget::PatternType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ConstrGraph::levels is defined at git_rose_development/src/midend/programAnalysis/genericDataflow/lattice/ConstrGraph.h:42
/** Converts an enum of type ConstrGraph::levels to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyConstrGraph_levels(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "uninitialized"; break;
        case 1: retval = "bottom"; break;
        case 2: retval = "constrKnown"; break;
        case 3: retval = "top"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ConstrGraph::levels)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ConstrGraph::levels::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ConstructParamEnum is defined at git_rose_development/src/ROSETTA/src/ROSETTA_macros.h:22
/** Converts an enum of type ConstructParamEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyConstructParamEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_CONSTRUCTOR_PARAMETER"; break;
        case 1: retval = "CONSTRUCTOR_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ConstructParamEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ConstructParamEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// CopyConfigEnum is defined at git_rose_development/src/ROSETTA/src/ROSETTA_macros.h:35
/** Converts an enum of type CopyConfigEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCopyConfigEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_COPY_DATA"; break;
        case 1: retval = "COPY_DATA"; break;
        case 2: retval = "CLONE_PTR"; break;
        case 3: retval = "CLONE_TREE"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(CopyConfigEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "CopyConfigEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Cxx_GrammarVariants is defined at frontend/SageIII/Cxx_Grammar.h:18
/** Converts an enum of type Cxx_GrammarVariants to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyCxx_GrammarVariants(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "AccessModifierTag"; break;
        case 2: retval = "ACTUAL_ARGUMENT_EXPRESSION"; break;
        case 3: retval = "ADD_OP"; break;
        case 4: retval = "ADDRESS_OP"; break;
        case 5: retval = "AGGREGATE_INIT"; break;
        case 6: retval = "ALIAS_SYMBOL"; break;
        case 7: retval = "TEMP_Allocate_Statement"; break;
        case 8: retval = "AND_ASSIGN_OP"; break;
        case 9: retval = "AND_OP"; break;
        case 10: retval = "TEMP_Arithmetic_If_Statement"; break;
        case 11: retval = "T_ARRAY"; break;
        case 12: retval = "POINTST_OP"; break;
        case 13: retval = "ARROWSTAR_OP"; break;
        case 14: retval = "AsmArmInstructionTag"; break;
        case 15: retval = "AsmBasicStringTag"; break;
        case 16: retval = "AsmBinaryAddTag"; break;
        case 17: retval = "AsmBinaryAddPostupdateTag"; break;
        case 18: retval = "AsmBinaryAddPreupdateTag"; break;
        case 19: retval = "AsmBinaryAsrTag"; break;
        case 20: retval = "AsmBinaryDivideTag"; break;
        case 21: retval = "AsmBinaryExpressionTag"; break;
        case 22: retval = "AsmBinaryLslTag"; break;
        case 23: retval = "AsmBinaryLsrTag"; break;
        case 24: retval = "AsmBinaryModTag"; break;
        case 25: retval = "AsmBinaryMultiplyTag"; break;
        case 26: retval = "AsmBinaryRorTag"; break;
        case 27: retval = "AsmBinarySubtractTag"; break;
        case 28: retval = "AsmBinarySubtractPostupdateTag"; break;
        case 29: retval = "AsmBinarySubtractPreupdateTag"; break;
        case 30: retval = "AsmBlockTag"; break;
        case 31: retval = "AsmCoffStrtabTag"; break;
        case 32: retval = "AsmCoffSymbolTag"; break;
        case 33: retval = "AsmCoffSymbolListTag"; break;
        case 34: retval = "AsmCoffSymbolTableTag"; break;
        case 35: retval = "AsmCommonSubExpressionTag"; break;
        case 36: retval = "AsmControlFlagsExpressionTag"; break;
        case 37: retval = "AsmConstantExpressionTag"; break;
        case 38: retval = "AsmDOSExtendedHeaderTag"; break;
        case 39: retval = "AsmDOSFileHeaderTag"; break;
        case 40: retval = "AsmSynthesizedDataStructureDeclarationTag"; break;
        case 41: retval = "AsmSynthesizedDeclarationTag"; break;
        case 42: retval = "AsmDirectRegisterExpressionTag"; break;
        case 43: retval = "AsmDwarfAccessDeclarationTag"; break;
        case 44: retval = "AsmDwarfArrayTypeTag"; break;
        case 45: retval = "AsmDwarfBaseTypeTag"; break;
        case 46: retval = "AsmDwarfCatchBlockTag"; break;
        case 47: retval = "AsmDwarfClassTemplateTag"; break;
        case 48: retval = "AsmDwarfClassTypeTag"; break;
        case 49: retval = "AsmDwarfCommonBlockTag"; break;
        case 50: retval = "AsmDwarfCommonInclusionTag"; break;
        case 51: retval = "AsmDwarfCompilationUnitTag"; break;
        case 52: retval = "AsmDwarfCompilationUnitListTag"; break;
        case 53: retval = "AsmDwarfConditionTag"; break;
        case 54: retval = "AsmDwarfConstTypeTag"; break;
        case 55: retval = "AsmDwarfConstantTag"; break;
        case 56: retval = "AsmDwarfConstructTag"; break;
        case 57: retval = "AsmDwarfConstructListTag"; break;
        case 58: retval = "AsmDwarfDwarfProcedureTag"; break;
        case 59: retval = "AsmDwarfEntryPointTag"; break;
        case 60: retval = "AsmDwarfEnumerationTypeTag"; break;
        case 61: retval = "AsmDwarfEnumeratorTag"; break;
        case 62: retval = "AsmDwarfFileTypeTag"; break;
        case 63: retval = "AsmDwarfFormalParameterTag"; break;
        case 64: retval = "AsmDwarfFormatLabelTag"; break;
        case 65: retval = "AsmDwarfFriendTag"; break;
        case 66: retval = "AsmDwarfFunctionTemplateTag"; break;
        case 67: retval = "AsmDwarfImportedDeclarationTag"; break;
        case 68: retval = "AsmDwarfImportedModuleTag"; break;
        case 69: retval = "AsmDwarfImportedUnitTag"; break;
        case 70: retval = "AsmDwarfInformationTag"; break;
        case 71: retval = "AsmDwarfInheritanceTag"; break;
        case 72: retval = "AsmDwarfInlinedSubroutineTag"; break;
        case 73: retval = "AsmDwarfInterfaceTypeTag"; break;
        case 74: retval = "AsmDwarfLabelTag"; break;
        case 75: retval = "AsmDwarfLexicalBlockTag"; break;
        case 76: retval = "AsmDwarfLineTag"; break;
        case 77: retval = "AsmDwarfLineListTag"; break;
        case 78: retval = "AsmDwarfMacroTag"; break;
        case 79: retval = "AsmDwarfMacroListTag"; break;
        case 80: retval = "AsmDwarfMemberTag"; break;
        case 81: retval = "AsmDwarfModuleTag"; break;
        case 82: retval = "AsmDwarfMutableTypeTag"; break;
        case 83: retval = "AsmDwarfNamelistTag"; break;
        case 84: retval = "AsmDwarfNamelistItemTag"; break;
        case 85: retval = "AsmDwarfNamespaceTag"; break;
        case 86: retval = "AsmDwarfPackedTypeTag"; break;
        case 87: retval = "AsmDwarfPartialUnitTag"; break;
        case 88: retval = "AsmDwarfPointerTypeTag"; break;
        case 89: retval = "AsmDwarfPtrToMemberTypeTag"; break;
        case 90: retval = "AsmDwarfReferenceTypeTag"; break;
        case 91: retval = "AsmDwarfRestrictTypeTag"; break;
        case 92: retval = "AsmDwarfSetTypeTag"; break;
        case 93: retval = "AsmDwarfSharedTypeTag"; break;
        case 94: retval = "AsmDwarfStringTypeTag"; break;
        case 95: retval = "AsmDwarfStructureTypeTag"; break;
        case 96: retval = "AsmDwarfSubprogramTag"; break;
        case 97: retval = "AsmDwarfSubrangeTypeTag"; break;
        case 98: retval = "AsmDwarfSubroutineTypeTag"; break;
        case 99: retval = "AsmDwarfTemplateTypeParameterTag"; break;
        case 100: retval = "AsmDwarfTemplateValueParameterTag"; break;
        case 101: retval = "AsmDwarfThrownTypeTag"; break;
        case 102: retval = "AsmDwarfTryBlockTag"; break;
        case 103: retval = "AsmDwarfTypedefTag"; break;
        case 104: retval = "AsmDwarfUnionTypeTag"; break;
        case 105: retval = "AsmDwarfUnknownConstructTag"; break;
        case 106: retval = "AsmDwarfUnspecifiedParametersTag"; break;
        case 107: retval = "AsmDwarfUnspecifiedTypeTag"; break;
        case 108: retval = "AsmDwarfUpcRelaxedTypeTag"; break;
        case 109: retval = "AsmDwarfUpcSharedTypeTag"; break;
        case 110: retval = "AsmDwarfUpcStrictTypeTag"; break;
        case 111: retval = "AsmDwarfVariableTag"; break;
        case 112: retval = "AsmDwarfVariantTag"; break;
        case 113: retval = "AsmDwarfVariantPartTag"; break;
        case 114: retval = "AsmDwarfVolatileTypeTag"; break;
        case 115: retval = "AsmDwarfWithStmtTag"; break;
        case 116: retval = "AsmElfDynamicEntryTag"; break;
        case 117: retval = "AsmElfDynamicEntryListTag"; break;
        case 118: retval = "AsmElfDynamicSectionTag"; break;
        case 119: retval = "AsmElfEHFrameEntryCITag"; break;
        case 120: retval = "AsmElfEHFrameEntryCIListTag"; break;
        case 121: retval = "AsmElfEHFrameEntryFDTag"; break;
        case 122: retval = "AsmElfEHFrameEntryFDListTag"; break;
        case 123: retval = "AsmElfEHFrameSection"; break;
        case 124: retval = "AsmElfFileHeaderTag"; break;
        case 125: retval = "AsmElfNoteEntryTag"; break;
        case 126: retval = "AsmElfNoteEntryListTag"; break;
        case 127: retval = "AsmElfNoteSection"; break;
        case 128: retval = "AsmElfRelocEntryTag"; break;
        case 129: retval = "AsmElfRelocEntryListTag"; break;
        case 130: retval = "AsmElfRelocSectionTag"; break;
        case 131: retval = "AsmElfSectionTag"; break;
        case 132: retval = "AsmElfSectionTableTag"; break;
        case 133: retval = "AsmElfSectionTableEntryTag"; break;
        case 134: retval = "AsmElfSegmentTableTag"; break;
        case 135: retval = "AsmElfSegmentTableEntryTag"; break;
        case 136: retval = "AsmElfSegmentTableEntryListTag"; break;
        case 137: retval = "AsmElfStringSectionTag"; break;
        case 138: retval = "AsmElfStrtabTag"; break;
        case 139: retval = "AsmElfSymbolTag"; break;
        case 140: retval = "AsmElfSymbolListTag"; break;
        case 141: retval = "AsmElfSymbolSectionTag"; break;
        case 142: retval = "AsmElfSymverDefinedAuxTag"; break;
        case 143: retval = "AsmElfSymverDefinedAuxListTag"; break;
        case 144: retval = "AsmElfSymverDefinedEntryTag"; break;
        case 145: retval = "AsmElfSymverDefinedEntryListTag"; break;
        case 146: retval = "AsmElfSymverDefinedSection"; break;
        case 147: retval = "AsmElfSymverEntryTag"; break;
        case 148: retval = "AsmElfSymverEntryListTag"; break;
        case 149: retval = "AsmElfSymverNeededAuxTag"; break;
        case 150: retval = "AsmElfSymverNeededAuxListTag"; break;
        case 151: retval = "AsmElfSymverNeededEntryTag"; break;
        case 152: retval = "AsmElfSymverNeededEntryListTag"; break;
        case 153: retval = "AsmElfSymverNeededSection"; break;
        case 154: retval = "AsmElfSymverSection"; break;
        case 155: retval = "AsmExecutableFileFormatTag"; break;
        case 156: retval = "AsmExprListExpTag"; break;
        case 157: retval = "AsmExpressionTag"; break;
        case 158: retval = "AsmSynthesizedFieldDeclarationTag"; break;
        case 159: retval = "AsmFloatTypeTag"; break;
        case 160: retval = "AsmFloatValueExpressionTag"; break;
        case 161: retval = "AsmFunctionTag"; break;
        case 163: retval = "AsmGenericDLLTag"; break;
        case 164: retval = "AsmGenericDLLListTag"; break;
        case 165: retval = "AsmGenericFileTag"; break;
        case 166: retval = "AsmGenericFileListTag"; break;
        case 167: retval = "AsmGenericFormatTag"; break;
        case 168: retval = "AsmGenericHeaderTag"; break;
        case 169: retval = "AsmGenericHeaderListTag"; break;
        case 170: retval = "AsmGenericSectionTag"; break;
        case 171: retval = "AsmGenericSectionListTag"; break;
        case 172: retval = "AsmGenericStringTag"; break;
        case 173: retval = "AsmGenericStrtabTag"; break;
        case 174: retval = "AsmGenericSymbolTag"; break;
        case 175: retval = "AsmGenericSymbolListTag"; break;
        case 176: retval = "AsmIndirectRegisterExpressionTag"; break;
        case 177: retval = "AsmInstructionTag"; break;
        case 178: retval = "AsmIntegerValueExpressionTag"; break;
        case 179: retval = "AsmIntegerTypeTag"; break;
        case 180: retval = "AsmInterpretationTag"; break;
        case 181: retval = "AsmInterpretationListTag"; break;
        case 182: retval = "AsmLEEntryPointTag"; break;
        case 183: retval = "AsmLEEntryTableTag"; break;
        case 184: retval = "AsmLEFileHeaderTag"; break;
        case 185: retval = "AsmLENameTableTag"; break;
        case 186: retval = "AsmLEPageTableTag"; break;
        case 187: retval = "AsmLEPageTableEntryTag"; break;
        case 188: retval = "AsmLERelocTableTag"; break;
        case 189: retval = "AsmLESectionTag"; break;
        case 190: retval = "AsmLESectionTableTag"; break;
        case 191: retval = "AsmLESectionTableEntryTag"; break;
        case 192: retval = "AsmM68kInstructionTag"; break;
        case 194: retval = "AsmMemoryReferenceExpressionTag"; break;
        case 195: retval = "AsmMipsInstructionTag"; break;
        case 196: retval = "AsmNEEntryPointTag"; break;
        case 197: retval = "AsmNEEntryTableTag"; break;
        case 198: retval = "AsmNEFileHeaderTag"; break;
        case 199: retval = "AsmNEModuleTableTag"; break;
        case 200: retval = "AsmNENameTableTag"; break;
        case 202: retval = "AsmNERelocEntryTag"; break;
        case 203: retval = "AsmNERelocTableTag"; break;
        case 204: retval = "AsmNESectionTag"; break;
        case 205: retval = "AsmNESectionTableTag"; break;
        case 206: retval = "AsmNESectionTableEntryTag"; break;
        case 207: retval = "AsmNEStringTableTag"; break;
        case 208: retval = "AsmNodeTag"; break;
        case 209: retval = "ASM_OP"; break;
        case 210: retval = "AsmOperandListTag"; break;
        case 211: retval = "AsmPEExportDirectoryTag"; break;
        case 212: retval = "AsmPEExportEntryTag"; break;
        case 213: retval = "AsmPEExportEntryListTag"; break;
        case 214: retval = "AsmPEExportSectionTag"; break;
        case 215: retval = "AsmPEFileHeaderTag"; break;
        case 216: retval = "AsmPEImportDirectoryTag"; break;
        case 217: retval = "AsmPEImportDirectoryListTag"; break;
        case 218: retval = "AsmPEImportItemTag"; break;
        case 219: retval = "AsmPEImportItemListTag"; break;
        case 220: retval = "AsmPEImportSectionTag"; break;
        case 221: retval = "AsmPERVASizePairTag"; break;
        case 222: retval = "AsmPERVASizePairListTag"; break;
        case 223: retval = "AsmPESectionTag"; break;
        case 224: retval = "AsmPESectionTableTag"; break;
        case 225: retval = "AsmPESectionTableEntryTag"; break;
        case 226: retval = "AsmPEStringSectionTag"; break;
        case 227: retval = "AsmPowerpcInstructionTag"; break;
        case 230: retval = "AsmRegisterNamesTag"; break;
        case 231: retval = "AsmRegisterReferenceExpressionTag"; break;
        case 232: retval = "AsmRiscOperationTag"; break;
        case 233: retval = "AsmScalarTypeTag"; break;
        case 236: retval = "AsmStatementTag"; break;
        case 237: retval = "AsmStaticDataTag"; break;
        case 238: retval = "ASM_STMT"; break;
        case 239: retval = "AsmStoredStringTag"; break;
        case 240: retval = "AsmStringStorageTag"; break;
        case 241: retval = "AsmTypeTag"; break;
        case 242: retval = "AsmUnaryArmSpecialRegisterListTag"; break;
        case 243: retval = "AsmUnaryExpressionTag"; break;
        case 244: retval = "AsmUnaryMinusTag"; break;
        case 245: retval = "AsmUnaryPlusTag"; break;
        case 246: retval = "AsmUnaryRrxTag"; break;
        case 247: retval = "AsmValueExpressionTag"; break;
        case 248: retval = "AsmVectorTypeTag"; break;
        case 249: retval = "AsmX86InstructionTag"; break;
        case 250: retval = "BINARY_ADDRESS_SYMBOL"; break;
        case 251: retval = "BINARY_DATA_SYMBOL"; break;
        case 252: retval = "ASSERT_STMT"; break;
        case 253: retval = "ASSIGN_INIT"; break;
        case 254: retval = "ASSIGN_OP"; break;
        case 255: retval = "TEMP_Assign_Statement"; break;
        case 256: retval = "TEMP_Assigned_Goto_Statement"; break;
        case 257: retval = "TEMP_Associate_Statement"; break;
        case 258: retval = "TEMP_AsteriskShapeExp"; break;
        case 259: retval = "ATERM"; break;
        case 260: retval = "AttributeTag"; break;
        case 261: retval = "TEMP_Attribute_Specification_Statement"; break;
        case 262: retval = "BACKSPACE_STATEMENT"; break;
        case 263: retval = "BaseClassTag"; break;
        case 264: retval = "ExpBaseClassTag"; break;
        case 265: retval = "BaseClassModifierTag"; break;
        case 266: retval = "BASIC_BLOCK_STMT"; break;
        case 267: retval = "BidirectionalGraphTag"; break;
        case 268: retval = "BinaryCompositeTag"; break;
        case 269: retval = "BINARY_EXPRESSION"; break;
        case 270: retval = "BITAND_OP"; break;
        case 271: retval = "BitAttributeTag"; break;
        case 272: retval = "BIT_COMPLEMENT_OP"; break;
        case 273: retval = "BITOR_OP"; break;
        case 274: retval = "BITXOR_OP"; break;
        case 275: retval = "TEMP_Block_Data_Statement"; break;
        case 276: retval = "BOOL_VAL"; break;
        case 277: retval = "BREAK_STMT"; break;
        case 278: retval = "CPP_DIRECTIVE_STMT"; break;
        case 279: retval = "CASE_STMT"; break;
        case 280: retval = "CAST_OP"; break;
        case 281: retval = "CATCH_STMT"; break;
        case 282: retval = "CATCH_STATEMENT_SEQ"; break;
        case 283: retval = "CHAR_VAL"; break;
        case 284: retval = "ClassDecl_attrTag"; break;
        case 285: retval = "CLASS_DECL_STMT"; break;
        case 286: retval = "CLASS_DEFN_STMT"; break;
        case 287: retval = "CLASSNAME_REF"; break;
        case 288: retval = "CLASS_NAME"; break;
        case 289: retval = "T_CLASS"; break;
        case 290: retval = "C_LINKAGE_DECLARATION_STMT"; break;
        case 291: retval = "C_LINKAGE_END_STMT"; break;
        case 292: retval = "C_LINKAGE_START_STMT"; break;
        case 293: retval = "CLOSE_STATEMENT"; break;
        case 294: retval = "TEMP_ColonShapeExp"; break;
        case 295: retval = "COMMA_OP"; break;
        case 296: retval = "COMMON_BLOCK"; break;
        case 297: retval = "TEMP_CommonBlockObject"; break;
        case 298: retval = "COMMON_SYMBOL"; break;
        case 299: retval = "COMPLEX_VAL"; break;
        case 300: retval = "COMPREHENSION"; break;
        case 302: retval = "COMPOUND_ASSIGN_OP"; break;
        case 303: retval = "COMPOUND_INIT"; break;
        case 304: retval = "COMPOUND_LITERAL"; break;
        case 305: retval = "TEMP_Computed_Goto_Statement"; break;
        case 306: retval = "CONCATENATION_OP"; break;
        case 307: retval = "EXPR_CONDITIONAL"; break;
        case 308: retval = "CONJUGATE_OP"; break;
        case 309: retval = "ConstVolatileModifierTag"; break;
        case 310: retval = "CONSTRUCTOR_INIT"; break;
        case 311: retval = "TEMP_Contains_Statement"; break;
        case 312: retval = "CONTINUE_STMT"; break;
        case 313: retval = "CTOR_INITIALIZER_LIST"; break;
        case 314: retval = "TEMP_DataStatementGroup"; break;
        case 315: retval = "TEMP_DataStatementObject"; break;
        case 316: retval = "TEMP_DataStatementValue"; break;
        case 317: retval = "DEAD_IF_DIRECTIVE_STMT"; break;
        case 318: retval = "TEMP_Deallocate_Statement"; break;
        case 319: retval = "DeclarationModifierTag"; break;
        case 320: retval = "DECL_STMT"; break;
        case 321: retval = "T_DECLTYPE"; break;
        case 322: retval = "DEFAULT_STMT"; break;
        case 323: retval = "DEFAULT_NAME"; break;
        case 324: retval = "DEFINE_DIRECTIVE_STMT"; break;
        case 325: retval = "DELETE_OP"; break;
        case 326: retval = "TEMP_Derived_Type_Statement"; break;
        case 327: retval = "DESIGNATED_INITIALIZER"; break;
        case 328: retval = "DICTIONARY_COMPREHENSION"; break;
        case 329: retval = "DICT_EXP"; break;
        case 330: retval = "TEMP_DimensionObject"; break;
        case 332: retval = "DirectedGraphEdgeTag"; break;
        case 334: retval = "DirectoryTag"; break;
        case 335: retval = "DirectoryListTag"; break;
        case 336: retval = "DIV_ASSIGN_OP"; break;
        case 337: retval = "DIV_OP"; break;
        case 338: retval = "DO_WHILE_STMT"; break;
        case 339: retval = "RECORD_REF"; break;
        case 340: retval = "DOTSTAR_OP"; break;
        case 341: retval = "DOUBLE_VAL"; break;
        case 342: retval = "ElaboratedTypeModifierTag"; break;
        case 343: retval = "ELEMENT_WISE_OP"; break;
        case 344: retval = "ELEMENT_ADD_OP"; break;
        case 345: retval = "ELEMENT_DIVIDE_OP"; break;
        case 346: retval = "ELEMENT_LEFT_DIVIDE_OP"; break;
        case 347: retval = "ELEMENT_MULT_OP"; break;
        case 348: retval = "ELEMENT_POWER_OP"; break;
        case 349: retval = "ELEMENT_SUBTRACT_OP"; break;
        case 350: retval = "ELSE_DIRECTIVE_STMT"; break;
        case 351: retval = "TEMP_Else_Where_Statement"; break;
        case 352: retval = "ELSEIF_DIRECTIVE_STMT"; break;
        case 353: retval = "EMPTY_DIRECTIVE_STMT"; break;
        case 354: retval = "ENDFILE_STATEMENT"; break;
        case 355: retval = "ENDIF_DIRECTIVE_STMT"; break;
        case 356: retval = "ENTRY_STMT"; break;
        case 357: retval = "ENUM_DECL_STMT"; break;
        case 358: retval = "FIELD_NAME"; break;
        case 359: retval = "ENUM_NAME"; break;
        case 360: retval = "T_ENUM"; break;
        case 361: retval = "ENUM_VAL"; break;
        case 362: retval = "EQ_OP"; break;
        case 363: retval = "TEMP_Equivalence_Statement"; break;
        case 364: retval = "ERROR_DIRECTIVE_STMT"; break;
        case 365: retval = "EXEC_STMT"; break;
        case 366: retval = "EXPONENTIATION_OP"; break;
        case 367: retval = "EXP_ASSIGN_OP"; break;
        case 368: retval = "EXPR_LIST"; break;
        case 369: retval = "EXPR_STMT"; break;
        case 370: retval = "ExpressionTag"; break;
        case 371: retval = "EXPRESSION_ROOT"; break;
        case 372: retval = "FileTag"; break;
        case 373: retval = "FileListTag"; break;
        case 374: retval = "FLOAT_VAL"; break;
        case 375: retval = "FLUSH_STATEMENT"; break;
        case 376: retval = "FOR_ALL_STMT"; break;
        case 377: retval = "FOR_INIT_STMT"; break;
        case 378: retval = "FOR_STMT"; break;
        case 379: retval = "TEMP_FormatItem"; break;
        case 380: retval = "TEMP_FormatItemList"; break;
        case 381: retval = "FORMAT_STATEMENT"; break;
        case 382: retval = "FORTRAN_DO"; break;
        case 383: retval = "TEMP_Fortran_Include_Line"; break;
        case 384: retval = "FORTRAN_NONBLOCKED_DO"; break;
        case 385: retval = "FuncDecl_attrTag"; break;
        case 386: retval = "FUNC_CALL"; break;
        case 387: retval = "FUNC_DECL_STMT"; break;
        case 388: retval = "FUNC_DEFN_STMT"; break;
        case 389: retval = "FunctionModifierTag"; break;
        case 390: retval = "FUNCTION_PARAMETER_LIST"; break;
        case 391: retval = "FUNCTION_PARAMETER_REF_EXP"; break;
        case 392: retval = "T_FUNCTION_PARAMETER_TYPE_LIST"; break;
        case 393: retval = "FUNCTION_REF"; break;
        case 394: retval = "FUNCTION_NAME"; break;
        case 395: retval = "T_FUNCTION"; break;
        case 396: retval = "FUNCTYPE_NAME"; break;
        case 397: retval = "FUNC_TBL_STMT"; break;
        case 398: retval = "TYPE_TABLE"; break;
        case 399: retval = "GLOBAL_STMT"; break;
        case 400: retval = "GOTO_STMT"; break;
        case 401: retval = "GraphTag"; break;
        case 402: retval = "GraphEdgeTag"; break;
        case 403: retval = "GraphEdgeListTag"; break;
        case 404: retval = "GraphNodeTag"; break;
        case 405: retval = "GraphNodeListTag"; break;
        case 406: retval = "GE_OP"; break;
        case 407: retval = "GT_OP"; break;
        case 408: retval = "IO_ITEM_EXPR"; break;
        case 409: retval = "IO_STATEMENT"; break;
        case 410: retval = "IDENT_DIRECTIVE_STMT"; break;
        case 411: retval = "IF_DIRECTIVE_STMT"; break;
        case 412: retval = "IF_STMT"; break;
        case 413: retval = "IFDEF_DIRECTIVE_STMT"; break;
        case 414: retval = "IFNDEF_DIRECTIVE_STMT"; break;
        case 415: retval = "IMAG_PART_OP"; break;
        case 416: retval = "TEMP_Implicit_Statement"; break;
        case 417: retval = "IMPLIED_DO"; break;
        case 418: retval = "TEMP_Import_Statement"; break;
        case 419: retval = "IncidenceDirectedGraphTag"; break;
        case 420: retval = "IncidenceUndirectedGraphTag"; break;
        case 421: retval = "INCLUDE_DIRECTIVE_STMT"; break;
        case 422: retval = "INCLUDE_NEXT_DIRECTIVE_STMT"; break;
        case 423: retval = "InitializedNameTag"; break;
        case 424: retval = "EXPR_INIT"; break;
        case 425: retval = "INQUIRE_STATEMENT"; break;
        case 426: retval = "IntKeyedBidirectionalGraphTag"; break;
        case 427: retval = "INT_VAL"; break;
        case 428: retval = "INTEGER_DIV_OP"; break;
        case 429: retval = "IDIV_ASSIGN_OP"; break;
        case 430: retval = "TEMP_Interface_Body"; break;
        case 431: retval = "TEMP_Header_File_Body"; break;
        case 432: retval = "INTERFACE_STATEMENT"; break;
        case 433: retval = "INTERFACE_SYMBOL"; break;
        case 434: retval = "INTRINSIC_SYMBOL"; break;
        case 435: retval = "IS_OP"; break;
        case 436: retval = "IS_NOT_OP"; break;
        case 437: retval = "IOR_ASSIGN_OP"; break;
        case 438: retval = "KEY_DATUM_PAIR"; break;
        case 439: retval = "EXEC_CONF"; break;
        case 440: retval = "KERN_CALL"; break;
        case 441: retval = "LABEL_REF"; break;
        case 442: retval = "LABEL_STMT"; break;
        case 443: retval = "JAVA_LABEL_STMT"; break;
        case 444: retval = "LABEL_NAME"; break;
        case 445: retval = "JAVA_LABEL_NAME"; break;
        case 446: retval = "LambdaCaptureTag"; break;
        case 447: retval = "LambdaCaptureListTag"; break;
        case 448: retval = "LAMBDA_EXP"; break;
        case 449: retval = "LAMBDA_REF_EXP"; break;
        case 450: retval = "LEFT_DIVIDE_OP"; break;
        case 451: retval = "LE_OP"; break;
        case 452: retval = "LT_OP"; break;
        case 453: retval = "LINE_DIRECTIVE_STMT"; break;
        case 454: retval = "LINEMARKER_DIRECTIVE_STMT"; break;
        case 455: retval = "LinkageModifierTag"; break;
        case 456: retval = "LIST_COMPREHENSION"; break;
        case 457: retval = "LIST_EXP"; break;
        case 458: retval = "LocatedNodeTag"; break;
        case 459: retval = "LocatedNodeSupportTag"; break;
        case 460: retval = "LONG_DOUBLE_VAL"; break;
        case 461: retval = "LONG_INT_VAL"; break;
        case 462: retval = "LONG_LONG_INT_VAL"; break;
        case 463: retval = "LSHIFT_ASSIGN_OP"; break;
        case 464: retval = "LSHIFT_OP"; break;
        case 465: retval = "MAGIC_COLON_EXP"; break;
        case 466: retval = "MATRIX_EXP"; break;
        case 467: retval = "MATRIX_TRANSPOSE_OP"; break;
        case 468: retval = "MATLAB_FOR_STATEMENT"; break;
        case 469: retval = "MFUNC_DECL_STMT"; break;
        case 470: retval = "MEMBER_FUNCTION_REF"; break;
        case 471: retval = "MEMBER_FUNC_NAME"; break;
        case 472: retval = "T_MEMBERFUNCTION"; break;
        case 473: retval = "MEMBERSHIP_OP"; break;
        case 474: retval = "MS_ATTRIBUTE_DECL_STMT"; break;
        case 475: retval = "MINUS_ASSIGN_OP"; break;
        case 476: retval = "MINUSMINUS_OP"; break;
        case 477: retval = "UNARY_MINUS_OP"; break;
        case 478: retval = "MOD_ASSIGN_OP"; break;
        case 479: retval = "MOD_OP"; break;
        case 480: retval = "ModifierTag"; break;
        case 481: retval = "ModifierNodesTag"; break;
        case 482: retval = "T_MODIFIER"; break;
        case 483: retval = "MODULE_STATEMENT"; break;
        case 484: retval = "MODULE_SYMBOL"; break;
        case 485: retval = "MULT_ASSIGN_OP"; break;
        case 486: retval = "MULT_OP"; break;
        case 487: retval = "NameTag"; break;
        case 488: retval = "TEMP_Name_Group"; break;
        case 489: retval = "T_NAME"; break;
        case 490: retval = "TEMP_Namelist_Statement"; break;
        case 491: retval = "NAMESPACE_ALIAS_DECLARATION_STMT"; break;
        case 492: retval = "NAMESPACE_DECLARATION_STMT"; break;
        case 493: retval = "NAMESPACE_DEFINITION_STMT"; break;
        case 494: retval = "NAMESPACE_NAME"; break;
        case 495: retval = "NARY_EXPRESSION"; break;
        case 496: retval = "NARY_BOOLEAN_OP"; break;
        case 497: retval = "NARY_COMPARISON_OP"; break;
        case 498: retval = "NEW_OP"; break;
        case 499: retval = "NodeTag"; break;
        case 500: retval = "NOEXCEPT_OP"; break;
        case 501: retval = "NE_OP"; break;
        case 502: retval = "NOT_OP"; break;
        case 503: retval = "NON_MEMBERSHIP_OP"; break;
        case 504: retval = "NULL_EXPR"; break;
        case 505: retval = "NULLPTR_VAL"; break;
        case 506: retval = "NULL_STMT"; break;
        case 507: retval = "TEMP_Nullify_Statement"; break;
        case 508: retval = "OMP_ATOMIC_STMT"; break;
        case 509: retval = "OMP_BARRIER_STMT"; break;
        case 510: retval = "OMP_CRITICAL_STMT"; break;
        case 511: retval = "OMP_CLAUSEBODY_STMT"; break;
        case 512: retval = "OMP_BODY_STMT"; break;
        case 513: retval = "OMP_DO_STMT"; break;
        case 514: retval = "OMP_FLUSH_STMT"; break;
        case 515: retval = "OMP_FOR_STMT"; break;
        case 516: retval = "OMP_MASTER_STMT"; break;
        case 517: retval = "OMP_ORDERED_STMT"; break;
        case 518: retval = "OMP_PARALLEL_STMT"; break;
        case 519: retval = "OMP_SECTION_STMT"; break;
        case 520: retval = "OMP_SECTIONS_STMT"; break;
        case 521: retval = "OMP_SINGLE_STMT"; break;
        case 522: retval = "OMP_TASK_STMT"; break;
        case 523: retval = "OMP_TASKWAIT_STMT"; break;
        case 524: retval = "OMP_THREADPRIVATE_STMT"; break;
        case 525: retval = "OMP_WORKSHARE_STMT"; break;
        case 526: retval = "OMP_TARGET_STMT"; break;
        case 527: retval = "OMP_TARGET_DATA_STMT"; break;
        case 528: retval = "OMP_SIMD_STMT"; break;
        case 529: retval = "OmpClauseTag"; break;
        case 530: retval = "OmpBeginClauseTag"; break;
        case 531: retval = "OmpCollapseClauseTag"; break;
        case 532: retval = "OmpCopyinClauseTag"; break;
        case 533: retval = "OmpCopyprivateClauseTag"; break;
        case 534: retval = "OmpDefaultClauseTag"; break;
        case 535: retval = "OmpEndClauseTag"; break;
        case 536: retval = "OmpExpressionClauseTag"; break;
        case 537: retval = "OmpFirstprivateClauseTag"; break;
        case 538: retval = "OmpIfClauseTag"; break;
        case 539: retval = "OmpIfDeviceTag"; break;
        case 540: retval = "OmpLastprivateClauseTag"; break;
        case 541: retval = "OmpNowaitClauseTag"; break;
        case 542: retval = "OmpNumThreadsClauseTag"; break;
        case 543: retval = "OmpOrderedClauseTag"; break;
        case 544: retval = "OmpPrivateClauseTag"; break;
        case 545: retval = "OmpReductionClauseTag"; break;
        case 546: retval = "OmpScheduleClauseTag"; break;
        case 547: retval = "OmpSharedClauseTag"; break;
        case 548: retval = "OmpUntiedClauseTag"; break;
        case 549: retval = "OmpVariablesClauseTag"; break;
        case 550: retval = "OmpMapClauseTag"; break;
        case 551: retval = "OmpSafelenTag"; break;
        case 552: retval = "OmpLinearClauseTag"; break;
        case 553: retval = "OmpUniformClauseTag"; break;
        case 554: retval = "OmpAlignedClauseTag"; break;
        case 555: retval = "OPENCL_ACCESS_MODE"; break;
        case 556: retval = "OPEN_STATEMENT"; break;
        case 557: retval = "OptionsTag"; break;
        case 558: retval = "OR_OP"; break;
        case 559: retval = "PARAMETER_STATEMENT"; break;
        case 560: retval = "T_PARTIAL_FUNCTION_MODIFIER"; break;
        case 561: retval = "T_PARTIAL_FUNCTION"; break;
        case 562: retval = "PASS_STATEMENT"; break;
        case 563: retval = "PLUS_ASSIGN_OP"; break;
        case 564: retval = "PLUSPLUS_OP"; break;
        case 565: retval = "ARRAY_OP"; break;
        case 566: retval = "POINTER_ASSIGN_OP"; break;
        case 567: retval = "DEREF_OP"; break;
        case 568: retval = "T_MEMBER_POINTER"; break;
        case 569: retval = "T_POINTER"; break;
        case 570: retval = "POWER_OP"; break;
        case 571: retval = "PragmaTag"; break;
        case 572: retval = "PRAGMA_DECL"; break;
        case 573: retval = "PRINT_STATEMENT"; break;
        case 574: retval = "PROCEDURE_HEADER_STMT"; break;
        case 575: retval = "PROGRAM_HEADER_STMT"; break;
        case 576: retval = "ProjectTag"; break;
        case 577: retval = "PSEUDO_DESTRUCTOR_REF"; break;
        case 578: retval = "PYTHON_GLOBAL_STMT"; break;
        case 579: retval = "PYTHON_PRINT_STMT"; break;
        case 580: retval = "QualifiedNameTag"; break;
        case 581: retval = "T_QUALIFIED_NAME"; break;
        case 582: retval = "RANGE_EXP"; break;
        case 583: retval = "READ_STATEMENT"; break;
        case 584: retval = "REAL_PART_OP"; break;
        case 585: retval = "TYPE_REF"; break;
        case 586: retval = "T_REFERENCE"; break;
        case 587: retval = "TEMP_Rename_Pair"; break;
        case 588: retval = "RENAME_SYMBOL"; break;
        case 589: retval = "RETURN_STMT"; break;
        case 590: retval = "REWIND_STATEMENT"; break;
        case 591: retval = "RSHIFT_ASSIGN_OP"; break;
        case 592: retval = "RSHIFT_OP"; break;
        case 593: retval = "T_RVALUE_REFERENCE"; break;
        case 594: retval = "JAVA_UNSIGNED_RSHIFT_ASSIGN_OP"; break;
        case 595: retval = "JAVA_UNSIGNED_RSHIFT_OP"; break;
        case 596: retval = "SCOPE_OP"; break;
        case 597: retval = "SCOPE_STMT"; break;
        case 598: retval = "TEMP_Sequence_Statement"; break;
        case 599: retval = "SET_COMPREHENSION"; break;
        case 600: retval = "SHORT_VAL"; break;
        case 601: retval = "SIZEOF_OP"; break;
        case 602: retval = "ALIGNOF_OP"; break;
        case 603: retval = "JAVA_INSTANCEOF_OP"; break;
        case 604: retval = "SourceFileTag"; break;
        case 605: retval = "SPAWN_STMT"; break;
        case 606: retval = "JAVE_THROW_STMT"; break;
        case 607: retval = "JAVA_FOREACH_STMT"; break;
        case 608: retval = "JAVA_SYNC_STMT"; break;
        case 609: retval = "T_JAVA_PARAM"; break;
        case 610: retval = "T_JAVA_WILD"; break;
        case 611: retval = "SpecialFunctionModifierTag"; break;
        case 612: retval = "StatementTag"; break;
        case 613: retval = "STATIC_ASSERTION_DECLARATION"; break;
        case 614: retval = "STMT_DECL_STMT"; break;
        case 615: retval = "STMT_EXPR"; break;
        case 616: retval = "TEMP_Statement_Function_Statement"; break;
        case 617: retval = "STOP_OR_PAUSE_STATEMENT"; break;
        case 618: retval = "StorageModifierTag"; break;
        case 619: retval = "STR_CONV"; break;
        case 620: retval = "StringKeyedBidirectionalGraphTag"; break;
        case 621: retval = "STRING_VAL"; break;
        case 622: retval = "SUBSCRIPT_EXPR"; break;
        case 623: retval = "SUBT_OP"; break;
        case 624: retval = "SupportTag"; break;
        case 625: retval = "SWITCH_STMT"; break;
        case 626: retval = "SymbolTag"; break;
        case 627: retval = "SymbolTableTag"; break;
        case 628: retval = "TemplateArgumentTag"; break;
        case 629: retval = "TemplateArgumentListTag"; break;
        case 630: retval = "TEMPLATE_DECL_STMT"; break;
        case 631: retval = "TEMPLATE_CLASS_DECL_STMT"; break;
        case 632: retval = "TEMPLATE_CLASS_NAME"; break;
        case 633: retval = "TEMPLATE_FUNCTION_DECL_STMT"; break;
        case 634: retval = "TEMPLATE_FUNCTION_REF"; break;
        case 635: retval = "TEMPLATE_FUNC_NAME"; break;
        case 636: retval = "TEMPLATE_MEMBER_FUNCTION_DECL_STMT"; break;
        case 637: retval = "TEMPLATE_MEMBER_FUNCTION_REF"; break;
        case 638: retval = "TEMPLATE_MEMBER_FUNC_NAME"; break;
        case 639: retval = "TEMPLATE_TYPEDEF_DECL_STMT"; break;
        case 640: retval = "TEMPLATE_TYPEDEF_NAME"; break;
        case 641: retval = "TEMPLATE_VARIABLE_DECL_STMT"; break;
        case 642: retval = "TEMPLATE_VARIABLE_NAME"; break;
        case 643: retval = "TEMPLATE_CLASS_DEF_STMT"; break;
        case 644: retval = "TEMPLATE_FUNCTION_DEF_STMT"; break;
        case 645: retval = "TEMPLATE_INST_DECL_STMT"; break;
        case 646: retval = "TEMPLATE_INST_DEFN_STMT"; break;
        case 647: retval = "TEMPLATE_INST_DIRECTIVE_STMT"; break;
        case 648: retval = "TEMPLATE_INST_FUNCTION_DECL_STMT"; break;
        case 649: retval = "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT"; break;
        case 650: retval = "TEMPLATE_INST_TYPEDEF_DECL_STMT"; break;
        case 651: retval = "TemplateParameterTag"; break;
        case 652: retval = "TEMPLATE_PARAMETER_VAL"; break;
        case 653: retval = "TemplateParameterListTag"; break;
        case 654: retval = "TEMPLATE_NAME"; break;
        case 655: retval = "T_TEMPLATE"; break;
        case 656: retval = "THIS_NODE"; break;
        case 657: retval = "TYPE_TRAIT_BUILTIN_OPERATOR"; break;
        case 658: retval = "SUPER_NODE"; break;
        case 659: retval = "THROW_OP"; break;
        case 660: retval = "TOKEN"; break;
        case 661: retval = "TRY_STMT"; break;
        case 662: retval = "TUPLE_EXP"; break;
        case 663: retval = "TypeTag"; break;
        case 664: retval = "T_BOOL"; break;
        case 665: retval = "T_CHAR"; break;
        case 666: retval = "T_COMPLEX"; break;
        case 667: retval = "T_DEFAULT"; break;
        case 668: retval = "TYPE_EXPRESSION"; break;
        case 669: retval = "T_LABEL"; break;
        case 670: retval = "T_DOUBLE"; break;
        case 671: retval = "T_ELLIPSE"; break;
        case 672: retval = "T_FLOAT"; break;
        case 673: retval = "T_GLOBAL_VOID"; break;
        case 674: retval = "TYPEID_OP"; break;
        case 675: retval = "T_IMAGINARY"; break;
        case 676: retval = "T_INT"; break;
        case 677: retval = "T_LONG"; break;
        case 678: retval = "T_LONG_DOUBLE"; break;
        case 679: retval = "T_LONG_LONG"; break;
        case 680: retval = "TypeModifierTag"; break;
        case 681: retval = "T_MATRIX"; break;
        case 682: retval = "T_TUPLE"; break;
        case 683: retval = "T_NULLPTR"; break;
        case 684: retval = "T_TYPEOF_TYPE"; break;
        case 685: retval = "T_SHORT"; break;
        case 686: retval = "T_SIGNED_128BIT_INTEGER"; break;
        case 687: retval = "T_SIGNED_CHAR"; break;
        case 688: retval = "T_SIGNED_INT"; break;
        case 689: retval = "T_SIGNED_LONG"; break;
        case 690: retval = "T_SIGNED_LONG_LONG"; break;
        case 691: retval = "T_SIGNED_SHORT"; break;
        case 692: retval = "T_STRING"; break;
        case 693: retval = "T_UNKNOWN"; break;
        case 694: retval = "T_UNSIGNED_128BIT_INTEGER"; break;
        case 695: retval = "T_UNSIGNED_CHAR"; break;
        case 696: retval = "T_UNSIGNED_INT"; break;
        case 697: retval = "T_UNSIGNED_LONG"; break;
        case 698: retval = "T_UNSIGNED_LONG_LONG"; break;
        case 699: retval = "T_UNSIGNED_SHORT"; break;
        case 700: retval = "T_VOID"; break;
        case 701: retval = "T_WCHAR"; break;
        case 702: retval = "TYPEDEF_STMT"; break;
        case 703: retval = "T_TYPEDEF_SEQ"; break;
        case 704: retval = "TYPEDEF_NAME"; break;
        case 705: retval = "T_TYPEDEF"; break;
        case 706: retval = "UPC_AccessModifierTag"; break;
        case 707: retval = "UNARY_ADD_OP"; break;
        case 708: retval = "UNARY_EXPRESSION"; break;
        case 709: retval = "UNDEF_DIRECTIVE_STMT"; break;
        case 710: retval = "UndirectedGraphEdgeTag"; break;
        case 711: retval = "TEMP_UnknownArrayOrFunctionReference"; break;
        case 712: retval = "UnknownFileTag"; break;
        case 714: retval = "Unparse_InfoTag"; break;
        case 715: retval = "UNSIGNED_CHAR_VAL"; break;
        case 716: retval = "UNSIGNED_INT_VAL"; break;
        case 717: retval = "UNSIGNED_LONG_LONG_INT_VAL"; break;
        case 718: retval = "UNSIGNED_LONG_INT_VAL"; break;
        case 719: retval = "UNSIGNED_SHORT_VAL"; break;
        case 720: retval = "UntypedNodeTag"; break;
        case 721: retval = "UntypedExpressionTag"; break;
        case 722: retval = "TEMP_UntypedUnaryOperator"; break;
        case 723: retval = "TEMP_UntypedBinaryOperator"; break;
        case 724: retval = "TEMP_UntypedValueExpression"; break;
        case 725: retval = "TEMP_UntypedArrayReferenceExpression"; break;
        case 726: retval = "TEMP_UntypedOtherExpression"; break;
        case 727: retval = "TEMP_UntypedFunctionCallOrArrayReferenceExpression"; break;
        case 728: retval = "UntypedStatementTag"; break;
        case 729: retval = "TEMP_UntypedNamedStatement"; break;
        case 730: retval = "TEMP_UntypedAssignmentStatement"; break;
        case 731: retval = "TEMP_UntypedFunctionCallStatement"; break;
        case 732: retval = "TEMP_UntypedBlockStatement"; break;
        case 733: retval = "TEMP_UntypedOtherStatement"; break;
        case 734: retval = "UntypedDeclarationStatementTag"; break;
        case 735: retval = "TEMP_UntypedInitializedName"; break;
        case 736: retval = "TEMP_UntypedImplicitDeclaration"; break;
        case 737: retval = "TEMP_UntypedVariableDeclaration"; break;
        case 738: retval = "TEMP_UntypedProgramHeaderDeclaration"; break;
        case 739: retval = "UntypedFunctionDeclarationTag"; break;
        case 740: retval = "TEMP_UntypedSubroutineDeclaration"; break;
        case 741: retval = "TEMP_UntypedReferenceExpression"; break;
        case 742: retval = "UntypedTypeTag"; break;
        case 743: retval = "TEMP_UntypedArrayType"; break;
        case 744: retval = "TEMP_UntypedAttribute"; break;
        case 745: retval = "TEMP_UntypedFile"; break;
        case 746: retval = "UntypedScopeTag"; break;
        case 747: retval = "TEMP_UntypedFunctionScope"; break;
        case 748: retval = "TEMP_UntypedModuleScope"; break;
        case 749: retval = "TEMP_UntypedGlobalScope"; break;
        case 750: retval = "TEMP_UntypedModuleDeclaration"; break;
        case 751: retval = "TEMP_UntypedStatementList"; break;
        case 752: retval = "TEMP_UntypedDeclarationStatementList"; break;
        case 753: retval = "TEMP_UntypedFunctionDeclarationList"; break;
        case 754: retval = "TEMP_UntypedInitializedNameList"; break;
        case 755: retval = "UPC_BARRIER_STMT"; break;
        case 756: retval = "UPC_BLOCK_SIZEOF_EXPR"; break;
        case 757: retval = "UPC_ELEM_SIZEOF_EXPR"; break;
        case 758: retval = "UPC_FENCE_STMT"; break;
        case 759: retval = "UPC_FORALL_STMT"; break;
        case 760: retval = "UPC_LOCAL_SIZEOF_EXPR"; break;
        case 761: retval = "UPC_MYTHREAD"; break;
        case 762: retval = "UPC_NOTIFY_STMT"; break;
        case 763: retval = "UPC_THREADS"; break;
        case 764: retval = "UPC_WAIT_STMT"; break;
        case 765: retval = "USE_STATEMENT"; break;
        case 766: retval = "USER_DEFINED_BINARY_OP"; break;
        case 767: retval = "USER_DEFINED_UNARY_OP"; break;
        case 768: retval = "USING_DECLARATION_STMT"; break;
        case 769: retval = "USING_DIRECTIVE_STMT"; break;
        case 770: retval = "ValueExpTag"; break;
        case 771: retval = "VA_COPY_OP"; break;
        case 772: retval = "VA_END_OP"; break;
        case 773: retval = "VA_OP"; break;
        case 774: retval = "VA_START_ONE_OPERAND_OP"; break;
        case 775: retval = "VA_START_OP"; break;
        case 776: retval = "VAR_REF"; break;
        case 777: retval = "VAR_DECL_STMT"; break;
        case 778: retval = "VAR_DEFN_STMT"; break;
        case 779: retval = "VARIABLE_NAME"; break;
        case 780: retval = "VARIANT_EXPR"; break;
        case 781: retval = "VARIANT_STMT"; break;
        case 782: retval = "WAIT_STATEMENT"; break;
        case 783: retval = "WARNING_DIRECTIVE_STMT"; break;
        case 784: retval = "WITH_STATEMENT"; break;
        case 785: retval = "WCHAR_VAL"; break;
        case 786: retval = "TEMP_Where_Statement"; break;
        case 787: retval = "WHILE_STMT"; break;
        case 788: retval = "WRITE_STATEMENT"; break;
        case 789: retval = "XOR_ASSIGN_OP"; break;
        case 790: retval = "YIELD_EXP"; break;
        case 791: retval = "_File_InfoTag"; break;
        case 792: retval = "T_CAFTEAM"; break;
        case 793: retval = "WITHTEAM_STMT"; break;
        case 794: retval = "COARRAY_REF_EXPR"; break;
        case 795: retval = "CALL_EXPRESSION"; break;
        case 796: retval = "T_CRAY_POINTER"; break;
        case 797: retval = "TEMP_JavaImportStatement"; break;
        case 798: retval = "TEMP_JavaPackageDeclaration"; break;
        case 799: retval = "TEMP_JavaPackageStatement"; break;
        case 800: retval = "JavaImportStatementListTag"; break;
        case 801: retval = "JavaClassDeclarationListTag"; break;
        case 802: retval = "JavaMemberValuePairTag"; break;
        case 803: retval = "JAVA_ANNOTATION"; break;
        case 804: retval = "JAVA_MARKER_ANNOTATION"; break;
        case 805: retval = "JAVA_SINGLE_MEMBER_ANNOTATION"; break;
        case 806: retval = "JAVA_NORMAL_ANNOTATION"; break;
        case 807: retval = "JAVA_TYPE_EXPRESSION"; break;
        case 808: retval = "T_JAVA_QUALIFIED"; break;
        case 809: retval = "CLASS_NODE"; break;
        case 810: retval = "T_JAVA_UNION"; break;
        case 811: retval = "T_JAVA_PARAMETER"; break;
        case 812: retval = "ASYNC_STMT"; break;
        case 813: retval = "FINISH_STMT"; break;
        case 814: retval = "AT_STMT"; break;
        case 815: retval = "HERE_NODE"; break;
        case 817: retval = "Cxx_Grammar_UNKNOWN_GRAMMAR"; break;
        case 818: retval = "Cxx_Grammar_LAST_TAG"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Cxx_GrammarVariants)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Cxx_GrammarVariants::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DOTGraphEdge::DOTArrowTypes is defined at git_rose_development/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:134
/** Converts an enum of type DOTGraphEdge::DOTArrowTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphEdgeDOTArrowTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementArrowTypes"; break;
        case 1: retval = "normal"; break;
        case 2: retval = "inv"; break;
        case 3: retval = "dot"; break;
        case 4: retval = "invdot"; break;
        case 5: retval = "odot"; break;
        case 6: retval = "invodot"; break;
        case 7: retval = "none"; break;
        case 8: retval = "tee"; break;
        case 9: retval = "empty"; break;
        case 10: retval = "invempty"; break;
        case 11: retval = "diamond"; break;
        case 12: retval = "odiamond"; break;
        case 13: retval = "ediamond"; break;
        case 14: retval = "crow"; break;
        case 15: retval = "box"; break;
        case 16: retval = "obox"; break;
        case 17: retval = "open"; break;
        case 18: retval = "halfopen"; break;
        case 19: retval = "vee"; break;
        case 20: retval = "END_OF_NODE_TYPE_LIST_DOTArrowTypes"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DOTGraphEdge::DOTArrowTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphEdge::DOTArrowTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DOTGraphNode::DOTShapeTypes is defined at git_rose_development/src/frontend/SageIII/astVisualization/AstAttributeDOT.h:87
/** Converts an enum of type DOTGraphNode::DOTShapeTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDOTGraphNodeDOTShapeTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementDOTShapeTypes"; break;
        case 1: retval = "polygon"; break;
        case 2: retval = "ellipse"; break;
        case 3: retval = "record"; break;
        case 4: retval = "mrecord"; break;
        case 5: retval = "END_OF_NODE_TYPE_LIST_DOTShapeTypes"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DOTGraphNode::DOTShapeTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DOTGraphNode::DOTShapeTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DependencyInfo::State is defined at git_rose_development/src/roseExtensions/qtWidgets/ProjectManager/DependencyInfo.h:21
/** Converts an enum of type DependencyInfo::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDependencyInfoState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "VALID"; break;
        case 1: retval = "INVALID"; break;
        case 2: retval = "ERROR"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DependencyInfo::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DependencyInfo::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DisplayEdge::PaintMode is defined at git_rose_development/src/roseExtensions/qtWidgets/AstGraphWidget/DisplayEdge.h:40
/** Converts an enum of type DisplayEdge::PaintMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDisplayEdgePaintMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STRAIGHT"; break;
        case 1: retval = "RECTANGULAR"; break;
        case 2: retval = "BEZIER_QUAD"; break;
        case 3: retval = "BEZIER_CUBIC"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DisplayEdge::PaintMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DisplayEdge::PaintMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::Dir_ection is defined at git_rose_development/src/midend/programAnalysis/dominanceAnalysis/DominatorTree.h:14
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::Dir_ection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDir_ection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PRE_DOMINATOR"; break;
        case 1: retval = "POST_DOMINATOR"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::Dir_ection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::Dir_ection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// DominatorTreesAndDominanceFrontiers::DominatorTree::Direction is defined at git_rose_development/src/midend/programAnalysis/dominatorTreesAndDominanceFrontiers/DominatorTree.h:51
/** Converts an enum of type DominatorTreesAndDominanceFrontiers::DominatorTree::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyDominatorTreesAndDominanceFrontiersDominatorTreeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PRE"; break;
        case 1: retval = "POST"; break;
    }
    if (retval.empty()) {
        char buf[125];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(DominatorTreesAndDominanceFrontiers::DominatorTree::Direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "DominatorTreesAndDominanceFrontiers::DominatorTree::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgActualArgumentExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1042
/** Converts an enum of type E_SgActualArgumentExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgActualArgumentExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgActualArgumentExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgActualArgumentExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgActualArgumentExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:796
/** Converts an enum of type E_SgAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAddOp_lhs_operand_i"; break;
        case 1: retval = "SgAddOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAddOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAddressOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:730
/** Converts an enum of type E_SgAddressOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAddressOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAddressOfOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAddressOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAddressOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAggregateInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:997
/** Converts an enum of type E_SgAggregateInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAggregateInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAggregateInitializer_initializers"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAggregateInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAggregateInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAliasSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1156
/** Converts an enum of type E_SgAliasSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAliasSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAliasSymbol_alias"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAliasSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAliasSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAlignOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1090
/** Converts an enum of type E_SgAlignOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAlignOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAlignOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAlignOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAlignOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAllocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:619
/** Converts an enum of type E_SgAllocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAllocateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAllocateStatement_expr_list"; break;
        case 1: retval = "SgAllocateStatement_stat_expression"; break;
        case 2: retval = "SgAllocateStatement_errmsg_expression"; break;
        case 3: retval = "SgAllocateStatement_source_expression"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAllocateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAllocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAndAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:868
/** Converts an enum of type E_SgAndAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAndAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgAndAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAndAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:814
/** Converts an enum of type E_SgAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAndOp_lhs_operand_i"; break;
        case 1: retval = "SgAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArithmeticIfStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:607
/** Converts an enum of type E_SgArithmeticIfStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArithmeticIfStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArithmeticIfStatement_conditional"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgArithmeticIfStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArithmeticIfStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:175
/** Converts an enum of type E_SgArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrayType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrayType_type_kind"; break;
        case 1: retval = "SgArrayType_index"; break;
        case 2: retval = "SgArrayType_dim_info"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgArrayType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrowExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:766
/** Converts an enum of type E_SgArrowExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrowExp_lhs_operand_i"; break;
        case 1: retval = "SgArrowExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgArrowExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgArrowStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:775
/** Converts an enum of type E_SgArrowStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgArrowStarOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgArrowStarOp_lhs_operand_i"; break;
        case 1: retval = "SgArrowStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgArrowStarOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgArrowStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmArmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1171
/** Converts an enum of type E_SgAsmArmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmArmInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmArmInstruction_operandList"; break;
        case 1: retval = "SgAsmArmInstruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmArmInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmArmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAdd is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1198
/** Converts an enum of type E_SgAsmBinaryAdd to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAdd(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAdd_lhs"; break;
        case 1: retval = "SgAsmBinaryAdd_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAdd)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAdd::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAddPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1219
/** Converts an enum of type E_SgAsmBinaryAddPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPostupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAddPostupdate_lhs"; break;
        case 1: retval = "SgAsmBinaryAddPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAddPostupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAddPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1213
/** Converts an enum of type E_SgAsmBinaryAddPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAddPreupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAddPreupdate_lhs"; break;
        case 1: retval = "SgAsmBinaryAddPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAddPreupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAddPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryAsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1231
/** Converts an enum of type E_SgAsmBinaryAsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryAsr(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryAsr_lhs"; break;
        case 1: retval = "SgAsmBinaryAsr_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryAsr)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryAsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryDivide is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1207
/** Converts an enum of type E_SgAsmBinaryDivide to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryDivide(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryDivide_lhs"; break;
        case 1: retval = "SgAsmBinaryDivide_rhs"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryDivide)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryDivide::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1237
/** Converts an enum of type E_SgAsmBinaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryExpression_lhs"; break;
        case 1: retval = "SgAsmBinaryExpression_rhs"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryLsl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1225
/** Converts an enum of type E_SgAsmBinaryLsl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryLsl_lhs"; break;
        case 1: retval = "SgAsmBinaryLsl_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryLsl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryLsr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1228
/** Converts an enum of type E_SgAsmBinaryLsr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryLsr(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryLsr_lhs"; break;
        case 1: retval = "SgAsmBinaryLsr_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryLsr)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryLsr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryMod is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1210
/** Converts an enum of type E_SgAsmBinaryMod to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMod(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryMod_lhs"; break;
        case 1: retval = "SgAsmBinaryMod_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryMod)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMod::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryMultiply is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1204
/** Converts an enum of type E_SgAsmBinaryMultiply to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryMultiply(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryMultiply_lhs"; break;
        case 1: retval = "SgAsmBinaryMultiply_rhs"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryMultiply)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryMultiply::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinaryRor is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1234
/** Converts an enum of type E_SgAsmBinaryRor to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinaryRor(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinaryRor_lhs"; break;
        case 1: retval = "SgAsmBinaryRor_rhs"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinaryRor)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinaryRor::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtract is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1201
/** Converts an enum of type E_SgAsmBinarySubtract to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtract(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtract_lhs"; break;
        case 1: retval = "SgAsmBinarySubtract_rhs"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtract)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtract::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtractPostupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1222
/** Converts an enum of type E_SgAsmBinarySubtractPostupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPostupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtractPostupdate_lhs"; break;
        case 1: retval = "SgAsmBinarySubtractPostupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtractPostupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPostupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBinarySubtractPreupdate is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1216
/** Converts an enum of type E_SgAsmBinarySubtractPreupdate to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBinarySubtractPreupdate(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBinarySubtractPreupdate_lhs"; break;
        case 1: retval = "SgAsmBinarySubtractPreupdate_rhs"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBinarySubtractPreupdate)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBinarySubtractPreupdate::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1165
/** Converts an enum of type E_SgAsmBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmBlock_statementList"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1369
/** Converts an enum of type E_SgAsmCoffSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCoffSymbol_name"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmCoffSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1438
/** Converts an enum of type E_SgAsmCoffSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCoffSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmCoffSymbolList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCoffSymbolTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1342
/** Converts an enum of type E_SgAsmCoffSymbolTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCoffSymbolTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCoffSymbolTable_symbols"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmCoffSymbolTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCoffSymbolTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmCommonSubExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1258
/** Converts an enum of type E_SgAsmCommonSubExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmCommonSubExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmCommonSubExpression_subexpression"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmCommonSubExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmCommonSubExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmConstantExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1192
/** Converts an enum of type E_SgAsmConstantExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmConstantExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmConstantExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmConstantExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmConstantExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDOSFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1291
/** Converts an enum of type E_SgAsmDOSFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDOSFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDOSFileHeader_exec_format"; break;
        case 1: retval = "SgAsmDOSFileHeader_dlls"; break;
        case 2: retval = "SgAsmDOSFileHeader_sections"; break;
        case 3: retval = "SgAsmDOSFileHeader_relocs"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDOSFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDOSFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1462
/** Converts an enum of type E_SgAsmDwarfArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfArrayType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfArrayType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfArrayType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1465
/** Converts an enum of type E_SgAsmDwarfClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfClassType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfClassType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfClassType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1486
/** Converts an enum of type E_SgAsmDwarfCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCommonBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCommonBlock_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCommonBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnit is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1474
/** Converts an enum of type E_SgAsmDwarfCompilationUnit to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnit(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCompilationUnit_line_info"; break;
        case 1: retval = "SgAsmDwarfCompilationUnit_language_constructs"; break;
        case 2: retval = "SgAsmDwarfCompilationUnit_macro_info"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCompilationUnit)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnit::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfCompilationUnitList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1459
/** Converts an enum of type E_SgAsmDwarfCompilationUnitList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfCompilationUnitList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfCompilationUnitList_cu_list"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfCompilationUnitList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfCompilationUnitList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfConstructList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1498
/** Converts an enum of type E_SgAsmDwarfConstructList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfConstructList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfConstructList_list"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfConstructList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfConstructList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfEnumerationType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1468
/** Converts an enum of type E_SgAsmDwarfEnumerationType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfEnumerationType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfEnumerationType_body"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfEnumerationType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfEnumerationType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfInlinedSubroutine is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1489
/** Converts an enum of type E_SgAsmDwarfInlinedSubroutine to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfInlinedSubroutine(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfInlinedSubroutine_body"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfInlinedSubroutine)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfInlinedSubroutine::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfLexicalBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1471
/** Converts an enum of type E_SgAsmDwarfLexicalBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLexicalBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfLexicalBlock_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfLexicalBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLexicalBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfLineList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1456
/** Converts an enum of type E_SgAsmDwarfLineList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfLineList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfLineList_line_list"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfLineList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfLineList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfMacroList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1453
/** Converts an enum of type E_SgAsmDwarfMacroList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfMacroList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfMacroList_macro_list"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfMacroList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfMacroList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfNamespace is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1495
/** Converts an enum of type E_SgAsmDwarfNamespace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfNamespace(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfNamespace_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfNamespace)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfNamespace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfStructureType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1477
/** Converts an enum of type E_SgAsmDwarfStructureType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfStructureType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfStructureType_body"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfStructureType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfStructureType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfSubprogram is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1492
/** Converts an enum of type E_SgAsmDwarfSubprogram to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubprogram(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfSubprogram_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfSubprogram)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubprogram::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfSubroutineType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1480
/** Converts an enum of type E_SgAsmDwarfSubroutineType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfSubroutineType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfSubroutineType_body"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfSubroutineType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfSubroutineType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmDwarfUnionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1483
/** Converts an enum of type E_SgAsmDwarfUnionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmDwarfUnionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmDwarfUnionType_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmDwarfUnionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmDwarfUnionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfDynamicEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1396
/** Converts an enum of type E_SgAsmElfDynamicEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfDynamicEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfDynamicEntry_name"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfDynamicEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfDynamicEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfDynamicSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1306
/** Converts an enum of type E_SgAsmElfDynamicSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfDynamicSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfDynamicSection_section_entry"; break;
        case 1: retval = "SgAsmElfDynamicSection_segment_entry"; break;
        case 2: retval = "SgAsmElfDynamicSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfDynamicSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfDynamicSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfEHFrameEntryCI is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1444
/** Converts an enum of type E_SgAsmElfEHFrameEntryCI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameEntryCI(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfEHFrameEntryCI_fd_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfEHFrameEntryCI)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameEntryCI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfEHFrameSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1315
/** Converts an enum of type E_SgAsmElfEHFrameSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfEHFrameSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfEHFrameSection_section_entry"; break;
        case 1: retval = "SgAsmElfEHFrameSection_segment_entry"; break;
        case 2: retval = "SgAsmElfEHFrameSection_ci_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfEHFrameSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfEHFrameSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1294
/** Converts an enum of type E_SgAsmElfFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfFileHeader_exec_format"; break;
        case 1: retval = "SgAsmElfFileHeader_dlls"; break;
        case 2: retval = "SgAsmElfFileHeader_sections"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfNoteEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1402
/** Converts an enum of type E_SgAsmElfNoteEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfNoteEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfNoteEntry_name"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfNoteEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfNoteEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfNoteSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1312
/** Converts an enum of type E_SgAsmElfNoteSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfNoteSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfNoteSection_section_entry"; break;
        case 1: retval = "SgAsmElfNoteSection_segment_entry"; break;
        case 2: retval = "SgAsmElfNoteSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfNoteSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfNoteSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfRelocEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1387
/** Converts an enum of type E_SgAsmElfRelocEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfRelocEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfRelocEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfRelocEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfRelocEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfRelocSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1303
/** Converts an enum of type E_SgAsmElfRelocSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfRelocSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfRelocSection_section_entry"; break;
        case 1: retval = "SgAsmElfRelocSection_segment_entry"; break;
        case 2: retval = "SgAsmElfRelocSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfRelocSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfRelocSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1327
/** Converts an enum of type E_SgAsmElfSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSection_section_entry"; break;
        case 1: retval = "SgAsmElfSection_segment_entry"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSegmentTableEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1399
/** Converts an enum of type E_SgAsmElfSegmentTableEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSegmentTableEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSegmentTableEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSegmentTableEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSegmentTableEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1309
/** Converts an enum of type E_SgAsmElfStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfStringSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfStringSection_section_entry"; break;
        case 1: retval = "SgAsmElfStringSection_segment_entry"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfStringSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1372
/** Converts an enum of type E_SgAsmElfSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymbol_name"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbolList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1384
/** Converts an enum of type E_SgAsmElfSymbolList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymbolList_symbols"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymbolList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymbolSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1300
/** Converts an enum of type E_SgAsmElfSymbolSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymbolSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymbolSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymbolSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymbolSection_symbols"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymbolSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymbolSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedAux is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1414
/** Converts an enum of type E_SgAsmElfSymverDefinedAux to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedAux(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedAux_name"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedAux)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedAux::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1417
/** Converts an enum of type E_SgAsmElfSymverDefinedAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedAuxList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedAuxList_entries"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedAuxList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1408
/** Converts an enum of type E_SgAsmElfSymverDefinedEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedEntry_entries"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1411
/** Converts an enum of type E_SgAsmElfSymverDefinedEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverDefinedSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1321
/** Converts an enum of type E_SgAsmElfSymverDefinedSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverDefinedSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverDefinedSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverDefinedSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverDefinedSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverDefinedSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverDefinedSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1405
/** Converts an enum of type E_SgAsmElfSymverEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededAux is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1426
/** Converts an enum of type E_SgAsmElfSymverNeededAux to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededAux(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededAux_name"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededAux)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededAux::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededAuxList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1429
/** Converts an enum of type E_SgAsmElfSymverNeededAuxList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededAuxList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededAuxList_entries"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededAuxList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededAuxList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1420
/** Converts an enum of type E_SgAsmElfSymverNeededEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededEntry_file_name"; break;
        case 1: retval = "SgAsmElfSymverNeededEntry_entries"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1423
/** Converts an enum of type E_SgAsmElfSymverNeededEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededEntryList_entries"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverNeededSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1324
/** Converts an enum of type E_SgAsmElfSymverNeededSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverNeededSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverNeededSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverNeededSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverNeededSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverNeededSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverNeededSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmElfSymverSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1318
/** Converts an enum of type E_SgAsmElfSymverSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmElfSymverSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmElfSymverSection_section_entry"; break;
        case 1: retval = "SgAsmElfSymverSection_segment_entry"; break;
        case 2: retval = "SgAsmElfSymverSection_entries"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmElfSymverSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmElfSymverSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1261
/** Converts an enum of type E_SgAsmExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmExprListExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmExprListExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmFloatValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1189
/** Converts an enum of type E_SgAsmFloatValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmFloatValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmFloatValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmFloatValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmFloatValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmFunction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1162
/** Converts an enum of type E_SgAsmFunction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmFunction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmFunction_statementList"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmFunction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmFunction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericDLL is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1276
/** Converts an enum of type E_SgAsmGenericDLL to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericDLL(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericDLL_name"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericDLL)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericDLL::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1279
/** Converts an enum of type E_SgAsmGenericFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericFile_dwarf_info"; break;
        case 1: retval = "SgAsmGenericFile_headers"; break;
        case 2: retval = "SgAsmGenericFile_holes"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1510
/** Converts an enum of type E_SgAsmGenericFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericFileList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericFileList_files"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericFileList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1297
/** Converts an enum of type E_SgAsmGenericHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericHeader_exec_format"; break;
        case 1: retval = "SgAsmGenericHeader_dlls"; break;
        case 2: retval = "SgAsmGenericHeader_sections"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericHeaderList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1381
/** Converts an enum of type E_SgAsmGenericHeaderList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericHeaderList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericHeaderList_headers"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericHeaderList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericHeaderList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericSectionList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1378
/** Converts an enum of type E_SgAsmGenericSectionList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericSectionList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericSectionList_sections"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericSectionList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericSectionList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmGenericSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1375
/** Converts an enum of type E_SgAsmGenericSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmGenericSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmGenericSymbol_name"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmGenericSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmGenericSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1183
/** Converts an enum of type E_SgAsmInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInstruction_operandList"; break;
        case 1: retval = "SgAsmInstruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmIntegerValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1186
/** Converts an enum of type E_SgAsmIntegerValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmIntegerValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmIntegerValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmIntegerValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmIntegerValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInterpretation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1270
/** Converts an enum of type E_SgAsmInterpretation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInterpretation_global_block"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmInterpretation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmInterpretationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1507
/** Converts an enum of type E_SgAsmInterpretationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmInterpretationList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmInterpretationList_interpretations"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmInterpretationList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmInterpretationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEEntryPoint is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1450
/** Converts an enum of type E_SgAsmLEEntryPoint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryPoint(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEEntryPoint_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLEEntryPoint)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryPoint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1363
/** Converts an enum of type E_SgAsmLEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEEntryTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLEEntryTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1285
/** Converts an enum of type E_SgAsmLEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmLEFileHeader_dlls"; break;
        case 2: retval = "SgAsmLEFileHeader_sections"; break;
        case 3: retval = "SgAsmLEFileHeader_dos2_header"; break;
        case 4: retval = "SgAsmLEFileHeader_page_table"; break;
        case 5: retval = "SgAsmLEFileHeader_resname_table"; break;
        case 6: retval = "SgAsmLEFileHeader_nonresname_table"; break;
        case 7: retval = "SgAsmLEFileHeader_entry_table"; break;
        case 8: retval = "SgAsmLEFileHeader_reloc_table"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLEPageTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1360
/** Converts an enum of type E_SgAsmLEPageTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLEPageTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLEPageTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLEPageTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLEPageTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1366
/** Converts an enum of type E_SgAsmLERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLERelocTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLERelocTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLERelocTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmLESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1357
/** Converts an enum of type E_SgAsmLESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmLESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmLESection_st_entry"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmLESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmLESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmM68kInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1180
/** Converts an enum of type E_SgAsmM68kInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmM68kInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmM68kInstruction_operandList"; break;
        case 1: retval = "SgAsmM68kInstruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmM68kInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmM68kInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmMemoryReferenceExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1255
/** Converts an enum of type E_SgAsmMemoryReferenceExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmMemoryReferenceExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmMemoryReferenceExpression_address"; break;
        case 1: retval = "SgAsmMemoryReferenceExpression_segment"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmMemoryReferenceExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmMemoryReferenceExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmMipsInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1177
/** Converts an enum of type E_SgAsmMipsInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmMipsInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmMipsInstruction_operandList"; break;
        case 1: retval = "SgAsmMipsInstruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmMipsInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmMipsInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEEntryTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1351
/** Converts an enum of type E_SgAsmNEEntryTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEEntryTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEEntryTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmNEEntryTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEEntryTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1288
/** Converts an enum of type E_SgAsmNEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmNEFileHeader_dlls"; break;
        case 2: retval = "SgAsmNEFileHeader_sections"; break;
        case 3: retval = "SgAsmNEFileHeader_dos2_header"; break;
        case 4: retval = "SgAsmNEFileHeader_resname_table"; break;
        case 5: retval = "SgAsmNEFileHeader_nonresname_table"; break;
        case 6: retval = "SgAsmNEFileHeader_module_table"; break;
        case 7: retval = "SgAsmNEFileHeader_entry_table"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmNEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNEModuleTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1348
/** Converts an enum of type E_SgAsmNEModuleTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNEModuleTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNEModuleTable_strtab"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmNEModuleTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNEModuleTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNERelocTable is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1354
/** Converts an enum of type E_SgAsmNERelocTable to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNERelocTable(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNERelocTable_entries"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmNERelocTable)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNERelocTable::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmNESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1345
/** Converts an enum of type E_SgAsmNESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmNESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmNESection_st_entry"; break;
        case 1: retval = "SgAsmNESection_reloc_table"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmNESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmNESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1039
/** Converts an enum of type E_SgAsmOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmOp_expression"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmOperandList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1273
/** Converts an enum of type E_SgAsmOperandList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmOperandList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmOperandList_operands"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmOperandList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmOperandList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1435
/** Converts an enum of type E_SgAsmPEExportDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportDirectory(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportDirectory_name"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEExportDirectory)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportEntry is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1390
/** Converts an enum of type E_SgAsmPEExportEntry to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntry(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportEntry_name"; break;
        case 1: retval = "SgAsmPEExportEntry_forwarder"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEExportEntry)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntry::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportEntryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1393
/** Converts an enum of type E_SgAsmPEExportEntryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportEntryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportEntryList_exports"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEExportEntryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportEntryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEExportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1333
/** Converts an enum of type E_SgAsmPEExportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEExportSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEExportSection_section_entry"; break;
        case 1: retval = "SgAsmPEExportSection_export_dir"; break;
        case 2: retval = "SgAsmPEExportSection_exports"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEExportSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEExportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEFileHeader is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1282
/** Converts an enum of type E_SgAsmPEFileHeader to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEFileHeader(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEFileHeader_exec_format"; break;
        case 1: retval = "SgAsmPEFileHeader_dlls"; break;
        case 2: retval = "SgAsmPEFileHeader_sections"; break;
        case 3: retval = "SgAsmPEFileHeader_rvasize_pairs"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEFileHeader)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEFileHeader::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1432
/** Converts an enum of type E_SgAsmPEImportDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectory(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportDirectory_dll_name"; break;
        case 1: retval = "SgAsmPEImportDirectory_imports"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEImportDirectory)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1447
/** Converts an enum of type E_SgAsmPEImportDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportDirectoryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportDirectoryList_vector"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEImportDirectoryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportItem is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1501
/** Converts an enum of type E_SgAsmPEImportItem to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportItem(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportItem_name"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEImportItem)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportItem::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportItemList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1504
/** Converts an enum of type E_SgAsmPEImportItemList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportItemList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportItemList_vector"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEImportItemList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportItemList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEImportSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1330
/** Converts an enum of type E_SgAsmPEImportSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEImportSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEImportSection_section_entry"; break;
        case 1: retval = "SgAsmPEImportSection_import_directories"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEImportSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEImportSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPERVASizePairList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1441
/** Converts an enum of type E_SgAsmPERVASizePairList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPERVASizePairList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPERVASizePairList_pairs"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPERVASizePairList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPERVASizePairList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPESection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1339
/** Converts an enum of type E_SgAsmPESection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPESection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPESection_section_entry"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPESection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPESection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPEStringSection is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1336
/** Converts an enum of type E_SgAsmPEStringSection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPEStringSection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPEStringSection_section_entry"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPEStringSection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPEStringSection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmPowerpcInstruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1174
/** Converts an enum of type E_SgAsmPowerpcInstruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmPowerpcInstruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmPowerpcInstruction_operandList"; break;
        case 1: retval = "SgAsmPowerpcInstruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmPowerpcInstruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmPowerpcInstruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmRegisterNames is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1264
/** Converts an enum of type E_SgAsmRegisterNames to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmRegisterNames(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmRegisterNames_registers"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmRegisterNames)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmRegisterNames::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmRiscOperation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1267
/** Converts an enum of type E_SgAsmRiscOperation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmRiscOperation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmRiscOperation_operands"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmRiscOperation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmRiscOperation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:445
/** Converts an enum of type E_SgAsmStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmStmt_operands"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryArmSpecialRegisterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1249
/** Converts an enum of type E_SgAsmUnaryArmSpecialRegisterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryArmSpecialRegisterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryArmSpecialRegisterList_operand"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmUnaryArmSpecialRegisterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryArmSpecialRegisterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1252
/** Converts an enum of type E_SgAsmUnaryExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryExpression_operand"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmUnaryExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryMinus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1243
/** Converts an enum of type E_SgAsmUnaryMinus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryMinus(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryMinus_operand"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmUnaryMinus)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryMinus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryPlus is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1240
/** Converts an enum of type E_SgAsmUnaryPlus to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryPlus(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryPlus_operand"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmUnaryPlus)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryPlus::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmUnaryRrx is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1246
/** Converts an enum of type E_SgAsmUnaryRrx to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmUnaryRrx(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmUnaryRrx_operand"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmUnaryRrx)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmUnaryRrx::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmValueExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1195
/** Converts an enum of type E_SgAsmValueExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmValueExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmValueExpression_unfolded_expression_tree"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmValueExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmValueExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsmX86Instruction is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1168
/** Converts an enum of type E_SgAsmX86Instruction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsmX86Instruction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsmX86Instruction_operandList"; break;
        case 1: retval = "SgAsmX86Instruction_semantics"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsmX86Instruction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsmX86Instruction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssertStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:694
/** Converts an enum of type E_SgAssertStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssertStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssertStmt_test"; break;
        case 1: retval = "SgAssertStmt_exception_argument"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssertStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssertStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1006
/** Converts an enum of type E_SgAssignInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignInitializer_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssignInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:844
/** Converts an enum of type E_SgAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:610
/** Converts an enum of type E_SgAssignStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignStatement_value"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssignStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssignedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:616
/** Converts an enum of type E_SgAssignedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssignedGotoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssignedGotoStatement_targets"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssignedGotoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssignedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAssociateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:403
/** Converts an enum of type E_SgAssociateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAssociateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAssociateStatement_variable_declaration"; break;
        case 1: retval = "SgAssociateStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAssociateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAssociateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAsyncStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:706
/** Converts an enum of type E_SgAsyncStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAsyncStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAsyncStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAsyncStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAsyncStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgAtStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:712
/** Converts an enum of type E_SgAtStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgAtStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgAtStmt_expression"; break;
        case 1: retval = "SgAtStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgAtStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgAtStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBackspaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:583
/** Converts an enum of type E_SgBackspaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBackspaceStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBackspaceStatement_io_stmt_list"; break;
        case 1: retval = "SgBackspaceStatement_unit"; break;
        case 2: retval = "SgBackspaceStatement_iostat"; break;
        case 3: retval = "SgBackspaceStatement_err"; break;
        case 4: retval = "SgBackspaceStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBackspaceStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBackspaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBaseClass is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:19
/** Converts an enum of type E_SgBaseClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBaseClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBaseClass_base_class"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBaseClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBaseClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBasicBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:364
/** Converts an enum of type E_SgBasicBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBasicBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBasicBlock_statements"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBasicBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBasicBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBinaryComposite is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:7
/** Converts an enum of type E_SgBinaryComposite to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryComposite(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBinaryComposite_genericFileList"; break;
        case 1: retval = "SgBinaryComposite_interpretations"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBinaryComposite)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryComposite::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:943
/** Converts an enum of type E_SgBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBinaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBinaryOp_lhs_operand_i"; break;
        case 1: retval = "SgBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBinaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitAndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:823
/** Converts an enum of type E_SgBitAndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitAndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitAndOp_lhs_operand_i"; break;
        case 1: retval = "SgBitAndOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBitAndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitAndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitComplementOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:739
/** Converts an enum of type E_SgBitComplementOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitComplementOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitComplementOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBitComplementOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitComplementOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:826
/** Converts an enum of type E_SgBitOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitOrOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitOrOp_lhs_operand_i"; break;
        case 1: retval = "SgBitOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBitOrOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgBitXorOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:820
/** Converts an enum of type E_SgBitXorOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgBitXorOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgBitXorOp_lhs_operand_i"; break;
        case 1: retval = "SgBitXorOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgBitXorOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgBitXorOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCAFCoExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1048
/** Converts an enum of type E_SgCAFCoExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFCoExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCAFCoExpression_referData"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCAFCoExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFCoExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCAFWithTeamStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:418
/** Converts an enum of type E_SgCAFWithTeamStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCAFWithTeamStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCAFWithTeamStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCAFWithTeamStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCAFWithTeamStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCallExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:967
/** Converts an enum of type E_SgCallExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCallExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCallExpression_function"; break;
        case 1: retval = "SgCallExpression_args"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCallExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCallExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCaseOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:541
/** Converts an enum of type E_SgCaseOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCaseOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCaseOptionStmt_key"; break;
        case 1: retval = "SgCaseOptionStmt_body"; break;
        case 2: retval = "SgCaseOptionStmt_key_range_end"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCaseOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCaseOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCastExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:742
/** Converts an enum of type E_SgCastExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCastExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCastExp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCastExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCastExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCatchOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:397
/** Converts an enum of type E_SgCatchOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCatchOptionStmt_condition"; break;
        case 1: retval = "SgCatchOptionStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCatchOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCatchStatementSeq is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:559
/** Converts an enum of type E_SgCatchStatementSeq to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCatchStatementSeq(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCatchStatementSeq_catch_statement_seq"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCatchStatementSeq)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCatchStatementSeq::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:496
/** Converts an enum of type E_SgClassDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassDeclaration_definition"; break;
        case 1: retval = "SgClassDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgClassDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:385
/** Converts an enum of type E_SgClassDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassDefinition_members"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgClassDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1132
/** Converts an enum of type E_SgClassSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgClassSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgClassType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:139
/** Converts an enum of type E_SgClassType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgClassType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgClassType_type_kind"; break;
        case 1: retval = "SgClassType_builtin_type"; break;
        case 2: retval = "SgClassType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgClassType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgClassType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCloseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:574
/** Converts an enum of type E_SgCloseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCloseStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCloseStatement_io_stmt_list"; break;
        case 1: retval = "SgCloseStatement_unit"; break;
        case 2: retval = "SgCloseStatement_iostat"; break;
        case 3: retval = "SgCloseStatement_err"; break;
        case 4: retval = "SgCloseStatement_iomsg"; break;
        case 5: retval = "SgCloseStatement_status"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCloseStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCloseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommaOpExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:829
/** Converts an enum of type E_SgCommaOpExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommaOpExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommaOpExp_lhs_operand_i"; break;
        case 1: retval = "SgCommaOpExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCommaOpExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommaOpExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommonBlock is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:460
/** Converts an enum of type E_SgCommonBlock to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlock(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommonBlock_block_list"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCommonBlock)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlock::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCommonBlockObject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:229
/** Converts an enum of type E_SgCommonBlockObject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCommonBlockObject(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCommonBlockObject_variable_reference_list"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCommonBlockObject)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCommonBlockObject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComplexVal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:958
/** Converts an enum of type E_SgComplexVal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComplexVal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgComplexVal_real_value"; break;
        case 1: retval = "SgComplexVal_imaginary_value"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgComplexVal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComplexVal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCompoundAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:901
/** Converts an enum of type E_SgCompoundAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCompoundAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCompoundAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgCompoundAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCompoundAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCompoundAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCompoundInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1000
/** Converts an enum of type E_SgCompoundInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCompoundInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCompoundInitializer_initializers"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCompoundInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCompoundInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1063
/** Converts an enum of type E_SgComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComprehension(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgComprehension_target"; break;
        case 1: retval = "SgComprehension_iter"; break;
        case 2: retval = "SgComprehension_filters"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgComprehension)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgComputedGotoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:613
/** Converts an enum of type E_SgComputedGotoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgComputedGotoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgComputedGotoStatement_labelList"; break;
        case 1: retval = "SgComputedGotoStatement_label_index"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgComputedGotoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgComputedGotoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConcatenationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:853
/** Converts an enum of type E_SgConcatenationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConcatenationOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConcatenationOp_lhs_operand_i"; break;
        case 1: retval = "SgConcatenationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgConcatenationOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConcatenationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConditionalExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:988
/** Converts an enum of type E_SgConditionalExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConditionalExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConditionalExp_conditional_exp"; break;
        case 1: retval = "SgConditionalExp_true_exp"; break;
        case 2: retval = "SgConditionalExp_false_exp"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgConditionalExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConditionalExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConjugateOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:754
/** Converts an enum of type E_SgConjugateOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConjugateOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConjugateOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgConjugateOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConjugateOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgConstructorInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1003
/** Converts an enum of type E_SgConstructorInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgConstructorInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgConstructorInitializer_args"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgConstructorInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgConstructorInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCtorInitializerList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:475
/** Converts an enum of type E_SgCtorInitializerList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCtorInitializerList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCtorInitializerList_ctors"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCtorInitializerList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCtorInitializerList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCudaKernelCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:961
/** Converts an enum of type E_SgCudaKernelCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelCallExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCudaKernelCallExp_function"; break;
        case 1: retval = "SgCudaKernelCallExp_args"; break;
        case 2: retval = "SgCudaKernelCallExp_exec_config"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCudaKernelCallExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgCudaKernelExecConfig is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1051
/** Converts an enum of type E_SgCudaKernelExecConfig to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgCudaKernelExecConfig(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgCudaKernelExecConfig_grid"; break;
        case 1: retval = "SgCudaKernelExecConfig_blocks"; break;
        case 2: retval = "SgCudaKernelExecConfig_shared"; break;
        case 3: retval = "SgCudaKernelExecConfig_stream"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgCudaKernelExecConfig)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgCudaKernelExecConfig::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeallocateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:622
/** Converts an enum of type E_SgDeallocateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeallocateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDeallocateStatement_expr_list"; break;
        case 1: retval = "SgDeallocateStatement_stat_expression"; break;
        case 2: retval = "SgDeallocateStatement_errmsg_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDeallocateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeallocateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeclType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:214
/** Converts an enum of type E_SgDeclType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeclType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDeclType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDeclType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeclType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDefaultOptionStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:547
/** Converts an enum of type E_SgDefaultOptionStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDefaultOptionStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDefaultOptionStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDefaultOptionStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDefaultOptionStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDeleteExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:994
/** Converts an enum of type E_SgDeleteExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDeleteExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDeleteExp_variable"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDeleteExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDeleteExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDerivedTypeStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:487
/** Converts an enum of type E_SgDerivedTypeStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDerivedTypeStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDerivedTypeStatement_definition"; break;
        case 1: retval = "SgDerivedTypeStatement_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDerivedTypeStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDerivedTypeStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDesignatedInitializer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1009
/** Converts an enum of type E_SgDesignatedInitializer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDesignatedInitializer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDesignatedInitializer_designatorList"; break;
        case 1: retval = "SgDesignatedInitializer_memberInit"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDesignatedInitializer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDesignatedInitializer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDictionaryComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1072
/** Converts an enum of type E_SgDictionaryComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDictionaryComprehension(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDictionaryComprehension_element"; break;
        case 1: retval = "SgDictionaryComprehension_generators"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDictionaryComprehension)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDictionaryComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDictionaryExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1057
/** Converts an enum of type E_SgDictionaryExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDictionaryExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDictionaryExp_key_datum_pairs"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDictionaryExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDictionaryExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDirectory is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:28
/** Converts an enum of type E_SgDirectory to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectory(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDirectory_fileList"; break;
        case 1: retval = "SgDirectory_directoryList"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDirectory)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectory::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDirectoryList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:34
/** Converts an enum of type E_SgDirectoryList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDirectoryList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDirectoryList_listOfDirectories"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDirectoryList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDirectoryList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDivAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:877
/** Converts an enum of type E_SgDivAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDivAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgDivAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDivAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:805
/** Converts an enum of type E_SgDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDoWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:391
/** Converts an enum of type E_SgDoWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDoWhileStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDoWhileStmt_body"; break;
        case 1: retval = "SgDoWhileStmt_condition"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDoWhileStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDoWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDotExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:769
/** Converts an enum of type E_SgDotExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDotExp_lhs_operand_i"; break;
        case 1: retval = "SgDotExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDotExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgDotStarOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:772
/** Converts an enum of type E_SgDotStarOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgDotStarOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgDotStarOp_lhs_operand_i"; break;
        case 1: retval = "SgDotStarOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgDotStarOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgDotStarOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:928
/** Converts an enum of type E_SgElementwiseAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseAddOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseAddOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseAddOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseAddOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:925
/** Converts an enum of type E_SgElementwiseDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseLeftDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:922
/** Converts an enum of type E_SgElementwiseLeftDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseLeftDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseLeftDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseLeftDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseLeftDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseLeftDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseMultiplyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:916
/** Converts an enum of type E_SgElementwiseMultiplyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseMultiplyOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseMultiplyOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseMultiplyOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseMultiplyOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseMultiplyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:934
/** Converts an enum of type E_SgElementwiseOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwisePowerOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:919
/** Converts an enum of type E_SgElementwisePowerOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwisePowerOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwisePowerOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwisePowerOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwisePowerOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwisePowerOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElementwiseSubtractOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:931
/** Converts an enum of type E_SgElementwiseSubtractOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElementwiseSubtractOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElementwiseSubtractOp_lhs_operand_i"; break;
        case 1: retval = "SgElementwiseSubtractOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElementwiseSubtractOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElementwiseSubtractOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgElseWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:601
/** Converts an enum of type E_SgElseWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgElseWhereStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgElseWhereStatement_condition"; break;
        case 1: retval = "SgElseWhereStatement_body"; break;
        case 2: retval = "SgElseWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgElseWhereStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgElseWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEndfileStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:589
/** Converts an enum of type E_SgEndfileStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEndfileStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEndfileStatement_io_stmt_list"; break;
        case 1: retval = "SgEndfileStatement_unit"; break;
        case 2: retval = "SgEndfileStatement_iostat"; break;
        case 3: retval = "SgEndfileStatement_err"; break;
        case 4: retval = "SgEndfileStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEndfileStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEndfileStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEntryStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:523
/** Converts an enum of type E_SgEntryStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEntryStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEntryStatement_parameterList"; break;
        case 1: retval = "SgEntryStatement_decoratorList"; break;
        case 2: retval = "SgEntryStatement_definition"; break;
        case 3: retval = "SgEntryStatement_result_name"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEntryStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEntryStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:442
/** Converts an enum of type E_SgEnumDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumDeclaration_enumerators"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEnumDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1138
/** Converts an enum of type E_SgEnumSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEnumSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEnumType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:148
/** Converts an enum of type E_SgEnumType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEnumType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEnumType_type_kind"; break;
        case 1: retval = "SgEnumType_builtin_type"; break;
        case 2: retval = "SgEnumType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEnumType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEnumType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgEqualityOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:778
/** Converts an enum of type E_SgEqualityOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgEqualityOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgEqualityOp_lhs_operand_i"; break;
        case 1: retval = "SgEqualityOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgEqualityOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgEqualityOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExecStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:697
/** Converts an enum of type E_SgExecStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExecStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExecStatement_executable"; break;
        case 1: retval = "SgExecStatement_globals"; break;
        case 2: retval = "SgExecStatement_locals"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExecStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExecStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExpBaseClass is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:16
/** Converts an enum of type E_SgExpBaseClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExpBaseClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExpBaseClass_base_class"; break;
        case 1: retval = "SgExpBaseClass_base_class_exp"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExpBaseClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExpBaseClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExponentiationAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:898
/** Converts an enum of type E_SgExponentiationAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExponentiationAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExponentiationAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgExponentiationAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExponentiationAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExponentiationAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExponentiationOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:847
/** Converts an enum of type E_SgExponentiationOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExponentiationOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExponentiationOp_lhs_operand_i"; break;
        case 1: retval = "SgExponentiationOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExponentiationOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExponentiationOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExprListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:955
/** Converts an enum of type E_SgExprListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprListExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExprListExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExprListExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExprStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:538
/** Converts an enum of type E_SgExprStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExprStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExprStatement_expression"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExprStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExprStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgExpressionRoot is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:715
/** Converts an enum of type E_SgExpressionRoot to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgExpressionRoot(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgExpressionRoot_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgExpressionRoot)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgExpressionRoot::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFileList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:31
/** Converts an enum of type E_SgFileList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFileList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFileList_listOfFiles"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFileList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFileList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFinishStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:709
/** Converts an enum of type E_SgFinishStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFinishStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFinishStmt_body"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFinishStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFinishStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:580
/** Converts an enum of type E_SgFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFlushStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFlushStatement_io_stmt_list"; break;
        case 1: retval = "SgFlushStatement_unit"; break;
        case 2: retval = "SgFlushStatement_iostat"; break;
        case 3: retval = "SgFlushStatement_err"; break;
        case 4: retval = "SgFlushStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFlushStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:412
/** Converts an enum of type E_SgForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForAllStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForAllStatement_forall_header"; break;
        case 1: retval = "SgForAllStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgForAllStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForInitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:556
/** Converts an enum of type E_SgForInitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForInitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForInitStatement_init_stmt"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgForInitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForInitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:370
/** Converts an enum of type E_SgForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgForStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgForStatement_for_init_stmt"; break;
        case 1: retval = "SgForStatement_test"; break;
        case 2: retval = "SgForStatement_increment"; break;
        case 3: retval = "SgForStatement_loop_body"; break;
        case 4: retval = "SgForStatement_else_body"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgForStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFortranDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:409
/** Converts an enum of type E_SgFortranDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFortranDo_initialization"; break;
        case 1: retval = "SgFortranDo_bound"; break;
        case 2: retval = "SgFortranDo_increment"; break;
        case 3: retval = "SgFortranDo_body"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFortranDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFortranNonblockedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:406
/** Converts an enum of type E_SgFortranNonblockedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFortranNonblockedDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFortranNonblockedDo_initialization"; break;
        case 1: retval = "SgFortranNonblockedDo_bound"; break;
        case 2: retval = "SgFortranNonblockedDo_increment"; break;
        case 3: retval = "SgFortranNonblockedDo_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFortranNonblockedDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFortranNonblockedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionCallExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:964
/** Converts an enum of type E_SgFunctionCallExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionCallExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionCallExp_function"; break;
        case 1: retval = "SgFunctionCallExp_args"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionCallExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionCallExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:526
/** Converts an enum of type E_SgFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgFunctionDeclaration_decoratorList"; break;
        case 2: retval = "SgFunctionDeclaration_definition"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:376
/** Converts an enum of type E_SgFunctionDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionDefinition_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:430
/** Converts an enum of type E_SgFunctionParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionParameterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionParameterList_args"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionParameterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionParameterRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1102
/** Converts an enum of type E_SgFunctionParameterRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionParameterRefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionParameterRefExp_parameter_expression"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionParameterRefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionParameterRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1126
/** Converts an enum of type E_SgFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:172
/** Converts an enum of type E_SgFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgFunctionType_type_kind"; break;
        case 1: retval = "SgFunctionType_return_type"; break;
        case 2: retval = "SgFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGlobal is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:361
/** Converts an enum of type E_SgGlobal to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGlobal(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGlobal_declarations"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgGlobal)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGlobal::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGreaterOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:793
/** Converts an enum of type E_SgGreaterOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterOrEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGreaterOrEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgGreaterOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgGreaterOrEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgGreaterThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:784
/** Converts an enum of type E_SgGreaterThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgGreaterThanOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgGreaterThanOp_lhs_operand_i"; break;
        case 1: retval = "SgGreaterThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgGreaterThanOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgGreaterThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgHereExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1108
/** Converts an enum of type E_SgHereExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgHereExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgHereExp_expression"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgHereExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgHereExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIOItemExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1033
/** Converts an enum of type E_SgIOItemExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOItemExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIOItemExpression_io_item"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIOItemExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOItemExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIOStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:595
/** Converts an enum of type E_SgIOStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIOStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIOStatement_io_stmt_list"; break;
        case 1: retval = "SgIOStatement_unit"; break;
        case 2: retval = "SgIOStatement_iostat"; break;
        case 3: retval = "SgIOStatement_err"; break;
        case 4: retval = "SgIOStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIOStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIOStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIfStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:367
/** Converts an enum of type E_SgIfStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIfStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIfStmt_conditional"; break;
        case 1: retval = "SgIfStmt_true_body"; break;
        case 2: retval = "SgIfStmt_false_body"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIfStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIfStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImagPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:751
/** Converts an enum of type E_SgImagPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImagPartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImagPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgImagPartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImagPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImplicitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:499
/** Converts an enum of type E_SgImplicitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImplicitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImplicitStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgImplicitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImplicitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgImpliedDo is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1030
/** Converts an enum of type E_SgImpliedDo to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgImpliedDo(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgImpliedDo_do_var_initialization"; break;
        case 1: retval = "SgImpliedDo_last_val"; break;
        case 2: retval = "SgImpliedDo_increment"; break;
        case 3: retval = "SgImpliedDo_object_list"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgImpliedDo)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgImpliedDo::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIncludeDirectiveStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:529
/** Converts an enum of type E_SgIncludeDirectiveStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIncludeDirectiveStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIncludeDirectiveStatement_headerFileBody"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIncludeDirectiveStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIncludeDirectiveStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInitializedName is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:232
/** Converts an enum of type E_SgInitializedName to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInitializedName(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInitializedName_initptr"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgInitializedName)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInitializedName::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInquireStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:577
/** Converts an enum of type E_SgInquireStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInquireStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInquireStatement_io_stmt_list"; break;
        case 1: retval = "SgInquireStatement_unit"; break;
        case 2: retval = "SgInquireStatement_iostat"; break;
        case 3: retval = "SgInquireStatement_err"; break;
        case 4: retval = "SgInquireStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgInquireStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInquireStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIntegerDivideAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:895
/** Converts an enum of type E_SgIntegerDivideAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntegerDivideAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIntegerDivideAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgIntegerDivideAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIntegerDivideAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntegerDivideAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIntegerDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:808
/** Converts an enum of type E_SgIntegerDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIntegerDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIntegerDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgIntegerDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIntegerDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIntegerDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgInterfaceStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:457
/** Converts an enum of type E_SgInterfaceStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgInterfaceStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgInterfaceStatement_interface_body_list"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgInterfaceStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgInterfaceStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:871
/** Converts an enum of type E_SgIorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIorAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIorAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgIorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIorAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIsNotOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:913
/** Converts an enum of type E_SgIsNotOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIsNotOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIsNotOp_lhs_operand_i"; break;
        case 1: retval = "SgIsNotOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIsNotOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIsNotOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgIsOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:910
/** Converts an enum of type E_SgIsOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgIsOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgIsOp_lhs_operand_i"; break;
        case 1: retval = "SgIsOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgIsOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgIsOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaClassDeclarationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:46
/** Converts an enum of type E_SgJavaClassDeclarationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaClassDeclarationList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaClassDeclarationList_java_class_list"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaClassDeclarationList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaClassDeclarationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaForEachStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:421
/** Converts an enum of type E_SgJavaForEachStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaForEachStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaForEachStatement_element"; break;
        case 1: retval = "SgJavaForEachStatement_collection"; break;
        case 2: retval = "SgJavaForEachStatement_loop_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaForEachStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaForEachStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaImportStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:43
/** Converts an enum of type E_SgJavaImportStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaImportStatementList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaImportStatementList_java_import_list"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaImportStatementList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaImportStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaInstanceOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:982
/** Converts an enum of type E_SgJavaInstanceOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaInstanceOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaInstanceOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaInstanceOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaInstanceOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaLabelStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:424
/** Converts an enum of type E_SgJavaLabelStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaLabelStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaLabelStatement_statement"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaLabelStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaLabelStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaLabelSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1159
/** Converts an enum of type E_SgJavaLabelSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaLabelSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaLabelSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaLabelSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaLabelSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaMemberValuePair is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:235
/** Converts an enum of type E_SgJavaMemberValuePair to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaMemberValuePair(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaMemberValuePair_value"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaMemberValuePair)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaMemberValuePair::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaNormalAnnotation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1099
/** Converts an enum of type E_SgJavaNormalAnnotation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaNormalAnnotation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaNormalAnnotation_value_pair_list"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaNormalAnnotation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaNormalAnnotation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaPackageDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:493
/** Converts an enum of type E_SgJavaPackageDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaPackageDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaPackageDeclaration_definition"; break;
        case 1: retval = "SgJavaPackageDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaPackageDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaPackageDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaParameterType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:136
/** Converts an enum of type E_SgJavaParameterType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaParameterType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaParameterType_type_kind"; break;
        case 1: retval = "SgJavaParameterType_builtin_type"; break;
        case 2: retval = "SgJavaParameterType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaParameterType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaParameterType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaParameterizedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:142
/** Converts an enum of type E_SgJavaParameterizedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaParameterizedType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaParameterizedType_type_kind"; break;
        case 1: retval = "SgJavaParameterizedType_builtin_type"; break;
        case 2: retval = "SgJavaParameterizedType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaParameterizedType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaParameterizedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaQualifiedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:145
/** Converts an enum of type E_SgJavaQualifiedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaQualifiedType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaQualifiedType_type_kind"; break;
        case 1: retval = "SgJavaQualifiedType_builtin_type"; break;
        case 2: retval = "SgJavaQualifiedType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaQualifiedType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaQualifiedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaSingleMemberAnnotation is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1096
/** Converts an enum of type E_SgJavaSingleMemberAnnotation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaSingleMemberAnnotation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaSingleMemberAnnotation_value"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaSingleMemberAnnotation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaSingleMemberAnnotation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaSynchronizedStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:703
/** Converts an enum of type E_SgJavaSynchronizedStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaSynchronizedStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaSynchronizedStatement_expression"; break;
        case 1: retval = "SgJavaSynchronizedStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaSynchronizedStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaSynchronizedStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:205
/** Converts an enum of type E_SgJavaUnionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaUnionType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaUnionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnsignedRshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:892
/** Converts an enum of type E_SgJavaUnsignedRshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnsignedRshiftAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaUnsignedRshiftAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgJavaUnsignedRshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaUnsignedRshiftAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnsignedRshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaUnsignedRshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:850
/** Converts an enum of type E_SgJavaUnsignedRshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaUnsignedRshiftOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaUnsignedRshiftOp_lhs_operand_i"; break;
        case 1: retval = "SgJavaUnsignedRshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaUnsignedRshiftOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaUnsignedRshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgJavaWildcardType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:154
/** Converts an enum of type E_SgJavaWildcardType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgJavaWildcardType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgJavaWildcardType_type_kind"; break;
        case 1: retval = "SgJavaWildcardType_builtin_type"; break;
        case 2: retval = "SgJavaWildcardType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgJavaWildcardType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgJavaWildcardType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgKeyDatumPair is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1060
/** Converts an enum of type E_SgKeyDatumPair to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgKeyDatumPair(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgKeyDatumPair_key"; break;
        case 1: retval = "SgKeyDatumPair_datum"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgKeyDatumPair)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgKeyDatumPair::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLabelSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1147
/** Converts an enum of type E_SgLabelSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLabelSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLabelSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLabelSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLabelSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaCapture is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:355
/** Converts an enum of type E_SgLambdaCapture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaCapture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLambdaCapture_capture_variable"; break;
        case 1: retval = "SgLambdaCapture_source_closure_variable"; break;
        case 2: retval = "SgLambdaCapture_closure_variable"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLambdaCapture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaCapture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaCaptureList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:358
/** Converts an enum of type E_SgLambdaCaptureList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaCaptureList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLambdaCaptureList_capture_list"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLambdaCaptureList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaCaptureList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1105
/** Converts an enum of type E_SgLambdaExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLambdaExp_lambda_capture_list"; break;
        case 1: retval = "SgLambdaExp_lambda_function"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLambdaExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLambdaRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1054
/** Converts an enum of type E_SgLambdaRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLambdaRefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLambdaRefExp_functionDeclaration"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLambdaRefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLambdaRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLeftDivideOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:940
/** Converts an enum of type E_SgLeftDivideOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLeftDivideOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLeftDivideOp_lhs_operand_i"; break;
        case 1: retval = "SgLeftDivideOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLeftDivideOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLeftDivideOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLessOrEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:790
/** Converts an enum of type E_SgLessOrEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessOrEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLessOrEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgLessOrEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLessOrEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessOrEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLessThanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:781
/** Converts an enum of type E_SgLessThanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLessThanOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLessThanOp_lhs_operand_i"; break;
        case 1: retval = "SgLessThanOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLessThanOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLessThanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgListComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1066
/** Converts an enum of type E_SgListComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgListComprehension(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgListComprehension_element"; break;
        case 1: retval = "SgListComprehension_generators"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgListComprehension)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgListComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgListExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:946
/** Converts an enum of type E_SgListExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgListExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgListExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgListExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgListExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:886
/** Converts an enum of type E_SgLshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLshiftAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgLshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLshiftAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgLshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:832
/** Converts an enum of type E_SgLshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgLshiftOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgLshiftOp_lhs_operand_i"; break;
        case 1: retval = "SgLshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgLshiftOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgLshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatlabForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:427
/** Converts an enum of type E_SgMatlabForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatlabForStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMatlabForStatement_index"; break;
        case 1: retval = "SgMatlabForStatement_range"; break;
        case 2: retval = "SgMatlabForStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMatlabForStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatlabForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatrixExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:952
/** Converts an enum of type E_SgMatrixExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatrixExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMatrixExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMatrixExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatrixExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMatrixTransposeOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:760
/** Converts an enum of type E_SgMatrixTransposeOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMatrixTransposeOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMatrixTransposeOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMatrixTransposeOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMatrixTransposeOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:511
/** Converts an enum of type E_SgMemberFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgMemberFunctionDeclaration_decoratorList"; break;
        case 2: retval = "SgMemberFunctionDeclaration_definition"; break;
        case 3: retval = "SgMemberFunctionDeclaration_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMemberFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1117
/** Converts an enum of type E_SgMemberFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMemberFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMemberFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:169
/** Converts an enum of type E_SgMemberFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMemberFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMemberFunctionType_type_kind"; break;
        case 1: retval = "SgMemberFunctionType_return_type"; break;
        case 2: retval = "SgMemberFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMemberFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMemberFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMembershipOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:904
/** Converts an enum of type E_SgMembershipOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMembershipOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMembershipOp_lhs_operand_i"; break;
        case 1: retval = "SgMembershipOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMembershipOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMembershipOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:865
/** Converts an enum of type E_SgMinusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgMinusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMinusAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:733
/** Converts an enum of type E_SgMinusMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusMinusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMinusMinusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMinusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:718
/** Converts an enum of type E_SgMinusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMinusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMinusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMinusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMinusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:880
/** Converts an enum of type E_SgModAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgModAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgModAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:811
/** Converts an enum of type E_SgModOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModOp_lhs_operand_i"; break;
        case 1: retval = "SgModOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgModOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:160
/** Converts an enum of type E_SgModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModifierType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModifierType_type_kind"; break;
        case 1: retval = "SgModifierType_base_type"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgModifierType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModuleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:490
/** Converts an enum of type E_SgModuleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModuleStatement_definition"; break;
        case 1: retval = "SgModuleStatement_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgModuleStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgModuleSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1153
/** Converts an enum of type E_SgModuleSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgModuleSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgModuleSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgModuleSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgModuleSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMultAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:874
/** Converts an enum of type E_SgMultAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMultAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgMultAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMultAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgMultiplyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:802
/** Converts an enum of type E_SgMultiplyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgMultiplyOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgMultiplyOp_lhs_operand_i"; break;
        case 1: retval = "SgMultiplyOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgMultiplyOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgMultiplyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:157
/** Converts an enum of type E_SgNamedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamedType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamedType_type_kind"; break;
        case 1: retval = "SgNamedType_builtin_type"; break;
        case 2: retval = "SgNamedType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNamedType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceDeclarationStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:454
/** Converts an enum of type E_SgNamespaceDeclarationStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDeclarationStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceDeclarationStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNamespaceDeclarationStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDeclarationStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceDefinitionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:400
/** Converts an enum of type E_SgNamespaceDefinitionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceDefinitionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceDefinitionStatement_declarations"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNamespaceDefinitionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceDefinitionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNamespaceSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1150
/** Converts an enum of type E_SgNamespaceSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNamespaceSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNamespaceSymbol_declaration"; break;
        case 1: retval = "SgNamespaceSymbol_aliasDeclaration"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNamespaceSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNamespaceSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryBooleanOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1075
/** Converts an enum of type E_SgNaryBooleanOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryBooleanOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNaryBooleanOp_operands"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNaryBooleanOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryBooleanOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryComparisonOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1078
/** Converts an enum of type E_SgNaryComparisonOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryComparisonOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNaryComparisonOp_operands"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNaryComparisonOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryComparisonOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1081
/** Converts an enum of type E_SgNaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNaryOp_operands"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNewExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:991
/** Converts an enum of type E_SgNewExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNewExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNewExp_placement_args"; break;
        case 1: retval = "SgNewExp_constructor_args"; break;
        case 2: retval = "SgNewExp_builtin_args"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNewExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNewExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNoexceptOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1111
/** Converts an enum of type E_SgNoexceptOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNoexceptOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNoexceptOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNoexceptOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNoexceptOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNonMembershipOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:907
/** Converts an enum of type E_SgNonMembershipOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNonMembershipOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNonMembershipOp_lhs_operand_i"; break;
        case 1: retval = "SgNonMembershipOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNonMembershipOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNonMembershipOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNotEqualOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:787
/** Converts an enum of type E_SgNotEqualOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotEqualOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNotEqualOp_lhs_operand_i"; break;
        case 1: retval = "SgNotEqualOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNotEqualOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotEqualOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNotOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:724
/** Converts an enum of type E_SgNotOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNotOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNotOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[73];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNotOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNotOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgNullifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:604
/** Converts an enum of type E_SgNullifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgNullifyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgNullifyStatement_pointer_list"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgNullifyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgNullifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpAlignedClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:286
/** Converts an enum of type E_SgOmpAlignedClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpAlignedClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpAlignedClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpAlignedClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpAlignedClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpAtomicStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:637
/** Converts an enum of type E_SgOmpAtomicStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpAtomicStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpAtomicStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpAtomicStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpAtomicStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:685
/** Converts an enum of type E_SgOmpBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpBodyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpBodyStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpBodyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpClauseBodyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:682
/** Converts an enum of type E_SgOmpClauseBodyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpClauseBodyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpClauseBodyStatement_body"; break;
        case 1: retval = "SgOmpClauseBodyStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpClauseBodyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpClauseBodyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCollapseClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:238
/** Converts an enum of type E_SgOmpCollapseClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCollapseClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCollapseClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpCollapseClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCollapseClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCopyinClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:268
/** Converts an enum of type E_SgOmpCopyinClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyinClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCopyinClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpCopyinClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyinClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCopyprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:256
/** Converts an enum of type E_SgOmpCopyprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCopyprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCopyprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpCopyprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCopyprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpCriticalStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:646
/** Converts an enum of type E_SgOmpCriticalStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpCriticalStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpCriticalStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpCriticalStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpCriticalStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpDeviceClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:247
/** Converts an enum of type E_SgOmpDeviceClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpDeviceClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpDeviceClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpDeviceClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpDeviceClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpDoStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:667
/** Converts an enum of type E_SgOmpDoStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpDoStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpDoStatement_body"; break;
        case 1: retval = "SgOmpDoStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpDoStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpDoStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpExpressionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:253
/** Converts an enum of type E_SgOmpExpressionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpExpressionClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpExpressionClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpExpressionClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpExpressionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpFirstprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:262
/** Converts an enum of type E_SgOmpFirstprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFirstprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpFirstprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpFirstprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFirstprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpFlushStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:634
/** Converts an enum of type E_SgOmpFlushStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpFlushStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpFlushStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpFlushStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpFlushStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpForStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:664
/** Converts an enum of type E_SgOmpForStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpForStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpForStatement_body"; break;
        case 1: retval = "SgOmpForStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpForStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpForStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpIfClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:241
/** Converts an enum of type E_SgOmpIfClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpIfClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpIfClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpIfClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpIfClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpLastprivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:271
/** Converts an enum of type E_SgOmpLastprivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpLastprivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpLastprivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpLastprivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpLastprivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpLinearClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:280
/** Converts an enum of type E_SgOmpLinearClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpLinearClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpLinearClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpLinearClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpLinearClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpMapClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:277
/** Converts an enum of type E_SgOmpMapClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpMapClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpMapClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpMapClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpMapClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpMasterStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:640
/** Converts an enum of type E_SgOmpMasterStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpMasterStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpMasterStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpMasterStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpMasterStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpNumThreadsClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:244
/** Converts an enum of type E_SgOmpNumThreadsClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpNumThreadsClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpNumThreadsClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpNumThreadsClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpNumThreadsClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpOrderedStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:643
/** Converts an enum of type E_SgOmpOrderedStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpOrderedStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpOrderedStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpOrderedStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpOrderedStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpParallelStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:655
/** Converts an enum of type E_SgOmpParallelStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpParallelStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpParallelStatement_body"; break;
        case 1: retval = "SgOmpParallelStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpParallelStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpParallelStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpPrivateClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:259
/** Converts an enum of type E_SgOmpPrivateClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpPrivateClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpPrivateClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpPrivateClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpPrivateClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpReductionClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:274
/** Converts an enum of type E_SgOmpReductionClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpReductionClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpReductionClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpReductionClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpReductionClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSafelenClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:250
/** Converts an enum of type E_SgOmpSafelenClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSafelenClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSafelenClause_expression"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSafelenClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSafelenClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpScheduleClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:292
/** Converts an enum of type E_SgOmpScheduleClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpScheduleClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpScheduleClause_chunk_size"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpScheduleClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpScheduleClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSectionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:649
/** Converts an enum of type E_SgOmpSectionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSectionStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSectionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSectionsStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:670
/** Converts an enum of type E_SgOmpSectionsStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSectionsStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSectionsStatement_body"; break;
        case 1: retval = "SgOmpSectionsStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSectionsStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSectionsStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSharedClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:265
/** Converts an enum of type E_SgOmpSharedClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSharedClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSharedClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSharedClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSharedClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSimdStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:679
/** Converts an enum of type E_SgOmpSimdStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSimdStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSimdStatement_body"; break;
        case 1: retval = "SgOmpSimdStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSimdStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSimdStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpSingleStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:658
/** Converts an enum of type E_SgOmpSingleStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpSingleStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpSingleStatement_body"; break;
        case 1: retval = "SgOmpSingleStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpSingleStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpSingleStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTargetDataStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:676
/** Converts an enum of type E_SgOmpTargetDataStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTargetDataStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpTargetDataStatement_body"; break;
        case 1: retval = "SgOmpTargetDataStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpTargetDataStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTargetDataStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTargetStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:673
/** Converts an enum of type E_SgOmpTargetStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTargetStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpTargetStatement_body"; break;
        case 1: retval = "SgOmpTargetStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpTargetStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTargetStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpTaskStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:661
/** Converts an enum of type E_SgOmpTaskStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpTaskStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpTaskStatement_body"; break;
        case 1: retval = "SgOmpTaskStatement_clauses"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpTaskStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpTaskStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpThreadprivateStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:532
/** Converts an enum of type E_SgOmpThreadprivateStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpThreadprivateStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpThreadprivateStatement_variables"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpThreadprivateStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpThreadprivateStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpUniformClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:283
/** Converts an enum of type E_SgOmpUniformClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpUniformClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpUniformClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpUniformClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpUniformClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpVariablesClause is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:289
/** Converts an enum of type E_SgOmpVariablesClause to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpVariablesClause(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpVariablesClause_variables"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpVariablesClause)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpVariablesClause::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOmpWorkshareStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:652
/** Converts an enum of type E_SgOmpWorkshareStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOmpWorkshareStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOmpWorkshareStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOmpWorkshareStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOmpWorkshareStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOpenStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:571
/** Converts an enum of type E_SgOpenStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOpenStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOpenStatement_io_stmt_list"; break;
        case 1: retval = "SgOpenStatement_unit"; break;
        case 2: retval = "SgOpenStatement_iostat"; break;
        case 3: retval = "SgOpenStatement_err"; break;
        case 4: retval = "SgOpenStatement_iomsg"; break;
        case 5: retval = "SgOpenStatement_file"; break;
        case 6: retval = "SgOpenStatement_status"; break;
        case 7: retval = "SgOpenStatement_access"; break;
        case 8: retval = "SgOpenStatement_form"; break;
        case 9: retval = "SgOpenStatement_recl"; break;
        case 10: retval = "SgOpenStatement_blank"; break;
        case 11: retval = "SgOpenStatement_position"; break;
        case 12: retval = "SgOpenStatement_action"; break;
        case 13: retval = "SgOpenStatement_delim"; break;
        case 14: retval = "SgOpenStatement_pad"; break;
        case 15: retval = "SgOpenStatement_round"; break;
        case 16: retval = "SgOpenStatement_sign"; break;
        case 17: retval = "SgOpenStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOpenStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOpenStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgOrOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:817
/** Converts an enum of type E_SgOrOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgOrOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgOrOp_lhs_operand_i"; break;
        case 1: retval = "SgOrOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgOrOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgOrOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPartialFunctionModifierType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:163
/** Converts an enum of type E_SgPartialFunctionModifierType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionModifierType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPartialFunctionModifierType_type_kind"; break;
        case 1: retval = "SgPartialFunctionModifierType_return_type"; break;
        case 2: retval = "SgPartialFunctionModifierType_orig_return_type"; break;
        case 3: retval = "SgPartialFunctionModifierType_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPartialFunctionModifierType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionModifierType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPartialFunctionType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:166
/** Converts an enum of type E_SgPartialFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPartialFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPartialFunctionType_type_kind"; break;
        case 1: retval = "SgPartialFunctionType_return_type"; break;
        case 2: retval = "SgPartialFunctionType_orig_return_type"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPartialFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPartialFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPlusAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:862
/** Converts an enum of type E_SgPlusAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPlusAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgPlusAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPlusAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPlusPlusOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:736
/** Converts an enum of type E_SgPlusPlusOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPlusPlusOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPlusPlusOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPlusPlusOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPlusPlusOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPntrArrRefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:838
/** Converts an enum of type E_SgPntrArrRefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPntrArrRefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPntrArrRefExp_lhs_operand_i"; break;
        case 1: retval = "SgPntrArrRefExp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPntrArrRefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPntrArrRefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:856
/** Converts an enum of type E_SgPointerAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgPointerAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPointerAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerDerefExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:727
/** Converts an enum of type E_SgPointerDerefExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerDerefExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerDerefExp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPointerDerefExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerDerefExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerMemberType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:127
/** Converts an enum of type E_SgPointerMemberType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerMemberType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerMemberType_type_kind"; break;
        case 1: retval = "SgPointerMemberType_base_type"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPointerMemberType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerMemberType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPointerType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:130
/** Converts an enum of type E_SgPointerType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPointerType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPointerType_type_kind"; break;
        case 1: retval = "SgPointerType_base_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPointerType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPointerType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPowerOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:937
/** Converts an enum of type E_SgPowerOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPowerOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPowerOp_lhs_operand_i"; break;
        case 1: retval = "SgPowerOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPowerOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPowerOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPragmaDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:478
/** Converts an enum of type E_SgPragmaDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPragmaDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPragmaDeclaration_pragma"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPragmaDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPragmaDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPrintStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:562
/** Converts an enum of type E_SgPrintStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPrintStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPrintStatement_io_stmt_list"; break;
        case 1: retval = "SgPrintStatement_unit"; break;
        case 2: retval = "SgPrintStatement_iostat"; break;
        case 3: retval = "SgPrintStatement_err"; break;
        case 4: retval = "SgPrintStatement_iomsg"; break;
        case 5: retval = "SgPrintStatement_format"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPrintStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPrintStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProcedureHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:520
/** Converts an enum of type E_SgProcedureHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProcedureHeaderStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProcedureHeaderStatement_parameterList"; break;
        case 1: retval = "SgProcedureHeaderStatement_decoratorList"; break;
        case 2: retval = "SgProcedureHeaderStatement_definition"; break;
        case 3: retval = "SgProcedureHeaderStatement_result_name"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgProcedureHeaderStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProcedureHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProgramHeaderStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:517
/** Converts an enum of type E_SgProgramHeaderStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProgramHeaderStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProgramHeaderStatement_parameterList"; break;
        case 1: retval = "SgProgramHeaderStatement_decoratorList"; break;
        case 2: retval = "SgProgramHeaderStatement_definition"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgProgramHeaderStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProgramHeaderStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgProject is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:13
/** Converts an enum of type E_SgProject to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgProject(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgProject_fileList_ptr"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgProject)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgProject::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPythonGlobalStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:700
/** Converts an enum of type E_SgPythonGlobalStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPythonGlobalStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPythonGlobalStmt_names"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPythonGlobalStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPythonGlobalStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgPythonPrintStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:691
/** Converts an enum of type E_SgPythonPrintStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgPythonPrintStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgPythonPrintStmt_destination"; break;
        case 1: retval = "SgPythonPrintStmt_values"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgPythonPrintStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgPythonPrintStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgQualifiedNameType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:184
/** Converts an enum of type E_SgQualifiedNameType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgQualifiedNameType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgQualifiedNameType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgQualifiedNameType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgQualifiedNameType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRangeExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1093
/** Converts an enum of type E_SgRangeExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRangeExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRangeExp_start"; break;
        case 1: retval = "SgRangeExp_end"; break;
        case 2: retval = "SgRangeExp_stride"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRangeExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRangeExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReadStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:565
/** Converts an enum of type E_SgReadStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReadStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReadStatement_io_stmt_list"; break;
        case 1: retval = "SgReadStatement_unit"; break;
        case 2: retval = "SgReadStatement_iostat"; break;
        case 3: retval = "SgReadStatement_err"; break;
        case 4: retval = "SgReadStatement_iomsg"; break;
        case 5: retval = "SgReadStatement_format"; break;
        case 6: retval = "SgReadStatement_rec"; break;
        case 7: retval = "SgReadStatement_end"; break;
        case 8: retval = "SgReadStatement_namelist"; break;
        case 9: retval = "SgReadStatement_advance"; break;
        case 10: retval = "SgReadStatement_size"; break;
        case 11: retval = "SgReadStatement_eor"; break;
        case 12: retval = "SgReadStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgReadStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReadStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRealPartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:748
/** Converts an enum of type E_SgRealPartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRealPartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRealPartOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRealPartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRealPartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReferenceType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:133
/** Converts an enum of type E_SgReferenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReferenceType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReferenceType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgReferenceType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReferenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRenameSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1123
/** Converts an enum of type E_SgRenameSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRenameSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRenameSymbol_declaration"; break;
        case 1: retval = "SgRenameSymbol_original_symbol"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRenameSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRenameSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgReturnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:550
/** Converts an enum of type E_SgReturnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgReturnStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgReturnStmt_expression"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgReturnStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgReturnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRewindStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:586
/** Converts an enum of type E_SgRewindStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRewindStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRewindStatement_io_stmt_list"; break;
        case 1: retval = "SgRewindStatement_unit"; break;
        case 2: retval = "SgRewindStatement_iostat"; break;
        case 3: retval = "SgRewindStatement_err"; break;
        case 4: retval = "SgRewindStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRewindStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRewindStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRshiftAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:889
/** Converts an enum of type E_SgRshiftAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRshiftAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgRshiftAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRshiftAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRshiftOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:835
/** Converts an enum of type E_SgRshiftOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRshiftOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRshiftOp_lhs_operand_i"; break;
        case 1: retval = "SgRshiftOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRshiftOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRshiftOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgRvalueReferenceType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:208
/** Converts an enum of type E_SgRvalueReferenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgRvalueReferenceType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgRvalueReferenceType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgRvalueReferenceType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgRvalueReferenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgScopeOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:841
/** Converts an enum of type E_SgScopeOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgScopeOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgScopeOp_lhs_operand_i"; break;
        case 1: retval = "SgScopeOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgScopeOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgScopeOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSetComprehension is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1069
/** Converts an enum of type E_SgSetComprehension to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSetComprehension(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSetComprehension_element"; break;
        case 1: retval = "SgSetComprehension_generators"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSetComprehension)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSetComprehension::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSizeOfOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:970
/** Converts an enum of type E_SgSizeOfOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSizeOfOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSizeOfOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSizeOfOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSizeOfOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSourceFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:4
/** Converts an enum of type E_SgSourceFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSourceFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSourceFile_globalScope"; break;
        case 1: retval = "SgSourceFile_package"; break;
        case 2: retval = "SgSourceFile_import_list"; break;
        case 3: retval = "SgSourceFile_class_list"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSourceFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSourceFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSpawnStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:553
/** Converts an enum of type E_SgSpawnStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSpawnStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSpawnStmt_the_func"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSpawnStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSpawnStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStatementExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1036
/** Converts an enum of type E_SgStatementExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStatementExpression_statement"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgStatementExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStatementFunctionStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:472
/** Converts an enum of type E_SgStatementFunctionStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStatementFunctionStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStatementFunctionStatement_function"; break;
        case 1: retval = "SgStatementFunctionStatement_expression"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgStatementFunctionStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStatementFunctionStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStmtDeclarationStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:535
/** Converts an enum of type E_SgStmtDeclarationStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStmtDeclarationStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStmtDeclarationStatement_statement"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgStmtDeclarationStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStmtDeclarationStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgStringConversion is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1084
/** Converts an enum of type E_SgStringConversion to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgStringConversion(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgStringConversion_expression"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgStringConversion)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgStringConversion::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSubscriptExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1027
/** Converts an enum of type E_SgSubscriptExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubscriptExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSubscriptExpression_lowerBound"; break;
        case 1: retval = "SgSubscriptExpression_upperBound"; break;
        case 2: retval = "SgSubscriptExpression_stride"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSubscriptExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubscriptExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSubtractOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:799
/** Converts an enum of type E_SgSubtractOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSubtractOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSubtractOp_lhs_operand_i"; break;
        case 1: retval = "SgSubtractOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSubtractOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSubtractOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgSwitchStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:394
/** Converts an enum of type E_SgSwitchStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgSwitchStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgSwitchStatement_item_selector"; break;
        case 1: retval = "SgSwitchStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgSwitchStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgSwitchStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateArgument is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:25
/** Converts an enum of type E_SgTemplateArgument to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgument(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateArgument_expression"; break;
        case 1: retval = "SgTemplateArgument_templateDeclaration"; break;
        case 2: retval = "SgTemplateArgument_initializedName"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateArgument)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgument::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateArgumentList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:37
/** Converts an enum of type E_SgTemplateArgumentList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateArgumentList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateArgumentList_args"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateArgumentList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateArgumentList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:481
/** Converts an enum of type E_SgTemplateClassDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateClassDeclaration_definition"; break;
        case 1: retval = "SgTemplateClassDeclaration_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateClassDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:382
/** Converts an enum of type E_SgTemplateClassDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateClassDefinition_members"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateClassDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateClassSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1129
/** Converts an enum of type E_SgTemplateClassSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateClassSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateClassSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateClassSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateClassSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:502
/** Converts an enum of type E_SgTemplateFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgTemplateFunctionDeclaration_decoratorList"; break;
        case 2: retval = "SgTemplateFunctionDeclaration_definition"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:373
/** Converts an enum of type E_SgTemplateFunctionDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateFunctionDefinition_body"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateFunctionDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1120
/** Converts an enum of type E_SgTemplateFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:484
/** Converts an enum of type E_SgTemplateInstantiationDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDecl_definition"; break;
        case 1: retval = "SgTemplateInstantiationDecl_decoratorList"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDefn is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:379
/** Converts an enum of type E_SgTemplateInstantiationDefn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDefn(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDefn_members"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDefn)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDefn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationDirectiveStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:448
/** Converts an enum of type E_SgTemplateInstantiationDirectiveStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationDirectiveStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationDirectiveStatement_declaration"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationDirectiveStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationDirectiveStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:514
/** Converts an enum of type E_SgTemplateInstantiationFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationFunctionDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationFunctionDecl_parameterList"; break;
        case 1: retval = "SgTemplateInstantiationFunctionDecl_decoratorList"; break;
        case 2: retval = "SgTemplateInstantiationFunctionDecl_definition"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationFunctionDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationMemberFunctionDecl is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:508
/** Converts an enum of type E_SgTemplateInstantiationMemberFunctionDecl to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationMemberFunctionDecl(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationMemberFunctionDecl_parameterList"; break;
        case 1: retval = "SgTemplateInstantiationMemberFunctionDecl_decoratorList"; break;
        case 2: retval = "SgTemplateInstantiationMemberFunctionDecl_definition"; break;
        case 3: retval = "SgTemplateInstantiationMemberFunctionDecl_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationMemberFunctionDecl)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationMemberFunctionDecl::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateInstantiationTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:466
/** Converts an enum of type E_SgTemplateInstantiationTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateInstantiationTypedefDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateInstantiationTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        char buf[107];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateInstantiationTypedefDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateInstantiationTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateMemberFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:505
/** Converts an enum of type E_SgTemplateMemberFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateMemberFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateMemberFunctionDeclaration_parameterList"; break;
        case 1: retval = "SgTemplateMemberFunctionDeclaration_decoratorList"; break;
        case 2: retval = "SgTemplateMemberFunctionDeclaration_definition"; break;
        case 3: retval = "SgTemplateMemberFunctionDeclaration_CtorInitializerList"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateMemberFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateMemberFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateMemberFunctionSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1114
/** Converts an enum of type E_SgTemplateMemberFunctionSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateMemberFunctionSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateMemberFunctionSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateMemberFunctionSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateMemberFunctionSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateParameter is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:22
/** Converts an enum of type E_SgTemplateParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateParameter_expression"; break;
        case 1: retval = "SgTemplateParameter_defaultExpressionParameter"; break;
        case 2: retval = "SgTemplateParameter_templateDeclaration"; break;
        case 3: retval = "SgTemplateParameter_defaultTemplateDeclarationParameter"; break;
        case 4: retval = "SgTemplateParameter_initializedName"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateParameterList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:40
/** Converts an enum of type E_SgTemplateParameterList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateParameterList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateParameterList_args"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateParameterList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateParameterList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1135
/** Converts an enum of type E_SgTemplateSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:181
/** Converts an enum of type E_SgTemplateType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:463
/** Converts an enum of type E_SgTemplateTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateTypedefDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateTypedefDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateTypedefSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1141
/** Converts an enum of type E_SgTemplateTypedefSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateTypedefSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateTypedefSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateTypedefSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateTypedefSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTemplateVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:433
/** Converts an enum of type E_SgTemplateVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTemplateVariableDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTemplateVariableDeclaration_baseTypeDefiningDeclaration"; break;
        case 1: retval = "SgTemplateVariableDeclaration_variables"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTemplateVariableDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTemplateVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgThrowOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:745
/** Converts an enum of type E_SgThrowOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgThrowOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgThrowOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgThrowOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgThrowOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTryStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:544
/** Converts an enum of type E_SgTryStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTryStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTryStmt_body"; break;
        case 1: retval = "SgTryStmt_catch_statement_seq_root"; break;
        case 2: retval = "SgTryStmt_else_body"; break;
        case 3: retval = "SgTryStmt_finally_body"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTryStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTryStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTupleExp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:949
/** Converts an enum of type E_SgTupleExp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTupleExp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTupleExp_expressions"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTupleExp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTupleExp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:226
/** Converts an enum of type E_SgType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeBool is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:124
/** Converts an enum of type E_SgTypeBool to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeBool(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeBool_type_kind"; break;
        case 1: retval = "SgTypeBool_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeBool)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeBool::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeCAFTeam is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:196
/** Converts an enum of type E_SgTypeCAFTeam to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCAFTeam(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeCAFTeam_type_kind"; break;
        case 1: retval = "SgTypeCAFTeam_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeCAFTeam)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCAFTeam::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:52
/** Converts an enum of type E_SgTypeChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeChar_type_kind"; break;
        case 1: retval = "SgTypeChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeComplex is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:187
/** Converts an enum of type E_SgTypeComplex to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeComplex(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeComplex_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeComplex)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeComplex::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeCrayPointer is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:199
/** Converts an enum of type E_SgTypeCrayPointer to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeCrayPointer(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeCrayPointer_type_kind"; break;
        case 1: retval = "SgTypeCrayPointer_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeCrayPointer)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeCrayPointer::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeDefault is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:193
/** Converts an enum of type E_SgTypeDefault to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDefault(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeDefault_type_kind"; break;
        case 1: retval = "SgTypeDefault_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeDefault)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDefault::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:100
/** Converts an enum of type E_SgTypeDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeDouble(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeDouble_type_kind"; break;
        case 1: retval = "SgTypeDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeDouble)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeEllipse is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:178
/** Converts an enum of type E_SgTypeEllipse to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeEllipse(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeEllipse_type_kind"; break;
        case 1: retval = "SgTypeEllipse_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeEllipse)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeEllipse::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeFloat is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:97
/** Converts an enum of type E_SgTypeFloat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeFloat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeFloat_type_kind"; break;
        case 1: retval = "SgTypeFloat_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeFloat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeFloat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeGlobalVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:91
/** Converts an enum of type E_SgTypeGlobalVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeGlobalVoid(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeGlobalVoid_type_kind"; break;
        case 1: retval = "SgTypeGlobalVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeGlobalVoid)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeGlobalVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeIdOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:985
/** Converts an enum of type E_SgTypeIdOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeIdOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeIdOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeIdOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeIdOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeImaginary is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:190
/** Converts an enum of type E_SgTypeImaginary to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeImaginary(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeImaginary_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeImaginary)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeImaginary::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:70
/** Converts an enum of type E_SgTypeInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeInt_type_kind"; break;
        case 1: retval = "SgTypeInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLabel is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:202
/** Converts an enum of type E_SgTypeLabel to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLabel(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLabel_type_kind"; break;
        case 1: retval = "SgTypeLabel_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeLabel)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLabel::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:79
/** Converts an enum of type E_SgTypeLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLong_type_kind"; break;
        case 1: retval = "SgTypeLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLongDouble is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:118
/** Converts an enum of type E_SgTypeLongDouble to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongDouble(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLongDouble_type_kind"; break;
        case 1: retval = "SgTypeLongDouble_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeLongDouble)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongDouble::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:103
/** Converts an enum of type E_SgTypeLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeLongLong_type_kind"; break;
        case 1: retval = "SgTypeLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeMatrix is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:220
/** Converts an enum of type E_SgTypeMatrix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeMatrix(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeMatrix_type_kind"; break;
        case 1: retval = "SgTypeMatrix_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeMatrix)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeMatrix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeNullptr is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:211
/** Converts an enum of type E_SgTypeNullptr to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeNullptr(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeNullptr_type_kind"; break;
        case 1: retval = "SgTypeNullptr_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeNullptr)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeNullptr::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeOfType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:217
/** Converts an enum of type E_SgTypeOfType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeOfType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeOfType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeOfType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeOfType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:61
/** Converts an enum of type E_SgTypeShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeShort_type_kind"; break;
        case 1: retval = "SgTypeShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSigned128bitInteger is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:112
/** Converts an enum of type E_SgTypeSigned128bitInteger to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSigned128bitInteger(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSigned128bitInteger_type_kind"; break;
        case 1: retval = "SgTypeSigned128bitInteger_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSigned128bitInteger)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSigned128bitInteger::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:55
/** Converts an enum of type E_SgTypeSignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedChar_type_kind"; break;
        case 1: retval = "SgTypeSignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSignedChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:73
/** Converts an enum of type E_SgTypeSignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedInt_type_kind"; break;
        case 1: retval = "SgTypeSignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSignedInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:82
/** Converts an enum of type E_SgTypeSignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedLong_type_kind"; break;
        case 1: retval = "SgTypeSignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSignedLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:106
/** Converts an enum of type E_SgTypeSignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedLongLong_type_kind"; break;
        case 1: retval = "SgTypeSignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSignedLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeSignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:64
/** Converts an enum of type E_SgTypeSignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeSignedShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeSignedShort_type_kind"; break;
        case 1: retval = "SgTypeSignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeSignedShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeSignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeString is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:121
/** Converts an enum of type E_SgTypeString to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeString(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeString_type_kind"; break;
        case 1: retval = "SgTypeString_lengthExpression"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeString)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeString::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeTuple is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:223
/** Converts an enum of type E_SgTypeTuple to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeTuple(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeTuple_type_kind"; break;
        case 1: retval = "SgTypeTuple_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeTuple)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeTuple::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnknown is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:49
/** Converts an enum of type E_SgTypeUnknown to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnknown(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnknown_type_kind"; break;
        case 1: retval = "SgTypeUnknown_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnknown)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnknown::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsigned128bitInteger is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:115
/** Converts an enum of type E_SgTypeUnsigned128bitInteger to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsigned128bitInteger(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsigned128bitInteger_type_kind"; break;
        case 1: retval = "SgTypeUnsigned128bitInteger_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsigned128bitInteger)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsigned128bitInteger::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedChar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:58
/** Converts an enum of type E_SgTypeUnsignedChar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedChar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedChar_type_kind"; break;
        case 1: retval = "SgTypeUnsignedChar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedChar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedChar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedInt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:76
/** Converts an enum of type E_SgTypeUnsignedInt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedInt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedInt_type_kind"; break;
        case 1: retval = "SgTypeUnsignedInt_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedInt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedInt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:85
/** Converts an enum of type E_SgTypeUnsignedLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedLong_type_kind"; break;
        case 1: retval = "SgTypeUnsignedLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedLongLong is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:109
/** Converts an enum of type E_SgTypeUnsignedLongLong to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedLongLong(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedLongLong_type_kind"; break;
        case 1: retval = "SgTypeUnsignedLongLong_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedLongLong)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedLongLong::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeUnsignedShort is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:67
/** Converts an enum of type E_SgTypeUnsignedShort to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeUnsignedShort(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeUnsignedShort_type_kind"; break;
        case 1: retval = "SgTypeUnsignedShort_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeUnsignedShort)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeUnsignedShort::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeVoid is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:88
/** Converts an enum of type E_SgTypeVoid to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeVoid(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeVoid_type_kind"; break;
        case 1: retval = "SgTypeVoid_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeVoid)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeVoid::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypeWchar is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:94
/** Converts an enum of type E_SgTypeWchar to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypeWchar(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypeWchar_type_kind"; break;
        case 1: retval = "SgTypeWchar_builtin_type"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypeWchar)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypeWchar::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:469
/** Converts an enum of type E_SgTypedefDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefDeclaration_declaration"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypedefDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefSymbol is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1144
/** Converts an enum of type E_SgTypedefSymbol to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefSymbol(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefSymbol_declaration"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypedefSymbol)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefSymbol::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgTypedefType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:151
/** Converts an enum of type E_SgTypedefType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgTypedefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgTypedefType_type_kind"; break;
        case 1: retval = "SgTypedefType_builtin_type"; break;
        case 2: retval = "SgTypedefType_declaration"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgTypedefType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgTypedefType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnaryAddOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:721
/** Converts an enum of type E_SgUnaryAddOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryAddOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnaryAddOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUnaryAddOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryAddOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:763
/** Converts an enum of type E_SgUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUnaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnknownArrayOrFunctionReference is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1045
/** Converts an enum of type E_SgUnknownArrayOrFunctionReference to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownArrayOrFunctionReference(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnknownArrayOrFunctionReference_named_reference"; break;
        case 1: retval = "SgUnknownArrayOrFunctionReference_expression_list"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUnknownArrayOrFunctionReference)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownArrayOrFunctionReference::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUnknownFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:10
/** Converts an enum of type E_SgUnknownFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUnknownFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUnknownFile_globalScope"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUnknownFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUnknownFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedArrayType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:334
/** Converts an enum of type E_SgUntypedArrayType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedArrayType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedArrayType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedArrayType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedArrayType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedAssignmentStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:316
/** Converts an enum of type E_SgUntypedAssignmentStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedAssignmentStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedAssignmentStatement_lhs_operand"; break;
        case 1: retval = "SgUntypedAssignmentStatement_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedAssignmentStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedAssignmentStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedBinaryOperator is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:298
/** Converts an enum of type E_SgUntypedBinaryOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedBinaryOperator(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedBinaryOperator_lhs_operand"; break;
        case 1: retval = "SgUntypedBinaryOperator_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedBinaryOperator)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedBinaryOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedBlockStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:319
/** Converts an enum of type E_SgUntypedBlockStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedBlockStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedBlockStatement_scope"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedBlockStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedBlockStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedDeclarationStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:346
/** Converts an enum of type E_SgUntypedDeclarationStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedDeclarationStatementList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedDeclarationStatementList_decl_list"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedDeclarationStatementList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedDeclarationStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFile is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:340
/** Converts an enum of type E_SgUntypedFile to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFile(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedFile_scope"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedFile)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFile::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:310
/** Converts an enum of type E_SgUntypedFunctionDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedFunctionDeclaration_parameters"; break;
        case 1: retval = "SgUntypedFunctionDeclaration_scope"; break;
        case 2: retval = "SgUntypedFunctionDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedFunctionDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionDeclarationList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:349
/** Converts an enum of type E_SgUntypedFunctionDeclarationList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionDeclarationList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedFunctionDeclarationList_func_list"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedFunctionDeclarationList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionDeclarationList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedFunctionScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:322
/** Converts an enum of type E_SgUntypedFunctionScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedFunctionScope(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedFunctionScope_declaration_list"; break;
        case 1: retval = "SgUntypedFunctionScope_statement_list"; break;
        case 2: retval = "SgUntypedFunctionScope_function_list"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedFunctionScope)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedFunctionScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedGlobalScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:328
/** Converts an enum of type E_SgUntypedGlobalScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedGlobalScope(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedGlobalScope_declaration_list"; break;
        case 1: retval = "SgUntypedGlobalScope_statement_list"; break;
        case 2: retval = "SgUntypedGlobalScope_function_list"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedGlobalScope)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedGlobalScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedInitializedNameList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:352
/** Converts an enum of type E_SgUntypedInitializedNameList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedInitializedNameList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedInitializedNameList_name_list"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedInitializedNameList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedInitializedNameList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedModuleDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:313
/** Converts an enum of type E_SgUntypedModuleDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedModuleDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedModuleDeclaration_scope"; break;
        case 1: retval = "SgUntypedModuleDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedModuleDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedModuleDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedModuleScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:325
/** Converts an enum of type E_SgUntypedModuleScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedModuleScope(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedModuleScope_declaration_list"; break;
        case 1: retval = "SgUntypedModuleScope_statement_list"; break;
        case 2: retval = "SgUntypedModuleScope_function_list"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedModuleScope)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedModuleScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedProgramHeaderDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:304
/** Converts an enum of type E_SgUntypedProgramHeaderDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedProgramHeaderDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedProgramHeaderDeclaration_parameters"; break;
        case 1: retval = "SgUntypedProgramHeaderDeclaration_scope"; break;
        case 2: retval = "SgUntypedProgramHeaderDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedProgramHeaderDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedProgramHeaderDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedScope is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:331
/** Converts an enum of type E_SgUntypedScope to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedScope(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedScope_declaration_list"; break;
        case 1: retval = "SgUntypedScope_statement_list"; break;
        case 2: retval = "SgUntypedScope_function_list"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedScope)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedScope::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedStatementList is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:343
/** Converts an enum of type E_SgUntypedStatementList to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedStatementList(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedStatementList_stmt_list"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedStatementList)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedStatementList::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedSubroutineDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:307
/** Converts an enum of type E_SgUntypedSubroutineDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedSubroutineDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedSubroutineDeclaration_parameters"; break;
        case 1: retval = "SgUntypedSubroutineDeclaration_scope"; break;
        case 2: retval = "SgUntypedSubroutineDeclaration_end_statement"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedSubroutineDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedSubroutineDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedType is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:337
/** Converts an enum of type E_SgUntypedType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedType_type_kind"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedUnaryOperator is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:295
/** Converts an enum of type E_SgUntypedUnaryOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedUnaryOperator(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedUnaryOperator_operand"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedUnaryOperator)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedUnaryOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUntypedVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:301
/** Converts an enum of type E_SgUntypedVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUntypedVariableDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUntypedVariableDeclaration_parameters"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUntypedVariableDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUntypedVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcBarrierStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:631
/** Converts an enum of type E_SgUpcBarrierStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBarrierStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcBarrierStatement_barrier_expression"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcBarrierStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBarrierStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcBlocksizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:976
/** Converts an enum of type E_SgUpcBlocksizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcBlocksizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcBlocksizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcBlocksizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcBlocksizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcElemsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:979
/** Converts an enum of type E_SgUpcElemsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcElemsizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcElemsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcElemsizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcElemsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcForAllStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:415
/** Converts an enum of type E_SgUpcForAllStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcForAllStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcForAllStatement_for_init_stmt"; break;
        case 1: retval = "SgUpcForAllStatement_test"; break;
        case 2: retval = "SgUpcForAllStatement_increment"; break;
        case 3: retval = "SgUpcForAllStatement_affinity"; break;
        case 4: retval = "SgUpcForAllStatement_loop_body"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcForAllStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcForAllStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcLocalsizeofExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:973
/** Converts an enum of type E_SgUpcLocalsizeofExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcLocalsizeofExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcLocalsizeofExpression_expression"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcLocalsizeofExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcLocalsizeofExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcNotifyStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:625
/** Converts an enum of type E_SgUpcNotifyStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcNotifyStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcNotifyStatement_notify_expression"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcNotifyStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcNotifyStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUpcWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:628
/** Converts an enum of type E_SgUpcWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUpcWaitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUpcWaitStatement_wait_expression"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUpcWaitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUpcWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUseStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:451
/** Converts an enum of type E_SgUseStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUseStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUseStatement_rename_list"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUseStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUseStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUserDefinedBinaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:859
/** Converts an enum of type E_SgUserDefinedBinaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedBinaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUserDefinedBinaryOp_lhs_operand_i"; break;
        case 1: retval = "SgUserDefinedBinaryOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUserDefinedBinaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedBinaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgUserDefinedUnaryOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:757
/** Converts an enum of type E_SgUserDefinedUnaryOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgUserDefinedUnaryOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgUserDefinedUnaryOp_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgUserDefinedUnaryOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgUserDefinedUnaryOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgCopyOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1021
/** Converts an enum of type E_SgVarArgCopyOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgCopyOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgCopyOp_lhs_operand"; break;
        case 1: retval = "SgVarArgCopyOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVarArgCopyOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgCopyOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgEndOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1018
/** Converts an enum of type E_SgVarArgEndOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgEndOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgEndOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVarArgEndOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgEndOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1015
/** Converts an enum of type E_SgVarArgOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVarArgOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgStartOneOperandOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1024
/** Converts an enum of type E_SgVarArgStartOneOperandOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOneOperandOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgStartOneOperandOp_operand_expr"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVarArgStartOneOperandOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOneOperandOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVarArgStartOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1012
/** Converts an enum of type E_SgVarArgStartOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVarArgStartOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVarArgStartOp_lhs_operand"; break;
        case 1: retval = "SgVarArgStartOp_rhs_operand"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVarArgStartOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVarArgStartOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVariableDeclaration is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:436
/** Converts an enum of type E_SgVariableDeclaration to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDeclaration(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVariableDeclaration_baseTypeDefiningDeclaration"; break;
        case 1: retval = "SgVariableDeclaration_variables"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVariableDeclaration)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDeclaration::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgVariableDefinition is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:439
/** Converts an enum of type E_SgVariableDefinition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgVariableDefinition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgVariableDefinition_vardefn"; break;
        case 1: retval = "SgVariableDefinition_bitfield"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgVariableDefinition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgVariableDefinition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWaitStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:592
/** Converts an enum of type E_SgWaitStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWaitStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWaitStatement_io_stmt_list"; break;
        case 1: retval = "SgWaitStatement_unit"; break;
        case 2: retval = "SgWaitStatement_iostat"; break;
        case 3: retval = "SgWaitStatement_err"; break;
        case 4: retval = "SgWaitStatement_iomsg"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgWaitStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWaitStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWhereStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:598
/** Converts an enum of type E_SgWhereStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhereStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWhereStatement_condition"; break;
        case 1: retval = "SgWhereStatement_body"; break;
        case 2: retval = "SgWhereStatement_elsewhere"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgWhereStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhereStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWhileStmt is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:388
/** Converts an enum of type E_SgWhileStmt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWhileStmt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWhileStmt_condition"; break;
        case 1: retval = "SgWhileStmt_body"; break;
        case 2: retval = "SgWhileStmt_else_body"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgWhileStmt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWhileStmt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWithStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:688
/** Converts an enum of type E_SgWithStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWithStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWithStatement_expression"; break;
        case 1: retval = "SgWithStatement_body"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgWithStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWithStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgWriteStatement is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:568
/** Converts an enum of type E_SgWriteStatement to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgWriteStatement(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgWriteStatement_io_stmt_list"; break;
        case 1: retval = "SgWriteStatement_unit"; break;
        case 2: retval = "SgWriteStatement_iostat"; break;
        case 3: retval = "SgWriteStatement_err"; break;
        case 4: retval = "SgWriteStatement_iomsg"; break;
        case 5: retval = "SgWriteStatement_format"; break;
        case 6: retval = "SgWriteStatement_rec"; break;
        case 7: retval = "SgWriteStatement_namelist"; break;
        case 8: retval = "SgWriteStatement_advance"; break;
        case 9: retval = "SgWriteStatement_asynchronous"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgWriteStatement)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgWriteStatement::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgXorAssignOp is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:883
/** Converts an enum of type E_SgXorAssignOp to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgXorAssignOp(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgXorAssignOp_lhs_operand_i"; break;
        case 1: retval = "SgXorAssignOp_rhs_operand_i"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgXorAssignOp)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgXorAssignOp::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// E_SgYieldExpression is defined at frontend/SageIII/Cxx_GrammarTreeTraversalAccessEnums.h:1087
/** Converts an enum of type E_SgYieldExpression to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyE_SgYieldExpression(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SgYieldExpression_value"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(E_SgYieldExpression)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "E_SgYieldExpression::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// EditDistance::TreeEditDistance::EditType is defined at git_rose_development/src/midend/programAnalysis/EditDistance/TreeEditDistance.h:60
/** Converts an enum of type EditDistance::TreeEditDistance::EditType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyEditDistanceTreeEditDistanceEditType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INSERT"; break;
        case 1: retval = "DELETE"; break;
        case 2: retval = "SUBSTITUTE"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(EditDistance::TreeEditDistance::EditType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "EditDistance::TreeEditDistance::EditType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FailSafe::fail_safe_enum is defined at git_rose_development/src/roseExtensions/failSafe/failSafePragma.h:32
/** Converts an enum of type FailSafe::fail_safe_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFailSafe_fail_safe_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_region"; break;
        case 2: retval = "e_status_predicate"; break;
        case 3: retval = "e_data_predicate"; break;
        case 4: retval = "e_tolerance"; break;
        case 5: retval = "e_double_redundancy"; break;
        case 6: retval = "e_triple_redundancy"; break;
        case 7: retval = "e_save"; break;
        case 8: retval = "e_assert"; break;
        case 9: retval = "e_specifier"; break;
        case 10: retval = "e_region_reference"; break;
        case 11: retval = "e_error"; break;
        case 12: retval = "e_violation"; break;
        case 13: retval = "e_recover"; break;
        case 14: retval = "e_pre"; break;
        case 15: retval = "e_post"; break;
        case 16: retval = "e_type_ET1"; break;
        case 17: retval = "e_type_ET2"; break;
        case 18: retval = "e_violation_NaN"; break;
        case 19: retval = "e_violation_SECDED"; break;
        case 20: retval = "e_violation_SEGFAULT"; break;
        case 21: retval = "e_violation_ANY"; break;
        case 22: retval = "e_not_failsafe"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(FailSafe::fail_safe_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FailSafe::fail_safe_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FailedAssertionBehaviorAdjuster::Behavior is defined at git_rose_development/src/util/commandlineProcessing/commandline_processing.C:56
/** Converts an enum of type FailedAssertionBehaviorAdjuster::Behavior to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFailedAssertionBehaviorAdjusterBehavior(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ABORT_ON_FAILURE"; break;
        case 1: retval = "EXIT_ON_FAILURE"; break;
        case 2: retval = "THROW_ON_FAILURE"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(FailedAssertionBehaviorAdjuster::Behavior)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FailedAssertionBehaviorAdjuster::Behavior::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Format_Opt is defined at git_rose_development/src/backend/unparser/formatSupport/unparse_format.h:52
/** Converts an enum of type Format_Opt to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFormat_Opt(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORMAT_BEFORE_DIRECTIVE"; break;
        case 1: retval = "FORMAT_AFTER_DIRECTIVE"; break;
        case 2: retval = "FORMAT_BEFORE_STMT"; break;
        case 3: retval = "FORMAT_AFTER_STMT"; break;
        case 4: retval = "FORMAT_BEFORE_BASIC_BLOCK1"; break;
        case 5: retval = "FORMAT_AFTER_BASIC_BLOCK1"; break;
        case 6: retval = "FORMAT_BEFORE_BASIC_BLOCK2"; break;
        case 7: retval = "FORMAT_AFTER_BASIC_BLOCK2"; break;
        case 8: retval = "FORMAT_BEFORE_NESTED_STATEMENT"; break;
        case 9: retval = "FORMAT_AFTER_NESTED_STATEMENT"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Format_Opt)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Format_Opt::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// FunctionCallInfo::InsertionMode is defined at git_rose_development/src/midend/programTransformation/extractFunctionArgumentsNormalization/functionEvaluationOrderTraversal.h:41
/** Converts an enum of type FunctionCallInfo::InsertionMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyFunctionCallInfoInsertionMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INSERT_BEFORE"; break;
        case 1: retval = "APPEND_SCOPE"; break;
        case 2: retval = "INVALID"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(FunctionCallInfo::InsertionMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "FunctionCallInfo::InsertionMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// GenRepresentation::TypeOfPrint is defined at git_rose_development/src/roseExtensions/dataStructureTraversal/GenRepresentation.h:24
/** Converts an enum of type GenRepresentation::TypeOfPrint to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyGenRepresentationTypeOfPrint(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElement"; break;
        case 1: retval = "Container"; break;
        case 2: retval = "Contained"; break;
        case 3: retval = "END_OF_LIST"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(GenRepresentation::TypeOfPrint)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "GenRepresentation::TypeOfPrint::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:177
/** Converts an enum of type HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownIntermediatePositionInScope"; break;
        case 1: retval = "GlobalScopePreamble"; break;
        case 2: retval = "GlobalScopeTopOfScope"; break;
        case 3: retval = "GlobalScopeTopOfIncludeRegion"; break;
        case 4: retval = "GlobalScopeBottomOfIncludeRegion"; break;
        case 5: retval = "GlobalScopeBeforeCurrentPosition"; break;
        case 6: retval = "GlobalScopeReplaceCurrentPosition"; break;
        case 7: retval = "FunctionScopePreamble"; break;
        case 8: retval = "FunctionScopeTopOfScope"; break;
        case 9: retval = "FunctionScopeBeforeCurrentPosition"; break;
        case 10: retval = "FunctionScopeReplaceCurrentPosition"; break;
        case 11: retval = "FunctionScopeAfterCurrentPosition"; break;
        case 12: retval = "FunctionScopeBottomOfScope"; break;
        case 13: retval = "GlobalScopeAfterCurrentPosition"; break;
        case 14: retval = "GlobalScopeBottomOfScope"; break;
        case 15: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[128];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::PlacementPosition_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:163
/** Converts an enum of type HighLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsPlacementPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownPositionInScope"; break;
        case 1: retval = "PreamblePositionInScope"; break;
        case 2: retval = "TopOfScope"; break;
        case 3: retval = "TopOfIncludeRegion"; break;
        case 4: retval = "BottomOfIncludeRegion"; break;
        case 5: retval = "BeforeCurrentPosition"; break;
        case 6: retval = "ReplaceCurrentPosition"; break;
        case 7: retval = "AfterCurrentPosition"; break;
        case 8: retval = "BottomOfScope"; break;
        case 9: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[115];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::PlacementPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// HighLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:142
/** Converts an enum of type HighLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyHighLevelCollectionTypedefsScopeIdentifier_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownScope"; break;
        case 1: retval = "SurroundingScope"; break;
        case 2: retval = "ParentScope"; break;
        case 3: retval = "NestedLoopScope"; break;
        case 4: retval = "NestedConditionalScope"; break;
        case 5: retval = "FunctionScope"; break;
        case 6: retval = "FileScope"; break;
        case 7: retval = "GlobalScope"; break;
        case 8: retval = "Preamble"; break;
        case 9: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        char buf[113];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(HighLevelCollectionTypedefs::ScopeIdentifier_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "HighLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// IRProcType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:164
/** Converts an enum of type IRProcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRProcType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ProcType_PGM"; break;
        case 1: retval = "ProcType_SUB"; break;
        case 2: retval = "ProcType_FUNC"; break;
        case 3: retval = "ProcType_BDATA"; break;
        case 4: retval = "ProcType_ILLEGAL"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(IRProcType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRProcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// IRStmtType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/Interface/IRInterface.h:174
/** Converts an enum of type IRStmtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyIRStmtType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SIMPLE"; break;
        case 1: retval = "COMPOUND"; break;
        case 2: retval = "LOOP"; break;
        case 3: retval = "END_TESTED_LOOP"; break;
        case 4: retval = "STRUCT_TWOWAY_CONDITIONAL"; break;
        case 5: retval = "STRUCT_MULTIWAY_CONDITIONAL"; break;
        case 6: retval = "USTRUCT_TWOWAY_CONDITIONAL_T"; break;
        case 7: retval = "USTRUCT_TWOWAY_CONDITIONAL_F"; break;
        case 8: retval = "USTRUCT_MULTIWAY_CONDITIONAL"; break;
        case 9: retval = "RETURN"; break;
        case 10: retval = "BREAK"; break;
        case 11: retval = "LOOP_CONTINUE"; break;
        case 12: retval = "ALTERNATE_PROC_ENTRY"; break;
        case 13: retval = "UNCONDITIONAL_JUMP"; break;
        case 14: retval = "UNCONDITIONAL_JUMP_I"; break;
        case 15: retval = "NONE"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(IRStmtType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "IRStmtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// KLT::Descriptor::tile_kind_e is defined at git_rose_development/src/midend/KLT/include/KLT/Core/descriptor.hpp:18
/** Converts an enum of type KLT::Descriptor::tile_kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyKLT_Descriptor_tile_kind_e(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -1: retval = "e_not_tile"; break;
        case 0: retval = "e_static_tile"; break;
        case 1: retval = "e_dynamic_tile"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(KLT::Descriptor::tile_kind_e)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "KLT::Descriptor::tile_kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// KLT::LoopTree::kind_e is defined at git_rose_development/src/midend/KLT/include/KLT/Core/looptree.hpp:30
/** Converts an enum of type KLT::LoopTree::kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyKLT_LoopTree_kind_e(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_block"; break;
        case 1: retval = "e_cond"; break;
        case 2: retval = "e_loop"; break;
        case 3: retval = "e_tile"; break;
        case 4: retval = "e_stmt"; break;
        case 5: retval = "e_ignored"; break;
        case 6: retval = "e_unknown"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(KLT::LoopTree::kind_e)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "KLT::LoopTree::kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kDataFormat is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:231
/** Converts an enum of type M68kDataFormat to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kDataFormat(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_fmt_i32"; break;
        case 1: retval = "m68k_fmt_f32"; break;
        case 2: retval = "m68k_fmt_f96"; break;
        case 3: retval = "m68k_fmt_p96"; break;
        case 4: retval = "m68k_fmt_i16"; break;
        case 5: retval = "m68k_fmt_f64"; break;
        case 6: retval = "m68k_fmt_i8"; break;
        case 255: retval = "m68k_fmt_unknown"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kDataFormat)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kDataFormat::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kEffectiveAddressMode is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:177
/** Converts an enum of type M68kEffectiveAddressMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kEffectiveAddressMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_eam_unknown"; break;
        case 1: retval = "m68k_eam_drd"; break;
        case 2: retval = "m68k_eam_ard"; break;
        case 3: retval = "m68k_eam_rd"; break;
        case 4: retval = "m68k_eam_ari"; break;
        case 8: retval = "m68k_eam_inc"; break;
        case 16: retval = "m68k_eam_dec"; break;
        case 32: retval = "m68k_eam_dsp"; break;
        case 60: retval = "m68k_eam_ri"; break;
        case 64: retval = "m68k_eam_idx8"; break;
        case 128: retval = "m68k_eam_idxbd"; break;
        case 192: retval = "m68k_eam_idx"; break;
        case 256: retval = "m68k_eam_mpost"; break;
        case 512: retval = "m68k_eam_mpre"; break;
        case 768: retval = "m68k_eam_mi"; break;
        case 1024: retval = "m68k_eam_pcdsp"; break;
        case 2048: retval = "m68k_eam_pcidx8"; break;
        case 4096: retval = "m68k_eam_pcidxbd"; break;
        case 6144: retval = "m68k_eam_pcidx"; break;
        case 8192: retval = "m68k_eam_pcmpost"; break;
        case 16384: retval = "m68k_eam_pcmpre"; break;
        case 24576: retval = "m68k_eam_pcmi"; break;
        case 29568: retval = "m68k_eam_234"; break;
        case 31744: retval = "m68k_eam_pc"; break;
        case 32768: retval = "m68k_eam_absw"; break;
        case 65536: retval = "m68k_eam_absl"; break;
        case 98304: retval = "m68k_eam_abs"; break;
        case 123903: retval = "m68k_eam_alter"; break;
        case 131044: retval = "m68k_eam_control"; break;
        case 131072: retval = "m68k_eam_imm"; break;
        case 262140: retval = "m68k_eam_memory"; break;
        case 262141: retval = "m68k_eam_data"; break;
        case 262143: retval = "m68k_eam_all"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kEffectiveAddressMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kEffectiveAddressMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kEmacRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:81
/** Converts an enum of type M68kEmacRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kEmacRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_emac_macsr"; break;
        case 1: retval = "m68k_emac_acc0"; break;
        case 2: retval = "m68k_emac_acc1"; break;
        case 3: retval = "m68k_emac_acc2"; break;
        case 4: retval = "m68k_emac_acc3"; break;
        case 5: retval = "m68k_emac_mask"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kEmacRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kEmacRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kFamily is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:12
/** Converts an enum of type M68kFamily to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kFamily(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "m68k_68000_only"; break;
        case 2: retval = "m68k_68ec000"; break;
        case 4: retval = "m68k_68hc000"; break;
        case 7: retval = "m68k_68000"; break;
        case 8: retval = "m68k_68008"; break;
        case 16: retval = "m68k_68010"; break;
        case 32: retval = "m68k_68012"; break;
        case 255: retval = "m68k_generation_1"; break;
        case 256: retval = "m68k_68020_only"; break;
        case 512: retval = "m68k_68ec020"; break;
        case 768: retval = "m68k_68020"; break;
        case 1024: retval = "m68k_68030_only"; break;
        case 4096: retval = "m68k_68ec030"; break;
        case 8192: retval = "m68k_68030"; break;
        case 65280: retval = "m68k_generation_2"; break;
        case 65536: retval = "m68k_68040_only"; break;
        case 131072: retval = "m68k_68ec040"; break;
        case 262144: retval = "m68k_68lc040"; break;
        case 458752: retval = "m68k_68040"; break;
        case 16711680: retval = "m68k_generation_3"; break;
        case 16777216: retval = "m68k_freescale_cpu32"; break;
        case 33554432: retval = "m68k_freescale_isaa"; break;
        case 67108864: retval = "m68k_freescale_isab"; break;
        case 134217728: retval = "m68k_freescale_isac"; break;
        case 268435456: retval = "m68k_freescale_fpu"; break;
        case 536870912: retval = "m68k_freescale_mac"; break;
        case 1073741824: retval = "m68k_freescale_emac"; break;
        case 2147483648: retval = "m68k_freescale_emacb"; break;
        case 4278190080: retval = "m68k_freescale"; break;
        case 4294967295: retval = "m68k_family"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kFamily)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kFamily::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kInstructionKind is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:242
/** Converts an enum of type M68kInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_unknown_instruction"; break;
        case 1: retval = "m68k_abcd"; break;
        case 2: retval = "m68k_add"; break;
        case 3: retval = "m68k_adda"; break;
        case 4: retval = "m68k_addi"; break;
        case 5: retval = "m68k_addq"; break;
        case 6: retval = "m68k_addx"; break;
        case 7: retval = "m68k_and"; break;
        case 8: retval = "m68k_andi"; break;
        case 9: retval = "m68k_asl"; break;
        case 10: retval = "m68k_asr"; break;
        case 11: retval = "m68k_bcc"; break;
        case 12: retval = "m68k_bcs"; break;
        case 13: retval = "m68k_beq"; break;
        case 14: retval = "m68k_bge"; break;
        case 15: retval = "m68k_bgt"; break;
        case 16: retval = "m68k_bhi"; break;
        case 17: retval = "m68k_ble"; break;
        case 18: retval = "m68k_bls"; break;
        case 19: retval = "m68k_blt"; break;
        case 20: retval = "m68k_bmi"; break;
        case 21: retval = "m68k_bne"; break;
        case 22: retval = "m68k_bpl"; break;
        case 23: retval = "m68k_bvc"; break;
        case 24: retval = "m68k_bvs"; break;
        case 25: retval = "m68k_bchg"; break;
        case 26: retval = "m68k_bclr"; break;
        case 27: retval = "m68k_bfchg"; break;
        case 28: retval = "m68k_bfclr"; break;
        case 29: retval = "m68k_bfexts"; break;
        case 30: retval = "m68k_bfextu"; break;
        case 31: retval = "m68k_bfins"; break;
        case 32: retval = "m68k_bfset"; break;
        case 33: retval = "m68k_bftst"; break;
        case 34: retval = "m68k_bkpt"; break;
        case 35: retval = "m68k_bra"; break;
        case 36: retval = "m68k_bset"; break;
        case 37: retval = "m68k_bsr"; break;
        case 38: retval = "m68k_btst"; break;
        case 39: retval = "m68k_callm"; break;
        case 40: retval = "m68k_cas"; break;
        case 41: retval = "m68k_cas2"; break;
        case 42: retval = "m68k_chk"; break;
        case 43: retval = "m68k_chk2"; break;
        case 44: retval = "m68k_clr"; break;
        case 45: retval = "m68k_cmp"; break;
        case 46: retval = "m68k_cmp2"; break;
        case 47: retval = "m68k_cmpa"; break;
        case 48: retval = "m68k_cmpi"; break;
        case 49: retval = "m68k_cmpm"; break;
        case 50: retval = "m68k_cpusha"; break;
        case 51: retval = "m68k_cpushl"; break;
        case 52: retval = "m68k_cpushp"; break;
        case 53: retval = "m68k_dbt"; break;
        case 54: retval = "m68k_dbf"; break;
        case 55: retval = "m68k_dbhi"; break;
        case 56: retval = "m68k_dbls"; break;
        case 57: retval = "m68k_dbcc"; break;
        case 58: retval = "m68k_dbcs"; break;
        case 59: retval = "m68k_dbne"; break;
        case 60: retval = "m68k_dbeq"; break;
        case 61: retval = "m68k_dbvc"; break;
        case 62: retval = "m68k_dbvs"; break;
        case 63: retval = "m68k_dbpl"; break;
        case 64: retval = "m68k_dbmi"; break;
        case 65: retval = "m68k_dbge"; break;
        case 66: retval = "m68k_dblt"; break;
        case 67: retval = "m68k_dbgt"; break;
        case 68: retval = "m68k_dble"; break;
        case 69: retval = "m68k_divs"; break;
        case 70: retval = "m68k_divsl"; break;
        case 71: retval = "m68k_divu"; break;
        case 72: retval = "m68k_divul"; break;
        case 73: retval = "m68k_eor"; break;
        case 74: retval = "m68k_eori"; break;
        case 75: retval = "m68k_exg"; break;
        case 76: retval = "m68k_ext"; break;
        case 77: retval = "m68k_extb"; break;
        case 78: retval = "m68k_fabs"; break;
        case 79: retval = "m68k_fadd"; break;
        case 80: retval = "m68k_fbeq"; break;
        case 81: retval = "m68k_fbne"; break;
        case 82: retval = "m68k_fbgt"; break;
        case 83: retval = "m68k_fbngt"; break;
        case 84: retval = "m68k_fbge"; break;
        case 85: retval = "m68k_fbnge"; break;
        case 86: retval = "m68k_fblt"; break;
        case 87: retval = "m68k_fbnlt"; break;
        case 88: retval = "m68k_fble"; break;
        case 89: retval = "m68k_fbnle"; break;
        case 90: retval = "m68k_fbgl"; break;
        case 91: retval = "m68k_fbngl"; break;
        case 92: retval = "m68k_fbgle"; break;
        case 93: retval = "m68k_fbngle"; break;
        case 94: retval = "m68k_fbogt"; break;
        case 95: retval = "m68k_fbule"; break;
        case 96: retval = "m68k_fboge"; break;
        case 97: retval = "m68k_fbult"; break;
        case 98: retval = "m68k_fbolt"; break;
        case 99: retval = "m68k_fbuge"; break;
        case 100: retval = "m68k_fbole"; break;
        case 101: retval = "m68k_fbugt"; break;
        case 102: retval = "m68k_fbogl"; break;
        case 103: retval = "m68k_fbueq"; break;
        case 104: retval = "m68k_fbor"; break;
        case 105: retval = "m68k_fbun"; break;
        case 106: retval = "m68k_fbf"; break;
        case 107: retval = "m68k_fbt"; break;
        case 108: retval = "m68k_fbsf"; break;
        case 109: retval = "m68k_fbst"; break;
        case 110: retval = "m68k_fbseq"; break;
        case 111: retval = "m68k_fbsne"; break;
        case 112: retval = "m68k_fcmp"; break;
        case 113: retval = "m68k_fdabs"; break;
        case 114: retval = "m68k_fdadd"; break;
        case 115: retval = "m68k_fddiv"; break;
        case 116: retval = "m68k_fdiv"; break;
        case 117: retval = "m68k_fdmove"; break;
        case 118: retval = "m68k_fdmul"; break;
        case 119: retval = "m68k_fdneg"; break;
        case 120: retval = "m68k_fdsqrt"; break;
        case 121: retval = "m68k_fdsub"; break;
        case 122: retval = "m68k_fint"; break;
        case 123: retval = "m68k_fintrz"; break;
        case 124: retval = "m68k_fmove"; break;
        case 125: retval = "m68k_fmovem"; break;
        case 126: retval = "m68k_fmul"; break;
        case 127: retval = "m68k_fneg"; break;
        case 128: retval = "m68k_fnop"; break;
        case 129: retval = "m68k_fsabs"; break;
        case 130: retval = "m68k_fsadd"; break;
        case 131: retval = "m68k_fsdiv"; break;
        case 132: retval = "m68k_fsmove"; break;
        case 133: retval = "m68k_fsmul"; break;
        case 134: retval = "m68k_fsneg"; break;
        case 135: retval = "m68k_fsqrt"; break;
        case 136: retval = "m68k_fssqrt"; break;
        case 137: retval = "m68k_fssub"; break;
        case 138: retval = "m68k_fsub"; break;
        case 139: retval = "m68k_ftst"; break;
        case 140: retval = "m68k_illegal"; break;
        case 141: retval = "m68k_jmp"; break;
        case 142: retval = "m68k_jsr"; break;
        case 143: retval = "m68k_lea"; break;
        case 144: retval = "m68k_link"; break;
        case 145: retval = "m68k_lsl"; break;
        case 146: retval = "m68k_lsr"; break;
        case 147: retval = "m68k_mac"; break;
        case 148: retval = "m68k_mov3q"; break;
        case 149: retval = "m68k_movclr"; break;
        case 150: retval = "m68k_move"; break;
        case 151: retval = "m68k_move_acc"; break;
        case 152: retval = "m68k_move_accext"; break;
        case 153: retval = "m68k_move_ccr"; break;
        case 154: retval = "m68k_move_macsr"; break;
        case 155: retval = "m68k_move_mask"; break;
        case 156: retval = "m68k_move_sr"; break;
        case 157: retval = "m68k_move16"; break;
        case 158: retval = "m68k_movea"; break;
        case 159: retval = "m68k_movec"; break;
        case 160: retval = "m68k_movem"; break;
        case 161: retval = "m68k_movep"; break;
        case 162: retval = "m68k_moveq"; break;
        case 163: retval = "m68k_msac"; break;
        case 164: retval = "m68k_muls"; break;
        case 165: retval = "m68k_mulu"; break;
        case 166: retval = "m68k_mvs"; break;
        case 167: retval = "m68k_mvz"; break;
        case 168: retval = "m68k_nbcd"; break;
        case 169: retval = "m68k_neg"; break;
        case 170: retval = "m68k_negx"; break;
        case 171: retval = "m68k_nop"; break;
        case 172: retval = "m68k_not"; break;
        case 173: retval = "m68k_or"; break;
        case 174: retval = "m68k_ori"; break;
        case 175: retval = "m68k_pack"; break;
        case 176: retval = "m68k_pea"; break;
        case 177: retval = "m68k_rol"; break;
        case 178: retval = "m68k_ror"; break;
        case 179: retval = "m68k_roxl"; break;
        case 180: retval = "m68k_roxr"; break;
        case 181: retval = "m68k_rtd"; break;
        case 182: retval = "m68k_rtm"; break;
        case 183: retval = "m68k_rtr"; break;
        case 184: retval = "m68k_rts"; break;
        case 185: retval = "m68k_sbcd"; break;
        case 186: retval = "m68k_st"; break;
        case 187: retval = "m68k_sf"; break;
        case 188: retval = "m68k_shi"; break;
        case 189: retval = "m68k_sls"; break;
        case 190: retval = "m68k_scc"; break;
        case 191: retval = "m68k_scs"; break;
        case 192: retval = "m68k_sne"; break;
        case 193: retval = "m68k_seq"; break;
        case 194: retval = "m68k_svc"; break;
        case 195: retval = "m68k_svs"; break;
        case 196: retval = "m68k_spl"; break;
        case 197: retval = "m68k_smi"; break;
        case 198: retval = "m68k_sge"; break;
        case 199: retval = "m68k_slt"; break;
        case 200: retval = "m68k_sgt"; break;
        case 201: retval = "m68k_sle"; break;
        case 202: retval = "m68k_sub"; break;
        case 203: retval = "m68k_suba"; break;
        case 204: retval = "m68k_subi"; break;
        case 205: retval = "m68k_subq"; break;
        case 206: retval = "m68k_subx"; break;
        case 207: retval = "m68k_swap"; break;
        case 208: retval = "m68k_tas"; break;
        case 209: retval = "m68k_trap"; break;
        case 210: retval = "m68k_trapt"; break;
        case 211: retval = "m68k_trapf"; break;
        case 212: retval = "m68k_traphi"; break;
        case 213: retval = "m68k_trapls"; break;
        case 214: retval = "m68k_trapcc"; break;
        case 215: retval = "m68k_trapcs"; break;
        case 216: retval = "m68k_trapne"; break;
        case 217: retval = "m68k_trapeq"; break;
        case 218: retval = "m68k_trapvc"; break;
        case 219: retval = "m68k_trapvs"; break;
        case 220: retval = "m68k_trappl"; break;
        case 221: retval = "m68k_trapmi"; break;
        case 222: retval = "m68k_trapge"; break;
        case 223: retval = "m68k_traplt"; break;
        case 224: retval = "m68k_trapgt"; break;
        case 225: retval = "m68k_traple"; break;
        case 226: retval = "m68k_trapv"; break;
        case 227: retval = "m68k_tst"; break;
        case 228: retval = "m68k_unlk"; break;
        case 229: retval = "m68k_unpk"; break;
        case 230: retval = "m68k_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kMacRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:66
/** Converts an enum of type M68kMacRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kMacRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_mac_macsr"; break;
        case 1: retval = "m68k_mac_acc0"; break;
        case 2: retval = "m68k_mac_acc1"; break;
        case 3: retval = "m68k_mac_acc2"; break;
        case 4: retval = "m68k_mac_acc3"; break;
        case 5: retval = "m68k_mac_ext01"; break;
        case 6: retval = "m68k_mac_ext23"; break;
        case 7: retval = "m68k_mac_ext0"; break;
        case 8: retval = "m68k_mac_ext1"; break;
        case 9: retval = "m68k_mac_ext2"; break;
        case 10: retval = "m68k_mac_ext3"; break;
        case 11: retval = "m68k_mac_mask"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kMacRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kMacRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kRegisterClass is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:49
/** Converts an enum of type M68kRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_regclass_data"; break;
        case 1: retval = "m68k_regclass_addr"; break;
        case 2: retval = "m68k_regclass_fpr"; break;
        case 3: retval = "m68k_regclass_spr"; break;
        case 4: retval = "m68k_regclass_mac"; break;
        case 5: retval = "m68k_regclass_sup"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kSpecialPurposeRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:58
/** Converts an enum of type M68kSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kSpecialPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_spr_pc"; break;
        case 1: retval = "m68k_spr_sr"; break;
        case 2: retval = "m68k_spr_fpcr"; break;
        case 3: retval = "m68k_spr_fpsr"; break;
        case 4: retval = "m68k_spr_fpiar"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kSpecialPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// M68kSupervisorRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsM68k.h:90
/** Converts an enum of type M68kSupervisorRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyM68kSupervisorRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "m68k_sup_vbr"; break;
        case 1: retval = "m68k_sup_ssp"; break;
        case 2: retval = "m68k_sup_sfc"; break;
        case 3: retval = "m68k_sup_dfc"; break;
        case 4: retval = "m68k_sup_cacr"; break;
        case 5: retval = "m68k_sup_asid"; break;
        case 6: retval = "m68k_sup_acr0"; break;
        case 7: retval = "m68k_sup_acr1"; break;
        case 8: retval = "m68k_sup_acr2"; break;
        case 9: retval = "m68k_sup_acr3"; break;
        case 10: retval = "m68k_sup_mmubar"; break;
        case 11: retval = "m68k_sup_rombar0"; break;
        case 12: retval = "m68k_sup_rombar1"; break;
        case 13: retval = "m68k_sup_rambar0"; break;
        case 14: retval = "m68k_sup_rambar1"; break;
        case 15: retval = "m68k_sup_mbar"; break;
        case 16: retval = "m68k_sup_mpcr"; break;
        case 17: retval = "m68k_sup_edrambar"; break;
        case 18: retval = "m68k_sup_secmbar"; break;
        case 19: retval = "m68k_sup_0_pcr1"; break;
        case 20: retval = "m68k_sup_0_pcr2"; break;
        case 21: retval = "m68k_sup_0_pcr3"; break;
        case 22: retval = "m68k_sup_1_pcr1"; break;
        case 23: retval = "m68k_sup_1_pcr2"; break;
        case 24: retval = "m68k_sup_1_pcr3"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(M68kSupervisorRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "M68kSupervisorRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MDCG::Model::element_t::kind_e is defined at git_rose_development/src/midend/MDCG/include/MDCG/Model/base.hpp:46
/** Converts an enum of type MDCG::Model::element_t::kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMDCG_Model_element_t_kind_e(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MDCG::Model::element_t::kind_e)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MDCG::Model::element_t::kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MDCG::Model::model_elements_e is defined at git_rose_development/src/midend/MDCG/include/MDCG/Model/base.hpp:24
/** Converts an enum of type MDCG::Model::model_elements_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMDCG_Model_model_elements_e(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_model_blank"; break;
        case 1: retval = "e_model_variable"; break;
        case 2: retval = "e_model_function"; break;
        case 3: retval = "e_model_field"; break;
        case 4: retval = "e_model_method"; break;
        case 5: retval = "e_model_type"; break;
        case 6: retval = "e_model_class"; break;
        case 7: retval = "e_model_namespace"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MDCG::Model::model_elements_e)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MDCG::Model::model_elements_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MatchStatus::CheckNodeMode is defined at git_rose_development/src/midend/astMatching/MatchOperation.h:43
/** Converts an enum of type MatchStatus::CheckNodeMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMatchStatusCheckNodeMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NODECHECKMODE_TYPEID"; break;
        case 1: retval = "NODECHECKMODE_VARIANT"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MatchStatus::CheckNodeMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MatchStatus::CheckNodeMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MatchStatus::PatternMatchMode is defined at git_rose_development/src/midend/astMatching/MatchOperation.h:42
/** Converts an enum of type MatchStatus::PatternMatchMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMatchStatusPatternMatchMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MATCHMODE_SHALLOW"; break;
        case 1: retval = "MATCHMODE_DEEP"; break;
        case 2: retval = "MATCHMODE_SINGLE"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MatchStatus::PatternMatchMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MatchStatus::PatternMatchMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:80
/** Converts an enum of type MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsIntermediateFileStringPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownIntermediatePositionInScope"; break;
        case 1: retval = "GlobalScopePreamble"; break;
        case 2: retval = "CurrentLocationTopOfScope"; break;
        case 3: retval = "CurrentLocationBefore"; break;
        case 4: retval = "CurrentLocationReplace"; break;
        case 5: retval = "CurrentLocationAfter"; break;
        case 6: retval = "CurrentLocationBottomOfScope"; break;
        case 7: retval = "LAST_INTERMEDIATE_SOURCE_CODE_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[127];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::IntermediateFileStringPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::PlacementPosition_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:67
/** Converts an enum of type MidLevelCollectionTypedefs::PlacementPosition_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsPlacementPosition_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownPositionInScope"; break;
        case 1: retval = "PreamblePositionInScope"; break;
        case 2: retval = "TopOfCurrentScope"; break;
        case 3: retval = "BeforeCurrentPosition"; break;
        case 4: retval = "ReplaceCurrentPosition"; break;
        case 5: retval = "AfterCurrentPosition"; break;
        case 6: retval = "BottomOfCurrentScope"; break;
        case 7: retval = "LAST_PLACEMENT_TAG"; break;
    }
    if (retval.empty()) {
        char buf[114];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::PlacementPosition_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::PlacementPosition_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MidLevelCollectionTypedefs::ScopeIdentifier_Enum is defined at git_rose_development/src/midend/astRewriteMechanism/rewrite.h:53
/** Converts an enum of type MidLevelCollectionTypedefs::ScopeIdentifier_Enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMidLevelCollectionTypedefsScopeIdentifier_Enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknownScope"; break;
        case 1: retval = "StatementScope"; break;
        case 2: retval = "SurroundingScope"; break;
        case 3: retval = "Preamble"; break;
        case 4: retval = "LAST_SCOPE_TAG"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MidLevelCollectionTypedefs::ScopeIdentifier_Enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MidLevelCollectionTypedefs::ScopeIdentifier_Enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsFcsrMinors is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsMips.h:18
/** Converts an enum of type MipsFcsrMinors to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsFcsrMinors(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mips_fcsr_all"; break;
        case 1: retval = "mips_fcsr_fccr"; break;
        case 2: retval = "mips_fcsr_fexr"; break;
        case 3: retval = "mips_fcsr_fenr"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MipsFcsrMinors)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsFcsrMinors::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsInstructionKind is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsMips.h:35
/** Converts an enum of type MipsInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mips_unknown_instruction"; break;
        case 1: retval = "mips_abs_s"; break;
        case 2: retval = "mips_abs_d"; break;
        case 3: retval = "mips_abs_ps"; break;
        case 4: retval = "mips_add"; break;
        case 5: retval = "mips_add_s"; break;
        case 6: retval = "mips_add_d"; break;
        case 7: retval = "mips_add_ps"; break;
        case 8: retval = "mips_addi"; break;
        case 9: retval = "mips_addiu"; break;
        case 10: retval = "mips_addu"; break;
        case 11: retval = "mips_alnv_ps"; break;
        case 12: retval = "mips_and"; break;
        case 13: retval = "mips_andi"; break;
        case 14: retval = "mips_bc1f"; break;
        case 15: retval = "mips_bc1fl"; break;
        case 16: retval = "mips_bc1t"; break;
        case 17: retval = "mips_bc1tl"; break;
        case 18: retval = "mips_bc2f"; break;
        case 19: retval = "mips_bc2fl"; break;
        case 20: retval = "mips_bc2t"; break;
        case 21: retval = "mips_bc2tl"; break;
        case 22: retval = "mips_beq"; break;
        case 23: retval = "mips_beql"; break;
        case 24: retval = "mips_bgez"; break;
        case 25: retval = "mips_bgezal"; break;
        case 26: retval = "mips_bgezall"; break;
        case 27: retval = "mips_bgezl"; break;
        case 28: retval = "mips_bgtz"; break;
        case 29: retval = "mips_bgtzl"; break;
        case 30: retval = "mips_blez"; break;
        case 31: retval = "mips_blezl"; break;
        case 32: retval = "mips_bltz"; break;
        case 33: retval = "mips_bltzal"; break;
        case 34: retval = "mips_bltzall"; break;
        case 35: retval = "mips_bltzl"; break;
        case 36: retval = "mips_bne"; break;
        case 37: retval = "mips_bnel"; break;
        case 38: retval = "mips_break"; break;
        case 39: retval = "mips_c_f_s"; break;
        case 40: retval = "mips_c_un_s"; break;
        case 41: retval = "mips_c_eq_s"; break;
        case 42: retval = "mips_c_ueq_s"; break;
        case 43: retval = "mips_c_olt_s"; break;
        case 44: retval = "mips_c_ult_s"; break;
        case 45: retval = "mips_c_ole_s"; break;
        case 46: retval = "mips_c_ule_s"; break;
        case 47: retval = "mips_c_sf_s"; break;
        case 48: retval = "mips_c_ngle_s"; break;
        case 49: retval = "mips_c_seq_s"; break;
        case 50: retval = "mips_c_ngl_s"; break;
        case 51: retval = "mips_c_lt_s"; break;
        case 52: retval = "mips_c_nge_s"; break;
        case 53: retval = "mips_c_le_s"; break;
        case 54: retval = "mips_c_ngt_s"; break;
        case 55: retval = "mips_c_f_d"; break;
        case 56: retval = "mips_c_un_d"; break;
        case 57: retval = "mips_c_eq_d"; break;
        case 58: retval = "mips_c_ueq_d"; break;
        case 59: retval = "mips_c_olt_d"; break;
        case 60: retval = "mips_c_ult_d"; break;
        case 61: retval = "mips_c_ole_d"; break;
        case 62: retval = "mips_c_ule_d"; break;
        case 63: retval = "mips_c_sf_d"; break;
        case 64: retval = "mips_c_ngle_d"; break;
        case 65: retval = "mips_c_seq_d"; break;
        case 66: retval = "mips_c_ngl_d"; break;
        case 67: retval = "mips_c_lt_d"; break;
        case 68: retval = "mips_c_nge_d"; break;
        case 69: retval = "mips_c_le_d"; break;
        case 70: retval = "mips_c_ngt_d"; break;
        case 71: retval = "mips_c_f_ps"; break;
        case 72: retval = "mips_c_un_ps"; break;
        case 73: retval = "mips_c_eq_ps"; break;
        case 74: retval = "mips_c_ueq_ps"; break;
        case 75: retval = "mips_c_olt_ps"; break;
        case 76: retval = "mips_c_ult_ps"; break;
        case 77: retval = "mips_c_ole_ps"; break;
        case 78: retval = "mips_c_ule_ps"; break;
        case 79: retval = "mips_c_sf_ps"; break;
        case 80: retval = "mips_c_ngle_ps"; break;
        case 81: retval = "mips_c_seq_ps"; break;
        case 82: retval = "mips_c_ngl_ps"; break;
        case 83: retval = "mips_c_lt_ps"; break;
        case 84: retval = "mips_c_nge_ps"; break;
        case 85: retval = "mips_c_le_ps"; break;
        case 86: retval = "mips_c_ngt_ps"; break;
        case 87: retval = "mips_cache"; break;
        case 88: retval = "mips_cachee"; break;
        case 89: retval = "mips_ceil_l_s"; break;
        case 90: retval = "mips_ceil_l_d"; break;
        case 91: retval = "mips_ceil_w_s"; break;
        case 92: retval = "mips_ceil_w_d"; break;
        case 93: retval = "mips_cfc1"; break;
        case 94: retval = "mips_cfc2"; break;
        case 95: retval = "mips_clo"; break;
        case 96: retval = "mips_clz"; break;
        case 97: retval = "mips_cop2"; break;
        case 98: retval = "mips_ctc1"; break;
        case 99: retval = "mips_ctc2"; break;
        case 100: retval = "mips_cvt_d_s"; break;
        case 101: retval = "mips_cvt_d_w"; break;
        case 102: retval = "mips_cvt_d_l"; break;
        case 103: retval = "mips_cvt_l_s"; break;
        case 104: retval = "mips_cvt_l_d"; break;
        case 105: retval = "mips_cvt_ps_s"; break;
        case 106: retval = "mips_cvt_s_d"; break;
        case 107: retval = "mips_cvt_s_w"; break;
        case 108: retval = "mips_cvt_s_l"; break;
        case 109: retval = "mips_cvt_s_pl"; break;
        case 110: retval = "mips_cvt_s_pu"; break;
        case 111: retval = "mips_cvt_w_s"; break;
        case 112: retval = "mips_cvt_w_d"; break;
        case 113: retval = "mips_di"; break;
        case 114: retval = "mips_div"; break;
        case 115: retval = "mips_div_s"; break;
        case 116: retval = "mips_div_d"; break;
        case 117: retval = "mips_divu"; break;
        case 118: retval = "mips_ehb"; break;
        case 119: retval = "mips_ei"; break;
        case 120: retval = "mips_eret"; break;
        case 121: retval = "mips_ext"; break;
        case 122: retval = "mips_floor_l_s"; break;
        case 123: retval = "mips_floor_l_d"; break;
        case 124: retval = "mips_floor_w_s"; break;
        case 125: retval = "mips_floor_w_d"; break;
        case 126: retval = "mips_ins"; break;
        case 127: retval = "mips_j"; break;
        case 128: retval = "mips_jal"; break;
        case 129: retval = "mips_jalr"; break;
        case 130: retval = "mips_jalr_hb"; break;
        case 131: retval = "mips_jalx"; break;
        case 132: retval = "mips_jr"; break;
        case 133: retval = "mips_jr_hb"; break;
        case 134: retval = "mips_lb"; break;
        case 135: retval = "mips_lbe"; break;
        case 136: retval = "mips_lbu"; break;
        case 137: retval = "mips_lbue"; break;
        case 138: retval = "mips_ldc1"; break;
        case 139: retval = "mips_ldc2"; break;
        case 140: retval = "mips_ldxc1"; break;
        case 141: retval = "mips_lh"; break;
        case 142: retval = "mips_lhe"; break;
        case 143: retval = "mips_lhu"; break;
        case 144: retval = "mips_lhue"; break;
        case 145: retval = "mips_ll"; break;
        case 146: retval = "mips_lle"; break;
        case 147: retval = "mips_lui"; break;
        case 148: retval = "mips_luxc1"; break;
        case 149: retval = "mips_lw"; break;
        case 150: retval = "mips_lwc1"; break;
        case 151: retval = "mips_lwc2"; break;
        case 152: retval = "mips_lwe"; break;
        case 153: retval = "mips_lwl"; break;
        case 154: retval = "mips_lwle"; break;
        case 155: retval = "mips_lwr"; break;
        case 156: retval = "mips_lwre"; break;
        case 157: retval = "mips_lwxc1"; break;
        case 158: retval = "mips_madd"; break;
        case 159: retval = "mips_madd_s"; break;
        case 160: retval = "mips_madd_d"; break;
        case 161: retval = "mips_madd_ps"; break;
        case 162: retval = "mips_maddu"; break;
        case 163: retval = "mips_mfc0"; break;
        case 164: retval = "mips_mfc1"; break;
        case 165: retval = "mips_mfc2"; break;
        case 166: retval = "mips_mfhc1"; break;
        case 167: retval = "mips_mfhc2"; break;
        case 168: retval = "mips_mfhi"; break;
        case 169: retval = "mips_mflo"; break;
        case 170: retval = "mips_mov_s"; break;
        case 171: retval = "mips_mov_d"; break;
        case 172: retval = "mips_mov_ps"; break;
        case 173: retval = "mips_movf"; break;
        case 174: retval = "mips_movf_s"; break;
        case 175: retval = "mips_movf_d"; break;
        case 176: retval = "mips_movf_ps"; break;
        case 177: retval = "mips_movn"; break;
        case 178: retval = "mips_movn_s"; break;
        case 179: retval = "mips_movn_d"; break;
        case 180: retval = "mips_movn_ps"; break;
        case 181: retval = "mips_movt"; break;
        case 182: retval = "mips_movt_s"; break;
        case 183: retval = "mips_movt_d"; break;
        case 184: retval = "mips_movt_ps"; break;
        case 185: retval = "mips_movz"; break;
        case 186: retval = "mips_movz_s"; break;
        case 187: retval = "mips_movz_d"; break;
        case 188: retval = "mips_movz_ps"; break;
        case 189: retval = "mips_msub"; break;
        case 190: retval = "mips_msub_s"; break;
        case 191: retval = "mips_msub_d"; break;
        case 192: retval = "mips_msub_ps"; break;
        case 193: retval = "mips_msubu"; break;
        case 194: retval = "mips_mtc0"; break;
        case 195: retval = "mips_mtc1"; break;
        case 196: retval = "mips_mtc2"; break;
        case 197: retval = "mips_mthc1"; break;
        case 198: retval = "mips_mthc2"; break;
        case 199: retval = "mips_mthi"; break;
        case 200: retval = "mips_mtlo"; break;
        case 201: retval = "mips_mul"; break;
        case 202: retval = "mips_mul_s"; break;
        case 203: retval = "mips_mul_d"; break;
        case 204: retval = "mips_mul_ps"; break;
        case 205: retval = "mips_mult"; break;
        case 206: retval = "mips_multu"; break;
        case 207: retval = "mips_neg_s"; break;
        case 208: retval = "mips_neg_d"; break;
        case 209: retval = "mips_neg_ps"; break;
        case 210: retval = "mips_nmadd_s"; break;
        case 211: retval = "mips_nmadd_d"; break;
        case 212: retval = "mips_nmadd_ps"; break;
        case 213: retval = "mips_nmsub_s"; break;
        case 214: retval = "mips_nmsub_d"; break;
        case 215: retval = "mips_nmsub_ps"; break;
        case 216: retval = "mips_nop"; break;
        case 217: retval = "mips_nor"; break;
        case 218: retval = "mips_or"; break;
        case 219: retval = "mips_ori"; break;
        case 220: retval = "mips_pause"; break;
        case 221: retval = "mips_pll_ps"; break;
        case 222: retval = "mips_plu_ps"; break;
        case 223: retval = "mips_pref"; break;
        case 224: retval = "mips_prefe"; break;
        case 225: retval = "mips_prefx"; break;
        case 226: retval = "mips_pul_ps"; break;
        case 227: retval = "mips_puu_ps"; break;
        case 228: retval = "mips_rdhwr"; break;
        case 229: retval = "mips_rdpgpr"; break;
        case 230: retval = "mips_recip_s"; break;
        case 231: retval = "mips_recip_d"; break;
        case 232: retval = "mips_rotr"; break;
        case 233: retval = "mips_rotrv"; break;
        case 234: retval = "mips_round_l_s"; break;
        case 235: retval = "mips_round_l_d"; break;
        case 236: retval = "mips_round_w_s"; break;
        case 237: retval = "mips_round_w_d"; break;
        case 238: retval = "mips_rsqrt_s"; break;
        case 239: retval = "mips_rsqrt_d"; break;
        case 240: retval = "mips_sb"; break;
        case 241: retval = "mips_sbe"; break;
        case 242: retval = "mips_sc"; break;
        case 243: retval = "mips_sce"; break;
        case 244: retval = "mips_sdc1"; break;
        case 245: retval = "mips_sdc2"; break;
        case 246: retval = "mips_sdxc1"; break;
        case 247: retval = "mips_seb"; break;
        case 248: retval = "mips_seh"; break;
        case 249: retval = "mips_sh"; break;
        case 250: retval = "mips_she"; break;
        case 251: retval = "mips_sll"; break;
        case 252: retval = "mips_sllv"; break;
        case 253: retval = "mips_slt"; break;
        case 254: retval = "mips_slti"; break;
        case 255: retval = "mips_sltiu"; break;
        case 256: retval = "mips_sltu"; break;
        case 257: retval = "mips_sqrt_s"; break;
        case 258: retval = "mips_sqrt_d"; break;
        case 259: retval = "mips_sra"; break;
        case 260: retval = "mips_srav"; break;
        case 261: retval = "mips_srl"; break;
        case 262: retval = "mips_srlv"; break;
        case 263: retval = "mips_ssnop"; break;
        case 264: retval = "mips_sub"; break;
        case 265: retval = "mips_sub_s"; break;
        case 266: retval = "mips_sub_d"; break;
        case 267: retval = "mips_sub_ps"; break;
        case 268: retval = "mips_subu"; break;
        case 269: retval = "mips_suxc1"; break;
        case 270: retval = "mips_sw"; break;
        case 271: retval = "mips_swc1"; break;
        case 272: retval = "mips_swc2"; break;
        case 273: retval = "mips_swe"; break;
        case 274: retval = "mips_swl"; break;
        case 275: retval = "mips_swle"; break;
        case 276: retval = "mips_swr"; break;
        case 277: retval = "mips_swre"; break;
        case 278: retval = "mips_swxc1"; break;
        case 279: retval = "mips_sync"; break;
        case 280: retval = "mips_synci"; break;
        case 281: retval = "mips_syscall"; break;
        case 282: retval = "mips_teq"; break;
        case 283: retval = "mips_teqi"; break;
        case 284: retval = "mips_tge"; break;
        case 285: retval = "mips_tgei"; break;
        case 286: retval = "mips_tgeiu"; break;
        case 287: retval = "mips_tgeu"; break;
        case 288: retval = "mips_tlbinv"; break;
        case 289: retval = "mips_tlbinvf"; break;
        case 290: retval = "mips_tlbp"; break;
        case 291: retval = "mips_tlbr"; break;
        case 292: retval = "mips_tlbwi"; break;
        case 293: retval = "mips_tlbwr"; break;
        case 294: retval = "mips_tlt"; break;
        case 295: retval = "mips_tlti"; break;
        case 296: retval = "mips_tltiu"; break;
        case 297: retval = "mips_tltu"; break;
        case 298: retval = "mips_tne"; break;
        case 299: retval = "mips_tnei"; break;
        case 300: retval = "mips_trunc_l_s"; break;
        case 301: retval = "mips_trunc_l_d"; break;
        case 302: retval = "mips_trunc_w_s"; break;
        case 303: retval = "mips_trunc_w_d"; break;
        case 304: retval = "mips_wait"; break;
        case 305: retval = "mips_wrpgpr"; break;
        case 306: retval = "mips_wsbh"; break;
        case 307: retval = "mips_xor"; break;
        case 308: retval = "mips_xori"; break;
        case 309: retval = "mips_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MipsInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsRegisterClass is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsMips.h:6
/** Converts an enum of type MipsRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mips_regclass_gpr"; break;
        case 1: retval = "mips_regclass_spr"; break;
        case 2: retval = "mips_regclass_fpr"; break;
        case 3: retval = "mips_regclass_fcsr"; break;
        case 4: retval = "mips_regclass_cp0gpr"; break;
        case 5: retval = "mips_regclass_cp2gpr"; break;
        case 6: retval = "mips_regclass_cp2spr"; break;
        case 7: retval = "mips_regclass_sgpr"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MipsRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// MipsSpecialPurposeRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsMips.h:26
/** Converts an enum of type MipsSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMipsSpecialPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "mips_spr_hi"; break;
        case 1: retval = "mips_spr_lo"; break;
        case 2: retval = "mips_spr_pc"; break;
        case 3: retval = "mips_spr_fir"; break;
        case 4: retval = "mips_spr_fcsr"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(MipsSpecialPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "MipsSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Mode is defined at git_rose_development/src/rose-config.C:27
/** Converts an enum of type Mode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BUILD"; break;
        case 1: retval = "INSTALLED"; break;
        case 2: retval = "NMODES"; break;
    }
    if (retval.empty()) {
        char buf[68];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Mode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Mode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NFAAssertion is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:64
/** Converts an enum of type NFAAssertion to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAAssertion(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoAssertion"; break;
        case 1: retval = "ZeroOrOne"; break;
        case 2: retval = "ZeroOrMore"; break;
        case 4: retval = "OneOrMore"; break;
        case 8: retval = "WordStart"; break;
        case 16: retval = "WordEnd"; break;
        case 32: retval = "Word"; break;
        case 64: retval = "NonWord"; break;
        case 128: retval = "Digit"; break;
        case 256: retval = "NonDigit"; break;
        case 512: retval = "Space"; break;
        case 1024: retval = "NonSpace"; break;
        case 2048: retval = "CaseSensitive"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NFAAssertion)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAAssertion::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NFAType is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfa.h:43
/** Converts an enum of type NFAType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNFAType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Char"; break;
        case 1: retval = "Match"; break;
        case 2: retval = "CxtBeg"; break;
        case 3: retval = "ContextBegin"; break;
        case 4: retval = "CxtEnd"; break;
        case 5: retval = "ContextEnd"; break;
        case 8: retval = "CxtEsc"; break;
        case 9: retval = "EscapeSeq"; break;
        case 16: retval = "Escaped"; break;
        case 32: retval = "Exclusive"; break;
        case 64: retval = "StayOnLine"; break;
        case 128: retval = "Reserved"; break;
    }
    if (retval.empty()) {
        char buf[71];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NFAType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NFAType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeOneParameter is defined at git_rose_development/src/midend/astQuery/nameQuery.h:75
/** Converts an enum of type NameQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableNames"; break;
        case 2: retval = "VariableTypeNames"; break;
        case 3: retval = "FunctionDeclarationNames"; break;
        case 4: retval = "MemberFunctionDeclarationNames"; break;
        case 5: retval = "ClassDeclarationNames"; break;
        case 6: retval = "ArgumentNames"; break;
        case 7: retval = "ClassFieldNames"; break;
        case 8: retval = "UnionFieldNames"; break;
        case 9: retval = "StructFieldNames"; break;
        case 10: retval = "FunctionReferenceNames"; break;
        case 11: retval = "StructNames"; break;
        case 12: retval = "UnionNames"; break;
        case 13: retval = "TypedefDeclarationNames"; break;
        case 14: retval = "TypeNames"; break;
        case 15: retval = "END_OF_NAME_TYPE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NameQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NameQuery::TypeOfQueryTypeTwoParameters is defined at git_rose_development/src/midend/astQuery/nameQuery.h:95
/** Converts an enum of type NameQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNameQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "VariableNamesWithTypeName"; break;
        case 2: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NameQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NameQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeOneParameter is defined at git_rose_development/src/midend/astQuery/nodeQuery.h:134
/** Converts an enum of type NodeQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "VariableDeclarations"; break;
        case 2: retval = "VariableTypes"; break;
        case 3: retval = "FunctionDeclarations"; break;
        case 4: retval = "MemberFunctionDeclarations"; break;
        case 5: retval = "ClassDeclarations"; break;
        case 6: retval = "StructDeclarations"; break;
        case 7: retval = "UnionDeclarations"; break;
        case 8: retval = "Arguments"; break;
        case 9: retval = "ClassFields"; break;
        case 10: retval = "StructFields"; break;
        case 11: retval = "UnionFields"; break;
        case 12: retval = "StructDefinitions"; break;
        case 13: retval = "TypedefDeclarations"; break;
        case 14: retval = "AnonymousTypedefs"; break;
        case 15: retval = "AnonymousTypedefClassDeclarations"; break;
        case 16: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NodeQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NodeQuery::TypeOfQueryTypeTwoParameters is defined at git_rose_development/src/midend/astQuery/nodeQuery.h:155
/** Converts an enum of type NodeQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNodeQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "FunctionDeclarationFromDefinition"; break;
        case 2: retval = "ClassDeclarationFromName"; break;
        case 3: retval = "ClassDeclarationsFromTypeName"; break;
        case 4: retval = "PragmaDeclarationFromName"; break;
        case 5: retval = "VariableDeclarationFromName"; break;
        case 6: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NodeQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NodeQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeOneParameter is defined at git_rose_development/src/midend/astQuery/numberQuery.h:11
/** Converts an enum of type NumberQuery::TypeOfQueryTypeOneParameter to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeOneParameter(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementType"; break;
        case 1: retval = "NumberOfArgsInConstructor"; break;
        case 2: retval = "NumberOfOperands"; break;
        case 3: retval = "NumberOfArgsInScalarIndexingOperator"; break;
        case 4: retval = "END_OF_NODE_TYPE_LIST_ONE_PARAMETER"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NumberQuery::TypeOfQueryTypeOneParameter)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeOneParameter::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// NumberQuery::TypeOfQueryTypeTwoParameters is defined at git_rose_development/src/midend/astQuery/numberQuery.h:20
/** Converts an enum of type NumberQuery::TypeOfQueryTypeTwoParameters to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyNumberQueryTypeOfQueryTypeTwoParameters(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "UnknownListElementTypeTwoParameters"; break;
        case 1: retval = "NumberOfArgsInParanthesisOperator"; break;
        case 2: retval = "END_OF_NODE_TYPE_LIST_TWO_PARAMETERS"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(NumberQuery::TypeOfQueryTypeTwoParameters)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "NumberQuery::TypeOfQueryTypeTwoParameters::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// OmpSupport::omp_construct_enum is defined at git_rose_development/src/frontend/SageIII/OmpAttribute.h:27
/** Converts an enum of type OmpSupport::omp_construct_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_construct_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_parallel"; break;
        case 2: retval = "e_for"; break;
        case 3: retval = "e_do"; break;
        case 4: retval = "e_workshare"; break;
        case 5: retval = "e_sections"; break;
        case 6: retval = "e_section"; break;
        case 7: retval = "e_single"; break;
        case 8: retval = "e_master"; break;
        case 9: retval = "e_critical"; break;
        case 10: retval = "e_barrier"; break;
        case 11: retval = "e_atomic"; break;
        case 12: retval = "e_flush"; break;
        case 13: retval = "e_target"; break;
        case 14: retval = "e_target_declare"; break;
        case 15: retval = "e_target_data"; break;
        case 16: retval = "e_target_update"; break;
        case 17: retval = "e_map"; break;
        case 18: retval = "e_device"; break;
        case 19: retval = "e_begin"; break;
        case 20: retval = "e_end"; break;
        case 21: retval = "e_threadprivate"; break;
        case 22: retval = "e_parallel_for"; break;
        case 23: retval = "e_parallel_do"; break;
        case 24: retval = "e_parallel_sections"; break;
        case 25: retval = "e_parallel_workshare"; break;
        case 26: retval = "e_task"; break;
        case 27: retval = "e_taskwait"; break;
        case 28: retval = "e_ordered_directive"; break;
        case 29: retval = "e_end_critical"; break;
        case 30: retval = "e_end_do"; break;
        case 31: retval = "e_end_master"; break;
        case 32: retval = "e_end_ordered"; break;
        case 33: retval = "e_end_parallel_do"; break;
        case 34: retval = "e_end_parallel_sections"; break;
        case 35: retval = "e_end_parallel_workshare"; break;
        case 36: retval = "e_end_parallel"; break;
        case 37: retval = "e_end_sections"; break;
        case 38: retval = "e_end_single"; break;
        case 39: retval = "e_end_task"; break;
        case 40: retval = "e_end_workshare"; break;
        case 41: retval = "e_default"; break;
        case 42: retval = "e_shared"; break;
        case 43: retval = "e_private"; break;
        case 44: retval = "e_firstprivate"; break;
        case 45: retval = "e_lastprivate"; break;
        case 46: retval = "e_copyin"; break;
        case 47: retval = "e_copyprivate"; break;
        case 48: retval = "e_if"; break;
        case 49: retval = "e_num_threads"; break;
        case 50: retval = "e_nowait"; break;
        case 51: retval = "e_ordered_clause"; break;
        case 52: retval = "e_reduction"; break;
        case 53: retval = "e_schedule"; break;
        case 54: retval = "e_collapse"; break;
        case 55: retval = "e_untied"; break;
        case 56: retval = "e_default_none"; break;
        case 57: retval = "e_default_shared"; break;
        case 58: retval = "e_default_private"; break;
        case 59: retval = "e_default_firstprivate"; break;
        case 60: retval = "e_reduction_plus"; break;
        case 61: retval = "e_reduction_mul"; break;
        case 62: retval = "e_reduction_minus"; break;
        case 63: retval = "e_reduction_bitand"; break;
        case 64: retval = "e_reduction_bitor"; break;
        case 65: retval = "e_reduction_bitxor"; break;
        case 66: retval = "e_reduction_logand"; break;
        case 67: retval = "e_reduction_logor"; break;
        case 68: retval = "e_reduction_and"; break;
        case 69: retval = "e_reduction_or"; break;
        case 70: retval = "e_reduction_eqv"; break;
        case 71: retval = "e_reduction_neqv"; break;
        case 72: retval = "e_reduction_max"; break;
        case 73: retval = "e_reduction_min"; break;
        case 74: retval = "e_reduction_iand"; break;
        case 75: retval = "e_reduction_ior"; break;
        case 76: retval = "e_reduction_ieor"; break;
        case 77: retval = "e_schedule_none"; break;
        case 78: retval = "e_schedule_static"; break;
        case 79: retval = "e_schedule_dynamic"; break;
        case 80: retval = "e_schedule_guided"; break;
        case 81: retval = "e_schedule_auto"; break;
        case 82: retval = "e_schedule_runtime"; break;
        case 83: retval = "e_map_alloc"; break;
        case 84: retval = "e_map_to"; break;
        case 85: retval = "e_map_from"; break;
        case 86: retval = "e_map_tofrom"; break;
        case 87: retval = "e_dist_data"; break;
        case 88: retval = "e_duplicate"; break;
        case 89: retval = "e_block"; break;
        case 90: retval = "e_cyclic"; break;
        case 91: retval = "e_simd"; break;
        case 92: retval = "e_safelen"; break;
        case 93: retval = "e_uniform"; break;
        case 94: retval = "e_aligned"; break;
        case 95: retval = "e_linear"; break;
        case 96: retval = "e_not_omp"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(OmpSupport::omp_construct_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_construct_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// OmpSupport::omp_rtl_enum is defined at git_rose_development/src/midend/programTransformation/ompLowering/omp_lowering.h:36
/** Converts an enum of type OmpSupport::omp_rtl_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyOmpSupport_omp_rtl_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gomp"; break;
        case 1: retval = "e_omni"; break;
        case 2: retval = "e_last_rtl"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(OmpSupport::omp_rtl_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "OmpSupport::omp_rtl_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcConditionRegisterAccessGranularity is defined at git_rose_development/src/frontend/Disassemblers/powerpcInstructionEnum.h:471
/** Converts an enum of type PowerpcConditionRegisterAccessGranularity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcConditionRegisterAccessGranularity(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_condreggranularity_whole"; break;
        case 1: retval = "powerpc_condreggranularity_field"; break;
        case 2: retval = "powerpc_condreggranularity_bit"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PowerpcConditionRegisterAccessGranularity)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcConditionRegisterAccessGranularity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcInstructionKind is defined at git_rose_development/src/frontend/Disassemblers/powerpcInstructionEnum.h:9
/** Converts an enum of type PowerpcInstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcInstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_unknown_instruction"; break;
        case 1: retval = "powerpc_add"; break;
        case 2: retval = "powerpc_add_record"; break;
        case 3: retval = "powerpc_addo"; break;
        case 4: retval = "powerpc_addo_record"; break;
        case 5: retval = "powerpc_addc"; break;
        case 6: retval = "powerpc_addc_record"; break;
        case 7: retval = "powerpc_addco"; break;
        case 8: retval = "powerpc_addco_record"; break;
        case 9: retval = "powerpc_adde"; break;
        case 10: retval = "powerpc_adde_record"; break;
        case 11: retval = "powerpc_addeo"; break;
        case 12: retval = "powerpc_addeo_record"; break;
        case 13: retval = "powerpc_addi"; break;
        case 14: retval = "powerpc_addic"; break;
        case 15: retval = "powerpc_addic_record"; break;
        case 16: retval = "powerpc_addis"; break;
        case 17: retval = "powerpc_addme"; break;
        case 18: retval = "powerpc_addme_record"; break;
        case 19: retval = "powerpc_addmeo"; break;
        case 20: retval = "powerpc_addmeo_record"; break;
        case 21: retval = "powerpc_addze"; break;
        case 22: retval = "powerpc_addze_record"; break;
        case 23: retval = "powerpc_addzeo"; break;
        case 24: retval = "powerpc_addzeo_record"; break;
        case 25: retval = "powerpc_and"; break;
        case 26: retval = "powerpc_and_record"; break;
        case 27: retval = "powerpc_andc"; break;
        case 28: retval = "powerpc_andc_record"; break;
        case 29: retval = "powerpc_andi_record"; break;
        case 30: retval = "powerpc_andis_record"; break;
        case 31: retval = "powerpc_b"; break;
        case 32: retval = "powerpc_ba"; break;
        case 33: retval = "powerpc_bl"; break;
        case 34: retval = "powerpc_bla"; break;
        case 35: retval = "powerpc_bc"; break;
        case 36: retval = "powerpc_bca"; break;
        case 37: retval = "powerpc_bcl"; break;
        case 38: retval = "powerpc_bcla"; break;
        case 39: retval = "powerpc_bcctr"; break;
        case 40: retval = "powerpc_bcctrl"; break;
        case 41: retval = "powerpc_bclr"; break;
        case 42: retval = "powerpc_bclrl"; break;
        case 43: retval = "powerpc_cmp"; break;
        case 44: retval = "powerpc_cmpi"; break;
        case 45: retval = "powerpc_cmpl"; break;
        case 46: retval = "powerpc_cmpli"; break;
        case 47: retval = "powerpc_cntlzd"; break;
        case 48: retval = "powerpc_cntlzd_record"; break;
        case 49: retval = "powerpc_cntlzw"; break;
        case 50: retval = "powerpc_cntlzw_record"; break;
        case 51: retval = "powerpc_crand"; break;
        case 52: retval = "powerpc_crandc"; break;
        case 53: retval = "powerpc_creqv"; break;
        case 54: retval = "powerpc_crnand"; break;
        case 55: retval = "powerpc_crnor"; break;
        case 56: retval = "powerpc_cror"; break;
        case 57: retval = "powerpc_crorc"; break;
        case 58: retval = "powerpc_crxor"; break;
        case 59: retval = "powerpc_dcbf"; break;
        case 60: retval = "powerpc_dcba"; break;
        case 61: retval = "powerpc_dcbi"; break;
        case 62: retval = "powerpc_dcbst"; break;
        case 63: retval = "powerpc_dcbt"; break;
        case 64: retval = "powerpc_dcbtst"; break;
        case 65: retval = "powerpc_dcbz"; break;
        case 66: retval = "powerpc_divd"; break;
        case 67: retval = "powerpc_divd_record"; break;
        case 68: retval = "powerpc_divdo"; break;
        case 69: retval = "powerpc_divdo_record"; break;
        case 70: retval = "powerpc_divdu"; break;
        case 71: retval = "powerpc_divdu_record"; break;
        case 72: retval = "powerpc_divduo"; break;
        case 73: retval = "powerpc_divduo_record"; break;
        case 74: retval = "powerpc_divw"; break;
        case 75: retval = "powerpc_divw_record"; break;
        case 76: retval = "powerpc_divwo"; break;
        case 77: retval = "powerpc_divwo_record"; break;
        case 78: retval = "powerpc_divwu"; break;
        case 79: retval = "powerpc_divwu_record"; break;
        case 80: retval = "powerpc_divwuo"; break;
        case 81: retval = "powerpc_divwuo_record"; break;
        case 82: retval = "powerpc_dst"; break;
        case 83: retval = "powerpc_dstt"; break;
        case 84: retval = "powerpc_dstst"; break;
        case 85: retval = "powerpc_dststt"; break;
        case 86: retval = "powerpc_dss"; break;
        case 87: retval = "powerpc_dssall"; break;
        case 88: retval = "powerpc_eciwx"; break;
        case 89: retval = "powerpc_ecowx"; break;
        case 90: retval = "powerpc_eieio"; break;
        case 91: retval = "powerpc_eqv"; break;
        case 92: retval = "powerpc_eqv_record"; break;
        case 93: retval = "powerpc_extsb"; break;
        case 94: retval = "powerpc_extsb_record"; break;
        case 95: retval = "powerpc_extsh"; break;
        case 96: retval = "powerpc_extsh_record"; break;
        case 97: retval = "powerpc_extsw"; break;
        case 98: retval = "powerpc_extsw_record"; break;
        case 99: retval = "powerpc_fabs"; break;
        case 100: retval = "powerpc_fabs_record"; break;
        case 101: retval = "powerpc_fadd"; break;
        case 102: retval = "powerpc_fadd_record"; break;
        case 103: retval = "powerpc_fadds"; break;
        case 104: retval = "powerpc_fadds_record"; break;
        case 105: retval = "powerpc_fcfid"; break;
        case 106: retval = "powerpc_fcfid_record"; break;
        case 107: retval = "powerpc_fcmpo"; break;
        case 108: retval = "powerpc_fcmpu"; break;
        case 109: retval = "powerpc_fctid"; break;
        case 110: retval = "powerpc_fctid_record"; break;
        case 111: retval = "powerpc_fctidz"; break;
        case 112: retval = "powerpc_fctidz_record"; break;
        case 113: retval = "powerpc_fctiw"; break;
        case 114: retval = "powerpc_fctiw_record"; break;
        case 115: retval = "powerpc_fctiwz"; break;
        case 116: retval = "powerpc_fctiwz_record"; break;
        case 117: retval = "powerpc_fdiv"; break;
        case 118: retval = "powerpc_fdiv_record"; break;
        case 119: retval = "powerpc_fdivs"; break;
        case 120: retval = "powerpc_fdivs_record"; break;
        case 121: retval = "powerpc_fmadd"; break;
        case 122: retval = "powerpc_fmadd_record"; break;
        case 123: retval = "powerpc_fmadds"; break;
        case 124: retval = "powerpc_fmadds_record"; break;
        case 125: retval = "powerpc_fmr"; break;
        case 126: retval = "powerpc_fmr_record"; break;
        case 127: retval = "powerpc_fmsub"; break;
        case 128: retval = "powerpc_fmsub_record"; break;
        case 129: retval = "powerpc_fmsubs"; break;
        case 130: retval = "powerpc_fmsubs_record"; break;
        case 131: retval = "powerpc_fmul"; break;
        case 132: retval = "powerpc_fmul_record"; break;
        case 133: retval = "powerpc_fmuls"; break;
        case 134: retval = "powerpc_fmuls_record"; break;
        case 135: retval = "powerpc_fnabs"; break;
        case 136: retval = "powerpc_fnabs_record"; break;
        case 137: retval = "powerpc_fneg"; break;
        case 138: retval = "powerpc_fneg_record"; break;
        case 139: retval = "powerpc_fnmadd"; break;
        case 140: retval = "powerpc_fnmadd_record"; break;
        case 141: retval = "powerpc_fnmadds"; break;
        case 142: retval = "powerpc_fnmadds_record"; break;
        case 143: retval = "powerpc_fnmsub"; break;
        case 144: retval = "powerpc_fnmsub_record"; break;
        case 145: retval = "powerpc_fnmsubs"; break;
        case 146: retval = "powerpc_fnmsubs_record"; break;
        case 147: retval = "powerpc_fpmul"; break;
        case 148: retval = "powerpc_fxmul"; break;
        case 149: retval = "powerpc_fxpmul"; break;
        case 150: retval = "powerpc_fxsmul"; break;
        case 151: retval = "powerpc_fpadd"; break;
        case 152: retval = "powerpc_fpsub"; break;
        case 153: retval = "powerpc_fpre"; break;
        case 154: retval = "powerpc_fprsqrte"; break;
        case 155: retval = "powerpc_fpmr"; break;
        case 156: retval = "powerpc_fpabs"; break;
        case 157: retval = "powerpc_lfssx"; break;
        case 158: retval = "powerpc_fpneg"; break;
        case 159: retval = "powerpc_lfssux"; break;
        case 160: retval = "powerpc_fprsp"; break;
        case 161: retval = "powerpc_lfsdx"; break;
        case 162: retval = "powerpc_fpnabs"; break;
        case 163: retval = "powerpc_lfsdux"; break;
        case 164: retval = "powerpc_lfxsx"; break;
        case 165: retval = "powerpc_fsmr"; break;
        case 166: retval = "powerpc_lfxsux"; break;
        case 167: retval = "powerpc_lfxdx"; break;
        case 168: retval = "powerpc_fsabs"; break;
        case 169: retval = "powerpc_lfxdux"; break;
        case 170: retval = "powerpc_lfpsx"; break;
        case 171: retval = "powerpc_fsneg"; break;
        case 172: retval = "powerpc_lfpsux"; break;
        case 173: retval = "powerpc_lfpdx"; break;
        case 174: retval = "powerpc_fsnabs"; break;
        case 175: retval = "powerpc_lfpdux"; break;
        case 176: retval = "powerpc_stfpiwx"; break;
        case 177: retval = "powerpc_fxmr"; break;
        case 178: retval = "powerpc_fpctiw"; break;
        case 179: retval = "powerpc_stfssx"; break;
        case 180: retval = "powerpc_stfssux"; break;
        case 181: retval = "powerpc_fpctiwz"; break;
        case 182: retval = "powerpc_stfsdx"; break;
        case 183: retval = "powerpc_stfsdux"; break;
        case 184: retval = "powerpc_stfxsx"; break;
        case 185: retval = "powerpc_fsmtp"; break;
        case 186: retval = "powerpc_stfxsux"; break;
        case 187: retval = "powerpc_stfxdx"; break;
        case 188: retval = "powerpc_stfxdux"; break;
        case 189: retval = "powerpc_stfpsx"; break;
        case 190: retval = "powerpc_fsmfp"; break;
        case 191: retval = "powerpc_stfpsux"; break;
        case 192: retval = "powerpc_stfpdx"; break;
        case 193: retval = "powerpc_stfpdux"; break;
        case 194: retval = "powerpc_fpsel"; break;
        case 195: retval = "powerpc_fpmadd"; break;
        case 196: retval = "powerpc_fpmsub"; break;
        case 197: retval = "powerpc_fxmadd"; break;
        case 198: retval = "powerpc_fxcpmadd"; break;
        case 199: retval = "powerpc_fxcsmadd"; break;
        case 200: retval = "powerpc_fpnmadd"; break;
        case 201: retval = "powerpc_fxnmadd"; break;
        case 202: retval = "powerpc_fxcpnmadd"; break;
        case 203: retval = "powerpc_fxcsnmadd"; break;
        case 204: retval = "powerpc_fxcpnpma"; break;
        case 205: retval = "powerpc_fxmsub"; break;
        case 206: retval = "powerpc_fxcsnpma"; break;
        case 207: retval = "powerpc_fxcpmsub"; break;
        case 208: retval = "powerpc_fxcpnsma"; break;
        case 209: retval = "powerpc_fxcsmsub"; break;
        case 210: retval = "powerpc_fxcsnsma"; break;
        case 211: retval = "powerpc_fpnmsub"; break;
        case 212: retval = "powerpc_fxcxma"; break;
        case 213: retval = "powerpc_fxnmsub"; break;
        case 214: retval = "powerpc_fxcxnpma"; break;
        case 215: retval = "powerpc_fxcpnmsub"; break;
        case 216: retval = "powerpc_fxcxnsma"; break;
        case 217: retval = "powerpc_fxcsnmsub"; break;
        case 218: retval = "powerpc_fxcxnms"; break;
        case 219: retval = "powerpc_fre"; break;
        case 220: retval = "powerpc_fre_record"; break;
        case 221: retval = "powerpc_fres"; break;
        case 222: retval = "powerpc_fres_record"; break;
        case 223: retval = "powerpc_frsp"; break;
        case 224: retval = "powerpc_frsp_record"; break;
        case 225: retval = "powerpc_frsqrte"; break;
        case 226: retval = "powerpc_frsqrte_record"; break;
        case 227: retval = "powerpc_frsqrtes"; break;
        case 228: retval = "powerpc_frsqrtes_record"; break;
        case 229: retval = "powerpc_fsel"; break;
        case 230: retval = "powerpc_fsel_record"; break;
        case 231: retval = "powerpc_fsqrt"; break;
        case 232: retval = "powerpc_fsqrt_record"; break;
        case 233: retval = "powerpc_fsqrts"; break;
        case 234: retval = "powerpc_fsqrts_record"; break;
        case 235: retval = "powerpc_fsub"; break;
        case 236: retval = "powerpc_fsub_record"; break;
        case 237: retval = "powerpc_fsubs"; break;
        case 238: retval = "powerpc_fsubs_record"; break;
        case 239: retval = "powerpc_icbi"; break;
        case 240: retval = "powerpc_isync"; break;
        case 241: retval = "powerpc_lbz"; break;
        case 242: retval = "powerpc_lbzu"; break;
        case 243: retval = "powerpc_lbzux"; break;
        case 244: retval = "powerpc_lbzx"; break;
        case 245: retval = "powerpc_ld"; break;
        case 246: retval = "powerpc_ldarx"; break;
        case 247: retval = "powerpc_ldu"; break;
        case 248: retval = "powerpc_ldux"; break;
        case 249: retval = "powerpc_ldx"; break;
        case 250: retval = "powerpc_lfd"; break;
        case 251: retval = "powerpc_lfdu"; break;
        case 252: retval = "powerpc_lfdux"; break;
        case 253: retval = "powerpc_lfdx"; break;
        case 254: retval = "powerpc_lfs"; break;
        case 255: retval = "powerpc_lfsu"; break;
        case 256: retval = "powerpc_lfsux"; break;
        case 257: retval = "powerpc_lfsx"; break;
        case 258: retval = "powerpc_lha"; break;
        case 259: retval = "powerpc_lhau"; break;
        case 260: retval = "powerpc_lhaux"; break;
        case 261: retval = "powerpc_lhax"; break;
        case 262: retval = "powerpc_lhbrx"; break;
        case 263: retval = "powerpc_lhz"; break;
        case 264: retval = "powerpc_lhzu"; break;
        case 265: retval = "powerpc_lhzux"; break;
        case 266: retval = "powerpc_lhzx"; break;
        case 267: retval = "powerpc_lmw"; break;
        case 268: retval = "powerpc_lswi"; break;
        case 269: retval = "powerpc_lswx"; break;
        case 270: retval = "powerpc_lwa"; break;
        case 271: retval = "powerpc_lwarx"; break;
        case 272: retval = "powerpc_lwaux"; break;
        case 273: retval = "powerpc_lwax"; break;
        case 274: retval = "powerpc_lwbrx"; break;
        case 275: retval = "powerpc_lwz"; break;
        case 276: retval = "powerpc_lwzu"; break;
        case 277: retval = "powerpc_lwzux"; break;
        case 278: retval = "powerpc_lwzx"; break;
        case 279: retval = "powerpc_mcrf"; break;
        case 280: retval = "powerpc_mcrfs"; break;
        case 281: retval = "powerpc_mcrxr"; break;
        case 282: retval = "powerpc_mfcr"; break;
        case 283: retval = "powerpc_mffs"; break;
        case 284: retval = "powerpc_mffs_record"; break;
        case 285: retval = "powerpc_mfmsr"; break;
        case 286: retval = "powerpc_mfspr"; break;
        case 287: retval = "powerpc_mfsr"; break;
        case 288: retval = "powerpc_mfsrin"; break;
        case 289: retval = "powerpc_mftb"; break;
        case 290: retval = "powerpc_mtcrf"; break;
        case 291: retval = "powerpc_mtfsb0"; break;
        case 292: retval = "powerpc_mtfsb0_record"; break;
        case 293: retval = "powerpc_mtfsb1"; break;
        case 294: retval = "powerpc_mtfsb1_record"; break;
        case 295: retval = "powerpc_mtfsf"; break;
        case 296: retval = "powerpc_mtfsf_record"; break;
        case 297: retval = "powerpc_mtfsfi"; break;
        case 298: retval = "powerpc_mtfsfi_record"; break;
        case 299: retval = "powerpc_mtmsr"; break;
        case 300: retval = "powerpc_mtmsrd"; break;
        case 301: retval = "powerpc_mtspr"; break;
        case 302: retval = "powerpc_mtsr"; break;
        case 303: retval = "powerpc_mtsrd"; break;
        case 304: retval = "powerpc_mtsrdin"; break;
        case 305: retval = "powerpc_mtsrin"; break;
        case 306: retval = "powerpc_mulhd"; break;
        case 307: retval = "powerpc_mulhd_record"; break;
        case 308: retval = "powerpc_mulhdu"; break;
        case 309: retval = "powerpc_mulhdu_record"; break;
        case 310: retval = "powerpc_mulhw"; break;
        case 311: retval = "powerpc_mulhw_record"; break;
        case 312: retval = "powerpc_mulhwu"; break;
        case 313: retval = "powerpc_mulhwu_record"; break;
        case 314: retval = "powerpc_mulld"; break;
        case 315: retval = "powerpc_mulld_record"; break;
        case 316: retval = "powerpc_mulldo"; break;
        case 317: retval = "powerpc_mulldo_record"; break;
        case 318: retval = "powerpc_mulli"; break;
        case 319: retval = "powerpc_mullw"; break;
        case 320: retval = "powerpc_mullw_record"; break;
        case 321: retval = "powerpc_mullwo"; break;
        case 322: retval = "powerpc_mullwo_record"; break;
        case 323: retval = "powerpc_nand"; break;
        case 324: retval = "powerpc_nand_record"; break;
        case 325: retval = "powerpc_neg"; break;
        case 326: retval = "powerpc_neg_record"; break;
        case 327: retval = "powerpc_nego"; break;
        case 328: retval = "powerpc_nego_record"; break;
        case 329: retval = "powerpc_nor"; break;
        case 330: retval = "powerpc_nor_record"; break;
        case 331: retval = "powerpc_or"; break;
        case 332: retval = "powerpc_or_record"; break;
        case 333: retval = "powerpc_orc"; break;
        case 334: retval = "powerpc_orc_record"; break;
        case 335: retval = "powerpc_ori"; break;
        case 336: retval = "powerpc_oris"; break;
        case 337: retval = "powerpc_rfi"; break;
        case 338: retval = "powerpc_rfid"; break;
        case 339: retval = "powerpc_rldcl"; break;
        case 340: retval = "powerpc_rldcl_record"; break;
        case 341: retval = "powerpc_rldcr"; break;
        case 342: retval = "powerpc_rldcr_record"; break;
        case 343: retval = "powerpc_rldic"; break;
        case 344: retval = "powerpc_rldic_record"; break;
        case 345: retval = "powerpc_rldicl"; break;
        case 346: retval = "powerpc_rldicl_record"; break;
        case 347: retval = "powerpc_rldicr"; break;
        case 348: retval = "powerpc_rldicr_record"; break;
        case 349: retval = "powerpc_rldimi"; break;
        case 350: retval = "powerpc_rldimi_record"; break;
        case 351: retval = "powerpc_rlwimi"; break;
        case 352: retval = "powerpc_rlwimi_record"; break;
        case 353: retval = "powerpc_rlwinm"; break;
        case 354: retval = "powerpc_rlwinm_record"; break;
        case 355: retval = "powerpc_rlwnm"; break;
        case 356: retval = "powerpc_rlwnm_record"; break;
        case 357: retval = "powerpc_sc"; break;
        case 358: retval = "powerpc_slbia"; break;
        case 359: retval = "powerpc_slbie"; break;
        case 360: retval = "powerpc_sld"; break;
        case 361: retval = "powerpc_sld_record"; break;
        case 362: retval = "powerpc_slw"; break;
        case 363: retval = "powerpc_slw_record"; break;
        case 364: retval = "powerpc_srad"; break;
        case 365: retval = "powerpc_srad_record"; break;
        case 366: retval = "powerpc_sradi"; break;
        case 367: retval = "powerpc_sradi_record"; break;
        case 368: retval = "powerpc_srd"; break;
        case 369: retval = "powerpc_srd_record"; break;
        case 370: retval = "powerpc_sraw"; break;
        case 371: retval = "powerpc_sraw_record"; break;
        case 372: retval = "powerpc_srawi"; break;
        case 373: retval = "powerpc_srawi_record"; break;
        case 374: retval = "powerpc_srw"; break;
        case 375: retval = "powerpc_srw_record"; break;
        case 376: retval = "powerpc_stb"; break;
        case 377: retval = "powerpc_stbu"; break;
        case 378: retval = "powerpc_stbux"; break;
        case 379: retval = "powerpc_stbx"; break;
        case 380: retval = "powerpc_std"; break;
        case 381: retval = "powerpc_stdcx_record"; break;
        case 382: retval = "powerpc_stdu"; break;
        case 383: retval = "powerpc_stdux"; break;
        case 384: retval = "powerpc_stdx"; break;
        case 385: retval = "powerpc_stfd"; break;
        case 386: retval = "powerpc_stfdu"; break;
        case 387: retval = "powerpc_stfdux"; break;
        case 388: retval = "powerpc_stfdx"; break;
        case 389: retval = "powerpc_stfiwx"; break;
        case 390: retval = "powerpc_stfs"; break;
        case 391: retval = "powerpc_stfsu"; break;
        case 392: retval = "powerpc_stfsux"; break;
        case 393: retval = "powerpc_stfsx"; break;
        case 394: retval = "powerpc_sth"; break;
        case 395: retval = "powerpc_sthbrx"; break;
        case 396: retval = "powerpc_sthu"; break;
        case 397: retval = "powerpc_sthux"; break;
        case 398: retval = "powerpc_sthx"; break;
        case 399: retval = "powerpc_stmw"; break;
        case 400: retval = "powerpc_stswi"; break;
        case 401: retval = "powerpc_stswx"; break;
        case 402: retval = "powerpc_stw"; break;
        case 403: retval = "powerpc_stwbrx"; break;
        case 404: retval = "powerpc_stwcx_record"; break;
        case 405: retval = "powerpc_stwu"; break;
        case 406: retval = "powerpc_stwux"; break;
        case 407: retval = "powerpc_stwx"; break;
        case 408: retval = "powerpc_subf"; break;
        case 409: retval = "powerpc_subf_record"; break;
        case 410: retval = "powerpc_subfo"; break;
        case 411: retval = "powerpc_subfo_record"; break;
        case 412: retval = "powerpc_subfc"; break;
        case 413: retval = "powerpc_subfc_record"; break;
        case 414: retval = "powerpc_subfco"; break;
        case 415: retval = "powerpc_subfco_record"; break;
        case 416: retval = "powerpc_subfe"; break;
        case 417: retval = "powerpc_subfe_record"; break;
        case 418: retval = "powerpc_subfeo"; break;
        case 419: retval = "powerpc_subfeo_record"; break;
        case 420: retval = "powerpc_subfic"; break;
        case 421: retval = "powerpc_subfme"; break;
        case 422: retval = "powerpc_subfme_record"; break;
        case 423: retval = "powerpc_subfmeo"; break;
        case 424: retval = "powerpc_subfmeo_record"; break;
        case 425: retval = "powerpc_subfze"; break;
        case 426: retval = "powerpc_subfze_record"; break;
        case 427: retval = "powerpc_subfzeo"; break;
        case 428: retval = "powerpc_subfzeo_record"; break;
        case 429: retval = "powerpc_sync"; break;
        case 430: retval = "powerpc_td"; break;
        case 431: retval = "powerpc_tdi"; break;
        case 432: retval = "powerpc_tlbia"; break;
        case 433: retval = "powerpc_tlbie"; break;
        case 434: retval = "powerpc_tlbsync"; break;
        case 435: retval = "powerpc_tw"; break;
        case 436: retval = "powerpc_twi"; break;
        case 437: retval = "powerpc_xor"; break;
        case 438: retval = "powerpc_xor_record"; break;
        case 439: retval = "powerpc_xori"; break;
        case 440: retval = "powerpc_xoris"; break;
        case 441: retval = "powerpc_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PowerpcInstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcInstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcRegisterClass is defined at git_rose_development/src/frontend/Disassemblers/powerpcInstructionEnum.h:455
/** Converts an enum of type PowerpcRegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcRegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "powerpc_regclass_unknown"; break;
        case 1: retval = "powerpc_regclass_gpr"; break;
        case 2: retval = "powerpc_regclass_fpr"; break;
        case 3: retval = "powerpc_regclass_cr"; break;
        case 4: retval = "powerpc_regclass_fpscr"; break;
        case 5: retval = "powerpc_regclass_spr"; break;
        case 6: retval = "powerpc_regclass_tbr"; break;
        case 7: retval = "powerpc_regclass_msr"; break;
        case 8: retval = "powerpc_regclass_sr"; break;
        case 9: retval = "powerpc_regclass_iar"; break;
        case 10: retval = "powerpc_regclass_pvr"; break;
        case 11: retval = "powerpc_last_register_class"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PowerpcRegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcRegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcSpecialPurposeRegister is defined at git_rose_development/src/frontend/Disassemblers/powerpcInstructionEnum.h:478
/** Converts an enum of type PowerpcSpecialPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcSpecialPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "powerpc_spr_xer"; break;
        case 8: retval = "powerpc_spr_lr"; break;
        case 9: retval = "powerpc_spr_ctr"; break;
        case 18: retval = "powerpc_spr_dsisr"; break;
        case 19: retval = "powerpc_spr_dar"; break;
        case 22: retval = "powerpc_spr_dec"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PowerpcSpecialPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcSpecialPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PowerpcTimeBaseRegister is defined at git_rose_development/src/frontend/Disassemblers/powerpcInstructionEnum.h:488
/** Converts an enum of type PowerpcTimeBaseRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPowerpcTimeBaseRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 268: retval = "powerpc_tbr_tbl"; break;
        case 269: retval = "powerpc_tbr_tbu"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PowerpcTimeBaseRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PowerpcTimeBaseRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PreprocessingInfo::DirectiveType is defined at git_rose_development/src/frontend/SageIII/rose_attributes_list.h:131
/** Converts an enum of type PreprocessingInfo::DirectiveType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoDirectiveType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CpreprocessorUnknownDeclaration"; break;
        case 1: retval = "C_StyleComment"; break;
        case 2: retval = "CplusplusStyleComment"; break;
        case 3: retval = "FortranStyleComment"; break;
        case 4: retval = "F90StyleComment"; break;
        case 5: retval = "CpreprocessorBlankLine"; break;
        case 6: retval = "CpreprocessorIncludeDeclaration"; break;
        case 7: retval = "CpreprocessorIncludeNextDeclaration"; break;
        case 8: retval = "CpreprocessorDefineDeclaration"; break;
        case 9: retval = "CpreprocessorUndefDeclaration"; break;
        case 10: retval = "CpreprocessorIfdefDeclaration"; break;
        case 11: retval = "CpreprocessorIfndefDeclaration"; break;
        case 12: retval = "CpreprocessorIfDeclaration"; break;
        case 13: retval = "CpreprocessorDeadIfDeclaration"; break;
        case 14: retval = "CpreprocessorElseDeclaration"; break;
        case 15: retval = "CpreprocessorElifDeclaration"; break;
        case 16: retval = "CpreprocessorEndifDeclaration"; break;
        case 17: retval = "CpreprocessorLineDeclaration"; break;
        case 18: retval = "CpreprocessorErrorDeclaration"; break;
        case 19: retval = "CpreprocessorWarningDeclaration"; break;
        case 20: retval = "CpreprocessorEmptyDeclaration"; break;
        case 21: retval = "CSkippedToken"; break;
        case 22: retval = "CMacroCall"; break;
        case 23: retval = "CMacroCallStatement"; break;
        case 24: retval = "LineReplacement"; break;
        case 25: retval = "ClinkageSpecificationStart"; break;
        case 26: retval = "ClinkageSpecificationEnd"; break;
        case 27: retval = "CpreprocessorIdentDeclaration"; break;
        case 28: retval = "CpreprocessorCompilerGeneratedLinemarker"; break;
        case 29: retval = "RawText"; break;
        case 30: retval = "LastDirectiveType"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PreprocessingInfo::DirectiveType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::DirectiveType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PreprocessingInfo::RelativePositionType is defined at git_rose_development/src/frontend/SageIII/rose_attributes_list.h:110
/** Converts an enum of type PreprocessingInfo::RelativePositionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPreprocessingInfoRelativePositionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "defaultValue"; break;
        case 1: retval = "undef"; break;
        case 2: retval = "before"; break;
        case 3: retval = "after"; break;
        case 4: retval = "inside"; break;
        case 6: retval = "before_syntax"; break;
        case 7: retval = "after_syntax"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PreprocessingInfo::RelativePositionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PreprocessingInfo::RelativePositionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PtrAliasAnalysis::COLOR is defined at git_rose_development/src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h:31
/** Converts an enum of type PtrAliasAnalysis::COLOR to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPtrAliasAnalysisCOLOR(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "WHITE"; break;
        case 1: retval = "GREY"; break;
        case 2: retval = "BLACK"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PtrAliasAnalysis::COLOR)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PtrAliasAnalysis::COLOR::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// PtrAliasAnalysis::TRAVERSAL_TYPE is defined at git_rose_development/src/midend/programAnalysis/VirtualFunctionAnalysis/PtrAliasAnalysis.h:33
/** Converts an enum of type PtrAliasAnalysis::TRAVERSAL_TYPE to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyPtrAliasAnalysisTRAVERSAL_TYPE(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "TOPOLOGICAL"; break;
        case 1: retval = "REVERSE_TOPOLOGICAL"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(PtrAliasAnalysis::TRAVERSAL_TYPE)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "PtrAliasAnalysis::TRAVERSAL_TYPE::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QCodeEdit::Position is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qcodeedit.h:47
/** Converts an enum of type QCodeEdit::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQCodeEditPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "West"; break;
        case 1: retval = "North"; break;
        case 2: retval = "South"; break;
        case 3: retval = "East"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QCodeEdit::Position)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QCodeEdit::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::LineEnding is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:85
/** Converts an enum of type QDocument::LineEnding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineEnding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Conservative"; break;
        case 1: retval = "Local"; break;
        case 2: retval = "Unix"; break;
        case 3: retval = "Windows"; break;
        case 4: retval = "Mac"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocument::LineEnding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::LineEnding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::TextProcessing is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:94
/** Converts an enum of type QDocument::TextProcessing to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentTextProcessing(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RemoveTrailingWS"; break;
        case 2: retval = "PreserveIndent"; break;
        case 4: retval = "RestoreTrailingIndent"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocument::TextProcessing)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::TextProcessing::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocument::WhiteSpaceFlag is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocument.h:101
/** Converts an enum of type QDocument::WhiteSpaceFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentWhiteSpaceFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ShowNone"; break;
        case 1: retval = "ShowTrailing"; break;
        case 2: retval = "ShowLeading"; break;
        case 4: retval = "ShowTabs"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocument::WhiteSpaceFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocument::WhiteSpaceFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCommand::Command is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcommand.h:38
/** Converts an enum of type QDocumentCommand::Command to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCommandCommand(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Insert"; break;
        case 2: retval = "Erase"; break;
        case 3: retval = "Replace"; break;
        case 4: retval = "Custom"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentCommand::Command)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCommand::Command::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::MoveFlag is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:40
/** Converts an enum of type QDocumentCursor::MoveFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MoveAnchor"; break;
        case 1: retval = "KeepAnchor"; break;
        case 2: retval = "ThroughWrap"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentCursor::MoveFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::MoveOperation is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:49
/** Converts an enum of type QDocumentCursor::MoveOperation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorMoveOperation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoMove"; break;
        case 1: retval = "Up"; break;
        case 2: retval = "Down"; break;
        case 3: retval = "Left"; break;
        case 4: retval = "Right"; break;
        case 5: retval = "Start"; break;
        case 6: retval = "StartOfLine"; break;
        case 7: retval = "StartOfWord"; break;
        case 8: retval = "PreviousBlock"; break;
        case 9: retval = "PreviousWord"; break;
        case 10: retval = "WordLeft"; break;
        case 11: retval = "WordRight"; break;
        case 12: retval = "End"; break;
        case 13: retval = "EndOfLine"; break;
        case 14: retval = "EndOfWord"; break;
        case 15: retval = "NextWord"; break;
        case 16: retval = "NextBlock"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentCursor::MoveOperation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::MoveOperation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursor::SelectionType is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor.h:76
/** Converts an enum of type QDocumentCursor::SelectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorSelectionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "WordUnderCursor"; break;
        case 1: retval = "LineUnderCursor"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentCursor::SelectionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursor::SelectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentCursorHandle::Flags is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentcursor_p.h:53
/** Converts an enum of type QDocumentCursorHandle::Flags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentCursorHandleFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "Silent"; break;
        case 2: retval = "ColumnMemory"; break;
        case 4: retval = "MoveWithinWrapped"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentCursorHandle::Flags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentCursorHandle::Flags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentLine::State is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:70
/** Converts an enum of type QDocumentLine::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentLineState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Hidden"; break;
        case 2: retval = "CollapsedBlockStart"; break;
        case 4: retval = "CollapsedBlockEnd"; break;
        case 16: retval = "LayoutDirty"; break;
        case 32: retval = "FormatsApplied"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentLine::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentLine::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QDocumentSearch::Option is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentsearch.h:41
/** Converts an enum of type QDocumentSearch::Option to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQDocumentSearchOption(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "WholeWords"; break;
        case 2: retval = "CaseSensitive"; break;
        case 4: retval = "RegExp"; break;
        case 8: retval = "Replace"; break;
        case 16: retval = "Prompt"; break;
        case 32: retval = "Silent"; break;
        case 64: retval = "HighlightAll"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QDocumentSearch::Option)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QDocumentSearch::Option::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::CodecUpdatePolicy is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:65
/** Converts an enum of type QEditor::CodecUpdatePolicy to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorCodecUpdatePolicy(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoUpdate"; break;
        case 1: retval = "UpdateOld"; break;
        case 2: retval = "UpdateDefault"; break;
        case 4: retval = "UpdateCustom"; break;
        case 7: retval = "UpdateAll"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QEditor::CodecUpdatePolicy)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::CodecUpdatePolicy::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::EditFlag is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:75
/** Converts an enum of type QEditor::EditFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorEditFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 1: retval = "Overwrite"; break;
        case 2: retval = "CursorOn"; break;
        case 4: retval = "ReadOnly"; break;
        case 8: retval = "MousePressed"; break;
        case 16: retval = "MaybeDrag"; break;
        case 32: retval = "Selection"; break;
        case 64: retval = "Persistent"; break;
        case 128: retval = "Multiline"; break;
        case 256: retval = "FoldedCursor"; break;
        case 4095: retval = "Internal"; break;
        case 4096: retval = "LineWrap"; break;
        case 65536: retval = "CtrlNavigation"; break;
        case 131072: retval = "CursorJumpPastWrap"; break;
        case 1048576: retval = "ReplaceTabs"; break;
        case 2097152: retval = "RemoveTrailing"; break;
        case 4194304: retval = "PreserveTrailingIndent"; break;
        case 16777216: retval = "AutoCloseChars"; break;
        case 33554432: retval = "AutoIndent"; break;
        case 4294963200: retval = "Accessible"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QEditor::EditFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::EditFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QEditor::SaveState is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qeditor.h:494
/** Converts an enum of type QEditor::SaveState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQEditorSaveState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Undefined"; break;
        case 1: retval = "Saving"; break;
        case 2: retval = "Saved"; break;
        case 3: retval = "Conflict"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QEditor::SaveState)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QEditor::SaveState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QLanguageDefinition::CollapseFlag is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qlanguagedefinition.h:45
/** Converts an enum of type QLanguageDefinition::CollapseFlag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQLanguageDefinitionCollapseFlag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "None"; break;
        case 4095: retval = "OpenMask"; break;
        case 16773120: retval = "CloseMask"; break;
        case 268435456: retval = "Collapsible"; break;
        case 536870912: retval = "Collapsed"; break;
        case 1073741824: retval = "Closure"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QLanguageDefinition::CollapseFlag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QLanguageDefinition::CollapseFlag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QNFAAction::QNFAAction_ is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:42
/** Converts an enum of type QNFAAction::QNFAAction_ to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFAActionQNFAAction_(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoAction"; break;
        case 4095: retval = "FormatMask"; break;
        case 16773120: retval = "ParenMask"; break;
        case 16777216: retval = "Highlight"; break;
        case 33554432: retval = "Indent"; break;
        case 67108864: retval = "ParenOpen"; break;
        case 134217728: retval = "ParenClose"; break;
        case 268435456: retval = "MatchParen"; break;
        case 536870912: retval = "Fold"; break;
        case 1073741824: retval = "Ambiguous"; break;
        case 2147483648: retval = "Content"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QNFAAction::QNFAAction_)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFAAction::QNFAAction_::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QNFADefinition::PMatch::Type is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qnfa/qnfadefinition.h:130
/** Converts an enum of type QNFADefinition::PMatch::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQNFADefinitionPMatchType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Invalid"; break;
        case 1: retval = "Match"; break;
        case 2: retval = "Mismatch"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QNFADefinition::PMatch::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QNFADefinition::PMatch::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QPanelLayout::Position is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:39
/** Converts an enum of type QPanelLayout::Position to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "West"; break;
        case 1: retval = "North"; break;
        case 2: retval = "South"; break;
        case 3: retval = "East"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QPanelLayout::Position)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::Position::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QPanelLayout::SizeType is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qpanellayout.h:87
/** Converts an enum of type QPanelLayout::SizeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQPanelLayoutSizeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "MinimumSize"; break;
        case 1: retval = "SizeHint"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QPanelLayout::SizeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QPanelLayout::SizeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QParenthesis::Role is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/document/qdocumentline.h:39
/** Converts an enum of type QParenthesis::Role to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQParenthesisRole(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "Open"; break;
        case 2: retval = "Close"; break;
        case 4: retval = "Indent"; break;
        case 8: retval = "Fold"; break;
        case 16: retval = "Match"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QParenthesis::Role)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QParenthesis::Role::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QReliableFileWatch::State is defined at git_rose_development/src/roseExtensions/qtWidgets/QCodeEditWidget/QCodeEdit/qreliablefilewatch.h:53
/** Converts an enum of type QReliableFileWatch::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQReliableFileWatchState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Clean"; break;
        case 1: retval = "Recent"; break;
        case 2: retval = "Duplicate"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QReliableFileWatch::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QReliableFileWatch::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QtColorLine::ColorComponent is defined at git_rose_development/src/roseExtensions/qtWidgets/QtGradientEditor/qtcolorline.h:63
/** Converts an enum of type QtColorLine::ColorComponent to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtColorLineColorComponent(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Red"; break;
        case 1: retval = "Green"; break;
        case 2: retval = "Blue"; break;
        case 3: retval = "Hue"; break;
        case 4: retval = "Saturation"; break;
        case 5: retval = "Value"; break;
        case 6: retval = "Alpha"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QtColorLine::ColorComponent)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtColorLine::ColorComponent::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// QtGradientWidgetPrivate::Handle is defined at git_rose_development/src/roseExtensions/qtWidgets/QtGradientEditor/qtgradientwidget.cpp:92
/** Converts an enum of type QtGradientWidgetPrivate::Handle to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyQtGradientWidgetPrivateHandle(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NoHandle"; break;
        case 1: retval = "StartLinearHandle"; break;
        case 2: retval = "EndLinearHandle"; break;
        case 3: retval = "CentralRadialHandle"; break;
        case 4: retval = "FocalRadialHandle"; break;
        case 5: retval = "RadiusRadialHandle"; break;
        case 6: retval = "CentralConicalHandle"; break;
        case 7: retval = "AngleConicalHandle"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(QtGradientWidgetPrivate::Handle)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "QtGradientWidgetPrivate::Handle::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RIFG::EdgeDirection is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:63
/** Converts an enum of type RIFG::EdgeDirection to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_EdgeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ED_INCOMING"; break;
        case 1: retval = "ED_OUTGOING"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RIFG::EdgeDirection)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::EdgeDirection::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RIFG::ForwardBackward is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CFG/RIFG.h:64
/** Converts an enum of type RIFG::ForwardBackward to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRIFG_ForwardBackward(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORWARD"; break;
        case 1: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RIFG::ForwardBackward)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RIFG::ForwardBackward::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RITarjEdgeType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:67
/** Converts an enum of type RITarjEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RI_TARJ_NORMAL"; break;
        case 1: retval = "RI_TARJ_LOOP_ENTRY"; break;
        case 2: retval = "RI_TARJ_IRRED_ENTRY"; break;
        case 3: retval = "RI_TARJ_ITERATE"; break;
    }
    if (retval.empty()) {
        char buf[78];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RITarjEdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RITarjType is defined at git_rose_development/src/midend/programAnalysis/OpenAnalysis/CFG/TarjanIntervals.h:65
/** Converts an enum of type RITarjType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRITarjType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RI_TARJ_NOTHING"; break;
        case 1: retval = "RI_TARJ_ACYCLIC"; break;
        case 2: retval = "RI_TARJ_INTERVAL"; break;
        case 3: retval = "RI_TARJ_IRREDUCIBLE"; break;
    }
    if (retval.empty()) {
        char buf[74];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RITarjType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RITarjType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSEAttributesList::languageTypeEnum is defined at git_rose_development/src/frontend/SageIII/rose_attributes_list.h:495
/** Converts an enum of type ROSEAttributesList::languageTypeEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSEAttributesList_languageTypeEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_language"; break;
        case 1: retval = "e_C_language"; break;
        case 2: retval = "e_Cxx_language"; break;
        case 3: retval = "e_Fortran77_language"; break;
        case 4: retval = "e_Fortran9x_language"; break;
        case 5: retval = "e_lastLanguage"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSEAttributesList::languageTypeEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSEAttributesList::languageTypeEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Callbacks::Direction is defined at git_rose_development/src/roseSupport/callbacks.h:12
/** Converts an enum of type ROSE_Callbacks::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_CallbacksDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORWARD"; break;
        case 1: retval = "BACKWARD"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Callbacks::Direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Callbacks::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Additional_Info is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:168
/** Converts an enum of type ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10001: retval = "ROSE_FORT_COMMENTS"; break;
        case 10002: retval = "ROSE_STRING_LITERALS"; break;
        case 10003: retval = "ROSE_IDENTIFIER"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Identifiers is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:11
/** Converts an enum of type ROSE_Fortran_Identifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Identifiers(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2: retval = "ROSE_ABSTRACT"; break;
        case 3: retval = "ROSE_ACCESS"; break;
        case 4: retval = "ROSE_ACTION"; break;
        case 5: retval = "ROSE_ALLOCATE"; break;
        case 6: retval = "ROSE_ALLOCATABLE"; break;
        case 7: retval = "ROSE_ASSIGN"; break;
        case 8: retval = "ROSE_ASSOCIATE"; break;
        case 9: retval = "ROSE_ASYNCHRONOUS"; break;
        case 10: retval = "ROSE_BACKSPACE"; break;
        case 11: retval = "ROSE_BIND"; break;
        case 12: retval = "ROSE_BLANK"; break;
        case 13: retval = "ROSE_BLOCK_DATA"; break;
        case 14: retval = "ROSE_CALL"; break;
        case 15: retval = "ROSE_CHARACTER"; break;
        case 16: retval = "ROSE_CLASS"; break;
        case 17: retval = "ROSE_CLOSE"; break;
        case 18: retval = "ROSE_CONTINUE"; break;
        case 19: retval = "ROSE_CYCLE"; break;
        case 20: retval = "ROSE_CASE"; break;
        case 21: retval = "ROSE_COMMON"; break;
        case 22: retval = "ROSE_COMPLEX"; break;
        case 23: retval = "ROSE_CONTAINS"; break;
        case 24: retval = "ROSE_DEALLOCATE"; break;
        case 25: retval = "ROSE_DATA"; break;
        case 26: retval = "ROSE_DEFERRED"; break;
        case 27: retval = "ROSE_DELIM"; break;
        case 28: retval = "ROSE_DIMENSION"; break;
        case 29: retval = "ROSE_DO"; break;
        case 30: retval = "ROSE_DT"; break;
        case 31: retval = "ROSE_DOUBLEPRECISION"; break;
        case 32: retval = "ROSE_ENCODING"; break;
        case 33: retval = "ROSE_END_CASE"; break;
        case 34: retval = "ROSE_ENDDO"; break;
        case 35: retval = "ROSE_END_FILE"; break;
        case 36: retval = "ROSE_END_ENUM"; break;
        case 37: retval = "ROSE_END_INTERFACE"; break;
        case 38: retval = "ROSE_END_TYPE"; break;
        case 39: retval = "ROSE_ERR"; break;
        case 40: retval = "ROSE_ERRMSG"; break;
        case 41: retval = "ROSE_EXIT"; break;
        case 42: retval = "ROSE_ELSE"; break;
        case 43: retval = "ROSE_ELSEWHERE"; break;
        case 44: retval = "ROSE_ELSEIF"; break;
        case 45: retval = "ROSE_ENDIF"; break;
        case 46: retval = "ROSE_ENTRY"; break;
        case 47: retval = "ROSE_END"; break;
        case 49: retval = "ROSE_ENUMERATOR"; break;
        case 50: retval = "ROSE_EQUIVALENCE"; break;
        case 51: retval = "ROSE_EXTERNAL"; break;
        case 52: retval = "ROSE_EXTENDS"; break;
        case 53: retval = "ROSE_FILE"; break;
        case 54: retval = "ROSE_FINAL"; break;
        case 55: retval = "ROSE_FMT"; break;
        case 56: retval = "ROSE_FORALL"; break;
        case 57: retval = "ROSE_FORM"; break;
        case 58: retval = "ROSE_FORMATTED"; break;
        case 59: retval = "ROSE_FORMAT"; break;
        case 60: retval = "ROSE_FLUSH"; break;
        case 61: retval = "ROSE_FUNCTION"; break;
        case 62: retval = "ROSE_GENERIC"; break;
        case 63: retval = "ROSE_GOTO"; break;
        case 64: retval = "ROSE_ID"; break;
        case 65: retval = "ROSE_IF"; break;
        case 66: retval = "ROSE_INQUIRE"; break;
        case 67: retval = "ROSE_INTEGER"; break;
        case 68: retval = "ROSE_IOMSG"; break;
        case 69: retval = "ROSE_IOSTAT"; break;
        case 70: retval = "ROSE_IMPLICIT"; break;
        case 71: retval = "ROSE_IMPLICIT_NONE"; break;
        case 72: retval = "ROSE_IMPORT"; break;
        case 73: retval = "ROSE_INTERFACE"; break;
        case 74: retval = "ROSE_INTENT"; break;
        case 75: retval = "ROSE_INTRINSIC"; break;
        case 76: retval = "ROSE_LEN"; break;
        case 77: retval = "ROSE_LOGICAL"; break;
        case 78: retval = "ROSE_KIND"; break;
        case 79: retval = "ROSE_MODULE_PROC"; break;
        case 80: retval = "ROSE_MODULE"; break;
        case 81: retval = "ROSE_NON_INTRINSIC"; break;
        case 82: retval = "ROSE_NON_OVERRIDABLE"; break;
        case 83: retval = "ROSE_NULL"; break;
        case 84: retval = "ROSE_NULLIFY"; break;
        case 85: retval = "ROSE_NAMELIST"; break;
        case 86: retval = "ROSE_NML"; break;
        case 87: retval = "ROSE_NONE"; break;
        case 88: retval = "ROSE_NOPASS"; break;
        case 89: retval = "ROSE_ONLY"; break;
        case 90: retval = "ROSE_OPEN"; break;
        case 91: retval = "ROSE_PARAMETER"; break;
        case 92: retval = "ROSE_PASS"; break;
        case 93: retval = "ROSE_PAUSE"; break;
        case 94: retval = "ROSE_POINTER"; break;
        case 96: retval = "ROSE_PRINT"; break;
        case 97: retval = "ROSE_PRIVATE"; break;
        case 98: retval = "ROSE_PROCEDURE"; break;
        case 99: retval = "ROSE_PROGRAM"; break;
        case 100: retval = "ROSE_PROTECTED"; break;
        case 101: retval = "ROSE_READ"; break;
        case 102: retval = "ROSE_REAL"; break;
        case 103: retval = "ROSE_RETURN"; break;
        case 104: retval = "ROSE_REWIND"; break;
        case 105: retval = "ROSE_ROUND"; break;
        case 106: retval = "ROSE_SELECTCASE"; break;
        case 107: retval = "ROSE_SELECTTYPE"; break;
        case 108: retval = "ROSE_SEQUENCE"; break;
        case 109: retval = "ROSE_SAVE"; break;
        case 110: retval = "ROSE_SIGN"; break;
        case 111: retval = "ROSE_SIZE"; break;
        case 112: retval = "ROSE_SOURCE"; break;
        case 113: retval = "ROSE_STAT"; break;
        case 114: retval = "ROSE_STOP"; break;
        case 115: retval = "ROSE_SUBROUTINE"; break;
        case 116: retval = "ROSE_TARGET"; break;
        case 117: retval = "ROSE_THEN"; break;
        case 118: retval = "ROSE_DERIVED_DECL"; break;
        case 119: retval = "ROSE_TYPEIS"; break;
        case 120: retval = "ROSE_UNFORMATTED"; break;
        case 121: retval = "ROSE_UNIT"; break;
        case 122: retval = "ROSE_USE"; break;
        case 123: retval = "ROSE_VALUE"; break;
        case 124: retval = "ROSE_VOLATILE"; break;
        case 125: retval = "ROSE_WAIT"; break;
        case 126: retval = "ROSE_WHERE"; break;
        case 127: retval = "ROSE_WRITE"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_Identifiers)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Identifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_Operators is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs.h:141
/** Converts an enum of type ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1001: retval = "ROSE_INTRINSIC_PLUS"; break;
        case 1002: retval = "ROSE_INTRINSIC_MINUS"; break;
        case 1003: retval = "ROSE_INTRINSIC_POWER"; break;
        case 1004: retval = "ROSE_INTRINSIC_CONCAT"; break;
        case 1005: retval = "ROSE_INTRINSIC_TIMES"; break;
        case 1006: retval = "ROSE_INTRINSIC_DIVIDE"; break;
        case 1007: retval = "ROSE_INTRINSIC_AND"; break;
        case 1008: retval = "ROSE_INTRINSIC_OR"; break;
        case 1009: retval = "ROSE_INTRINSIC_EQV"; break;
        case 1010: retval = "ROSE_INTRINSIC_NEQV"; break;
        case 1011: retval = "ROSE_INTRINSIC_EQ"; break;
        case 1012: retval = "ROSE_INTRINSIC_NE"; break;
        case 1013: retval = "ROSE_INTRINSIC_GE"; break;
        case 1014: retval = "ROSE_INTRINSIC_LE"; break;
        case 1015: retval = "ROSE_INTRINSIC_LT"; break;
        case 1016: retval = "ROSE_INTRINSIC_GT"; break;
        case 1017: retval = "ROSE_INTRINSIC_NOT"; break;
        case 1018: retval = "ROSE_INTRINSIC_OLDEQ"; break;
        case 1019: retval = "ROSE_INTRINSIC_OLDNE"; break;
        case 1020: retval = "ROSE_INTRINSIC_OLDGE"; break;
        case 1021: retval = "ROSE_INTRINSIC_OLDLE"; break;
        case 1022: retval = "ROSE_INTRINSIC_OLDLT"; break;
        case 1023: retval = "ROSE_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_keywords is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:148
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500: retval = "C_CXX_ASM"; break;
        case 501: retval = "C_CXX_AUTO"; break;
        case 502: retval = "C_CXX_BOOL"; break;
        case 503: retval = "C_CXX_BREAK"; break;
        case 504: retval = "C_CXX_CASE"; break;
        case 505: retval = "C_CXX_CATCH"; break;
        case 506: retval = "C_CXX_CHAR"; break;
        case 507: retval = "C_CXX_CLASS"; break;
        case 508: retval = "C_CXX_CONST"; break;
        case 509: retval = "C_CXX_CONSTCAST"; break;
        case 510: retval = "C_CXX_CONTINUE"; break;
        case 511: retval = "C_CXX_DEFAULT"; break;
        case 512: retval = "C_CXX_DEFINED"; break;
        case 513: retval = "C_CXX_DELETE"; break;
        case 514: retval = "C_CXX_DO"; break;
        case 515: retval = "C_CXX_DOUBLE"; break;
        case 516: retval = "C_CXX_DYNAMICCAST"; break;
        case 517: retval = "C_CXX_ELSE"; break;
        case 518: retval = "C_CXX_ENUM"; break;
        case 519: retval = "C_CXX_EXPLICIT"; break;
        case 520: retval = "C_CXX_EXPORT"; break;
        case 521: retval = "C_CXX_EXTERN"; break;
        case 522: retval = "C_CXX_FALSE"; break;
        case 523: retval = "C_CXX_FLOAT"; break;
        case 524: retval = "C_CXX_FOR"; break;
        case 525: retval = "C_CXX_FRIEND"; break;
        case 526: retval = "C_CXX_GOTO"; break;
        case 527: retval = "C_CXX_IF"; break;
        case 528: retval = "C_CXX_INLINE"; break;
        case 529: retval = "C_CXX_INT"; break;
        case 530: retval = "C_CXX_LONG"; break;
        case 531: retval = "C_CXX_MUTABLE"; break;
        case 532: retval = "C_CXX_NAMESPACE"; break;
        case 533: retval = "C_CXX_NEW"; break;
        case 534: retval = "C_CXX_OPERATOR"; break;
        case 535: retval = "C_CXX_PRIVATE"; break;
        case 536: retval = "C_CXX_PROTECTED"; break;
        case 537: retval = "C_CXX_PUBLIC"; break;
        case 538: retval = "C_CXX_REGISTER"; break;
        case 539: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540: retval = "C_CXX_RETURN"; break;
        case 541: retval = "C_CXX_SHORT"; break;
        case 542: retval = "C_CXX_SIGNED"; break;
        case 543: retval = "C_CXX_SIZEOF"; break;
        case 544: retval = "C_CXX_STATIC"; break;
        case 545: retval = "C_CXX_STATICCAST"; break;
        case 546: retval = "C_CXX_STRUCT"; break;
        case 547: retval = "C_CXX_SWITCH"; break;
        case 548: retval = "C_CXX_TEMPLATE"; break;
        case 549: retval = "C_CXX_THIS"; break;
        case 550: retval = "C_CXX_THROW"; break;
        case 551: retval = "C_CXX_TRY"; break;
        case 552: retval = "C_CXX_TRUE"; break;
        case 553: retval = "C_CXX_TYPEDEF"; break;
        case 554: retval = "C_CXX_TYPEID"; break;
        case 555: retval = "C_CXX_TYPENAME"; break;
        case 556: retval = "C_CXX_UNION"; break;
        case 557: retval = "C_CXX_UNSIGNED"; break;
        case 558: retval = "C_CXX_USING"; break;
        case 559: retval = "C_CXX_VIRTUAL"; break;
        case 560: retval = "C_CXX_VOID"; break;
        case 561: retval = "C_CXX_VOLATILE"; break;
        case 562: retval = "C_CXX_WCHART"; break;
        case 563: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_C_CXX_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_C_CXX_operators is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:243
/** Converts an enum of type ROSE_Fortran_defs::ROSE_C_CXX_operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_C_CXX_operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000: retval = "C_CXX_AND"; break;
        case 50001: retval = "C_CXX_ANDAND"; break;
        case 50002: retval = "C_CXX_ASSIGN"; break;
        case 50003: retval = "C_CXX_ANDASSIGN"; break;
        case 50004: retval = "C_CXX_OR"; break;
        case 50005: retval = "C_CXX_ORASSIGN"; break;
        case 50006: retval = "C_CXX_XOR"; break;
        case 50007: retval = "C_CXX_XORASSIGN"; break;
        case 50008: retval = "C_CXX_COMMA"; break;
        case 50009: retval = "C_CXX_COLON"; break;
        case 50010: retval = "C_CXX_DIVIDE"; break;
        case 50011: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012: retval = "C_CXX_DOT"; break;
        case 50013: retval = "C_CXX_DOTSTAR"; break;
        case 50014: retval = "C_CXX_ELLIPSIS"; break;
        case 50015: retval = "C_CXX_EQUAL"; break;
        case 50016: retval = "C_CXX_GREATER"; break;
        case 50017: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018: retval = "C_CXX_LEFTBRACE"; break;
        case 50019: retval = "C_CXX_LESS"; break;
        case 50020: retval = "C_CXX_LESSEQUAL"; break;
        case 50021: retval = "C_CXX_LEFTPAREN"; break;
        case 50022: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023: retval = "C_CXX_MINUS"; break;
        case 50024: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025: retval = "C_CXX_MINUSMINUS"; break;
        case 50026: retval = "C_CXX_PERCENT"; break;
        case 50027: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028: retval = "C_CXX_NOT"; break;
        case 50029: retval = "C_CXX_NOTEQUAL"; break;
        case 50030: retval = "C_CXX_OROR"; break;
        case 50031: retval = "C_CXX_PLUS"; break;
        case 50032: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033: retval = "C_CXX_PLUSPLUS"; break;
        case 50034: retval = "C_CXX_ARROW"; break;
        case 50035: retval = "C_CXX_ARROWSTAR"; break;
        case 50036: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040: retval = "C_CXX_COLON_COLON"; break;
        case 50041: retval = "C_CXX_SEMICOLON"; break;
        case 50042: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046: retval = "C_CXX_STAR"; break;
        case 50047: retval = "C_CXX_COMPL"; break;
        case 50048: retval = "C_CXX_STARASSIGN"; break;
        case 50049: retval = "C_CXX_POUND_POUND"; break;
        case 50050: retval = "C_CXX_POUND"; break;
        case 50051: retval = "C_CXX_AND_ALT"; break;
        case 50052: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053: retval = "C_CXX_OR_ALT"; break;
        case 50054: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055: retval = "C_CXX_XOR_ALT"; break;
        case 50056: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059: retval = "C_CXX_NOT_ALT"; break;
        case 50060: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063: retval = "C_CXX_COMPL_ALT"; break;
        case 50064: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065: retval = "C_CXX_POUND_ALT"; break;
        case 50066: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_C_CXX_operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_C_CXX_operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Additional_Info is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:322
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000: retval = "FORTRAN_COMMENTS"; break;
        case 100001: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_Operators is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:216
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_Fortran_defs::ROSE_Fortran_keywords is defined at git_rose_development/src/frontend/OpenFortranParser_SAGE_Connection/rose_token_defs_gen.h:15
/** Converts an enum of type ROSE_Fortran_defs::ROSE_Fortran_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_Fortran_defsROSE_Fortran_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORTRAN_ABSTRACT"; break;
        case 1: retval = "FORTRAN_ACCESS"; break;
        case 2: retval = "FORTRAN_ACTION"; break;
        case 3: retval = "FORTRAN_ALLOCATE"; break;
        case 4: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5: retval = "FORTRAN_ASSIGN"; break;
        case 6: retval = "FORTRAN_ASSOCIATE"; break;
        case 7: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8: retval = "FORTRAN_BACKSPACE"; break;
        case 9: retval = "FORTRAN_BIND"; break;
        case 10: retval = "FORTRAN_BLANK"; break;
        case 11: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12: retval = "FORTRAN_CALL"; break;
        case 13: retval = "FORTRAN_CHARACTER"; break;
        case 14: retval = "FORTRAN_CLASS"; break;
        case 15: retval = "FORTRAN_CLOSE"; break;
        case 16: retval = "FORTRAN_CONTINUE"; break;
        case 17: retval = "FORTRAN_CYCLE"; break;
        case 18: retval = "FORTRAN_CASE"; break;
        case 19: retval = "FORTRAN_COMMON"; break;
        case 20: retval = "FORTRAN_COMPLEX"; break;
        case 21: retval = "FORTRAN_CONTAINS"; break;
        case 22: retval = "FORTRAN_DEALLOCATE"; break;
        case 23: retval = "FORTRAN_DATA"; break;
        case 24: retval = "FORTRAN_DEFERRED"; break;
        case 25: retval = "FORTRAN_DELIM"; break;
        case 26: retval = "FORTRAN_DIMENSION"; break;
        case 27: retval = "FORTRAN_DO"; break;
        case 28: retval = "FORTRAN_DT"; break;
        case 29: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30: retval = "FORTRAN_ENCODING"; break;
        case 31: retval = "FORTRAN_END_CASE"; break;
        case 32: retval = "FORTRAN_ENDDO"; break;
        case 33: retval = "FORTRAN_END_FILE"; break;
        case 34: retval = "FORTRAN_END_ENUM"; break;
        case 35: retval = "FORTRAN_END_INTERFACE"; break;
        case 36: retval = "FORTRAN_END_TYPE"; break;
        case 37: retval = "FORTRAN_ERR"; break;
        case 38: retval = "FORTRAN_ERRMSG"; break;
        case 39: retval = "FORTRAN_EXIT"; break;
        case 40: retval = "FORTRAN_ELSE"; break;
        case 41: retval = "FORTRAN_ELSEWHERE"; break;
        case 42: retval = "FORTRAN_ELSEIF"; break;
        case 43: retval = "FORTRAN_ENDIF"; break;
        case 44: retval = "FORTRAN_ENTRY"; break;
        case 45: retval = "FORTRAN_END"; break;
        case 46: retval = "FORTRAN_ENUM"; break;
        case 47: retval = "FORTRAN_ENUMERATOR"; break;
        case 48: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49: retval = "FORTRAN_EXTERNAL"; break;
        case 50: retval = "FORTRAN_EXTENDS"; break;
        case 51: retval = "FORTRAN_FILE"; break;
        case 52: retval = "FORTRAN_FINAL"; break;
        case 53: retval = "FORTRAN_FMT"; break;
        case 54: retval = "FORTRAN_FORALL"; break;
        case 55: retval = "FORTRAN_FORM"; break;
        case 56: retval = "FORTRAN_FORMATTED"; break;
        case 57: retval = "FORTRAN_FORMAT"; break;
        case 58: retval = "FORTRAN_FLUSH"; break;
        case 59: retval = "FORTRAN_FUNCTION"; break;
        case 60: retval = "FORTRAN_GENERIC"; break;
        case 61: retval = "FORTRAN_GOTO"; break;
        case 62: retval = "FORTRAN_ID"; break;
        case 63: retval = "FORTRAN_IF"; break;
        case 64: retval = "FORTRAN_INQUIRE"; break;
        case 65: retval = "FORTRAN_INTEGER"; break;
        case 66: retval = "FORTRAN_IOMSG"; break;
        case 67: retval = "FORTRAN_IOSTAT"; break;
        case 68: retval = "FORTRAN_IMPLICIT"; break;
        case 69: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70: retval = "FORTRAN_IMPORT"; break;
        case 71: retval = "FORTRAN_INTERFACE"; break;
        case 72: retval = "FORTRAN_INTENT"; break;
        case 73: retval = "FORTRAN_INTRINSIC"; break;
        case 74: retval = "FORTRAN_LEN"; break;
        case 75: retval = "FORTRAN_LOGICAL"; break;
        case 76: retval = "FORTRAN_KIND"; break;
        case 77: retval = "FORTRAN_MODULE_PROC"; break;
        case 78: retval = "FORTRAN_MODULE"; break;
        case 79: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81: retval = "FORTRAN_NULL"; break;
        case 82: retval = "FORTRAN_NULLIFY"; break;
        case 83: retval = "FORTRAN_NAMELIST"; break;
        case 84: retval = "FORTRAN_NML"; break;
        case 85: retval = "FORTRAN_NONE"; break;
        case 86: retval = "FORTRAN_NOPASS"; break;
        case 87: retval = "FORTRAN_ONLY"; break;
        case 88: retval = "FORTRAN_OPEN"; break;
        case 89: retval = "FORTRAN_OPTIONAL"; break;
        case 90: retval = "FORTRAN_PARAMETER"; break;
        case 91: retval = "FORTRAN_PASS"; break;
        case 92: retval = "FORTRAN_PAUSE"; break;
        case 93: retval = "FORTRAN_POINTER"; break;
        case 94: retval = "FORTRAN_PRINT"; break;
        case 95: retval = "FORTRAN_PRIVATE"; break;
        case 96: retval = "FORTRAN_PROCEDURE"; break;
        case 97: retval = "FORTRAN_PROGRAM"; break;
        case 98: retval = "FORTRAN_PROTECTED"; break;
        case 99: retval = "FORTRAN_READ"; break;
        case 100: retval = "FORTRAN_REAL"; break;
        case 101: retval = "FORTRAN_RETURN"; break;
        case 102: retval = "FORTRAN_REWIND"; break;
        case 103: retval = "FORTRAN_ROUND"; break;
        case 104: retval = "FORTRAN_SELECTCASE"; break;
        case 105: retval = "FORTRAN_SELECTTYPE"; break;
        case 106: retval = "FORTRAN_SEQUENCE"; break;
        case 107: retval = "FORTRAN_SAVE"; break;
        case 108: retval = "FORTRAN_SIGN"; break;
        case 109: retval = "FORTRAN_SIZE"; break;
        case 110: retval = "FORTRAN_SOURCE"; break;
        case 111: retval = "FORTRAN_STAT"; break;
        case 112: retval = "FORTRAN_STOP"; break;
        case 113: retval = "FORTRAN_SUBROUTINE"; break;
        case 114: retval = "FORTRAN_TARGET"; break;
        case 115: retval = "FORTRAN_THEN"; break;
        case 116: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117: retval = "FORTRAN_TYPEIS"; break;
        case 118: retval = "FORTRAN_UNFORMATTED"; break;
        case 119: retval = "FORTRAN_UNIT"; break;
        case 120: retval = "FORTRAN_USE"; break;
        case 121: retval = "FORTRAN_VALUE"; break;
        case 122: retval = "FORTRAN_VOLATILE"; break;
        case 123: retval = "FORTRAN_WAIT"; break;
        case 124: retval = "FORTRAN_WHERE"; break;
        case 125: retval = "FORTRAN_WRITE"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_Fortran_defs::ROSE_Fortran_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_Fortran_defs::ROSE_Fortran_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_Additional_Info is defined at git_rose_development/src/frontend/SageIII/general_token_defs.h:172
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000: retval = "C_CXX_COMMENTS"; break;
        case 100001: retval = "C_CXX_STRING_LITERALS"; break;
        case 100002: retval = "C_CXX_IDENTIFIER"; break;
        case 100003: retval = "C_CXX_PREPROCESSING_INFO"; break;
        case 100004: retval = "C_CXX_UNIDENTIFIED_TOKEN"; break;
        case 100005: retval = "C_CXX_SYNTAX"; break;
        case 100006: retval = "C_CXX_WHITESPACE"; break;
        case 100007: retval = "C_CXX_PRAGMA"; break;
        case 100008: retval = "C_CXX_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_token_ids::ROSE_C_CXX_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_alternate_tok is defined at git_rose_development/src/frontend/SageIII/general_token_defs.h:160
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_alternate_tok to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_alternate_tok(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "C_CXX_LEFT_CURLY_ALT"; break;
        case 1: retval = "C_CXX_RIGHT_CURLY_ALT"; break;
        case 2: retval = "C_CXX_LEFT_SQUARE_ALT"; break;
        case 3: retval = "C_CXX_RIGHT_SQUARE_ALT"; break;
        case 4: retval = "C_CXX_HASH_ALT"; break;
        case 5: retval = "C_CXX_HASH_HASH_ALT"; break;
        case 6: retval = "C_CXX_and_ALT"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_token_ids::ROSE_C_CXX_alternate_tok)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_alternate_tok::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::ROSE_C_CXX_keywords is defined at git_rose_development/src/frontend/SageIII/general_token_defs.h:89
/** Converts an enum of type ROSE_token_ids::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_idsROSE_C_CXX_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500: retval = "C_CXX_ASM"; break;
        case 501: retval = "C_CXX_AUTO"; break;
        case 502: retval = "C_CXX_BOOL"; break;
        case 503: retval = "C_CXX_BREAK"; break;
        case 504: retval = "C_CXX_CASE"; break;
        case 505: retval = "C_CXX_CATCH"; break;
        case 506: retval = "C_CXX_CHAR"; break;
        case 507: retval = "C_CXX_CLASS"; break;
        case 508: retval = "C_CXX_CONST"; break;
        case 509: retval = "C_CXX_CONSTCAST"; break;
        case 510: retval = "C_CXX_CONTINUE"; break;
        case 511: retval = "C_CXX_DEFAULT"; break;
        case 512: retval = "C_CXX_DEFINED"; break;
        case 513: retval = "C_CXX_DELETE"; break;
        case 514: retval = "C_CXX_DO"; break;
        case 515: retval = "C_CXX_DOUBLE"; break;
        case 516: retval = "C_CXX_DYNAMICCAST"; break;
        case 517: retval = "C_CXX_ELSE"; break;
        case 518: retval = "C_CXX_ENUM"; break;
        case 519: retval = "C_CXX_EXPLICIT"; break;
        case 520: retval = "C_CXX_EXPORT"; break;
        case 521: retval = "C_CXX_EXTERN"; break;
        case 522: retval = "C_CXX_FALSE"; break;
        case 523: retval = "C_CXX_FLOAT"; break;
        case 524: retval = "C_CXX_FOR"; break;
        case 525: retval = "C_CXX_FRIEND"; break;
        case 526: retval = "C_CXX_GOTO"; break;
        case 527: retval = "C_CXX_IF"; break;
        case 528: retval = "C_CXX_INLINE"; break;
        case 529: retval = "C_CXX_INT"; break;
        case 530: retval = "C_CXX_LONG"; break;
        case 531: retval = "C_CXX_MUTABLE"; break;
        case 532: retval = "C_CXX_NAMESPACE"; break;
        case 533: retval = "C_CXX_NEW"; break;
        case 534: retval = "C_CXX_OPERATOR"; break;
        case 535: retval = "C_CXX_PRIVATE"; break;
        case 536: retval = "C_CXX_PROTECTED"; break;
        case 537: retval = "C_CXX_PUBLIC"; break;
        case 538: retval = "C_CXX_REGISTER"; break;
        case 539: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540: retval = "C_CXX_RETURN"; break;
        case 541: retval = "C_CXX_SHORT"; break;
        case 542: retval = "C_CXX_SIGNED"; break;
        case 543: retval = "C_CXX_SIZEOF"; break;
        case 544: retval = "C_CXX_STATIC"; break;
        case 545: retval = "C_CXX_STATICCAST"; break;
        case 546: retval = "C_CXX_STRUCT"; break;
        case 547: retval = "C_CXX_SWITCH"; break;
        case 548: retval = "C_CXX_TEMPLATE"; break;
        case 549: retval = "C_CXX_THIS"; break;
        case 550: retval = "C_CXX_THROW"; break;
        case 551: retval = "C_CXX_TRY"; break;
        case 552: retval = "C_CXX_TRUE"; break;
        case 553: retval = "C_CXX_TYPEDEF"; break;
        case 554: retval = "C_CXX_TYPEID"; break;
        case 555: retval = "C_CXX_TYPENAME"; break;
        case 556: retval = "C_CXX_UNION"; break;
        case 557: retval = "C_CXX_UNSIGNED"; break;
        case 558: retval = "C_CXX_USING"; break;
        case 559: retval = "C_CXX_VIRTUAL"; break;
        case 560: retval = "C_CXX_VOID"; break;
        case 561: retval = "C_CXX_VOLATILE"; break;
        case 562: retval = "C_CXX_WCHART"; break;
        case 563: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_token_ids::ROSE_C_CXX_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ROSE_token_ids::whitespace is defined at git_rose_development/src/frontend/SageIII/general_token_defs.h:13
/** Converts an enum of type ROSE_token_ids::whitespace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyROSE_token_ids_whitespace(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "T_NOTKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ROSE_token_ids::whitespace)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ROSE_token_ids::whitespace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ReachingDef::Type is defined at git_rose_development/src/midend/programAnalysis/staticSingleAssignment/reachingDef.h:19
/** Converts an enum of type ReachingDef::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyReachingDefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PHI_FUNCTION"; break;
        case 1: retval = "ORIGINAL_DEF"; break;
        case 2: retval = "EXPANDED_DEF"; break;
    }
    if (retval.empty()) {
        char buf[81];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ReachingDef::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ReachingDef::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RegisterDictionary::SortBySize::Direction is defined at git_rose_development/src/frontend/Disassemblers/Registers.h:149
/** Converts an enum of type RegisterDictionary::SortBySize::Direction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRegisterDictionarySortBySizeDirection(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ASCENDING"; break;
        case 1: retval = "DESCENDING"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RegisterDictionary::SortBySize::Direction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RegisterDictionary::SortBySize::Direction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_Arch::Architecture is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:51
/** Converts an enum of type RoseBin_Arch::Architecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_ArchArchitecture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "bit32"; break;
        case 1: retval = "bit64"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_Arch::Architecture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Arch::Architecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_DataTypes::DataTypes is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:86
/** Converts an enum of type RoseBin_DataTypes::DataTypes to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DataTypesDataTypes(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknown"; break;
        case 1: retval = "d_none"; break;
        case 2: retval = "d_int"; break;
        case 3: retval = "d_uint"; break;
        case 4: retval = "d_struct"; break;
        case 5: retval = "d_char_p"; break;
        case 6: retval = "d_size_t"; break;
        case 7: retval = "d_const_char_p"; break;
        case 8: retval = "d_pid_t"; break;
        case 9: retval = "d_uint_p"; break;
        case 10: retval = "d_long"; break;
        case 11: retval = "d_array"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_DataTypes::DataTypes)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_DataTypes::DataTypes::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_Def::RoseLanguage is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:32
/** Converts an enum of type RoseBin_Def::RoseLanguage to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_DefRoseLanguage(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "none"; break;
        case 1: retval = "x86"; break;
        case 2: retval = "arm"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_Def::RoseLanguage)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_Def::RoseLanguage::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_OS::OSSYSTEM is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:42
/** Converts an enum of type RoseBin_OS::OSSYSTEM to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_OSSYSTEM(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "linux_op"; break;
        case 1: retval = "windows_op"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_OS::OSSYSTEM)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS::OSSYSTEM::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_OS_VER::OS_VERSION is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:60
/** Converts an enum of type RoseBin_OS_VER::OS_VERSION to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_OS_VER_OS_VERSION(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "linux_22"; break;
        case 1: retval = "linux_24"; break;
        case 2: retval = "linux_26"; break;
        case 3: retval = "linux_27"; break;
        case 4: retval = "NT_SP3"; break;
        case 5: retval = "NT_SP4"; break;
        case 6: retval = "NT_SP5"; break;
        case 7: retval = "NT_SP6"; break;
        case 8: retval = "Win2000_SP0"; break;
        case 9: retval = "Win2000_SP1"; break;
        case 10: retval = "Win2000_SP2"; break;
        case 11: retval = "Win2000_SP3"; break;
        case 12: retval = "Win2000_SP4"; break;
        case 13: retval = "WinXP_SP0"; break;
        case 14: retval = "WinXP_SP1"; break;
        case 15: retval = "WinXP_SP2"; break;
        case 16: retval = "WinVista_SP0"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_OS_VER::OS_VERSION)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_OS_VER::OS_VERSION::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// RoseBin_support::X86PositionInRegister is defined at git_rose_development/src/frontend/BinaryDisassembly/RoseBin_support.h:175
/** Converts an enum of type RoseBin_support::X86PositionInRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyRoseBin_supportX86PositionInRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_regpos_unknown"; break;
        case 1: retval = "x86_regpos_low_byte"; break;
        case 2: retval = "x86_regpos_high_byte"; break;
        case 3: retval = "x86_regpos_word"; break;
        case 4: retval = "x86_regpos_dword"; break;
        case 5: retval = "x86_regpos_qword"; break;
        case 6: retval = "x86_regpos_all"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(RoseBin_support::X86PositionInRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "RoseBin_support::X86PositionInRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::PDGEdge::EdgeType is defined at git_rose_development/src/midend/programAnalysis/systemDependenceGraph/PDG.h:33
/** Converts an enum of type SDG::PDGEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_PDGEdgeEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ControlDependence"; break;
        case 1: retval = "DataDependence"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SDG::PDGEdge::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::PDGEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGEdge::ControlDependenceType is defined at git_rose_development/src/midend/programAnalysis/systemDependenceGraph/SDG.h:59
/** Converts an enum of type SDG::SDGEdge::ControlDependenceType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGEdgeControlDependenceType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "cdTrue"; break;
        case 1: retval = "cdFalse"; break;
        case 2: retval = "cdCase"; break;
        case 3: retval = "cdDefault"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SDG::SDGEdge::ControlDependenceType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGEdge::ControlDependenceType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGEdge::EdgeType is defined at git_rose_development/src/midend/programAnalysis/systemDependenceGraph/SDG.h:49
/** Converts an enum of type SDG::SDGEdge::EdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGEdgeEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ControlDependence"; break;
        case 1: retval = "DataDependence"; break;
        case 2: retval = "ParameterIn"; break;
        case 3: retval = "ParameterOut"; break;
        case 4: retval = "Call"; break;
        case 5: retval = "Summary"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SDG::SDGEdge::EdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGEdge::EdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SDG::SDGNode::NodeType is defined at git_rose_development/src/midend/programAnalysis/systemDependenceGraph/SDG.h:22
/** Converts an enum of type SDG::SDGNode::NodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySDG_SDGNodeNodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "Entry"; break;
        case 1: retval = "ASTNode"; break;
        case 2: retval = "FunctionCall"; break;
        case 3: retval = "ActualIn"; break;
        case 4: retval = "ActualOut"; break;
        case 5: retval = "FormalIn"; break;
        case 6: retval = "FormalOut"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SDG::SDGNode::NodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SDG::SDGNode::NodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SPRAY::LabelProperty::IOType is defined at git_rose_development/src/midend/abstractLayer/Labeler.h:85
/** Converts an enum of type SPRAY::LabelProperty::IOType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySPRAY_LabelPropertyIOType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LABELIO_NONE"; break;
        case 1: retval = "LABELIO_STDIN"; break;
        case 2: retval = "LABELIO_STDOUTVAR"; break;
        case 3: retval = "LABELIO_STDOUTCONST"; break;
        case 4: retval = "LABELIO_STDERR"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SPRAY::LabelProperty::IOType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SPRAY::LabelProperty::IOType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SPRAY::LabelProperty::LabelType is defined at git_rose_development/src/midend/abstractLayer/Labeler.h:59
/** Converts an enum of type SPRAY::LabelProperty::LabelType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySPRAY_LabelPropertyLabelType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "LABEL_UNDEF"; break;
        case 2: retval = "LABEL_OTHER"; break;
        case 100: retval = "LABEL_FUNCTIONCALL"; break;
        case 101: retval = "LABEL_FUNCTIONCALLRETURN"; break;
        case 102: retval = "LABEL_FUNCTIONENTRY"; break;
        case 103: retval = "LABEL_FUNCTIONEXIT"; break;
        case 104: retval = "LABEL_BLOCKBEGIN"; break;
        case 105: retval = "LABEL_BLOCKEND"; break;
        case 106: retval = "LABEL_EMPTY_STMT"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SPRAY::LabelProperty::LabelType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SPRAY::LabelProperty::LabelType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SageBuilder::SourcePositionClassification is defined at git_rose_development/src/frontend/SageIII/sageInterface/sageBuilder.h:123
/** Converts an enum of type SageBuilder::SourcePositionClassification to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySageBuilderSourcePositionClassification(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_sourcePositionError"; break;
        case 1: retval = "e_sourcePositionDefault"; break;
        case 2: retval = "e_sourcePositionTransformation"; break;
        case 3: retval = "e_sourcePositionCompilerGenerated"; break;
        case 4: retval = "e_sourcePositionNullPointers"; break;
        case 5: retval = "e_sourcePositionFrontendConstruction"; break;
        case 6: retval = "e_sourcePosition_last"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SageBuilder::SourcePositionClassification)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SageBuilder::SourcePositionClassification::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Access::Access is defined at git_rose_development/src/util/Sawyer/Access.h:17
/** Converts an enum of type Sawyer::Access::Access to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerAccessAccess(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "EXECUTABLE"; break;
        case 2: retval = "WRITABLE"; break;
        case 4: retval = "READABLE"; break;
        case 8: retval = "IMMUTABLE"; break;
        case 255: retval = "RESERVED_MASK"; break;
        case 4294967040: retval = "USERDEF_MASK"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Access::Access)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Access::Access::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::CommandLine::SortOrder is defined at git_rose_development/src/util/Sawyer/CommandLine.h:170
/** Converts an enum of type Sawyer::CommandLine::SortOrder to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerCommandLineSortOrder(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INSERTION_ORDER"; break;
        case 1: retval = "DOCKEY_ORDER"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::CommandLine::SortOrder)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::CommandLine::SortOrder::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::CommandLine::WhichValue is defined at git_rose_development/src/util/Sawyer/CommandLine.h:1789
/** Converts an enum of type Sawyer::CommandLine::WhichValue to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerCommandLineWhichValue(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SAVE_NONE"; break;
        case 1: retval = "SAVE_ONE"; break;
        case 2: retval = "SAVE_LAST"; break;
        case 3: retval = "SAVE_FIRST"; break;
        case 4: retval = "SAVE_ALL"; break;
        case 5: retval = "SAVE_AUGMENTED"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::CommandLine::WhichValue)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::CommandLine::WhichValue::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Container::Algorithm::TraversalEvent is defined at git_rose_development/src/util/Sawyer/GraphTraversal.h:38
/** Converts an enum of type Sawyer::Container::Algorithm::TraversalEvent to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerContainerAlgorithmTraversalEvent(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_EVENT"; break;
        case 1: retval = "ENTER_VERTEX"; break;
        case 2: retval = "ENTER_EDGE"; break;
        case 4: retval = "DISCOVER_VERTEX"; break;
        case 8: retval = "LEAVE_EDGE"; break;
        case 16: retval = "LEAVE_VERTEX"; break;
        case 32: retval = "FOLLOW_EDGE"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Container::Algorithm::TraversalEvent)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Container::Algorithm::TraversalEvent::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Container::Graph::EdgePhase is defined at git_rose_development/src/util/Sawyer/Graph.h:264
/** Converts an enum of type Sawyer::Container::Graph::EdgePhase to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerContainerGraphEdgePhase(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "IN_EDGES"; break;
        case 1: retval = "OUT_EDGES"; break;
        case 2: retval = "N_PHASES"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Container::Graph::EdgePhase)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Container::Graph::EdgePhase::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Markup::DivSpan is defined at git_rose_development/src/util/Sawyer/Markup.h:104
/** Converts an enum of type Sawyer::Markup::DivSpan to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMarkupDivSpan(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "DIVIDING"; break;
        case 1: retval = "SPANNING"; break;
        case 2: retval = "VERBATIM"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Markup::DivSpan)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Markup::DivSpan::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Markup::TextMode is defined at git_rose_development/src/util/Sawyer/Markup.h:424
/** Converts an enum of type Sawyer::Markup::TextMode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMarkupTextMode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PROSE"; break;
        case 1: retval = "NONPROSE"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Markup::TextMode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Markup::TextMode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::AnsiColor is defined at git_rose_development/src/util/Sawyer/Message.h:340
/** Converts an enum of type Sawyer::Message::AnsiColor to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageAnsiColor(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "COLOR_BLACK"; break;
        case 1: retval = "COLOR_RED"; break;
        case 2: retval = "COLOR_GREEN"; break;
        case 3: retval = "COLOR_YELLOW"; break;
        case 4: retval = "COLOR_BLUE"; break;
        case 5: retval = "COLOR_MAGENTA"; break;
        case 6: retval = "COLOR_CYAN"; break;
        case 7: retval = "COLOR_WHITE"; break;
        case 8: retval = "COLOR_DEFAULT"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Message::AnsiColor)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::AnsiColor::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::Importance is defined at git_rose_development/src/util/Sawyer/Message.h:310
/** Converts an enum of type Sawyer::Message::Importance to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageImportance(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "DEBUG"; break;
        case 1: retval = "TRACE"; break;
        case 2: retval = "WHERE"; break;
        case 3: retval = "MARCH"; break;
        case 4: retval = "INFO"; break;
        case 5: retval = "WARN"; break;
        case 6: retval = "ERROR"; break;
        case 7: retval = "FATAL"; break;
        case 8: retval = "N_IMPORTANCE"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Message::Importance)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::Importance::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sawyer::Message::When is defined at git_rose_development/src/util/Sawyer/Message.h:980
/** Converts an enum of type Sawyer::Message::When to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySawyerMessageWhen(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NEVER"; break;
        case 1: retval = "SOMETIMES"; break;
        case 2: retval = "ALWAYS"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sawyer::Message::When)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sawyer::Message::When::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAccessModifier::access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11870
/** Converts an enum of type SgAccessModifier::access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAccessModifier_access_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_private"; break;
        case 2: retval = "e_protected"; break;
        case 3: retval = "e_public"; break;
        case 4: retval = "e_undefined"; break;
        case 5: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAccessModifier::access_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAccessModifier::access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmBlock::Reason is defined at frontend/SageIII/Cxx_Grammar.h:307880
/** Converts an enum of type SgAsmBlock::Reason to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmBlockReason(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BLK_NONE"; break;
        case 1: retval = "BLK_FINDDATA"; break;
        case 2: retval = "BLK_POSTFUNC"; break;
        case 255: retval = "BLK_MISCMASK"; break;
        case 65536: retval = "BLK_ENTRY_POINT"; break;
        case 131072: retval = "BLK_PADDING"; break;
        case 524288: retval = "BLK_FRAGMENT"; break;
        case 1048576: retval = "BLK_CFGHEAD"; break;
        case 2097152: retval = "BLK_USERDEF"; break;
        case 4194304: retval = "BLK_LEFTOVERS"; break;
        case 8388608: retval = "BLK_JUMPTABLE"; break;
        case 16777216: retval = "BLK_GRAPH1"; break;
        case 33554432: retval = "BLK_GRAPH2"; break;
        case 67108864: retval = "BLK_GRAPH3"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmBlock::Reason)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmBlock::Reason::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfDynamicEntry::EntryType is defined at frontend/SageIII/Cxx_Grammar.h:365467
/** Converts an enum of type SgAsmElfDynamicEntry::EntryType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfDynamicEntryEntryType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "DT_NULL"; break;
        case 1: retval = "DT_NEEDED"; break;
        case 2: retval = "DT_PLTRELSZ"; break;
        case 3: retval = "DT_PLTGOT"; break;
        case 4: retval = "DT_HASH"; break;
        case 5: retval = "DT_STRTAB"; break;
        case 6: retval = "DT_SYMTAB"; break;
        case 7: retval = "DT_RELA"; break;
        case 8: retval = "DT_RELASZ"; break;
        case 9: retval = "DT_RELAENT"; break;
        case 10: retval = "DT_STRSZ"; break;
        case 11: retval = "DT_SYMENT"; break;
        case 12: retval = "DT_INIT"; break;
        case 13: retval = "DT_FINI"; break;
        case 14: retval = "DT_SONAME"; break;
        case 15: retval = "DT_RPATH"; break;
        case 16: retval = "DT_SYMBOLIC"; break;
        case 17: retval = "DT_REL"; break;
        case 18: retval = "DT_RELSZ"; break;
        case 19: retval = "DT_RELENT"; break;
        case 20: retval = "DT_PLTREL"; break;
        case 21: retval = "DT_DEBUG"; break;
        case 22: retval = "DT_TEXTREL"; break;
        case 23: retval = "DT_JMPREL"; break;
        case 24: retval = "DT_BIND_NOW"; break;
        case 25: retval = "DT_INIT_ARRAY"; break;
        case 26: retval = "DT_FINI_ARRAY"; break;
        case 27: retval = "DT_INIT_ARRAYSZ"; break;
        case 28: retval = "DT_FINI_ARRAYSZ"; break;
        case 29: retval = "DT_RUNPATH"; break;
        case 30: retval = "DT_FLAGS"; break;
        case 32: retval = "DT_PREINIT_ARRAY"; break;
        case 33: retval = "DT_PREINIT_ARRAYSZ"; break;
        case 34: retval = "DT_NUM"; break;
        case 1879047669: retval = "DT_GNU_PRELINKED"; break;
        case 1879047670: retval = "DT_GNU_CONFLICTSZ"; break;
        case 1879047671: retval = "DT_GNU_LIBLISTSZ"; break;
        case 1879047672: retval = "DT_CHECKSUM"; break;
        case 1879047673: retval = "DT_PLTPADSZ"; break;
        case 1879047674: retval = "DT_MOVEENT"; break;
        case 1879047675: retval = "DT_MOVESZ"; break;
        case 1879047676: retval = "DT_FEATURE_1"; break;
        case 1879047677: retval = "DT_POSFLAG_1"; break;
        case 1879047678: retval = "DT_SYMINSZ"; break;
        case 1879047679: retval = "DT_SYMINENT"; break;
        case 1879047925: retval = "DT_GNU_HASH"; break;
        case 1879047926: retval = "DT_TLSDESC_PLT"; break;
        case 1879047927: retval = "DT_TLSDESC_GOT"; break;
        case 1879047928: retval = "DT_GNU_CONFLICT"; break;
        case 1879047929: retval = "DT_GNU_LIBLIST"; break;
        case 1879047930: retval = "DT_CONFIG"; break;
        case 1879047931: retval = "DT_DEPAUDIT"; break;
        case 1879047932: retval = "DT_AUDIT"; break;
        case 1879047933: retval = "DT_PLTPAD"; break;
        case 1879047934: retval = "DT_MOVETAB"; break;
        case 1879047935: retval = "DT_SYMINFO"; break;
        case 1879048176: retval = "DT_VERSYM"; break;
        case 1879048185: retval = "DT_RELACOUNT"; break;
        case 1879048186: retval = "DT_RELCOUNT"; break;
        case 1879048187: retval = "DT_FLAGS_1"; break;
        case 1879048188: retval = "DT_VERDEF"; break;
        case 1879048189: retval = "DT_VERDEFNUM"; break;
        case 1879048190: retval = "DT_VERNEED"; break;
        case 1879048191: retval = "DT_VERNEEDNUM"; break;
        case 2147483645: retval = "DT_AUXILIARY"; break;
        case 2147483647: retval = "DT_FILTER"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfDynamicEntry::EntryType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfDynamicEntry::EntryType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfFileHeader::ObjectType is defined at frontend/SageIII/Cxx_Grammar.h:339157
/** Converts an enum of type SgAsmElfFileHeader::ObjectType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfFileHeaderObjectType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ET_NONE"; break;
        case 1: retval = "ET_REL"; break;
        case 2: retval = "ET_EXEC"; break;
        case 3: retval = "ET_DYN"; break;
        case 4: retval = "ET_CORE"; break;
        case 65024: retval = "ET_LOOS"; break;
        case 65279: retval = "ET_HIOS"; break;
        case 65280: retval = "ET_LOPROC"; break;
        case 65535: retval = "ET_HIPROC"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfFileHeader::ObjectType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfFileHeader::ObjectType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfRelocEntry::RelocType is defined at frontend/SageIII/Cxx_Grammar.h:363378
/** Converts an enum of type SgAsmElfRelocEntry::RelocType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfRelocEntryRelocType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "R_386_NONE"; break;
        case 1: retval = "R_386_32"; break;
        case 2: retval = "R_386_PC32"; break;
        case 3: retval = "R_386_GOT32"; break;
        case 4: retval = "R_386_PLT32"; break;
        case 5: retval = "R_386_COPY"; break;
        case 6: retval = "R_386_GLOB_DAT"; break;
        case 7: retval = "R_386_JMP_SLOT"; break;
        case 8: retval = "R_386_RELATIVE"; break;
        case 9: retval = "R_386_GOTOFF"; break;
        case 10: retval = "R_386_GOTPC"; break;
        case 11: retval = "R_386_32PLT"; break;
        case 14: retval = "R_386_TLS_TPOFF"; break;
        case 15: retval = "R_386_TLS_IE"; break;
        case 16: retval = "R_386_TLS_GOTIE"; break;
        case 17: retval = "R_386_TLS_LE"; break;
        case 18: retval = "R_386_TLS_GD"; break;
        case 19: retval = "R_386_TLS_LDM"; break;
        case 20: retval = "R_386_16"; break;
        case 21: retval = "R_386_PC16"; break;
        case 22: retval = "R_386_8"; break;
        case 23: retval = "R_386_PC8"; break;
        case 24: retval = "R_386_TLS_GD_32"; break;
        case 25: retval = "R_386_TLS_GD_PUSH"; break;
        case 26: retval = "R_386_TLS_GD_CALL"; break;
        case 27: retval = "R_386_TLS_GD_POP"; break;
        case 28: retval = "R_386_TLS_LDM_32"; break;
        case 29: retval = "R_386_TLS_LDM_PUSH"; break;
        case 30: retval = "R_386_TLS_LDM_CALL"; break;
        case 31: retval = "R_386_TLS_LDM_POP"; break;
        case 32: retval = "R_386_TLS_LDO_32"; break;
        case 33: retval = "R_386_TLS_IE_32"; break;
        case 34: retval = "R_386_TLS_LE_32"; break;
        case 35: retval = "R_386_TLS_DTPMOD32"; break;
        case 36: retval = "R_386_TLS_DTPOFF32"; break;
        case 37: retval = "R_386_TLS_TPOFF32"; break;
        case 100: retval = "R_X86_64_NONE"; break;
        case 101: retval = "R_X86_64_64"; break;
        case 102: retval = "R_X86_64_PC32"; break;
        case 103: retval = "R_X86_64_GOT32"; break;
        case 104: retval = "R_X86_64_PLT32"; break;
        case 105: retval = "R_X86_64_COPY"; break;
        case 106: retval = "R_X86_64_GLOB_DAT"; break;
        case 107: retval = "R_X86_64_JUMP_SLOT"; break;
        case 108: retval = "R_X86_64_RELATIVE"; break;
        case 109: retval = "R_X86_64_GOTPCREL"; break;
        case 110: retval = "R_X86_64_32"; break;
        case 111: retval = "R_X86_64_32S"; break;
        case 112: retval = "R_X86_64_16"; break;
        case 113: retval = "R_X86_64_PC16"; break;
        case 114: retval = "R_X86_64_8"; break;
        case 115: retval = "R_X86_64_PC8"; break;
        case 116: retval = "R_X86_64_DTPMOD64"; break;
        case 117: retval = "R_X86_64_DTPOFF64"; break;
        case 118: retval = "R_X86_64_TPOFF64"; break;
        case 119: retval = "R_X86_64_TLSGD"; break;
        case 120: retval = "R_X86_64_TLSLD"; break;
        case 121: retval = "R_X86_64_DTPOFF32"; break;
        case 122: retval = "R_X86_64_GOTTPOFF"; break;
        case 123: retval = "R_X86_64_TPOFF32"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfRelocEntry::RelocType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfRelocEntry::RelocType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:361622
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SHF_NULL"; break;
        case 1: retval = "SHF_WRITE"; break;
        case 2: retval = "SHF_ALLOC"; break;
        case 4: retval = "SHF_EXECINSTR"; break;
        case 16: retval = "SHF_MERGE"; break;
        case 32: retval = "SHF_STRINGS"; break;
        case 64: retval = "SHF_INFO_LINK"; break;
        case 128: retval = "SHF_LINK_ORDER"; break;
        case 256: retval = "SHF_OS_NONCONFORMING"; break;
        case 512: retval = "SHF_GROUP"; break;
        case 1024: retval = "SHF_TLS"; break;
        case 267386880: retval = "SHF_MASKOS"; break;
        case 4026531840: retval = "SHF_MASKPROC"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSectionTableEntry::SectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSectionTableEntry::SectionType is defined at frontend/SageIII/Cxx_Grammar.h:361595
/** Converts an enum of type SgAsmElfSectionTableEntry::SectionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSectionTableEntrySectionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SHT_NULL"; break;
        case 1: retval = "SHT_PROGBITS"; break;
        case 2: retval = "SHT_SYMTAB"; break;
        case 3: retval = "SHT_STRTAB"; break;
        case 4: retval = "SHT_RELA"; break;
        case 5: retval = "SHT_HASH"; break;
        case 6: retval = "SHT_DYNAMIC"; break;
        case 7: retval = "SHT_NOTE"; break;
        case 8: retval = "SHT_NOBITS"; break;
        case 9: retval = "SHT_REL"; break;
        case 10: retval = "SHT_SHLIB"; break;
        case 11: retval = "SHT_DYNSYM"; break;
        case 1610612736: retval = "SHT_LOOS"; break;
        case 1879048189: retval = "SHT_GNU_verdef"; break;
        case 1879048190: retval = "SHT_GNU_verneed"; break;
        case 1879048191: retval = "SHT_GNU_versym"; break;
        case 1879048192: retval = "SHT_LOPROC"; break;
        case 2147483647: retval = "SHT_HIPROC"; break;
        case 2147483648: retval = "SHT_LOUSER"; break;
        case 4294967295: retval = "SHT_HIUSER"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSectionTableEntry::SectionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSectionTableEntry::SectionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentFlags is defined at frontend/SageIII/Cxx_Grammar.h:362288
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PF_NONE"; break;
        case 1: retval = "PF_XPERM"; break;
        case 2: retval = "PF_WPERM"; break;
        case 4: retval = "PF_RPERM"; break;
        case 1048568: retval = "PF_RESERVED"; break;
        case 267386880: retval = "PF_OS_MASK"; break;
        case 4026531840: retval = "PF_PROC_MASK"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSegmentTableEntry::SegmentFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSegmentTableEntry::SegmentType is defined at frontend/SageIII/Cxx_Grammar.h:362260
/** Converts an enum of type SgAsmElfSegmentTableEntry::SegmentType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSegmentTableEntrySegmentType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PT_NULL"; break;
        case 1: retval = "PT_LOAD"; break;
        case 2: retval = "PT_DYNAMIC"; break;
        case 3: retval = "PT_INTERP"; break;
        case 4: retval = "PT_NOTE"; break;
        case 5: retval = "PT_SHLIB"; break;
        case 6: retval = "PT_PHDR"; break;
        case 7: retval = "PT_TLS"; break;
        case 1610612736: retval = "PT_LOOS"; break;
        case 1685382480: retval = "PT_GNU_EH_FRAME"; break;
        case 1685382481: retval = "PT_GNU_STACK"; break;
        case 1685382482: retval = "PT_GNU_RELRO"; break;
        case 1694766464: retval = "PT_PAX_FLAGS"; break;
        case 1879048186: retval = "PT_SUNWBSS"; break;
        case 1879048187: retval = "PT_SUNWSTACK"; break;
        case 1879048191: retval = "PT_HIOS"; break;
        case 1879048192: retval = "PT_LOPROC"; break;
        case 2147483647: retval = "PT_HIPROC"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSegmentTableEntry::SegmentType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSegmentTableEntry::SegmentType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymBinding is defined at frontend/SageIII/Cxx_Grammar.h:356684
/** Converts an enum of type SgAsmElfSymbol::ElfSymBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymBinding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STB_LOCAL"; break;
        case 1: retval = "STB_GLOBAL"; break;
        case 2: retval = "STB_WEAK"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSymbol::ElfSymBinding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmElfSymbol::ElfSymType is defined at frontend/SageIII/Cxx_Grammar.h:356690
/** Converts an enum of type SgAsmElfSymbol::ElfSymType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmElfSymbolElfSymType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "STT_NOTYPE"; break;
        case 1: retval = "STT_OBJECT"; break;
        case 2: retval = "STT_FUNC"; break;
        case 3: retval = "STT_SECTION"; break;
        case 4: retval = "STT_FILE"; break;
        case 5: retval = "STT_COMMON"; break;
        case 6: retval = "STT_TLS"; break;
        case 10: retval = "STT_IFUNC"; break;
    }
    if (retval.empty()) {
        char buf[90];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmElfSymbol::ElfSymType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmElfSymbol::ElfSymType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecABI is defined at frontend/SageIII/Cxx_Grammar.h:331070
/** Converts an enum of type SgAsmExecutableFileFormat::ExecABI to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecABI(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ABI_UNSPECIFIED"; break;
        case 1: retval = "ABI_OTHER"; break;
        case 2: retval = "ABI_86OPEN"; break;
        case 3: retval = "ABI_AIX"; break;
        case 4: retval = "ABI_ARM"; break;
        case 5: retval = "ABI_FREEBSD"; break;
        case 6: retval = "ABI_HPUX"; break;
        case 7: retval = "ABI_IRIX"; break;
        case 8: retval = "ABI_HURD"; break;
        case 9: retval = "ABI_LINUX"; break;
        case 10: retval = "ABI_MODESTO"; break;
        case 11: retval = "ABI_MONTEREY"; break;
        case 12: retval = "ABI_MSDOS"; break;
        case 13: retval = "ABI_NT"; break;
        case 14: retval = "ABI_NETBSD"; break;
        case 15: retval = "ABI_OS2"; break;
        case 16: retval = "ABI_SOLARIS"; break;
        case 17: retval = "ABI_SYSV"; break;
        case 18: retval = "ABI_TRU64"; break;
        case 19: retval = "ABI_WIN386"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecABI)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecABI::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecFamily is defined at frontend/SageIII/Cxx_Grammar.h:331060
/** Converts an enum of type SgAsmExecutableFileFormat::ExecFamily to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecFamily(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FAMILY_UNSPECIFIED"; break;
        case 1: retval = "FAMILY_DOS"; break;
        case 2: retval = "FAMILY_ELF"; break;
        case 3: retval = "FAMILY_LE"; break;
        case 4: retval = "FAMILY_LX"; break;
        case 5: retval = "FAMILY_NE"; break;
        case 6: retval = "FAMILY_PE"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecFamily)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecFamily::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::ExecPurpose is defined at frontend/SageIII/Cxx_Grammar.h:331273
/** Converts an enum of type SgAsmExecutableFileFormat::ExecPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatExecPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PURPOSE_UNSPECIFIED"; break;
        case 1: retval = "PURPOSE_OTHER"; break;
        case 2: retval = "PURPOSE_EXECUTABLE"; break;
        case 3: retval = "PURPOSE_LIBRARY"; break;
        case 4: retval = "PURPOSE_CORE_DUMP"; break;
        case 5: retval = "PURPOSE_OS_SPECIFIC"; break;
        case 6: retval = "PURPOSE_PROC_SPECIFIC"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::ExecPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::ExecPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmExecutableFileFormat::InsSetArchitecture is defined at frontend/SageIII/Cxx_Grammar.h:331094
/** Converts an enum of type SgAsmExecutableFileFormat::InsSetArchitecture to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmExecutableFileFormatInsSetArchitecture(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ISA_UNSPECIFIED"; break;
        case 256: retval = "ISA_IA32_Family"; break;
        case 257: retval = "ISA_IA32_286"; break;
        case 258: retval = "ISA_IA32_386"; break;
        case 259: retval = "ISA_IA32_486"; break;
        case 260: retval = "ISA_IA32_Pentium"; break;
        case 261: retval = "ISA_IA32_Cyrix6x86"; break;
        case 262: retval = "ISA_IA32_AMDK5"; break;
        case 263: retval = "ISA_IA32_PentiumPro"; break;
        case 264: retval = "ISA_IA32_PentiumII"; break;
        case 265: retval = "ISA_IA32_Athlon"; break;
        case 266: retval = "ISA_IA32_Pentium4"; break;
        case 267: retval = "ISA_IA32_PentiumM"; break;
        case 512: retval = "ISA_X8664_Family"; break;
        case 513: retval = "ISA_X8664_Athlon64"; break;
        case 514: retval = "ISA_X8664_Prescott"; break;
        case 515: retval = "ISA_X8664_IntelCore"; break;
        case 516: retval = "ISA_X8664_AMDPhenom"; break;
        case 768: retval = "ISA_SPARC_Family"; break;
        case 769: retval = "ISA_SPARC_V7"; break;
        case 770: retval = "ISA_SPARC_V8"; break;
        case 771: retval = "ISA_SPARC_V8E"; break;
        case 772: retval = "ISA_SPARC_V9"; break;
        case 773: retval = "ISA_SPARC_V9JPS1"; break;
        case 774: retval = "ISA_SPARC_V9UA"; break;
        case 775: retval = "ISA_SPARC_V9JPS2"; break;
        case 1024: retval = "ISA_M68K_Family"; break;
        case 1025: retval = "ISA_M68K_68000"; break;
        case 1026: retval = "ISA_M68K_68EC000"; break;
        case 1027: retval = "ISA_M68K_68HC000"; break;
        case 1028: retval = "ISA_M68K_68008"; break;
        case 1029: retval = "ISA_M68K_68010"; break;
        case 1030: retval = "ISA_M68K_68012"; break;
        case 1031: retval = "ISA_M68K_68020"; break;
        case 1032: retval = "ISA_M68K_68EC020"; break;
        case 1033: retval = "ISA_M68K_68030"; break;
        case 1034: retval = "ISA_M68K_68EC030"; break;
        case 1035: retval = "ISA_M68K_68040"; break;
        case 1036: retval = "ISA_M68K_68EC040"; break;
        case 1037: retval = "ISA_M68K_68LC040"; break;
        case 1038: retval = "ISA_M68K_68060"; break;
        case 1039: retval = "ISA_M68K_ColdFire"; break;
        case 1040: retval = "ISA_M68K_DragonBall"; break;
        case 1280: retval = "ISA_M88K_Family"; break;
        case 1281: retval = "ISA_M88K_88100"; break;
        case 1282: retval = "ISA_M88K_88110"; break;
        case 1283: retval = "ISA_M88K_88110MP"; break;
        case 1284: retval = "ISA_M88K_88120"; break;
        case 1536: retval = "ISA_MIPS_Family"; break;
        case 1537: retval = "ISA_MIPS_MarkI"; break;
        case 1538: retval = "ISA_MIPS_MarkII"; break;
        case 1539: retval = "ISA_MIPS_MarkIII"; break;
        case 1540: retval = "ISA_MIPS_R2000"; break;
        case 1541: retval = "ISA_MIPS_R3000"; break;
        case 1542: retval = "ISA_MIPS_R4000"; break;
        case 1543: retval = "ISA_MIPS_R4200"; break;
        case 1544: retval = "ISA_MIPS_R4300"; break;
        case 1545: retval = "ISA_MIPS_R4600"; break;
        case 1546: retval = "ISA_MIPS_R4650"; break;
        case 1547: retval = "ISA_MIPS_R4700"; break;
        case 1548: retval = "ISA_MIPS_R5000"; break;
        case 1549: retval = "ISA_MIPS_RM7000"; break;
        case 1550: retval = "ISA_MIPS_R8000"; break;
        case 1551: retval = "ISA_MIPS_R10000"; break;
        case 1552: retval = "ISA_MIPS_R12000"; break;
        case 1553: retval = "ISA_MIPS_R14000"; break;
        case 1554: retval = "ISA_MIPS_R16000"; break;
        case 1555: retval = "ISA_MIPS_R16000A"; break;
        case 1556: retval = "ISA_MIPS_16"; break;
        case 1557: retval = "ISA_MIPS_FPU"; break;
        case 1558: retval = "ISA_MIPS_16FPU"; break;
        case 1792: retval = "ISA_I860_Family"; break;
        case 1793: retval = "ISA_I860_860XR"; break;
        case 1794: retval = "ISA_I860_860XP"; break;
        case 2048: retval = "ISA_IA64_Family"; break;
        case 2049: retval = "ISA_IA64_Itanium"; break;
        case 2050: retval = "ISA_IA64_Itanium2"; break;
        case 2304: retval = "ISA_ARM_Family"; break;
        case 2305: retval = "ISA_ARM_ARM1"; break;
        case 2306: retval = "ISA_ARM_ARM2"; break;
        case 2307: retval = "ISA_ARM_ARM3"; break;
        case 2308: retval = "ISA_ARM_ARM6"; break;
        case 2309: retval = "ISA_ARM_ARM7"; break;
        case 2310: retval = "ISA_ARM_ARM7TDMI"; break;
        case 2311: retval = "ISA_ARM_StrongARM"; break;
        case 2312: retval = "ISA_ARM_ARM8"; break;
        case 2313: retval = "ISA_ARM_ARM9TDMI"; break;
        case 2314: retval = "ISA_ARM_ARM9E"; break;
        case 2315: retval = "ISA_ARM_ARM10E"; break;
        case 2316: retval = "ISA_ARM_XScale"; break;
        case 2317: retval = "ISA_ARM_ARM11"; break;
        case 2318: retval = "ISA_ARM_Cortex"; break;
        case 61440: retval = "ISA_OTHER_Family"; break;
        case 61441: retval = "ISA_ATT_WE_32100"; break;
        case 61442: retval = "ISA_IBM_System_370"; break;
        case 61443: retval = "ISA_HPPA"; break;
        case 61444: retval = "ISA_Fujitsu_VPP500"; break;
        case 61445: retval = "ISA_Sun_v8plus"; break;
        case 61446: retval = "ISA_PowerPC"; break;
        case 61447: retval = "ISA_PowerPC_64bit"; break;
        case 61448: retval = "ISA_IBM_S390"; break;
        case 61449: retval = "ISA_NEC_V800_series"; break;
        case 61450: retval = "ISA_Fujitsu_FR20"; break;
        case 61451: retval = "ISA_TRW_RH_32"; break;
        case 61452: retval = "ISA_Motorola_RCE"; break;
        case 61454: retval = "ISA_Digital_Alpha_fake"; break;
        case 61455: retval = "ISA_Hitachi_SH"; break;
        case 61456: retval = "ISA_Siemens_Tricore"; break;
        case 61457: retval = "ISA_Argonaut_RISC_Core"; break;
        case 61458: retval = "ISA_Hitachi_H8_300"; break;
        case 61459: retval = "ISA_Hitachi_H8_300H"; break;
        case 61460: retval = "ISA_Hitachi_H8S"; break;
        case 61461: retval = "ISA_Hitachi_H8_500"; break;
        case 61462: retval = "ISA_Stanford_MIPS_X"; break;
        case 61463: retval = "ISA_Motorola_M68HC12"; break;
        case 61464: retval = "ISA_Fujitsu_MMA_Multimedia_Accelerator"; break;
        case 61465: retval = "ISA_Siemens_PCP"; break;
        case 61466: retval = "ISA_Sony_nCPU_embeeded_RISC"; break;
        case 61467: retval = "ISA_Denso_NDR1_microprocessor"; break;
        case 61468: retval = "ISA_Motorola_Start_Core_processor"; break;
        case 61469: retval = "ISA_Toyota_ME16_processor"; break;
        case 61470: retval = "ISA_STMicroelectronic_ST100_processor"; break;
        case 61471: retval = "ISA_Advanced_Logic_Corp_Tinyj_emb_family"; break;
        case 61472: retval = "ISA_AMD_x86_64_architecture"; break;
        case 61473: retval = "ISA_Sony_DSP_Processor"; break;
        case 61474: retval = "ISA_Siemens_FX66_microcontroller"; break;
        case 61475: retval = "ISA_STMicroelectronics_ST9_plus_8_16_microcontroller"; break;
        case 61476: retval = "ISA_STMicroelectronics_ST7_8bit_microcontroller"; break;
        case 61477: retval = "ISA_Motorola_MC68HC16_microcontroller"; break;
        case 61478: retval = "ISA_Motorola_MC68HC11_microcontroller"; break;
        case 61479: retval = "ISA_Motorola_MC68HC08_microcontroller"; break;
        case 61480: retval = "ISA_Motorola_MC68HC05_microcontroller"; break;
        case 61481: retval = "ISA_Silicon_Graphics_SVx"; break;
        case 61482: retval = "ISA_STMicroelectronics_ST19_8bit_microcontroller"; break;
        case 61483: retval = "ISA_Digital_VAX"; break;
        case 61484: retval = "ISA_Axis_Communications_32bit_embedded_processor"; break;
        case 61485: retval = "ISA_Infineon_Technologies_32bit_embedded_processor"; break;
        case 61486: retval = "ISA_Element_14_64bit_DSP_Processor"; break;
        case 61487: retval = "ISA_LSI_Logic_16bit_DSP_Processor"; break;
        case 61488: retval = "ISA_Donald_Knuths_educational_64bit_processor"; break;
        case 61489: retval = "ISA_Harvard_University_machine_independent_object_files"; break;
        case 61490: retval = "ISA_SiTera_Prism"; break;
        case 61491: retval = "ISA_Atmel_AVR_8bit_microcontroller"; break;
        case 61492: retval = "ISA_Fujitsu_FR30"; break;
        case 61493: retval = "ISA_Mitsubishi_D10V"; break;
        case 61494: retval = "ISA_Mitsubishi_D30V"; break;
        case 61495: retval = "ISA_NEC_v850"; break;
        case 61496: retval = "ISA_Mitsubishi_M32R"; break;
        case 61497: retval = "ISA_Matsushita_MN10300"; break;
        case 61498: retval = "ISA_Matsushita_MN10200"; break;
        case 61499: retval = "ISA_picoJava"; break;
        case 61500: retval = "ISA_OpenRISC_32bit_embedded_processor"; break;
        case 61501: retval = "ISA_ARC_Cores_Tangent_A5"; break;
        case 61502: retval = "ISA_Tensilica_Xtensa_Architecture"; break;
        case 61503: retval = "ISA_Digital_Alpha"; break;
        case 61504: retval = "ISA_Matsushita_AM33"; break;
        case 61505: retval = "ISA_EFI_ByteCode"; break;
        case 65280: retval = "ISA_FAMILY_MASK"; break;
        case 65535: retval = "ISA_OTHER"; break;
    }
    if (retval.empty()) {
        char buf[109];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmExecutableFileFormat::InsSetArchitecture)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmExecutableFileFormat::InsSetArchitecture::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::FunctionReason is defined at frontend/SageIII/Cxx_Grammar.h:306715
/** Converts an enum of type SgAsmFunction::FunctionReason to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionFunctionReason(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FUNC_NONE"; break;
        case 1: retval = "FUNC_INTERPADFUNC"; break;
        case 255: retval = "FUNC_MISCMASK"; break;
        case 32768: retval = "FUNC_EXCEPTION_HANDLER"; break;
        case 65536: retval = "FUNC_ENTRY_POINT"; break;
        case 131072: retval = "FUNC_CALL_TARGET"; break;
        case 262144: retval = "FUNC_CALL_INSN"; break;
        case 524288: retval = "FUNC_EH_FRAME"; break;
        case 1048576: retval = "FUNC_SYMBOL"; break;
        case 2097152: retval = "FUNC_PATTERN"; break;
        case 4194304: retval = "FUNC_GRAPH"; break;
        case 8388608: retval = "FUNC_USERDEF"; break;
        case 16777216: retval = "FUNC_PADDING"; break;
        case 33554432: retval = "FUNC_DISCONT"; break;
        case 67108864: retval = "FUNC_INSNHEAD"; break;
        case 134217728: retval = "FUNC_IMPORT"; break;
        case 268435456: retval = "FUNC_LEFTOVERS"; break;
        case 536870912: retval = "FUNC_INTRABLOCK"; break;
        case 1073741824: retval = "FUNC_THUNK"; break;
        case 2147483648: retval = "FUNC_EXPORT"; break;
        case 4026499327: retval = "FUNC_DEFAULT"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmFunction::FunctionReason)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::FunctionReason::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::MayReturn is defined at frontend/SageIII/Cxx_Grammar.h:306705
/** Converts an enum of type SgAsmFunction::MayReturn to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunctionMayReturn(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RET_UNKNOWN"; break;
        case 1: retval = "RET_NEVER"; break;
        case 2: retval = "RET_SOMETIMES"; break;
        case 3: retval = "RET_ALWAYS"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmFunction::MayReturn)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::MayReturn::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmFunction::function_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:306820
/** Converts an enum of type SgAsmFunction::function_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmFunction_function_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_standard"; break;
        case 2: retval = "e_library"; break;
        case 3: retval = "e_imported"; break;
        case 4: retval = "e_thunk"; break;
        case 5: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmFunction::function_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmFunction::function_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericFile::AddressSpace is defined at frontend/SageIII/Cxx_Grammar.h:333847
/** Converts an enum of type SgAsmGenericFile::AddressSpace to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileAddressSpace(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "ADDRSP_MEMORY"; break;
        case 2: retval = "ADDRSP_FILE"; break;
        case 3: retval = "ADDRSP_ALL"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericFile::AddressSpace)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::AddressSpace::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericFile::Elasticity is defined at frontend/SageIII/Cxx_Grammar.h:333852
/** Converts an enum of type SgAsmGenericFile::Elasticity to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericFileElasticity(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ELASTIC_NONE"; break;
        case 1: retval = "ELASTIC_UNREF"; break;
        case 2: retval = "ELASTIC_HOLE"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericFile::Elasticity)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericFile::Elasticity::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSection::SectionPurpose is defined at frontend/SageIII/Cxx_Grammar.h:334451
/** Converts an enum of type SgAsmGenericSection::SectionPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSectionSectionPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SP_UNSPECIFIED"; break;
        case 1: retval = "SP_PROGRAM"; break;
        case 2: retval = "SP_HEADER"; break;
        case 3: retval = "SP_SYMTAB"; break;
        case 4: retval = "SP_OTHER"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericSection::SectionPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSection::SectionPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolBinding is defined at frontend/SageIII/Cxx_Grammar.h:355573
/** Converts an enum of type SgAsmGenericSymbol::SymbolBinding to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolBinding(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_NO_BINDING"; break;
        case 1: retval = "SYM_LOCAL"; break;
        case 2: retval = "SYM_GLOBAL"; break;
        case 3: retval = "SYM_WEAK"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolBinding)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolBinding::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolDefState is defined at frontend/SageIII/Cxx_Grammar.h:355554
/** Converts an enum of type SgAsmGenericSymbol::SymbolDefState to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolDefState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_UNDEFINED"; break;
        case 1: retval = "SYM_TENTATIVE"; break;
        case 2: retval = "SYM_DEFINED"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolDefState)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolDefState::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmGenericSymbol::SymbolType is defined at frontend/SageIII/Cxx_Grammar.h:355560
/** Converts an enum of type SgAsmGenericSymbol::SymbolType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmGenericSymbolSymbolType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SYM_NO_TYPE"; break;
        case 1: retval = "SYM_DATA"; break;
        case 2: retval = "SYM_FUNC"; break;
        case 3: retval = "SYM_SECTION"; break;
        case 4: retval = "SYM_FILE"; break;
        case 5: retval = "SYM_ARRAY"; break;
        case 6: retval = "SYM_TLS"; break;
        case 7: retval = "SYM_REGISTER"; break;
        case 8: retval = "SYM_COMMON"; break;
        case 9: retval = "SYM_IFUNC"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmGenericSymbol::SymbolType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmGenericSymbol::SymbolType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmLEFileHeader::LEFileHeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:336740
/** Converts an enum of type SgAsmLEFileHeader::LEFileHeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLEFileHeaderLEFileHeaderFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_MODTYPE_PROG"; break;
        case 4: retval = "HF_PROC_LIB_INIT"; break;
        case 16: retval = "HF_IFIXUPS_APPLIED"; break;
        case 32: retval = "HF_EFIXUPS_APPLIED"; break;
        case 256: retval = "HF_PM_WINDOW_NO"; break;
        case 512: retval = "HF_PM_WINDOW_OK"; break;
        case 768: retval = "HF_PM_WINDOW_USE"; break;
        case 8192: retval = "HF_NOT_LOADABLE"; break;
        case 32768: retval = "HF_MODTYPE_LIB"; break;
        case 98304: retval = "HF_MODTYPE_PLIB"; break;
        case 131072: retval = "HF_MODTYPE_PDEV"; break;
        case 163840: retval = "HF_MODTYPE_VDEV"; break;
        case 229376: retval = "HF_MODTYPE_MASK"; break;
        case 1073741824: retval = "HF_PROC_LIB_TERM"; break;
        case 3220987083: retval = "HF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmLEFileHeader::LEFileHeaderFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLEFileHeader::LEFileHeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmLESectionTableEntry::LESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:381025
/** Converts an enum of type SgAsmLESectionTableEntry::LESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmLESectionTableEntryLESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SF_TYPE_NORMAL"; break;
        case 1: retval = "SF_READABLE"; break;
        case 2: retval = "SF_WRITABLE"; break;
        case 4: retval = "SF_EXECUTABLE"; break;
        case 8: retval = "SF_RESOURCE"; break;
        case 16: retval = "SF_DISCARDABLE"; break;
        case 32: retval = "SF_SHARED"; break;
        case 64: retval = "SF_PRELOAD_PAGES"; break;
        case 128: retval = "SF_INVALID_PAGES"; break;
        case 256: retval = "SF_TYPE_ZERO"; break;
        case 512: retval = "SF_TYPE_RESIDENT"; break;
        case 768: retval = "SF_TYPE_RESCONT"; break;
        case 1024: retval = "SF_RES_LONG_LOCK"; break;
        case 4096: retval = "SF_1616_ALIAS"; break;
        case 8192: retval = "SF_BIG_BIT"; break;
        case 16384: retval = "SF_CODE_CONFORM"; break;
        case 32768: retval = "SF_IO_PRIV"; break;
        case 4294903808: retval = "SF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmLESectionTableEntry::LESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmLESectionTableEntry::LESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEEntryPoint::NEEntryFlags is defined at frontend/SageIII/Cxx_Grammar.h:377749
/** Converts an enum of type SgAsmNEEntryPoint::NEEntryFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEEntryPointNEEntryFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "EF_ZERO"; break;
        case 1: retval = "EF_EXPORTED"; break;
        case 2: retval = "EF_GLOBAL"; break;
        case 252: retval = "EF_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNEEntryPoint::NEEntryFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEEntryPoint::NEEntryFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags1 is defined at frontend/SageIII/Cxx_Grammar.h:337722
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags1 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags1(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF1_NO_DATA"; break;
        case 1: retval = "HF1_SINGLE_DATA"; break;
        case 2: retval = "HF1_MULTIPLE_DATA"; break;
        case 2048: retval = "HF1_LOADER_SEGMENT"; break;
        case 8192: retval = "HF1_FATAL_ERRORS"; break;
        case 22516: retval = "HF1_RESERVED"; break;
        case 32768: retval = "HF1_LIBRARY"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNEFileHeader::HeaderFlags1)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags1::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNEFileHeader::HeaderFlags2 is defined at frontend/SageIII/Cxx_Grammar.h:337733
/** Converts an enum of type SgAsmNEFileHeader::HeaderFlags2 to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNEFileHeaderHeaderFlags2(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 2: retval = "HF2_PROTECTED_MODE"; break;
        case 4: retval = "HF2_PFONTS"; break;
        case 8: retval = "HF2_FASTLOAD"; break;
        case 241: retval = "HF2_RESERVED"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNEFileHeader::HeaderFlags2)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNEFileHeader::HeaderFlags2::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocFlags is defined at frontend/SageIII/Cxx_Grammar.h:378293
/** Converts an enum of type SgAsmNERelocEntry::NERelocFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RF_ADDITIVE"; break;
        case 2: retval = "RF_RESERVED"; break;
        case 4: retval = "RF_2EXTRA"; break;
        case 8: retval = "RF_32ADD"; break;
        case 16: retval = "RF_16SECTION"; break;
        case 32: retval = "RF_8ORDINAL"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocModifiers is defined at frontend/SageIII/Cxx_Grammar.h:378288
/** Converts an enum of type SgAsmNERelocEntry::NERelocModifiers to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocModifiers(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "RF_MODIFIER_SINGLE"; break;
        case 3: retval = "RF_MODIFIER_MULTI"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocModifiers)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocModifiers::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocSrcType is defined at frontend/SageIII/Cxx_Grammar.h:378269
/** Converts an enum of type SgAsmNERelocEntry::NERelocSrcType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocSrcType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RF_SRCTYPE_8OFF"; break;
        case 2: retval = "RF_SRCTYPE_WORDSEG"; break;
        case 3: retval = "RF_SRCTYPE_16PTR"; break;
        case 5: retval = "RF_SRCTYPE_16OFF"; break;
        case 6: retval = "RF_SRCTYPE_32PTR"; break;
        case 7: retval = "RF_SRCTYPE_32OFF"; break;
        case 8: retval = "RF_SRCTYPE_NEARCALL"; break;
        case 11: retval = "RF_SRCTYPE_48PTR"; break;
        case 13: retval = "RF_SRCTYPE_32OFF_b"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocSrcType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocSrcType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNERelocEntry::NERelocTgtType is defined at frontend/SageIII/Cxx_Grammar.h:378281
/** Converts an enum of type SgAsmNERelocEntry::NERelocTgtType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNERelocEntryNERelocTgtType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "RF_TGTTYPE_IREF"; break;
        case 1: retval = "RF_TGTTYPE_IORD"; break;
        case 2: retval = "RF_TGTTYPE_INAME"; break;
        case 3: retval = "RF_TGTTYPE_OSFIXUP"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNERelocEntry::NERelocTgtType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNERelocEntry::NERelocTgtType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmNESectionTableEntry::NESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:378925
/** Converts an enum of type SgAsmNESectionTableEntry::NESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmNESectionTableEntryNESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "SF_CODE"; break;
        case 1: retval = "SF_DATA"; break;
        case 2: retval = "SF_ALLOC"; break;
        case 4: retval = "SF_LOAD"; break;
        case 7: retval = "SF_TYPE_MASK"; break;
        case 16: retval = "SF_MOVABLE"; break;
        case 32: retval = "SF_PURE"; break;
        case 64: retval = "SF_PRELOAD"; break;
        case 128: retval = "SF_NOT_WRITABLE"; break;
        case 256: retval = "SF_RELOCINFO"; break;
        case 3592: retval = "SF_RESERVED"; break;
        case 4096: retval = "SF_DISCARDABLE"; break;
        case 61440: retval = "SF_DISCARD"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmNESectionTableEntry::NESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmNESectionTableEntry::NESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmOp::asm_operand_constraint_enum is defined at frontend/SageIII/Cxx_Grammar.h:272772
/** Converts an enum of type SgAsmOp::asm_operand_constraint_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_constraint_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_invalid"; break;
        case 1: retval = "e_any"; break;
        case 2: retval = "e_general"; break;
        case 3: retval = "e_match_0"; break;
        case 4: retval = "aoc_match_1"; break;
        case 5: retval = "aoc_match_2"; break;
        case 6: retval = "aoc_match_3"; break;
        case 7: retval = "aoc_match_4"; break;
        case 8: retval = "e_match_5"; break;
        case 9: retval = "aoc_match_6"; break;
        case 10: retval = "aoc_match_7"; break;
        case 11: retval = "aoc_match_8"; break;
        case 12: retval = "aoc_match_9"; break;
        case 13: retval = "e_reg_integer"; break;
        case 14: retval = "e_reg_float"; break;
        case 15: retval = "e_mem_any"; break;
        case 16: retval = "e_mem_offset"; break;
        case 17: retval = "e_mem_nonoffset"; break;
        case 18: retval = "e_mem_autoinc"; break;
        case 19: retval = "e_mem_autodec"; break;
        case 20: retval = "e_imm_int"; break;
        case 21: retval = "e_imm_number"; break;
        case 22: retval = "e_imm_symbol"; break;
        case 23: retval = "e_imm_float"; break;
        case 24: retval = "e_reg_a"; break;
        case 25: retval = "e_reg_b"; break;
        case 26: retval = "e_reg_c"; break;
        case 27: retval = "e_reg_d"; break;
        case 28: retval = "e_reg_si"; break;
        case 29: retval = "e_reg_di"; break;
        case 30: retval = "e_reg_legacy"; break;
        case 31: retval = "e_reg_q"; break;
        case 32: retval = "e_reg_ad"; break;
        case 33: retval = "e_reg_float_tos"; break;
        case 34: retval = "e_reg_float_second"; break;
        case 35: retval = "e_reg_sse"; break;
        case 36: retval = "e_reg_sse2"; break;
        case 37: retval = "e_reg_mmx"; break;
        case 38: retval = "e_imm_short_shift"; break;
        case 39: retval = "e_imm_long_shift"; break;
        case 40: retval = "e_imm_lea_shift"; break;
        case 41: retval = "e_imm_signed8"; break;
        case 42: retval = "e_imm_unsigned8"; break;
        case 43: retval = "e_imm_and_zext"; break;
        case 44: retval = "e_imm_80387"; break;
        case 45: retval = "e_imm_sse"; break;
        case 46: retval = "e_imm_sext32"; break;
        case 47: retval = "e_imm_zext32"; break;
        case 48: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmOp::asm_operand_constraint_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_constraint_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmOp::asm_operand_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:272753
/** Converts an enum of type SgAsmOp::asm_operand_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmOp_asm_operand_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_input"; break;
        case 2: retval = "e_output"; break;
        case 3: retval = "e_modify"; break;
        case 4: retval = "e_earlyclobber"; break;
        case 8: retval = "e_commutative"; break;
        case 16: retval = "e_ignore_next"; break;
        case 32: retval = "e_ignore_till_comma"; break;
        case 64: retval = "e_poor_choice"; break;
        case 128: retval = "e_bad_choice"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmOp::asm_operand_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmOp::asm_operand_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::DLLFlags is defined at frontend/SageIII/Cxx_Grammar.h:335844
/** Converts an enum of type SgAsmPEFileHeader::DLLFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderDLLFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "DLL_PROC_INIT"; break;
        case 2: retval = "DLL_PROC_TERM"; break;
        case 4: retval = "DLL_THRD_INIT"; break;
        case 8: retval = "DLL_THRD_TERM"; break;
        case 65520: retval = "DLL_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        char buf[91];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::DLLFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::DLLFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::HeaderFlags is defined at frontend/SageIII/Cxx_Grammar.h:335825
/** Converts an enum of type SgAsmPEFileHeader::HeaderFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderHeaderFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_PROGRAM"; break;
        case 2: retval = "HF_EXECUTABLE"; break;
        case 512: retval = "HF_FIXED"; break;
        case 8192: retval = "HF_LIBRARY"; break;
        case 56829: retval = "HF_RESERVED_MASK"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::HeaderFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::HeaderFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::PairPurpose is defined at frontend/SageIII/Cxx_Grammar.h:335853
/** Converts an enum of type SgAsmPEFileHeader::PairPurpose to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderPairPurpose(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PAIR_EXPORTS"; break;
        case 1: retval = "PAIR_IMPORTS"; break;
        case 2: retval = "PAIR_RESOURCES"; break;
        case 3: retval = "PAIR_EXCEPTIONS"; break;
        case 4: retval = "PAIR_CERTIFICATES"; break;
        case 5: retval = "PAIR_BASERELOCS"; break;
        case 6: retval = "PAIR_DEBUG"; break;
        case 7: retval = "PAIR_ARCHITECTURE"; break;
        case 8: retval = "PAIR_GLOBALPTR"; break;
        case 9: retval = "PAIR_TLS"; break;
        case 10: retval = "PAIR_LOADCONFIG"; break;
        case 11: retval = "PAIR_BOUNDIMPORT"; break;
        case 12: retval = "PAIR_IAT"; break;
        case 13: retval = "PAIR_DELAYIMPORT"; break;
        case 14: retval = "PAIR_CLRRUNTIME"; break;
        case 15: retval = "PAIR_RESERVED15"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::PairPurpose)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::PairPurpose::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPEFileHeader::Subsystem is defined at frontend/SageIII/Cxx_Grammar.h:335834
/** Converts an enum of type SgAsmPEFileHeader::Subsystem to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPEFileHeaderSubsystem(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HF_SPEC_UNKNOWN"; break;
        case 1: retval = "HF_NATIVE"; break;
        case 2: retval = "HF_WINGUI"; break;
        case 3: retval = "HF_WINCHAR"; break;
        case 5: retval = "HF_OS2CHAR"; break;
        case 7: retval = "HF_POSIX"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmPEFileHeader::Subsystem)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPEFileHeader::Subsystem::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmPESectionTableEntry::PESectionFlags is defined at frontend/SageIII/Cxx_Grammar.h:374043
/** Converts an enum of type SgAsmPESectionTableEntry::PESectionFlags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmPESectionTableEntryPESectionFlags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 32: retval = "OF_CODE"; break;
        case 64: retval = "OF_IDATA"; break;
        case 128: retval = "OF_UDATA"; break;
        case 512: retval = "OF_INFO"; break;
        case 2048: retval = "OF_REMOVE"; break;
        case 4096: retval = "OF_COMDAT"; break;
        case 16384: retval = "OF_NO_DEFER_SPEC_EXC"; break;
        case 32768: retval = "OF_GPREL"; break;
        case 1048576: retval = "OF_ALIGN_1"; break;
        case 2097152: retval = "OF_ALIGN_2"; break;
        case 3145728: retval = "OF_ALIGN_4"; break;
        case 4194304: retval = "OF_ALIGN_8"; break;
        case 5242880: retval = "OF_ALIGN_16"; break;
        case 6291456: retval = "OF_ALIGN_32"; break;
        case 7340032: retval = "OF_ALIGN_64"; break;
        case 8388608: retval = "OF_ALIGN_128"; break;
        case 9437184: retval = "OF_ALIGN_256"; break;
        case 10485760: retval = "OF_ALIGN_512"; break;
        case 11534336: retval = "OF_ALIGN_1k"; break;
        case 12582912: retval = "OF_ALIGN_2k"; break;
        case 13631488: retval = "OF_ALIGN_4k"; break;
        case 14680064: retval = "OF_ALIGN_8k"; break;
        case 15728640: retval = "OF_ALIGN_MASK"; break;
        case 16777216: retval = "OF_NRELOC_OVFL"; break;
        case 33554432: retval = "OF_DISCARDABLE"; break;
        case 67108864: retval = "OF_NO_CACHE"; break;
        case 134217728: retval = "OF_NO_PAGING"; break;
        case 268435456: retval = "OF_SHARED"; break;
        case 536870912: retval = "OF_EXECUTABLE"; break;
        case 1073741824: retval = "OF_READABLE"; break;
        case 2147483648: retval = "OF_WRITABLE"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmPESectionTableEntry::PESectionFlags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmPESectionTableEntry::PESectionFlags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAsmRiscOperation::RiscOperator is defined at frontend/SageIII/Cxx_Grammar.h:327018
/** Converts an enum of type SgAsmRiscOperation::RiscOperator to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAsmRiscOperationRiscOperator(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OP_NONE"; break;
        case 1: retval = "OP_bottom"; break;
        case 2: retval = "OP_undefined"; break;
        case 3: retval = "OP_unspecified"; break;
        case 4: retval = "OP_filterCallTarget"; break;
        case 5: retval = "OP_filterReturnTarget"; break;
        case 6: retval = "OP_filterIndirectJumpTarget"; break;
        case 7: retval = "OP_hlt"; break;
        case 8: retval = "OP_cpuid"; break;
        case 9: retval = "OP_rdtsc"; break;
        case 10: retval = "OP_and_"; break;
        case 11: retval = "OP_or_"; break;
        case 12: retval = "OP_xor_"; break;
        case 13: retval = "OP_invert"; break;
        case 14: retval = "OP_extract"; break;
        case 15: retval = "OP_concat"; break;
        case 16: retval = "OP_leastSignificantSetBit"; break;
        case 17: retval = "OP_mostSignificantSetBit"; break;
        case 18: retval = "OP_rotateLeft"; break;
        case 19: retval = "OP_rotateRight"; break;
        case 20: retval = "OP_shiftLeft"; break;
        case 21: retval = "OP_shiftRight"; break;
        case 22: retval = "OP_shiftRightArithmetic"; break;
        case 23: retval = "OP_equalToZero"; break;
        case 24: retval = "OP_ite"; break;
        case 25: retval = "OP_isEqual"; break;
        case 26: retval = "OP_isNotEqual"; break;
        case 27: retval = "OP_isUnsignedLessThan"; break;
        case 28: retval = "OP_isUnsignedLessThanOrEqual"; break;
        case 29: retval = "OP_isUnsignedGreaterThan"; break;
        case 30: retval = "OP_isUnsignedGreaterThanOrEqual"; break;
        case 31: retval = "OP_isSignedLessThan"; break;
        case 32: retval = "OP_isSignedLessThanOrEqual"; break;
        case 33: retval = "OP_isSignedGreaterThan"; break;
        case 34: retval = "OP_isSignedGreaterThanOrEqual"; break;
        case 35: retval = "OP_unsignedExtend"; break;
        case 36: retval = "OP_signExtend"; break;
        case 37: retval = "OP_add"; break;
        case 38: retval = "OP_addCarries"; break;
        case 39: retval = "OP_subtract"; break;
        case 40: retval = "OP_negate"; break;
        case 41: retval = "OP_signedDivide"; break;
        case 42: retval = "OP_signedModulo"; break;
        case 43: retval = "OP_signedMultiply"; break;
        case 44: retval = "OP_unsignedDivide"; break;
        case 45: retval = "OP_unsignedModulo"; break;
        case 46: retval = "OP_unsignedMultiply"; break;
        case 47: retval = "OP_interrupt"; break;
        case 48: retval = "OP_readRegister"; break;
        case 49: retval = "OP_writeRegister"; break;
        case 50: retval = "OP_readMemory"; break;
        case 51: retval = "OP_writeMemory"; break;
        case 52: retval = "OP_N_OPERATORS"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAsmRiscOperation::RiscOperator)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAsmRiscOperation::RiscOperator::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgAttributeSpecificationStatement::attribute_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:134116
/** Converts an enum of type SgAttributeSpecificationStatement::attribute_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgAttributeSpecificationStatement_attribute_spec_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_attribute_spec"; break;
        case 1: retval = "e_accessStatement_private"; break;
        case 2: retval = "e_accessStatement_public"; break;
        case 3: retval = "e_allocatableStatement"; break;
        case 4: retval = "e_asynchronousStatement"; break;
        case 5: retval = "e_bindStatement"; break;
        case 6: retval = "e_dataStatement"; break;
        case 7: retval = "e_dimensionStatement"; break;
        case 8: retval = "e_externalStatement"; break;
        case 9: retval = "e_intentStatement"; break;
        case 10: retval = "e_intrinsicStatement"; break;
        case 11: retval = "e_optionalStatement"; break;
        case 12: retval = "e_parameterStatement"; break;
        case 13: retval = "e_pointerStatement"; break;
        case 14: retval = "e_protectedStatement"; break;
        case 15: retval = "e_saveStatement"; break;
        case 16: retval = "e_targetStatement"; break;
        case 17: retval = "e_valueStatement"; break;
        case 18: retval = "e_volatileStatement"; break;
        case 19: retval = "e_last_attribute_spec"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgAttributeSpecificationStatement::attribute_spec_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgAttributeSpecificationStatement::attribute_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgBaseClassModifier::baseclass_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:15299
/** Converts an enum of type SgBaseClassModifier::baseclass_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgBaseClassModifier_baseclass_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_virtual"; break;
        case 3: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgBaseClassModifier::baseclass_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgBaseClassModifier::baseclass_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgCastExp::cast_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:207277
/** Converts an enum of type SgCastExp::cast_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgCastExp_cast_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_C_style_cast"; break;
        case 3: retval = "e_const_cast"; break;
        case 4: retval = "e_static_cast"; break;
        case 5: retval = "e_dynamic_cast"; break;
        case 6: retval = "e_reinterpret_cast"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgCastExp::cast_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgCastExp::cast_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgClassDeclaration::class_types is defined at frontend/SageIII/Cxx_Grammar.h:143457
/** Converts an enum of type SgClassDeclaration::class_types to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgClassDeclaration_class_types(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_class"; break;
        case 1: retval = "e_struct"; break;
        case 2: retval = "e_union"; break;
        case 3: retval = "e_template_parameter"; break;
        case 4: retval = "e_java_interface"; break;
        case 5: retval = "e_java_enum"; break;
        case 6: retval = "e_java_parameter"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgClassDeclaration::class_types)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgClassDeclaration::class_types::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgConstVolatileModifier::cv_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:10722
/** Converts an enum of type SgConstVolatileModifier::cv_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgConstVolatileModifier_cv_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_const"; break;
        case 3: retval = "e_volatile"; break;
        case 4: retval = "e_java_transient"; break;
        case 5: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgConstVolatileModifier::cv_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgConstVolatileModifier::cv_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDataStatementValue::data_statement_value_enum is defined at frontend/SageIII/Cxx_Grammar.h:45052
/** Converts an enum of type SgDataStatementValue::data_statement_value_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDataStatementValue_data_statement_value_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_explict_list"; break;
        case 3: retval = "e_implicit_list"; break;
        case 4: retval = "e_implied_do"; break;
        case 5: retval = "e_last_initializer_form"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgDataStatementValue::data_statement_value_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDataStatementValue::data_statement_value_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationModifier::declaration_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:16683
/** Converts an enum of type SgDeclarationModifier::declaration_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_declaration_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_friend"; break;
        case 3: retval = "e_typedef"; break;
        case 4: retval = "e_export"; break;
        case 5: retval = "e_throw"; break;
        case 6: retval = "e_bind"; break;
        case 7: retval = "e_final"; break;
        case 8: retval = "e_override"; break;
        case 9: retval = "e_java_abstract"; break;
        case 10: retval = "e_ms_declspec_align"; break;
        case 11: retval = "e_ms_declspec_allocate"; break;
        case 12: retval = "e_ms_declspec_appdomain"; break;
        case 13: retval = "e_ms_declspec_code_seg"; break;
        case 14: retval = "e_ms_declspec_deprecated"; break;
        case 15: retval = "e_ms_declspec_dllimport"; break;
        case 16: retval = "e_ms_declspec_dllexport"; break;
        case 17: retval = "e_ms_declspec_jitintrinsic"; break;
        case 18: retval = "e_ms_declspec_naked"; break;
        case 19: retval = "e_ms_declspec_noalias"; break;
        case 20: retval = "e_ms_declspec_noinline"; break;
        case 21: retval = "e_ms_declspec_noreturn"; break;
        case 22: retval = "e_ms_declspec_nothrow"; break;
        case 23: retval = "e_ms_declspec_novtable"; break;
        case 24: retval = "e_ms_declspec_process"; break;
        case 25: retval = "e_ms_declspec_property"; break;
        case 26: retval = "e_ms_declspec_restrict"; break;
        case 27: retval = "e_ms_declspec_safebuffers"; break;
        case 28: retval = "e_ms_declspec_selectany"; break;
        case 29: retval = "e_ms_declspec_thread"; break;
        case 30: retval = "e_ms_declspec_uuid"; break;
        case 31: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgDeclarationModifier::declaration_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::declaration_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationModifier::gnu_declaration_visability_enum is defined at frontend/SageIII/Cxx_Grammar.h:16730
/** Converts an enum of type SgDeclarationModifier::gnu_declaration_visability_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationModifier_gnu_declaration_visability_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_visibility"; break;
        case 1: retval = "e_error_visibility"; break;
        case 2: retval = "e_unspecified_visibility"; break;
        case 3: retval = "e_hidden_visibility"; break;
        case 4: retval = "e_protected_visibility"; break;
        case 5: retval = "e_internal_visibility"; break;
        case 6: retval = "e_default_visibility"; break;
        case 7: retval = "e_last_visibility_attribute"; break;
    }
    if (retval.empty()) {
        char buf[118];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgDeclarationModifier::gnu_declaration_visability_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationModifier::gnu_declaration_visability_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationStatement::gnu_extension_visability_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:128282
/** Converts an enum of type SgDeclarationStatement::gnu_extension_visability_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_gnu_extension_visability_attribute_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute_visability_unknown"; break;
        case 1: retval = "e_gnu_attribute_visability_unspecified"; break;
        case 2: retval = "e_gnu_attribute_visability_hidden"; break;
        case 3: retval = "e_gnu_attribute_visability_protected"; break;
        case 4: retval = "e_gnu_attribute_visability_internal"; break;
        case 5: retval = "e_last_gnu_visability_attribute"; break;
    }
    if (retval.empty()) {
        char buf[127];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgDeclarationStatement::gnu_extension_visability_attribute_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::gnu_extension_visability_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgDeclarationStatement::template_specialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:128267
/** Converts an enum of type SgDeclarationStatement::template_specialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgDeclarationStatement_template_specialization_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_no_specialization"; break;
        case 2: retval = "e_partial_specialization"; break;
        case 3: retval = "e_specialization"; break;
        case 4: retval = "e_template_specialization_last"; break;
    }
    if (retval.empty()) {
        char buf[116];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgDeclarationStatement::template_specialization_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgDeclarationStatement::template_specialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgElaboratedTypeModifier::elaborated_type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:14240
/** Converts an enum of type SgElaboratedTypeModifier::elaborated_type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgElaboratedTypeModifier_elaborated_type_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_class"; break;
        case 3: retval = "e_struct"; break;
        case 4: retval = "e_union"; break;
        case 5: retval = "e_enum"; break;
        case 6: retval = "e_typename"; break;
        case 7: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[119];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgElaboratedTypeModifier::elaborated_type_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgElaboratedTypeModifier::elaborated_type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFile::outputFormatOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:22837
/** Converts an enum of type SgFile::outputFormatOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputFormatOption_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_output_format"; break;
        case 1: retval = "e_fixed_form_output_format"; break;
        case 2: retval = "e_free_form_output_format"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgFile::outputFormatOption_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputFormatOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFile::outputLanguageOption_enum is defined at frontend/SageIII/Cxx_Grammar.h:22851
/** Converts an enum of type SgFile::outputLanguageOption_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFile_outputLanguageOption_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_error_output_language"; break;
        case 1: retval = "e_default_output_language"; break;
        case 2: retval = "e_C_output_language"; break;
        case 3: retval = "e_Cxx_output_language"; break;
        case 4: retval = "e_Fortran_output_language"; break;
        case 5: retval = "e_Java_output_language"; break;
        case 6: retval = "e_X10_output_language"; break;
        case 7: retval = "e_Promela_output_language"; break;
        case 8: retval = "e_PHP_output_language"; break;
        case 9: retval = "e_Python_output_language"; break;
        case 10: retval = "e_last_output_language"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgFile::outputLanguageOption_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFile::outputLanguageOption_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgFunctionModifier::function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:12397
/** Converts an enum of type SgFunctionModifier::function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgFunctionModifier_function_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_inline"; break;
        case 3: retval = "e_virtual"; break;
        case 4: retval = "e_pure_virtual"; break;
        case 5: retval = "e_explicit"; break;
        case 7: retval = "e_pure"; break;
        case 8: retval = "e_elemental"; break;
        case 9: retval = "e_recursive"; break;
        case 10: retval = "e_gnu_attribute__constructor__"; break;
        case 11: retval = "e_gnu_attribute__destructor__"; break;
        case 12: retval = "e_gnu_attribute__pure__"; break;
        case 13: retval = "e_gnu_attribute__weak__"; break;
        case 14: retval = "e_gnu_attribute__unused__"; break;
        case 15: retval = "e_gnu_attribute__used__"; break;
        case 16: retval = "e_gnu_attribute__deprecated__"; break;
        case 17: retval = "e_gnu_attribute__malloc__"; break;
        case 18: retval = "e_gnu_attribute__naked__"; break;
        case 19: retval = "e_gnu_attribute__no_instrument_function__"; break;
        case 20: retval = "e_gnu_attribute__no_check_memory_usage__"; break;
        case 21: retval = "e_gnu_attribute__noinline__"; break;
        case 22: retval = "e_gnu_attribute__always_inline__"; break;
        case 23: retval = "e_gnu_attribute__nothrow__"; break;
        case 24: retval = "e_gnu_attribute__weakref__"; break;
        case 25: retval = "e_cuda_device"; break;
        case 26: retval = "e_cuda_kernel"; break;
        case 27: retval = "e_cuda_host"; break;
        case 28: retval = "e_opencl_kernel"; break;
        case 29: retval = "e_opencl_vec_type_hint"; break;
        case 30: retval = "e_opencl_work_group_size_hint"; break;
        case 31: retval = "e_opencl_work_group_size_req"; break;
        case 32: retval = "e_java_native"; break;
        case 33: retval = "e_java_synchronized"; break;
        case 34: retval = "e_java_strictfp"; break;
        case 35: retval = "e_java_initializer"; break;
        case 36: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgFunctionModifier::function_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgFunctionModifier::function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgGraph::GraphEdgeType is defined at frontend/SageIII/Cxx_Grammar.h:35507
/** Converts an enum of type SgGraph::GraphEdgeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphEdgeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_type_error"; break;
        case 1: retval = "none"; break;
        case 2: retval = "cfg"; break;
        case 3: retval = "usage"; break;
        case 4: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgGraph::GraphEdgeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphEdgeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgGraph::GraphProperties is defined at frontend/SageIII/Cxx_Grammar.h:35521
/** Converts an enum of type SgGraph::GraphProperties to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgGraphGraphProperties(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_property_error"; break;
        case 1: retval = "name"; break;
        case 2: retval = "type"; break;
        case 3: retval = "nodest_jmp"; break;
        case 4: retval = "itself_call"; break;
        case 5: retval = "nodest_call"; break;
        case 6: retval = "interrupt"; break;
        case 7: retval = "eval"; break;
        case 8: retval = "regs"; break;
        case 9: retval = "done"; break;
        case 10: retval = "dfa_standard"; break;
        case 11: retval = "dfa_resolved_func"; break;
        case 12: retval = "dfa_unresolved_func"; break;
        case 13: retval = "dfa_variable"; break;
        case 14: retval = "dfa_conditional_def"; break;
        case 15: retval = "edgeLabel"; break;
        case 16: retval = "visitedCounter"; break;
        case 17: retval = "variable"; break;
        case 18: retval = "dfa_bufferoverflow"; break;
        case 19: retval = "e_last_property"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgGraph::GraphProperties)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgGraph::GraphProperties::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgIOStatement::io_statement_enum is defined at frontend/SageIII/Cxx_Grammar.h:173776
/** Converts an enum of type SgIOStatement::io_statement_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgIOStatement_io_statement_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_read"; break;
        case 2: retval = "e_print"; break;
        case 3: retval = "e_write"; break;
        case 4: retval = "e_open"; break;
        case 5: retval = "e_close"; break;
        case 6: retval = "e_inquire"; break;
        case 7: retval = "e_backspace"; break;
        case 8: retval = "e_endfile"; break;
        case 9: retval = "e_rewind"; break;
        case 10: retval = "e_last_io_statment_kind"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgIOStatement::io_statement_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgIOStatement::io_statement_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::asm_register_name_enum is defined at frontend/SageIII/Cxx_Grammar.h:80440
/** Converts an enum of type SgInitializedName::asm_register_name_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_asm_register_name_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_invalid_register"; break;
        case 1: retval = "e_memory_register"; break;
        case 2: retval = "e_register_a"; break;
        case 3: retval = "e_register_b"; break;
        case 4: retval = "e_register_c"; break;
        case 5: retval = "e_register_d"; break;
        case 6: retval = "e_register_si"; break;
        case 7: retval = "e_register_di"; break;
        case 8: retval = "e_register_bp"; break;
        case 9: retval = "e_register_sp"; break;
        case 10: retval = "e_register_r8"; break;
        case 11: retval = "e_register_r9"; break;
        case 12: retval = "e_register_r10"; break;
        case 13: retval = "e_register_r11"; break;
        case 14: retval = "e_register_r12"; break;
        case 15: retval = "e_register_r13"; break;
        case 16: retval = "e_register_r14"; break;
        case 17: retval = "e_register_r15"; break;
        case 18: retval = "e_register_st0"; break;
        case 19: retval = "e_register_st1"; break;
        case 20: retval = "e_register_st2"; break;
        case 21: retval = "e_register_st3"; break;
        case 22: retval = "e_register_st4"; break;
        case 23: retval = "e_register_st5"; break;
        case 24: retval = "e_register_st6"; break;
        case 25: retval = "e_register_st7"; break;
        case 26: retval = "e_register_mm0"; break;
        case 27: retval = "e_register_mm1"; break;
        case 28: retval = "e_register_mm2"; break;
        case 29: retval = "e_register_mm3"; break;
        case 30: retval = "e_register_mm4"; break;
        case 31: retval = "e_register_mm5"; break;
        case 32: retval = "e_register_mm6"; break;
        case 33: retval = "e_register_mm7"; break;
        case 34: retval = "e_register_f0"; break;
        case 35: retval = "e_register_f1"; break;
        case 36: retval = "e_register_f2"; break;
        case 37: retval = "e_register_f3"; break;
        case 38: retval = "e_register_f4"; break;
        case 39: retval = "e_register_f5"; break;
        case 40: retval = "e_register_f6"; break;
        case 41: retval = "e_register_f7"; break;
        case 42: retval = "e_register_f8"; break;
        case 43: retval = "e_register_f9"; break;
        case 44: retval = "e_register_f10"; break;
        case 45: retval = "e_register_f11"; break;
        case 46: retval = "e_register_f12"; break;
        case 47: retval = "e_register_f13"; break;
        case 48: retval = "e_register_f14"; break;
        case 49: retval = "e_register_f15"; break;
        case 50: retval = "e_register_flags"; break;
        case 51: retval = "e_register_fpsr"; break;
        case 52: retval = "e_register_dirflag"; break;
        case 53: retval = "e_unrecognized_register"; break;
        case 54: retval = "e_last_register"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgInitializedName::asm_register_name_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::asm_register_name_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::excess_specifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:80536
/** Converts an enum of type SgInitializedName::excess_specifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_excess_specifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_excess_specifier_none"; break;
        case 1: retval = "e_excess_specifier_positionals"; break;
        case 2: retval = "e_excess_specifier_keywords"; break;
        case 3: retval = "e_excess_specifier_last"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgInitializedName::excess_specifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::excess_specifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::gnu_variable_attribute_enum is defined at frontend/SageIII/Cxx_Grammar.h:80502
/** Converts an enum of type SgInitializedName::gnu_variable_attribute_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_gnu_variable_attribute_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute__weak__"; break;
        case 1: retval = "e_gnu_attribute__unused__"; break;
        case 2: retval = "e_gnu_attribute__used__"; break;
        case 3: retval = "e_gnu_attribute__deprecated__"; break;
        case 4: retval = "e_gnu_attribute__nocommon__"; break;
        case 5: retval = "e_gnu_attribute__transparent_union__"; break;
        case 6: retval = "e_gnu_attribute__weakref__"; break;
        case 7: retval = "e_gnu_attribute__packed__"; break;
        case 8: retval = "e_gnu_attribute__noreturn__"; break;
        case 9: retval = "e_ms_declspec_parameter_appdomain"; break;
        case 10: retval = "e_ms_declspec_parameter_deprecated"; break;
        case 11: retval = "e_ms_declspec_parameter_dllimport"; break;
        case 12: retval = "e_ms_declspec_parameter_dllexport"; break;
        case 13: retval = "e_ms_declspec_parameter_novtable"; break;
        case 14: retval = "e_ms_declspec_parameter_process"; break;
        case 15: retval = "e_ms_declspec_parameter_property"; break;
        case 16: retval = "e_ms_declspec_parameter_restrict"; break;
        case 18: retval = "e_ms_declspec_parameter_selectany"; break;
        case 19: retval = "e_ms_declspec_parameter_thread"; break;
        case 20: retval = "e_ms_declspec_parameter_uuid"; break;
        case 21: retval = "e_last_gnu_variable_attribute"; break;
    }
    if (retval.empty()) {
        char buf[110];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgInitializedName::gnu_variable_attribute_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::gnu_variable_attribute_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInitializedName::preinitialization_enum is defined at frontend/SageIII/Cxx_Grammar.h:80425
/** Converts an enum of type SgInitializedName::preinitialization_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInitializedName_preinitialization_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_preinitialization"; break;
        case 1: retval = "e_virtual_base_class"; break;
        case 2: retval = "e_nonvirtual_base_class"; break;
        case 3: retval = "e_data_member"; break;
        case 4: retval = "e_delegation_constructor"; break;
        case 5: retval = "e_last_preinitialization"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgInitializedName::preinitialization_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInitializedName::preinitialization_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgInterfaceStatement::generic_spec_enum is defined at frontend/SageIII/Cxx_Grammar.h:138246
/** Converts an enum of type SgInterfaceStatement::generic_spec_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgInterfaceStatement_generic_spec_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_error_interface_type"; break;
        case 1: retval = "e_default_interface_type"; break;
        case 2: retval = "e_unnamed_interface_type"; break;
        case 3: retval = "e_named_interface_type"; break;
        case 4: retval = "e_operator_interface_type"; break;
        case 5: retval = "e_assignment_interface_type"; break;
        case 6: retval = "e_last_interface_type"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgInterfaceStatement::generic_spec_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgInterfaceStatement::generic_spec_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgLabelSymbol::label_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:299231
/** Converts an enum of type SgLabelSymbol::label_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLabelSymbol_label_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_label_type"; break;
        case 1: retval = "e_non_numeric_label_type"; break;
        case 2: retval = "e_start_label_type"; break;
        case 3: retval = "e_else_label_type"; break;
        case 4: retval = "e_end_label_type"; break;
        case 5: retval = "e_alternative_return_type"; break;
        case 6: retval = "e_last_label_type"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgLabelSymbol::label_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLabelSymbol::label_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgLinkageModifier::linkage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:14774
/** Converts an enum of type SgLinkageModifier::linkage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgLinkageModifier_linkage_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_C_linkage"; break;
        case 3: retval = "e_Cpp_linkage"; break;
        case 4: retval = "e_fortran_linkage"; break;
        case 5: retval = "e_fortran90_linkage"; break;
        case 6: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgLinkageModifier::linkage_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgLinkageModifier::linkage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgMemberFunctionType::mfunc_specifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:67625
/** Converts an enum of type SgMemberFunctionType::mfunc_specifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgMemberFunctionType_mfunc_specifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "e_const"; break;
        case 2: retval = "e_volatile"; break;
        case 4: retval = "e_restrict"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgMemberFunctionType::mfunc_specifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgMemberFunctionType::mfunc_specifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgNodeHelper::Pattern::OutputTarget::OType is defined at git_rose_development/src/midend/abstractLayer/SgNodeHelper.h:342
/** Converts an enum of type SgNodeHelper::Pattern::OutputTarget::OType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgNodeHelperPatternOutputTargetOType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "VAR"; break;
        case 1: retval = "INT"; break;
        case 2: retval = "UNKNOWNPRINTF"; break;
        case 3: retval = "UNKNOWNOPERATION"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgNodeHelper::Pattern::OutputTarget::OType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgNodeHelper::Pattern::OutputTarget::OType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_default_option_enum is defined at frontend/SageIII/Cxx_Grammar.h:83482
/** Converts an enum of type SgOmpClause::omp_default_option_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_default_option_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_default_unknown"; break;
        case 1: retval = "e_omp_default_none"; break;
        case 2: retval = "e_omp_default_shared"; break;
        case 3: retval = "e_omp_default_private"; break;
        case 4: retval = "e_omp_default_firstprivate"; break;
        case 5: retval = "e_omp_default_last"; break;
    }
    if (retval.empty()) {
        char buf[100];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOmpClause::omp_default_option_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_default_option_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_map_dist_data_enum is defined at frontend/SageIII/Cxx_Grammar.h:83545
/** Converts an enum of type SgOmpClause::omp_map_dist_data_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_map_dist_data_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_map_dist_data_unknown"; break;
        case 1: retval = "e_omp_map_dist_data_duplicate"; break;
        case 2: retval = "e_omp_map_dist_data_block"; break;
        case 3: retval = "e_omp_map_dist_data_cyclic"; break;
        case 4: retval = "e_omp_map_dist_data_last"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOmpClause::omp_map_dist_data_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_map_dist_data_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_map_operator_enum is defined at frontend/SageIII/Cxx_Grammar.h:83534
/** Converts an enum of type SgOmpClause::omp_map_operator_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_map_operator_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_map_unknown"; break;
        case 1: retval = "e_omp_map_alloc"; break;
        case 2: retval = "e_omp_map_to"; break;
        case 3: retval = "e_omp_map_from"; break;
        case 4: retval = "e_omp_map_tofrom"; break;
        case 5: retval = "e_omp_map_last"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOmpClause::omp_map_operator_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_map_operator_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_reduction_operator_enum is defined at frontend/SageIII/Cxx_Grammar.h:83505
/** Converts an enum of type SgOmpClause::omp_reduction_operator_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_reduction_operator_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_reduction_unknown"; break;
        case 1: retval = "e_omp_reduction_plus"; break;
        case 2: retval = "e_omp_reduction_mul"; break;
        case 3: retval = "e_omp_reduction_minus"; break;
        case 4: retval = "e_omp_reduction_bitand"; break;
        case 5: retval = "e_omp_reduction_bitor"; break;
        case 6: retval = "e_omp_reduction_bitxor"; break;
        case 7: retval = "e_omp_reduction_logand"; break;
        case 8: retval = "e_omp_reduction_logor"; break;
        case 9: retval = "e_omp_reduction_and"; break;
        case 10: retval = "e_omp_reduction_or"; break;
        case 11: retval = "e_omp_reduction_eqv"; break;
        case 12: retval = "e_omp_reduction_neqv"; break;
        case 13: retval = "e_omp_reduction_max"; break;
        case 14: retval = "e_omp_reduction_min"; break;
        case 15: retval = "e_omp_reduction_iand"; break;
        case 16: retval = "e_omp_reduction_ior"; break;
        case 17: retval = "e_omp_reduction_ieor"; break;
        case 18: retval = "e_omp_reduction_last"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOmpClause::omp_reduction_operator_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_reduction_operator_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOmpClause::omp_schedule_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:83494
/** Converts an enum of type SgOmpClause::omp_schedule_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOmpClause_omp_schedule_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_omp_schedule_unknown"; break;
        case 1: retval = "e_omp_schedule_static"; break;
        case 2: retval = "e_omp_schedule_dynamic"; break;
        case 3: retval = "e_omp_schedule_guided"; break;
        case 4: retval = "e_omp_schedule_auto"; break;
        case 5: retval = "e_omp_schedule_runtime"; break;
        case 6: retval = "e_omp_schedule_last"; break;
    }
    if (retval.empty()) {
        char buf[99];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOmpClause::omp_schedule_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOmpClause::omp_schedule_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgOpenclAccessModeModifier::access_mode_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:17447
/** Converts an enum of type SgOpenclAccessModeModifier::access_mode_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgOpenclAccessModeModifier_access_mode_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_read_only"; break;
        case 3: retval = "e_write_only"; break;
        case 4: retval = "e_read_write"; break;
        case 5: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[117];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgOpenclAccessModeModifier::access_mode_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgOpenclAccessModeModifier::access_mode_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgProcedureHeaderStatement::subprogram_kind_enum is defined at frontend/SageIII/Cxx_Grammar.h:152773
/** Converts an enum of type SgProcedureHeaderStatement::subprogram_kind_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProcedureHeaderStatement_subprogram_kind_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_kind"; break;
        case 1: retval = "e_function_subprogram_kind"; break;
        case 2: retval = "e_subroutine_subprogram_kind"; break;
        case 3: retval = "e_block_data_subprogram_kind"; break;
        case 4: retval = "e_last_subprogram_kind"; break;
    }
    if (retval.empty()) {
        char buf[112];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgProcedureHeaderStatement::subprogram_kind_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProcedureHeaderStatement::subprogram_kind_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgProject::template_instantiation_enum is defined at frontend/SageIII/Cxx_Grammar.h:26237
/** Converts an enum of type SgProject::template_instantiation_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgProject_template_instantiation_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_none"; break;
        case 3: retval = "e_used"; break;
        case 4: retval = "e_all"; break;
        case 5: retval = "e_local"; break;
        case 6: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[102];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgProject::template_instantiation_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgProject::template_instantiation_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgSpecialFunctionModifier::special_function_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:13691
/** Converts an enum of type SgSpecialFunctionModifier::special_function_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgSpecialFunctionModifier_special_function_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_constructor"; break;
        case 3: retval = "e_destructor"; break;
        case 4: retval = "e_conversion"; break;
        case 5: retval = "e_operator"; break;
        case 6: retval = "e_uld_operator"; break;
        case 7: retval = "e_lambda_entry_point"; break;
        case 8: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[121];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgSpecialFunctionModifier::special_function_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgSpecialFunctionModifier::special_function_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgStopOrPauseStatement::stop_or_pause_enum is defined at frontend/SageIII/Cxx_Grammar.h:173268
/** Converts an enum of type SgStopOrPauseStatement::stop_or_pause_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStopOrPauseStatement_stop_or_pause_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_stop"; break;
        case 2: retval = "e_pause"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgStopOrPauseStatement::stop_or_pause_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStopOrPauseStatement::stop_or_pause_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgStorageModifier::storage_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:11265
/** Converts an enum of type SgStorageModifier::storage_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgStorageModifier_storage_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_extern"; break;
        case 3: retval = "e_static"; break;
        case 4: retval = "e_auto"; break;
        case 5: retval = "e_unspecified"; break;
        case 6: retval = "e_register"; break;
        case 7: retval = "e_mutable"; break;
        case 8: retval = "e_typedef"; break;
        case 9: retval = "e_asm"; break;
        case 10: retval = "e_local"; break;
        case 11: retval = "e_common"; break;
        case 12: retval = "e_associated"; break;
        case 13: retval = "e_intrinsic"; break;
        case 14: retval = "e_pointer_based"; break;
        case 15: retval = "e_cuda_global"; break;
        case 16: retval = "e_cuda_constant"; break;
        case 17: retval = "e_cuda_shared"; break;
        case 18: retval = "e_cuda_dynamic_shared"; break;
        case 19: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[104];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgStorageModifier::storage_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgStorageModifier::storage_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateArgument::template_argument_enum is defined at frontend/SageIII/Cxx_Grammar.h:31355
/** Converts an enum of type SgTemplateArgument::template_argument_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateArgument_template_argument_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "argument_undefined"; break;
        case 1: retval = "type_argument"; break;
        case 2: retval = "nontype_argument"; break;
        case 3: retval = "template_template_argument"; break;
        case 4: retval = "start_of_pack_expansion_argument"; break;
    }
    if (retval.empty()) {
        char buf[106];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTemplateArgument::template_argument_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateArgument::template_argument_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateClassDeclaration::class_types is defined at frontend/SageIII/Cxx_Grammar.h:144149
/** Converts an enum of type SgTemplateClassDeclaration::class_types to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateClassDeclaration_class_types(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_class"; break;
        case 1: retval = "e_struct"; break;
        case 2: retval = "e_union"; break;
        case 3: retval = "e_template_parameter"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTemplateClassDeclaration::class_types)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateClassDeclaration::class_types::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateDeclaration::template_type_enum is defined at frontend/SageIII/Cxx_Grammar.h:135174
/** Converts an enum of type SgTemplateDeclaration::template_type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateDeclaration_template_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_template_none"; break;
        case 1: retval = "e_template_class"; break;
        case 2: retval = "e_template_m_class"; break;
        case 3: retval = "e_template_function"; break;
        case 4: retval = "e_template_m_function"; break;
        case 5: retval = "e_template_m_data"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTemplateDeclaration::template_type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateDeclaration::template_type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTemplateParameter::template_parameter_enum is defined at frontend/SageIII/Cxx_Grammar.h:30797
/** Converts an enum of type SgTemplateParameter::template_parameter_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTemplateParameter_template_parameter_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "parameter_undefined"; break;
        case 1: retval = "type_parameter"; break;
        case 2: retval = "nontype_parameter"; break;
        case 3: retval = "template_parameter"; break;
    }
    if (retval.empty()) {
        char buf[108];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTemplateParameter::template_parameter_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTemplateParameter::template_parameter_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgThrowOp::e_throw_kind is defined at frontend/SageIII/Cxx_Grammar.h:207844
/** Converts an enum of type SgThrowOp::e_throw_kind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgThrowOp_e_throw_kind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "unknown_throw"; break;
        case 1: retval = "throw_expression"; break;
        case 2: retval = "rethrow"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgThrowOp::e_throw_kind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgThrowOp::e_throw_kind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_C_CXX_Operators is defined at frontend/SageIII/Cxx_Grammar.h:78887
/** Converts an enum of type SgToken::ROSE_C_CXX_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 50000: retval = "C_CXX_AND"; break;
        case 50001: retval = "C_CXX_ANDAND"; break;
        case 50002: retval = "C_CXX_ASSIGN"; break;
        case 50003: retval = "C_CXX_ANDASSIGN"; break;
        case 50004: retval = "C_CXX_OR"; break;
        case 50005: retval = "C_CXX_ORASSIGN"; break;
        case 50006: retval = "C_CXX_XOR"; break;
        case 50007: retval = "C_CXX_XORASSIGN"; break;
        case 50008: retval = "C_CXX_COMMA"; break;
        case 50009: retval = "C_CXX_COLON"; break;
        case 50010: retval = "C_CXX_DIVIDE"; break;
        case 50011: retval = "C_CXX_DIVIDEASSIGN"; break;
        case 50012: retval = "C_CXX_DOT"; break;
        case 50013: retval = "C_CXX_DOTSTAR"; break;
        case 50014: retval = "C_CXX_ELLIPSIS"; break;
        case 50015: retval = "C_CXX_EQUAL"; break;
        case 50016: retval = "C_CXX_GREATER"; break;
        case 50017: retval = "C_CXX_GREATEREQUAL"; break;
        case 50018: retval = "C_CXX_LEFTBRACE"; break;
        case 50019: retval = "C_CXX_LESS"; break;
        case 50020: retval = "C_CXX_LESSEQUAL"; break;
        case 50021: retval = "C_CXX_LEFTPAREN"; break;
        case 50022: retval = "C_CXX_LEFTBRACKET"; break;
        case 50023: retval = "C_CXX_MINUS"; break;
        case 50024: retval = "C_CXX_MINUSASSIGN"; break;
        case 50025: retval = "C_CXX_MINUSMINUS"; break;
        case 50026: retval = "C_CXX_PERCENT"; break;
        case 50027: retval = "C_CXX_PERCENTASSIGN"; break;
        case 50028: retval = "C_CXX_NOT"; break;
        case 50029: retval = "C_CXX_NOTEQUAL"; break;
        case 50030: retval = "C_CXX_OROR"; break;
        case 50031: retval = "C_CXX_PLUS"; break;
        case 50032: retval = "C_CXX_PLUSASSIGN"; break;
        case 50033: retval = "C_CXX_PLUSPLUS"; break;
        case 50034: retval = "C_CXX_ARROW"; break;
        case 50035: retval = "C_CXX_ARROWSTAR"; break;
        case 50036: retval = "C_CXX_QUESTION_MARK"; break;
        case 50037: retval = "C_CXX_RIGHTBRACE"; break;
        case 50038: retval = "C_CXX_RIGHTPAREN"; break;
        case 50039: retval = "C_CXX_RIGHTBRACKET"; break;
        case 50040: retval = "C_CXX_COLON_COLON"; break;
        case 50041: retval = "C_CXX_SEMICOLON"; break;
        case 50042: retval = "C_CXX_SHIFTLEFT"; break;
        case 50043: retval = "C_CXX_SHIFTLEFTASSIGN"; break;
        case 50044: retval = "C_CXX_SHIFTRIGHT"; break;
        case 50045: retval = "C_CXX_SHIFTRIGHTASSIGN"; break;
        case 50046: retval = "C_CXX_STAR"; break;
        case 50047: retval = "C_CXX_COMPL"; break;
        case 50048: retval = "C_CXX_STARASSIGN"; break;
        case 50049: retval = "C_CXX_POUND_POUND"; break;
        case 50050: retval = "C_CXX_POUND"; break;
        case 50051: retval = "C_CXX_AND_ALT"; break;
        case 50052: retval = "C_CXX_ANDASSIGN_ALT"; break;
        case 50053: retval = "C_CXX_OR_ALT"; break;
        case 50054: retval = "C_CXX_ORASSIGN_ALT"; break;
        case 50055: retval = "C_CXX_XOR_ALT"; break;
        case 50056: retval = "C_CXX_XORASSIGN_ALT"; break;
        case 50057: retval = "C_CXX_LEFTBRACE_ALT"; break;
        case 50058: retval = "C_CXX_LEFTBRACKET_ALT"; break;
        case 50059: retval = "C_CXX_NOT_ALT"; break;
        case 50060: retval = "C_CXX_NOTEQUAL_ALT"; break;
        case 50061: retval = "C_CXX_RIGHTBRACE_ALT"; break;
        case 50062: retval = "C_CXX_RIGHTBRACKET_ALT"; break;
        case 50063: retval = "C_CXX_COMPL_ALT"; break;
        case 50064: retval = "C_CXX_POUND_POUND_ALT"; break;
        case 50065: retval = "C_CXX_POUND_ALT"; break;
        case 50066: retval = "C_CXX_OR_TRIGRAPH"; break;
        case 50067: retval = "C_CXX_XOR_TRIGRAPH"; break;
        case 50068: retval = "C_CXX_LEFTBRACE_TRIGRAPH"; break;
        case 50069: retval = "C_CXX_LEFTBRACKET_TRIGRAPH"; break;
        case 50070: retval = "C_CXX_RIGHTBRACE_TRIGRAPH"; break;
        case 50071: retval = "C_CXX_RIGHTBRACKET_TRIGRAPH"; break;
        case 50072: retval = "C_CXX_COMPL_TRIGRAPH"; break;
        case 50073: retval = "C_CXX_POUND_POUND_TRIGRAPH"; break;
        case 50074: retval = "C_CXX_POUND_TRIGRAPH"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgToken::ROSE_C_CXX_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_C_CXX_keywords is defined at frontend/SageIII/Cxx_Grammar.h:78791
/** Converts an enum of type SgToken::ROSE_C_CXX_keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_C_CXX_keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 500: retval = "C_CXX_ASM"; break;
        case 501: retval = "C_CXX_AUTO"; break;
        case 502: retval = "C_CXX_BOOL"; break;
        case 503: retval = "C_CXX_BREAK"; break;
        case 504: retval = "C_CXX_CASE"; break;
        case 505: retval = "C_CXX_CATCH"; break;
        case 506: retval = "C_CXX_CHAR"; break;
        case 507: retval = "C_CXX_CLASS"; break;
        case 508: retval = "C_CXX_CONST"; break;
        case 509: retval = "C_CXX_CONSTCAST"; break;
        case 510: retval = "C_CXX_CONTINUE"; break;
        case 511: retval = "C_CXX_DEFAULT"; break;
        case 512: retval = "C_CXX_DEFINED"; break;
        case 513: retval = "C_CXX_DELETE"; break;
        case 514: retval = "C_CXX_DO"; break;
        case 515: retval = "C_CXX_DOUBLE"; break;
        case 516: retval = "C_CXX_DYNAMICCAST"; break;
        case 517: retval = "C_CXX_ELSE"; break;
        case 518: retval = "C_CXX_ENUM"; break;
        case 519: retval = "C_CXX_EXPLICIT"; break;
        case 520: retval = "C_CXX_EXPORT"; break;
        case 521: retval = "C_CXX_EXTERN"; break;
        case 522: retval = "C_CXX_FALSE"; break;
        case 523: retval = "C_CXX_FLOAT"; break;
        case 524: retval = "C_CXX_FOR"; break;
        case 525: retval = "C_CXX_FRIEND"; break;
        case 526: retval = "C_CXX_GOTO"; break;
        case 527: retval = "C_CXX_IF"; break;
        case 528: retval = "C_CXX_INLINE"; break;
        case 529: retval = "C_CXX_INT"; break;
        case 530: retval = "C_CXX_LONG"; break;
        case 531: retval = "C_CXX_MUTABLE"; break;
        case 532: retval = "C_CXX_NAMESPACE"; break;
        case 533: retval = "C_CXX_NEW"; break;
        case 534: retval = "C_CXX_OPERATOR"; break;
        case 535: retval = "C_CXX_PRIVATE"; break;
        case 536: retval = "C_CXX_PROTECTED"; break;
        case 537: retval = "C_CXX_PUBLIC"; break;
        case 538: retval = "C_CXX_REGISTER"; break;
        case 539: retval = "C_CXX_REINTERPRETCAST"; break;
        case 540: retval = "C_CXX_RETURN"; break;
        case 541: retval = "C_CXX_SHORT"; break;
        case 542: retval = "C_CXX_SIGNED"; break;
        case 543: retval = "C_CXX_SIZEOF"; break;
        case 544: retval = "C_CXX_STATIC"; break;
        case 545: retval = "C_CXX_STATICCAST"; break;
        case 546: retval = "C_CXX_STRUCT"; break;
        case 547: retval = "C_CXX_SWITCH"; break;
        case 548: retval = "C_CXX_TEMPLATE"; break;
        case 549: retval = "C_CXX_THIS"; break;
        case 550: retval = "C_CXX_THROW"; break;
        case 551: retval = "C_CXX_TRY"; break;
        case 552: retval = "C_CXX_TRUE"; break;
        case 553: retval = "C_CXX_TYPEDEF"; break;
        case 554: retval = "C_CXX_TYPEID"; break;
        case 555: retval = "C_CXX_TYPENAME"; break;
        case 556: retval = "C_CXX_UNION"; break;
        case 557: retval = "C_CXX_UNSIGNED"; break;
        case 558: retval = "C_CXX_USING"; break;
        case 559: retval = "C_CXX_VIRTUAL"; break;
        case 560: retval = "C_CXX_VOID"; break;
        case 561: retval = "C_CXX_VOLATILE"; break;
        case 562: retval = "C_CXX_WCHART"; break;
        case 563: retval = "C_CXX_WHILE"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgToken::ROSE_C_CXX_keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_C_CXX_keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Additional_Info is defined at frontend/SageIII/Cxx_Grammar.h:78967
/** Converts an enum of type SgToken::ROSE_Fortran_Additional_Info to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Additional_Info(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 100000: retval = "FORTRAN_COMMENTS"; break;
        case 100001: retval = "FORTRAN_STRING_LITERALS"; break;
        case 100002: retval = "FORTRAN_IDENTIFIER"; break;
        case 100003: retval = "FORTRAN_UNIDENTIFIED_TOKEN"; break;
        case 100004: retval = "FORTRAN_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Additional_Info)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Additional_Info::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Keywords is defined at frontend/SageIII/Cxx_Grammar.h:78652
/** Converts an enum of type SgToken::ROSE_Fortran_Keywords to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Keywords(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FORTRAN_ABSTRACT"; break;
        case 1: retval = "FORTRAN_ACCESS"; break;
        case 2: retval = "FORTRAN_ACTION"; break;
        case 3: retval = "FORTRAN_ALLOCATE"; break;
        case 4: retval = "FORTRAN_ALLOCATABLE"; break;
        case 5: retval = "FORTRAN_ASSIGN"; break;
        case 6: retval = "FORTRAN_ASSOCIATE"; break;
        case 7: retval = "FORTRAN_ASYNCHRONOUS"; break;
        case 8: retval = "FORTRAN_BACKSPACE"; break;
        case 9: retval = "FORTRAN_BIND"; break;
        case 10: retval = "FORTRAN_BLANK"; break;
        case 11: retval = "FORTRAN_BLOCK_DATA"; break;
        case 12: retval = "FORTRAN_CALL"; break;
        case 13: retval = "FORTRAN_CHARACTER"; break;
        case 14: retval = "FORTRAN_CLASS"; break;
        case 15: retval = "FORTRAN_CLOSE"; break;
        case 16: retval = "FORTRAN_CONTINUE"; break;
        case 17: retval = "FORTRAN_CYCLE"; break;
        case 18: retval = "FORTRAN_CASE"; break;
        case 19: retval = "FORTRAN_COMMON"; break;
        case 20: retval = "FORTRAN_COMPLEX"; break;
        case 21: retval = "FORTRAN_CONTAINS"; break;
        case 22: retval = "FORTRAN_DEALLOCATE"; break;
        case 23: retval = "FORTRAN_DATA"; break;
        case 24: retval = "FORTRAN_DEFERRED"; break;
        case 25: retval = "FORTRAN_DELIM"; break;
        case 26: retval = "FORTRAN_DIMENSION"; break;
        case 27: retval = "FORTRAN_DO"; break;
        case 28: retval = "FORTRAN_DT"; break;
        case 29: retval = "FORTRAN_DOUBLEPRECISION"; break;
        case 30: retval = "FORTRAN_ENCODING"; break;
        case 31: retval = "FORTRAN_END_CASE"; break;
        case 32: retval = "FORTRAN_ENDDO"; break;
        case 33: retval = "FORTRAN_END_FILE"; break;
        case 34: retval = "FORTRAN_END_ENUM"; break;
        case 35: retval = "FORTRAN_END_INTERFACE"; break;
        case 36: retval = "FORTRAN_END_TYPE"; break;
        case 37: retval = "FORTRAN_ERR"; break;
        case 38: retval = "FORTRAN_ERRMSG"; break;
        case 39: retval = "FORTRAN_EXIT"; break;
        case 40: retval = "FORTRAN_ELSE"; break;
        case 41: retval = "FORTRAN_ELSEWHERE"; break;
        case 42: retval = "FORTRAN_ELSEIF"; break;
        case 43: retval = "FORTRAN_ENDIF"; break;
        case 44: retval = "FORTRAN_ENTRY"; break;
        case 45: retval = "FORTRAN_END"; break;
        case 46: retval = "FORTRAN_ENUM"; break;
        case 47: retval = "FORTRAN_ENUMERATOR"; break;
        case 48: retval = "FORTRAN_EQUIVALENCE"; break;
        case 49: retval = "FORTRAN_EXTERNAL"; break;
        case 50: retval = "FORTRAN_EXTENDS"; break;
        case 51: retval = "FORTRAN_FILE"; break;
        case 52: retval = "FORTRAN_FINAL"; break;
        case 53: retval = "FORTRAN_FMT"; break;
        case 54: retval = "FORTRAN_FORALL"; break;
        case 55: retval = "FORTRAN_FORM"; break;
        case 56: retval = "FORTRAN_FORMATTED"; break;
        case 57: retval = "FORTRAN_FORMAT"; break;
        case 58: retval = "FORTRAN_FLUSH"; break;
        case 59: retval = "FORTRAN_FUNCTION"; break;
        case 60: retval = "FORTRAN_GENERIC"; break;
        case 61: retval = "FORTRAN_GOTO"; break;
        case 62: retval = "FORTRAN_ID"; break;
        case 63: retval = "FORTRAN_IF"; break;
        case 64: retval = "FORTRAN_INQUIRE"; break;
        case 65: retval = "FORTRAN_INTEGER"; break;
        case 66: retval = "FORTRAN_IOMSG"; break;
        case 67: retval = "FORTRAN_IOSTAT"; break;
        case 68: retval = "FORTRAN_IMPLICIT"; break;
        case 69: retval = "FORTRAN_IMPLICIT_NONE"; break;
        case 70: retval = "FORTRAN_IMPORT"; break;
        case 71: retval = "FORTRAN_INTERFACE"; break;
        case 72: retval = "FORTRAN_INTENT"; break;
        case 73: retval = "FORTRAN_INTRINSIC"; break;
        case 74: retval = "FORTRAN_LEN"; break;
        case 75: retval = "FORTRAN_LOGICAL"; break;
        case 76: retval = "FORTRAN_KIND"; break;
        case 77: retval = "FORTRAN_MODULE_PROC"; break;
        case 78: retval = "FORTRAN_MODULE"; break;
        case 79: retval = "FORTRAN_NON_INTRINSIC"; break;
        case 80: retval = "FORTRAN_NON_OVERRIDABLE"; break;
        case 81: retval = "FORTRAN_NULL"; break;
        case 82: retval = "FORTRAN_NULLIFY"; break;
        case 83: retval = "FORTRAN_NAMELIST"; break;
        case 84: retval = "FORTRAN_NML"; break;
        case 85: retval = "FORTRAN_NONE"; break;
        case 86: retval = "FORTRAN_NOPASS"; break;
        case 87: retval = "FORTRAN_ONLY"; break;
        case 88: retval = "FORTRAN_OPEN"; break;
        case 89: retval = "FORTRAN_OPTIONAL"; break;
        case 90: retval = "FORTRAN_PARAMETER"; break;
        case 91: retval = "FORTRAN_PASS"; break;
        case 92: retval = "FORTRAN_PAUSE"; break;
        case 93: retval = "FORTRAN_POINTER"; break;
        case 94: retval = "FORTRAN_PRINT"; break;
        case 95: retval = "FORTRAN_PRIVATE"; break;
        case 96: retval = "FORTRAN_PROCEDURE"; break;
        case 97: retval = "FORTRAN_PROGRAM"; break;
        case 98: retval = "FORTRAN_PROTECTED"; break;
        case 99: retval = "FORTRAN_READ"; break;
        case 100: retval = "FORTRAN_REAL"; break;
        case 101: retval = "FORTRAN_RETURN"; break;
        case 102: retval = "FORTRAN_REWIND"; break;
        case 103: retval = "FORTRAN_ROUND"; break;
        case 104: retval = "FORTRAN_SELECTCASE"; break;
        case 105: retval = "FORTRAN_SELECTTYPE"; break;
        case 106: retval = "FORTRAN_SEQUENCE"; break;
        case 107: retval = "FORTRAN_SAVE"; break;
        case 108: retval = "FORTRAN_SIGN"; break;
        case 109: retval = "FORTRAN_SIZE"; break;
        case 110: retval = "FORTRAN_SOURCE"; break;
        case 111: retval = "FORTRAN_STAT"; break;
        case 112: retval = "FORTRAN_STOP"; break;
        case 113: retval = "FORTRAN_SUBROUTINE"; break;
        case 114: retval = "FORTRAN_TARGET"; break;
        case 115: retval = "FORTRAN_THEN"; break;
        case 116: retval = "FORTRAN_DERIVED_DECL"; break;
        case 117: retval = "FORTRAN_TYPEIS"; break;
        case 118: retval = "FORTRAN_UNFORMATTED"; break;
        case 119: retval = "FORTRAN_UNIT"; break;
        case 120: retval = "FORTRAN_USE"; break;
        case 121: retval = "FORTRAN_VALUE"; break;
        case 122: retval = "FORTRAN_VOLATILE"; break;
        case 123: retval = "FORTRAN_WAIT"; break;
        case 124: retval = "FORTRAN_WHERE"; break;
        case 125: retval = "FORTRAN_WRITE"; break;
        case 126: retval = "FORTRAN_END_PROGRAM"; break;
        case 127: retval = "FORTRAN_END_FUNCTION"; break;
        case 128: retval = "FORTRAN_END_SUBROUTINE"; break;
        case 129: retval = "FORTRAN_END_MODULE"; break;
        case 130: retval = "FORTRAN_DOUBLE_COMPLEX"; break;
        case 131: retval = "FORTRAN_TYPE"; break;
        case 132: retval = "FORTRAN_UNKNOWN"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Keywords)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Keywords::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgToken::ROSE_Fortran_Operators is defined at frontend/SageIII/Cxx_Grammar.h:78860
/** Converts an enum of type SgToken::ROSE_Fortran_Operators to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTokenROSE_Fortran_Operators(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 10000: retval = "FORTRAN_INTRINSIC_PLUS"; break;
        case 10001: retval = "FORTRAN_INTRINSIC_MINUS"; break;
        case 10002: retval = "FORTRAN_INTRINSIC_POWER"; break;
        case 10003: retval = "FORTRAN_INTRINSIC_CONCAT"; break;
        case 10004: retval = "FORTRAN_INTRINSIC_TIMES"; break;
        case 10005: retval = "FORTRAN_INTRINSIC_DIVIDE"; break;
        case 10006: retval = "FORTRAN_INTRINSIC_AND"; break;
        case 10007: retval = "FORTRAN_INTRINSIC_OR"; break;
        case 10008: retval = "FORTRAN_INTRINSIC_EQV"; break;
        case 10009: retval = "FORTRAN_INTRINSIC_NEQV"; break;
        case 10010: retval = "FORTRAN_INTRINSIC_EQ"; break;
        case 10011: retval = "FORTRAN_INTRINSIC_NE"; break;
        case 10012: retval = "FORTRAN_INTRINSIC_GE"; break;
        case 10013: retval = "FORTRAN_INTRINSIC_LE"; break;
        case 10014: retval = "FORTRAN_INTRINSIC_LT"; break;
        case 10015: retval = "FORTRAN_INTRINSIC_GT"; break;
        case 10016: retval = "FORTRAN_INTRINSIC_NOT"; break;
        case 10017: retval = "FORTRAN_INTRINSIC_OLDEQ"; break;
        case 10018: retval = "FORTRAN_INTRINSIC_OLDNE"; break;
        case 10019: retval = "FORTRAN_INTRINSIC_OLDGE"; break;
        case 10020: retval = "FORTRAN_INTRINSIC_OLDLE"; break;
        case 10021: retval = "FORTRAN_INTRINSIC_OLDLT"; break;
        case 10022: retval = "FORTRAN_INTRINSIC_OLDGT"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgToken::ROSE_Fortran_Operators)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgToken::ROSE_Fortran_Operators::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgType::fortran_attribute_specifiers_enum is defined at frontend/SageIII/Cxx_Grammar.h:46667
/** Converts an enum of type SgType::fortran_attribute_specifiers_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgType_fortran_attribute_specifiers_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown_attribute_specifier"; break;
        case 1: retval = "e_public_access"; break;
        case 2: retval = "e_private_access"; break;
        case 3: retval = "e_allocatable"; break;
        case 4: retval = "e_asynchronous"; break;
        case 5: retval = "e_bind"; break;
        case 6: retval = "e_data"; break;
        case 7: retval = "e_dimension"; break;
        case 8: retval = "e_intent"; break;
        case 9: retval = "e_optional"; break;
        case 10: retval = "e_parameter"; break;
        case 11: retval = "e_pointer"; break;
        case 12: retval = "e_protected"; break;
        case 13: retval = "e_save"; break;
        case 14: retval = "e_target"; break;
        case 15: retval = "e_value"; break;
        case 16: retval = "e_volatile"; break;
        case 17: retval = "e_last_attribute_specifier"; break;
    }
    if (retval.empty()) {
        char buf[105];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgType::fortran_attribute_specifiers_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgType::fortran_attribute_specifiers_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTypeModifier::gnu_extension_machine_mode_enum is defined at frontend/SageIII/Cxx_Grammar.h:15906
/** Converts an enum of type SgTypeModifier::gnu_extension_machine_mode_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_gnu_extension_machine_mode_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_extension_machine_mode_unknown"; break;
        case 1: retval = "e_gnu_extension_machine_mode_unspecified"; break;
        case 2: retval = "e_gnu_extension_machine_mode_BImode"; break;
        case 3: retval = "e_gnu_extension_machine_mode_QImode"; break;
        case 4: retval = "e_gnu_extension_machine_mode_HImode"; break;
        case 5: retval = "e_gnu_extension_machine_mode_PSImode"; break;
        case 6: retval = "e_gnu_extension_machine_mode_SImode"; break;
        case 7: retval = "e_gnu_extension_machine_mode_PDImode"; break;
        case 8: retval = "e_gnu_extension_machine_mode_DImode"; break;
        case 9: retval = "e_gnu_extension_machine_mode_TImode"; break;
        case 10: retval = "e_gnu_extension_machine_mode_OImode"; break;
        case 11: retval = "e_gnu_extension_machine_mode_QFmode"; break;
        case 12: retval = "e_gnu_extension_machine_mode_HFmode"; break;
        case 13: retval = "e_gnu_extension_machine_mode_TQFmode"; break;
        case 14: retval = "e_gnu_extension_machine_mode_SFmode"; break;
        case 15: retval = "e_gnu_extension_machine_mode_DFmode"; break;
        case 16: retval = "e_gnu_extension_machine_mode_XFmode"; break;
        case 17: retval = "e_gnu_extension_machine_mode_SDmode"; break;
        case 18: retval = "e_gnu_extension_machine_mode_DDmode"; break;
        case 19: retval = "e_gnu_extension_machine_mode_TDmode"; break;
        case 20: retval = "e_gnu_extension_machine_mode_TFmode"; break;
        case 21: retval = "e_gnu_extension_machine_mode_QQmode"; break;
        case 22: retval = "e_gnu_extension_machine_mode_HQmode"; break;
        case 23: retval = "e_gnu_extension_machine_mode_SQmode"; break;
        case 24: retval = "e_gnu_extension_machine_mode_DQmode"; break;
        case 25: retval = "e_gnu_extension_machine_mode_TQmode"; break;
        case 26: retval = "e_gnu_extension_machine_mode_UQQmode"; break;
        case 27: retval = "e_gnu_extension_machine_mode_UHQmode"; break;
        case 28: retval = "e_gnu_extension_machine_mode_USQmode"; break;
        case 29: retval = "e_gnu_extension_machine_mode_UDQmode"; break;
        case 30: retval = "e_gnu_extension_machine_mode_UTQmode"; break;
        case 31: retval = "e_gnu_extension_machine_mode_HAmode"; break;
        case 32: retval = "e_gnu_extension_machine_mode_SAmode"; break;
        case 33: retval = "e_gnu_extension_machine_mode_DAmode"; break;
        case 34: retval = "e_gnu_extension_machine_mode_TAmode"; break;
        case 35: retval = "e_gnu_extension_machine_mode_UHAmode"; break;
        case 36: retval = "e_gnu_extension_machine_mode_USAmode"; break;
        case 37: retval = "e_gnu_extension_machine_mode_UDAmode"; break;
        case 38: retval = "e_gnu_extension_machine_mode_UTAmode"; break;
        case 39: retval = "e_gnu_extension_machine_mode_CCmode"; break;
        case 40: retval = "e_gnu_extension_machine_mode_BLKmode"; break;
        case 41: retval = "e_gnu_extension_machine_mode_VOIDmode"; break;
        case 42: retval = "e_gnu_extension_machine_mode_QCmode"; break;
        case 43: retval = "e_gnu_extension_machine_mode_HCmode"; break;
        case 44: retval = "e_gnu_extension_machine_mode_SCmode"; break;
        case 45: retval = "e_gnu_extension_machine_mode_DCmode"; break;
        case 46: retval = "e_gnu_extension_machine_mode_XCmode"; break;
        case 47: retval = "e_gnu_extension_machine_mode_TCmode"; break;
        case 48: retval = "e_gnu_extension_machine_mode_CQImode"; break;
        case 49: retval = "e_gnu_extension_machine_mode_CHImode"; break;
        case 50: retval = "e_gnu_extension_machine_mode_CSImode"; break;
        case 51: retval = "e_gnu_extension_machine_mode_CDImode"; break;
        case 52: retval = "e_gnu_extension_machine_mode_CTImode"; break;
        case 53: retval = "e_gnu_extension_machine_mode_COImode"; break;
        case 54: retval = "e_last_machine_mode"; break;
    }
    if (retval.empty()) {
        char buf[111];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTypeModifier::gnu_extension_machine_mode_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::gnu_extension_machine_mode_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgTypeModifier::type_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:15828
/** Converts an enum of type SgTypeModifier::type_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgTypeModifier_type_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_restrict"; break;
        case 3: retval = "e_allocatable"; break;
        case 4: retval = "e_asynchronous"; break;
        case 5: retval = "e_bind"; break;
        case 6: retval = "e_data"; break;
        case 7: retval = "e_dimension"; break;
        case 8: retval = "e_intent_in"; break;
        case 9: retval = "e_intent_out"; break;
        case 10: retval = "e_intent_inout"; break;
        case 11: retval = "e_intrinsic"; break;
        case 12: retval = "e_optional"; break;
        case 13: retval = "e_extends"; break;
        case 14: retval = "e_abstract"; break;
        case 15: retval = "e_save"; break;
        case 16: retval = "e_target"; break;
        case 17: retval = "e_value"; break;
        case 18: retval = "e_gnu_attribute__unused__"; break;
        case 19: retval = "e_gnu_attribute__packed__"; break;
        case 20: retval = "e_gnu_attribute__deprecated__"; break;
        case 21: retval = "e_gnu_attribute__transparent_union__"; break;
        case 22: retval = "e_gnu_attribute__noreturn__"; break;
        case 23: retval = "e_gnu_attribute__const__"; break;
        case 24: retval = "e_gnu_attribute__cdecl__"; break;
        case 25: retval = "e_gnu_attribute__stdcall__"; break;
        case 26: retval = "e_gnu_attribute__warn_unused_result__"; break;
        case 27: retval = "e_gnu_attribute__nonnull__"; break;
        case 28: retval = "e_gnu_attribute__sentinel__"; break;
        case 29: retval = "e_address_space__"; break;
        case 30: retval = "e_ocl_global__"; break;
        case 31: retval = "e_ocl_local__"; break;
        case 32: retval = "e_ocl_constant__"; break;
        case 33: retval = "e_vector_type__"; break;
        case 34: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[98];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgTypeModifier::type_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgTypeModifier::type_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUPC_AccessModifier::upc_access_modifier_enum is defined at frontend/SageIII/Cxx_Grammar.h:13149
/** Converts an enum of type SgUPC_AccessModifier::upc_access_modifier_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUPC_AccessModifier_upc_access_modifier_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_default"; break;
        case 2: retval = "e_upc_strict"; break;
        case 3: retval = "e_upc_relaxed"; break;
        case 4: retval = "e_last_modifier"; break;
    }
    if (retval.empty()) {
        char buf[110];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgUPC_AccessModifier::upc_access_modifier_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUPC_AccessModifier::upc_access_modifier_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnaryOp::Sgop_mode is defined at frontend/SageIII/Cxx_Grammar.h:202400
/** Converts an enum of type SgUnaryOp::Sgop_mode to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnaryOpSgop_mode(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "prefix"; break;
        case 1: retval = "postfix"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgUnaryOp::Sgop_mode)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnaryOp::Sgop_mode::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnparse_Info::access_attr_enum is defined at frontend/SageIII/Cxx_Grammar.h:28303
/** Converts an enum of type SgUnparse_Info::access_attr_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_access_attr_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "a_unset_access"; break;
        case 2: retval = "a_private_access"; break;
        case 3: retval = "a_protected_access"; break;
        case 4: retval = "a_public_access"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgUnparse_Info::access_attr_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::access_attr_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUnparse_Info::unparse_type_num is defined at frontend/SageIII/Cxx_Grammar.h:28145
/** Converts an enum of type SgUnparse_Info::unparse_type_num to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUnparse_Info_unparse_type_num(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "b_enum_defaultValue"; break;
        case 1: retval = "b_isPointerToSomething"; break;
        case 2: retval = "b_isReferenceToSomething"; break;
        case 3: retval = "b_inVarDecl"; break;
        case 4: retval = "b_inArgList"; break;
        case 5: retval = "b_SkipSemiColon"; break;
        case 6: retval = "b_inEnumDecl"; break;
        case 7: retval = "b_inTemplateList"; break;
        case 8: retval = "b_SkipBaseType"; break;
        case 9: retval = "b_inAggregateInitializer"; break;
        case 10: retval = "b_isWithType"; break;
        case 11: retval = "b_inConditional"; break;
        case 12: retval = "b_SkipDefinition"; break;
        case 13: retval = "b_SkipClassSpecifier"; break;
        case 14: retval = "b_inEmbeddedDecl"; break;
        case 15: retval = "b_SkipGlobal"; break;
        case 16: retval = "b_SkipAtomic"; break;
        case 17: retval = "b_PrintName"; break;
        case 18: retval = "b_CheckAccess"; break;
        case 19: retval = "b_SkipFunctionQualifier"; break;
        case 20: retval = "b_isArrayType"; break;
        case 21: retval = "b_inRhsExpr"; break;
        case 22: retval = "b_SkipParen"; break;
        case 23: retval = "b_isTypeSecondPart"; break;
        case 24: retval = "b_isTypeFirstPart"; break;
        case 25: retval = "b_SkipInitializer"; break;
        case 26: retval = "b_SkipComments"; break;
        case 27: retval = "b_SkipCPPDirectives"; break;
        case 28: retval = "b_SkipEnumDefinition"; break;
        case 29: retval = "b_SkipFunctionDefinition"; break;
        case 30: retval = "b_SkipClassDefinition"; break;
        case 31: retval = "b_AddSemiColonAfterDeclaration"; break;
        case 32: retval = "b_SkipWhitespaces"; break;
        case 33: retval = "b_SkipBasicBlock"; break;
        case 34: retval = "b_outputClassTemplateName"; break;
        case 35: retval = "b_outputCompilerGeneratedStatements"; break;
        case 36: retval = "b_SkipConstantFoldedExpressions"; break;
        case 37: retval = "b_forceQualifiedNames"; break;
        case 38: retval = "b_SkipQualifiedNames"; break;
        case 39: retval = "b_skipCheckAccess"; break;
        case 40: retval = "b_requiresGlobalNameQualification"; break;
        case 41: retval = "b_useTypeAttributes"; break;
        case 42: retval = "b_SkipFormatting"; break;
        case 43: retval = "b_outputFortranModFile"; break;
        case 44: retval = "b_supressStrippedTypeName"; break;
        case 45: retval = "b_prefixOperator"; break;
        case 46: retval = "b_supressArrayBound"; break;
        case 47: retval = "b_supressImplicitThisOperator"; break;
        case 48: retval = "b_unparsedPartiallyUsingTokenStream"; break;
        case 49: retval = "b_skipCompilerGeneratedSubExpressions"; break;
        case 50: retval = "b_parentStatementListBeingUnparsedUsingPartialTokenSequence"; break;
        case 51: retval = "UNPARSE_TYPE_LAST"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgUnparse_Info::unparse_type_num)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUnparse_Info::unparse_type_num::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgUntypedType::type_enum is defined at frontend/SageIII/Cxx_Grammar.h:107998
/** Converts an enum of type SgUntypedType::type_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgUntypedType_type_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_void"; break;
        case 2: retval = "e_int"; break;
        case 3: retval = "e_float"; break;
        case 4: retval = "e_double"; break;
        case 5: retval = "e_complex"; break;
        case 6: retval = "e_char"; break;
        case 7: retval = "e_last"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgUntypedType::type_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgUntypedType::type_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SgVariableDeclaration::gnu_extension_declaration_attributes_enum is defined at frontend/SageIII/Cxx_Grammar.h:129720
/** Converts an enum of type SgVariableDeclaration::gnu_extension_declaration_attributes_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySgVariableDeclaration_gnu_extension_declaration_attributes_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_gnu_attribute_unknown"; break;
        case 1: retval = "e_gnu_attribute_unspecified"; break;
        case 2: retval = "e_gnu_attribute__weak__"; break;
        case 3: retval = "e_gnu_attribute__unused__"; break;
        case 4: retval = "e_gnu_attribute__deprecated__"; break;
        case 5: retval = "e_gnu_attribute__nocommon__"; break;
        case 6: retval = "e_gnu_attribute__transparent_union__"; break;
        case 7: retval = "e_last_gnu_declaration_attribute"; break;
    }
    if (retval.empty()) {
        char buf[128];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SgVariableDeclaration::gnu_extension_declaration_attributes_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SgVariableDeclaration::gnu_extension_declaration_attributes_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sg_File_Info::classifier is defined at frontend/SageIII/Cxx_Grammar.h:22030
/** Converts an enum of type Sg_File_Info::classifier to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_classifier(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "e_transformation"; break;
        case 2: retval = "e_compiler_generated"; break;
        case 4: retval = "e_output_in_code_generation"; break;
        case 8: retval = "e_shared"; break;
        case 16: retval = "e_frontend_specific"; break;
        case 32: retval = "e_source_position_unavailable_in_frontend"; break;
        case 64: retval = "e_comment_or_directive"; break;
        case 128: retval = "e_token"; break;
        case 256: retval = "e_default_argument"; break;
        case 512: retval = "e_implicit_cast"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sg_File_Info::classifier)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::classifier::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Sg_File_Info::p_fileflags is defined at frontend/SageIII/Cxx_Grammar.h:22280
/** Converts an enum of type Sg_File_Info::p_fileflags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySg_File_Info_p_fileflags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case -6: retval = "BAD_FILE_ID"; break;
        case -5: retval = "COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID"; break;
        case -4: retval = "COMPILER_GENERATED_FILE_ID"; break;
        case -3: retval = "TRANSFORMATION_FILE_ID"; break;
        case -2: retval = "NULL_FILE_ID"; break;
        case -1: retval = "COPY_FILE_ID"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Sg_File_Info::p_fileflags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Sg_File_Info::p_fileflags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Snippet::InsertMechanism is defined at git_rose_development/src/midend/astSnippet/Snippet.h:319
/** Converts an enum of type Snippet::InsertMechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySnippetInsertMechanism(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INSERT_BODY"; break;
        case 1: retval = "INSERT_STMTS"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Snippet::InsertMechanism)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Snippet::InsertMechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Snippet::LocalDeclarationPosition is defined at git_rose_development/src/midend/astSnippet/Snippet.h:329
/** Converts an enum of type Snippet::LocalDeclarationPosition to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySnippetLocalDeclarationPosition(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LOCDECLS_AT_BEGINNING"; break;
        case 1: retval = "LOCDECLS_AT_END"; break;
        case 2: retval = "LOCDECLS_AT_CURSOR"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Snippet::LocalDeclarationPosition)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Snippet::LocalDeclarationPosition::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// SqlDatabase::Driver is defined at git_rose_development/src/roseSupport/SqlDatabase.h:120
/** Converts an enum of type SqlDatabase::Driver to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifySqlDatabaseDriver(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "NO_DRIVER"; break;
        case 1: retval = "SQLITE3"; break;
        case 2: retval = "POSTGRESQL"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(SqlDatabase::Driver)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "SqlDatabase::Driver::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// StringUtility::FileNameLocation is defined at git_rose_development/src/util/stringSupport/string_functions.h:288
/** Converts an enum of type StringUtility::FileNameLocation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityFileNameLocation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FILENAME_LOCATION_UNKNOWN"; break;
        case 1: retval = "FILENAME_LOCATION_USER"; break;
        case 2: retval = "FILENAME_LOCATION_LIBRARY"; break;
        case 3: retval = "FILENAME_LOCATION_NOT_EXIST"; break;
    }
    if (retval.empty()) {
        char buf[95];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(StringUtility::FileNameLocation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::FileNameLocation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// StringUtility::OSType is defined at git_rose_development/src/util/stringSupport/string_functions.h:270
/** Converts an enum of type StringUtility::OSType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyStringUtilityOSType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "OS_TYPE_UNKNOWN"; break;
        case 1: retval = "OS_TYPE_LINUX"; break;
        case 2: retval = "OS_TYPE_OSX"; break;
        case 3: retval = "OS_TYPE_WINDOWS"; break;
        case 4: retval = "OS_TPYE_WINDOWSXP"; break;
    }
    if (retval.empty()) {
        char buf[85];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(StringUtility::OSType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "StringUtility::OSType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// TaintLattice::Vertex is defined at git_rose_development/src/midend/programAnalysis/genericDataflow/simpleAnalyses/taintAnalysis.h:60
/** Converts an enum of type TaintLattice::Vertex to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTaintLatticeVertex(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "VERTEX_BOTTOM"; break;
        case 1: retval = "VERTEX_UNTAINTED"; break;
        case 2: retval = "VERTEX_TAINTED"; break;
    }
    if (retval.empty()) {
        char buf[84];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(TaintLattice::Vertex)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TaintLattice::Vertex::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Task::State is defined at git_rose_development/src/roseExtensions/qtWidgets/TaskSystem/TaskInterface.h:26
/** Converts an enum of type Task::State to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTaskState(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BEFORE_START"; break;
        case 1: retval = "RUNNING"; break;
        case 2: retval = "FINISHED_SUCCESS"; break;
        case 3: retval = "FINISHED_ERROR"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Task::State)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Task::State::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Terminal::TypeEvaluation is defined at git_rose_development/src/ROSETTA/src/terminal.h:332
/** Converts an enum of type Terminal::TypeEvaluation to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminalTypeEvaluation(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "CHAR_POINTER"; break;
        case 1: retval = "CONST_CHAR_POINTER"; break;
        case 2: retval = "ATTACHEDPREPROCESSINGINFOTYPE"; break;
        case 3: retval = "ROSE_HASH_MULTIMAP"; break;
        case 4: retval = "ROSE_GRAPH_HASH_MULTIMAP"; break;
        case 5: retval = "ROSE_GRAPH_DIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 6: retval = "ROSE_GRAPH_UNDIRECTED_EDGE_HASH_MULTIMAP"; break;
        case 7: retval = "ROSE_GRAPH_NODE_EDGE_HASH_MULTIMAP"; break;
        case 8: retval = "ROSE_GRAPH_INTEGER_NODE_HASH_MAP"; break;
        case 9: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MAP"; break;
        case 10: retval = "ROSE_GRAPH_STRING_INTEGER_HASH_MULTIMAP"; break;
        case 11: retval = "ROSE_GRAPH_INTEGER_PAIR_EDGE_HASH_MULTIMAP"; break;
        case 12: retval = "ROSE_GRAPH_INTEGER_EDGE_HASH_MULTIMAP"; break;
        case 13: retval = "SGCLASS_POINTER"; break;
        case 14: retval = "ROSEATTRUBUTESLISTCONTAINER"; break;
        case 15: retval = "SGCLASS_POINTER_LIST"; break;
        case 16: retval = "SGCLASS_POINTER_VECTOR"; break;
        case 17: retval = "SGCLASS_POINTER_VECTOR_NAMED_LIST"; break;
        case 18: retval = "STL_CONTAINER"; break;
        case 19: retval = "STL_SET"; break;
        case 20: retval = "STL_MULTIMAP"; break;
        case 21: retval = "STL_MAP"; break;
        case 22: retval = "STRING"; break;
        case 23: retval = "SGNAME"; break;
        case 24: retval = "BIT_VECTOR"; break;
        case 25: retval = "MODIFIERCLASS"; break;
        case 26: retval = "MODIFIERCLASS_WITHOUTEASYSTORAGE"; break;
        case 27: retval = "ASTATTRIBUTEMECHANISM"; break;
        case 28: retval = "TO_HANDLE"; break;
        case 29: retval = "OSTREAM"; break;
        case 30: retval = "ENUM_TYPE"; break;
        case 31: retval = "BASIC_DATA_TYPE"; break;
        case 32: retval = "SKIP_TYPE"; break;
        case 33: retval = "SGCLASS_POINTER_LIST_POINTER"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Terminal::TypeEvaluation)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::TypeEvaluation::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Terminal::includeExcludeMechanism is defined at git_rose_development/src/ROSETTA/src/terminal.h:125
/** Converts an enum of type Terminal::includeExcludeMechanism to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminal_includeExcludeMechanism(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "INCLUDE_LIST"; break;
        case 1: retval = "EXCLUDE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[97];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Terminal::includeExcludeMechanism)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::includeExcludeMechanism::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// Terminal::locationInTree is defined at git_rose_development/src/ROSETTA/src/terminal.h:119
/** Converts an enum of type Terminal::locationInTree to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTerminal_locationInTree(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "LOCAL_LIST"; break;
        case 1: retval = "SUBTREE_LIST"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(Terminal::locationInTree)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "Terminal::locationInTree::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// TransformationSupport::operatorCodeType is defined at git_rose_development/src/roseSupport/transformationSupport.h:38
/** Converts an enum of type TransformationSupport::operatorCodeType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyTransformationSupport_operatorCodeType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "FUNCTION_CALL_OPERATOR_CODE"; break;
        case 1: retval = "ADD_OPERATOR_CODE"; break;
        case 2: retval = "SUBT_OPERATOR_CODE"; break;
        case 3: retval = "MULT_OPERATOR_CODE"; break;
        case 4: retval = "DIV_OPERATOR_CODE"; break;
        case 5: retval = "INTEGER_DIV_OPERATOR_CODE"; break;
        case 6: retval = "MOD_OPERATOR_CODE"; break;
        case 7: retval = "AND_OPERATOR_CODE"; break;
        case 8: retval = "OR_OPERATOR_CODE"; break;
        case 9: retval = "BITXOR_OPERATOR_CODE"; break;
        case 10: retval = "BITAND_OPERATOR_CODE"; break;
        case 11: retval = "BITOR_OPERATOR_CODE"; break;
        case 12: retval = "EQ_OPERATOR_CODE"; break;
        case 13: retval = "LT_OPERATOR_CODE"; break;
        case 14: retval = "GT_OPERATOR_CODE"; break;
        case 15: retval = "NE_OPERATOR_CODE"; break;
        case 16: retval = "LE_OPERATOR_CODE"; break;
        case 17: retval = "GE_OPERATOR_CODE"; break;
        case 18: retval = "ASSIGN_OPERATOR_CODE"; break;
        case 19: retval = "PLUS_ASSIGN_OPERATOR_CODE"; break;
        case 20: retval = "MINUS_ASSIGN_OPERATOR_CODE"; break;
        case 21: retval = "AND_ASSIGN_OPERATOR_CODE"; break;
        case 22: retval = "IOR_ASSIGN_OPERATOR_CODE"; break;
        case 23: retval = "MULT_ASSIGN_OPERATOR_CODE"; break;
        case 24: retval = "DIV_ASSIGN_OPERATOR_CODE"; break;
        case 25: retval = "MOD_ASSIGN_OPERATOR_CODE"; break;
        case 26: retval = "XOR_ASSIGN_OPERATOR_CODE"; break;
        case 27: retval = "PARENTHESIS_OPERATOR_CODE"; break;
        case 28: retval = "BRACKET_OPERATOR_CODE"; break;
        case 29: retval = "NOT_OPERATOR_CODE"; break;
        case 30: retval = "DEREFERENCE_OPERATOR_CODE"; break;
        case 31: retval = "ADDRESS_OPERATOR_CODE"; break;
        case 32: retval = "LSHIFT_OPERATOR_CODE"; break;
        case 33: retval = "RSHIFT_OPERATOR_CODE"; break;
        case 34: retval = "LSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 35: retval = "RSHIFT_ASSIGN_OPERATOR_CODE"; break;
        case 36: retval = "PREFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 37: retval = "POSTFIX_PLUSPLUS_OPERATOR_CODE"; break;
        case 38: retval = "PREFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 39: retval = "POSTFIX_MINUSMINUS_OPERATOR_CODE"; break;
        case 99: retval = "OPERATOR_CODE_LAST_TAG"; break;
    }
    if (retval.empty()) {
        char buf[103];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(TransformationSupport::operatorCodeType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "TransformationSupport::operatorCodeType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// UnparseLanguageIndependentConstructs::token_sequence_position_enum_type is defined at git_rose_development/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:41
/** Converts an enum of type UnparseLanguageIndependentConstructs::token_sequence_position_enum_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyUnparseLanguageIndependentConstructs_token_sequence_position_enum_type(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_leading_whitespace_start"; break;
        case 1: retval = "e_leading_whitespace_end"; break;
        case 2: retval = "e_token_subsequence_start"; break;
        case 3: retval = "e_token_subsequence_end"; break;
        case 4: retval = "e_trailing_whitespace_start"; break;
        case 5: retval = "e_trailing_whitespace_end"; break;
        case 6: retval = "e_else_whitespace_start"; break;
        case 7: retval = "e_else_whitespace_end"; break;
    }
    if (retval.empty()) {
        char buf[135];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(UnparseLanguageIndependentConstructs::token_sequence_position_enum_type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "UnparseLanguageIndependentConstructs::token_sequence_position_enum_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// UnparseLanguageIndependentConstructs::unparsed_as_enum_type is defined at git_rose_development/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h:66
/** Converts an enum of type UnparseLanguageIndependentConstructs::unparsed_as_enum_type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyUnparseLanguageIndependentConstructs_unparsed_as_enum_type(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unparsed_as_error"; break;
        case 1: retval = "e_unparsed_as_AST"; break;
        case 2: retval = "e_unparsed_as_partial_token_sequence"; break;
        case 3: retval = "e_unparsed_as_token_stream"; break;
        case 4: retval = "e_unparsed_as_last"; break;
    }
    if (retval.empty()) {
        char buf[123];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(UnparseLanguageIndependentConstructs::unparsed_as_enum_type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "UnparseLanguageIndependentConstructs::unparsed_as_enum_type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VariantT is defined at frontend/SageIII/Cxx_Grammar.h:828
/** Converts an enum of type VariantT to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVariantT(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "V_SgAccessModifier"; break;
        case 2: retval = "V_SgActualArgumentExpression"; break;
        case 3: retval = "V_SgAddOp"; break;
        case 4: retval = "V_SgAddressOfOp"; break;
        case 5: retval = "V_SgAggregateInitializer"; break;
        case 6: retval = "V_SgAliasSymbol"; break;
        case 7: retval = "V_SgAllocateStatement"; break;
        case 8: retval = "V_SgAndAssignOp"; break;
        case 9: retval = "V_SgAndOp"; break;
        case 10: retval = "V_SgArithmeticIfStatement"; break;
        case 11: retval = "V_SgArrayType"; break;
        case 12: retval = "V_SgArrowExp"; break;
        case 13: retval = "V_SgArrowStarOp"; break;
        case 14: retval = "V_SgAsmArmInstruction"; break;
        case 15: retval = "V_SgAsmBasicString"; break;
        case 16: retval = "V_SgAsmBinaryAdd"; break;
        case 17: retval = "V_SgAsmBinaryAddPostupdate"; break;
        case 18: retval = "V_SgAsmBinaryAddPreupdate"; break;
        case 19: retval = "V_SgAsmBinaryAsr"; break;
        case 20: retval = "V_SgAsmBinaryDivide"; break;
        case 21: retval = "V_SgAsmBinaryExpression"; break;
        case 22: retval = "V_SgAsmBinaryLsl"; break;
        case 23: retval = "V_SgAsmBinaryLsr"; break;
        case 24: retval = "V_SgAsmBinaryMod"; break;
        case 25: retval = "V_SgAsmBinaryMultiply"; break;
        case 26: retval = "V_SgAsmBinaryRor"; break;
        case 27: retval = "V_SgAsmBinarySubtract"; break;
        case 28: retval = "V_SgAsmBinarySubtractPostupdate"; break;
        case 29: retval = "V_SgAsmBinarySubtractPreupdate"; break;
        case 30: retval = "V_SgAsmBlock"; break;
        case 31: retval = "V_SgAsmCoffStrtab"; break;
        case 32: retval = "V_SgAsmCoffSymbol"; break;
        case 33: retval = "V_SgAsmCoffSymbolList"; break;
        case 34: retval = "V_SgAsmCoffSymbolTable"; break;
        case 35: retval = "V_SgAsmCommonSubExpression"; break;
        case 36: retval = "V_SgAsmControlFlagsExpression"; break;
        case 37: retval = "V_SgAsmConstantExpression"; break;
        case 38: retval = "V_SgAsmDOSExtendedHeader"; break;
        case 39: retval = "V_SgAsmDOSFileHeader"; break;
        case 40: retval = "V_SgAsmSynthesizedDataStructureDeclaration"; break;
        case 41: retval = "V_SgAsmSynthesizedDeclaration"; break;
        case 42: retval = "V_SgAsmDirectRegisterExpression"; break;
        case 43: retval = "V_SgAsmDwarfAccessDeclaration"; break;
        case 44: retval = "V_SgAsmDwarfArrayType"; break;
        case 45: retval = "V_SgAsmDwarfBaseType"; break;
        case 46: retval = "V_SgAsmDwarfCatchBlock"; break;
        case 47: retval = "V_SgAsmDwarfClassTemplate"; break;
        case 48: retval = "V_SgAsmDwarfClassType"; break;
        case 49: retval = "V_SgAsmDwarfCommonBlock"; break;
        case 50: retval = "V_SgAsmDwarfCommonInclusion"; break;
        case 51: retval = "V_SgAsmDwarfCompilationUnit"; break;
        case 52: retval = "V_SgAsmDwarfCompilationUnitList"; break;
        case 53: retval = "V_SgAsmDwarfCondition"; break;
        case 54: retval = "V_SgAsmDwarfConstType"; break;
        case 55: retval = "V_SgAsmDwarfConstant"; break;
        case 56: retval = "V_SgAsmDwarfConstruct"; break;
        case 57: retval = "V_SgAsmDwarfConstructList"; break;
        case 58: retval = "V_SgAsmDwarfDwarfProcedure"; break;
        case 59: retval = "V_SgAsmDwarfEntryPoint"; break;
        case 60: retval = "V_SgAsmDwarfEnumerationType"; break;
        case 61: retval = "V_SgAsmDwarfEnumerator"; break;
        case 62: retval = "V_SgAsmDwarfFileType"; break;
        case 63: retval = "V_SgAsmDwarfFormalParameter"; break;
        case 64: retval = "V_SgAsmDwarfFormatLabel"; break;
        case 65: retval = "V_SgAsmDwarfFriend"; break;
        case 66: retval = "V_SgAsmDwarfFunctionTemplate"; break;
        case 67: retval = "V_SgAsmDwarfImportedDeclaration"; break;
        case 68: retval = "V_SgAsmDwarfImportedModule"; break;
        case 69: retval = "V_SgAsmDwarfImportedUnit"; break;
        case 70: retval = "V_SgAsmDwarfInformation"; break;
        case 71: retval = "V_SgAsmDwarfInheritance"; break;
        case 72: retval = "V_SgAsmDwarfInlinedSubroutine"; break;
        case 73: retval = "V_SgAsmDwarfInterfaceType"; break;
        case 74: retval = "V_SgAsmDwarfLabel"; break;
        case 75: retval = "V_SgAsmDwarfLexicalBlock"; break;
        case 76: retval = "V_SgAsmDwarfLine"; break;
        case 77: retval = "V_SgAsmDwarfLineList"; break;
        case 78: retval = "V_SgAsmDwarfMacro"; break;
        case 79: retval = "V_SgAsmDwarfMacroList"; break;
        case 80: retval = "V_SgAsmDwarfMember"; break;
        case 81: retval = "V_SgAsmDwarfModule"; break;
        case 82: retval = "V_SgAsmDwarfMutableType"; break;
        case 83: retval = "V_SgAsmDwarfNamelist"; break;
        case 84: retval = "V_SgAsmDwarfNamelistItem"; break;
        case 85: retval = "V_SgAsmDwarfNamespace"; break;
        case 86: retval = "V_SgAsmDwarfPackedType"; break;
        case 87: retval = "V_SgAsmDwarfPartialUnit"; break;
        case 88: retval = "V_SgAsmDwarfPointerType"; break;
        case 89: retval = "V_SgAsmDwarfPtrToMemberType"; break;
        case 90: retval = "V_SgAsmDwarfReferenceType"; break;
        case 91: retval = "V_SgAsmDwarfRestrictType"; break;
        case 92: retval = "V_SgAsmDwarfSetType"; break;
        case 93: retval = "V_SgAsmDwarfSharedType"; break;
        case 94: retval = "V_SgAsmDwarfStringType"; break;
        case 95: retval = "V_SgAsmDwarfStructureType"; break;
        case 96: retval = "V_SgAsmDwarfSubprogram"; break;
        case 97: retval = "V_SgAsmDwarfSubrangeType"; break;
        case 98: retval = "V_SgAsmDwarfSubroutineType"; break;
        case 99: retval = "V_SgAsmDwarfTemplateTypeParameter"; break;
        case 100: retval = "V_SgAsmDwarfTemplateValueParameter"; break;
        case 101: retval = "V_SgAsmDwarfThrownType"; break;
        case 102: retval = "V_SgAsmDwarfTryBlock"; break;
        case 103: retval = "V_SgAsmDwarfTypedef"; break;
        case 104: retval = "V_SgAsmDwarfUnionType"; break;
        case 105: retval = "V_SgAsmDwarfUnknownConstruct"; break;
        case 106: retval = "V_SgAsmDwarfUnspecifiedParameters"; break;
        case 107: retval = "V_SgAsmDwarfUnspecifiedType"; break;
        case 108: retval = "V_SgAsmDwarfUpcRelaxedType"; break;
        case 109: retval = "V_SgAsmDwarfUpcSharedType"; break;
        case 110: retval = "V_SgAsmDwarfUpcStrictType"; break;
        case 111: retval = "V_SgAsmDwarfVariable"; break;
        case 112: retval = "V_SgAsmDwarfVariant"; break;
        case 113: retval = "V_SgAsmDwarfVariantPart"; break;
        case 114: retval = "V_SgAsmDwarfVolatileType"; break;
        case 115: retval = "V_SgAsmDwarfWithStmt"; break;
        case 116: retval = "V_SgAsmElfDynamicEntry"; break;
        case 117: retval = "V_SgAsmElfDynamicEntryList"; break;
        case 118: retval = "V_SgAsmElfDynamicSection"; break;
        case 119: retval = "V_SgAsmElfEHFrameEntryCI"; break;
        case 120: retval = "V_SgAsmElfEHFrameEntryCIList"; break;
        case 121: retval = "V_SgAsmElfEHFrameEntryFD"; break;
        case 122: retval = "V_SgAsmElfEHFrameEntryFDList"; break;
        case 123: retval = "V_SgAsmElfEHFrameSection"; break;
        case 124: retval = "V_SgAsmElfFileHeader"; break;
        case 125: retval = "V_SgAsmElfNoteEntry"; break;
        case 126: retval = "V_SgAsmElfNoteEntryList"; break;
        case 127: retval = "V_SgAsmElfNoteSection"; break;
        case 128: retval = "V_SgAsmElfRelocEntry"; break;
        case 129: retval = "V_SgAsmElfRelocEntryList"; break;
        case 130: retval = "V_SgAsmElfRelocSection"; break;
        case 131: retval = "V_SgAsmElfSection"; break;
        case 132: retval = "V_SgAsmElfSectionTable"; break;
        case 133: retval = "V_SgAsmElfSectionTableEntry"; break;
        case 134: retval = "V_SgAsmElfSegmentTable"; break;
        case 135: retval = "V_SgAsmElfSegmentTableEntry"; break;
        case 136: retval = "V_SgAsmElfSegmentTableEntryList"; break;
        case 137: retval = "V_SgAsmElfStringSection"; break;
        case 138: retval = "V_SgAsmElfStrtab"; break;
        case 139: retval = "V_SgAsmElfSymbol"; break;
        case 140: retval = "V_SgAsmElfSymbolList"; break;
        case 141: retval = "V_SgAsmElfSymbolSection"; break;
        case 142: retval = "V_SgAsmElfSymverDefinedAux"; break;
        case 143: retval = "V_SgAsmElfSymverDefinedAuxList"; break;
        case 144: retval = "V_SgAsmElfSymverDefinedEntry"; break;
        case 145: retval = "V_SgAsmElfSymverDefinedEntryList"; break;
        case 146: retval = "V_SgAsmElfSymverDefinedSection"; break;
        case 147: retval = "V_SgAsmElfSymverEntry"; break;
        case 148: retval = "V_SgAsmElfSymverEntryList"; break;
        case 149: retval = "V_SgAsmElfSymverNeededAux"; break;
        case 150: retval = "V_SgAsmElfSymverNeededAuxList"; break;
        case 151: retval = "V_SgAsmElfSymverNeededEntry"; break;
        case 152: retval = "V_SgAsmElfSymverNeededEntryList"; break;
        case 153: retval = "V_SgAsmElfSymverNeededSection"; break;
        case 154: retval = "V_SgAsmElfSymverSection"; break;
        case 155: retval = "V_SgAsmExecutableFileFormat"; break;
        case 156: retval = "V_SgAsmExprListExp"; break;
        case 157: retval = "V_SgAsmExpression"; break;
        case 158: retval = "V_SgAsmSynthesizedFieldDeclaration"; break;
        case 159: retval = "V_SgAsmFloatType"; break;
        case 160: retval = "V_SgAsmFloatValueExpression"; break;
        case 161: retval = "V_SgAsmFunction"; break;
        case 163: retval = "V_SgAsmGenericDLL"; break;
        case 164: retval = "V_SgAsmGenericDLLList"; break;
        case 165: retval = "V_SgAsmGenericFile"; break;
        case 166: retval = "V_SgAsmGenericFileList"; break;
        case 167: retval = "V_SgAsmGenericFormat"; break;
        case 168: retval = "V_SgAsmGenericHeader"; break;
        case 169: retval = "V_SgAsmGenericHeaderList"; break;
        case 170: retval = "V_SgAsmGenericSection"; break;
        case 171: retval = "V_SgAsmGenericSectionList"; break;
        case 172: retval = "V_SgAsmGenericString"; break;
        case 173: retval = "V_SgAsmGenericStrtab"; break;
        case 174: retval = "V_SgAsmGenericSymbol"; break;
        case 175: retval = "V_SgAsmGenericSymbolList"; break;
        case 176: retval = "V_SgAsmIndirectRegisterExpression"; break;
        case 177: retval = "V_SgAsmInstruction"; break;
        case 178: retval = "V_SgAsmIntegerValueExpression"; break;
        case 179: retval = "V_SgAsmIntegerType"; break;
        case 180: retval = "V_SgAsmInterpretation"; break;
        case 181: retval = "V_SgAsmInterpretationList"; break;
        case 182: retval = "V_SgAsmLEEntryPoint"; break;
        case 183: retval = "V_SgAsmLEEntryTable"; break;
        case 184: retval = "V_SgAsmLEFileHeader"; break;
        case 185: retval = "V_SgAsmLENameTable"; break;
        case 186: retval = "V_SgAsmLEPageTable"; break;
        case 187: retval = "V_SgAsmLEPageTableEntry"; break;
        case 188: retval = "V_SgAsmLERelocTable"; break;
        case 189: retval = "V_SgAsmLESection"; break;
        case 190: retval = "V_SgAsmLESectionTable"; break;
        case 191: retval = "V_SgAsmLESectionTableEntry"; break;
        case 192: retval = "V_SgAsmM68kInstruction"; break;
        case 194: retval = "V_SgAsmMemoryReferenceExpression"; break;
        case 195: retval = "V_SgAsmMipsInstruction"; break;
        case 196: retval = "V_SgAsmNEEntryPoint"; break;
        case 197: retval = "V_SgAsmNEEntryTable"; break;
        case 198: retval = "V_SgAsmNEFileHeader"; break;
        case 199: retval = "V_SgAsmNEModuleTable"; break;
        case 200: retval = "V_SgAsmNENameTable"; break;
        case 202: retval = "V_SgAsmNERelocEntry"; break;
        case 203: retval = "V_SgAsmNERelocTable"; break;
        case 204: retval = "V_SgAsmNESection"; break;
        case 205: retval = "V_SgAsmNESectionTable"; break;
        case 206: retval = "V_SgAsmNESectionTableEntry"; break;
        case 207: retval = "V_SgAsmNEStringTable"; break;
        case 208: retval = "V_SgAsmNode"; break;
        case 209: retval = "V_SgAsmOp"; break;
        case 210: retval = "V_SgAsmOperandList"; break;
        case 211: retval = "V_SgAsmPEExportDirectory"; break;
        case 212: retval = "V_SgAsmPEExportEntry"; break;
        case 213: retval = "V_SgAsmPEExportEntryList"; break;
        case 214: retval = "V_SgAsmPEExportSection"; break;
        case 215: retval = "V_SgAsmPEFileHeader"; break;
        case 216: retval = "V_SgAsmPEImportDirectory"; break;
        case 217: retval = "V_SgAsmPEImportDirectoryList"; break;
        case 218: retval = "V_SgAsmPEImportItem"; break;
        case 219: retval = "V_SgAsmPEImportItemList"; break;
        case 220: retval = "V_SgAsmPEImportSection"; break;
        case 221: retval = "V_SgAsmPERVASizePair"; break;
        case 222: retval = "V_SgAsmPERVASizePairList"; break;
        case 223: retval = "V_SgAsmPESection"; break;
        case 224: retval = "V_SgAsmPESectionTable"; break;
        case 225: retval = "V_SgAsmPESectionTableEntry"; break;
        case 226: retval = "V_SgAsmPEStringSection"; break;
        case 227: retval = "V_SgAsmPowerpcInstruction"; break;
        case 230: retval = "V_SgAsmRegisterNames"; break;
        case 231: retval = "V_SgAsmRegisterReferenceExpression"; break;
        case 232: retval = "V_SgAsmRiscOperation"; break;
        case 233: retval = "V_SgAsmScalarType"; break;
        case 236: retval = "V_SgAsmStatement"; break;
        case 237: retval = "V_SgAsmStaticData"; break;
        case 238: retval = "V_SgAsmStmt"; break;
        case 239: retval = "V_SgAsmStoredString"; break;
        case 240: retval = "V_SgAsmStringStorage"; break;
        case 241: retval = "V_SgAsmType"; break;
        case 242: retval = "V_SgAsmUnaryArmSpecialRegisterList"; break;
        case 243: retval = "V_SgAsmUnaryExpression"; break;
        case 244: retval = "V_SgAsmUnaryMinus"; break;
        case 245: retval = "V_SgAsmUnaryPlus"; break;
        case 246: retval = "V_SgAsmUnaryRrx"; break;
        case 247: retval = "V_SgAsmValueExpression"; break;
        case 248: retval = "V_SgAsmVectorType"; break;
        case 249: retval = "V_SgAsmX86Instruction"; break;
        case 250: retval = "V_SgAsmBinaryAddressSymbol"; break;
        case 251: retval = "V_SgAsmBinaryDataSymbol"; break;
        case 252: retval = "V_SgAssertStmt"; break;
        case 253: retval = "V_SgAssignInitializer"; break;
        case 254: retval = "V_SgAssignOp"; break;
        case 255: retval = "V_SgAssignStatement"; break;
        case 256: retval = "V_SgAssignedGotoStatement"; break;
        case 257: retval = "V_SgAssociateStatement"; break;
        case 258: retval = "V_SgAsteriskShapeExp"; break;
        case 259: retval = "V_SgAterm"; break;
        case 260: retval = "V_SgAttribute"; break;
        case 261: retval = "V_SgAttributeSpecificationStatement"; break;
        case 262: retval = "V_SgBackspaceStatement"; break;
        case 263: retval = "V_SgBaseClass"; break;
        case 264: retval = "V_SgExpBaseClass"; break;
        case 265: retval = "V_SgBaseClassModifier"; break;
        case 266: retval = "V_SgBasicBlock"; break;
        case 267: retval = "V_SgBidirectionalGraph"; break;
        case 268: retval = "V_SgBinaryComposite"; break;
        case 269: retval = "V_SgBinaryOp"; break;
        case 270: retval = "V_SgBitAndOp"; break;
        case 271: retval = "V_SgBitAttribute"; break;
        case 272: retval = "V_SgBitComplementOp"; break;
        case 273: retval = "V_SgBitOrOp"; break;
        case 274: retval = "V_SgBitXorOp"; break;
        case 275: retval = "V_SgBlockDataStatement"; break;
        case 276: retval = "V_SgBoolValExp"; break;
        case 277: retval = "V_SgBreakStmt"; break;
        case 278: retval = "V_SgC_PreprocessorDirectiveStatement"; break;
        case 279: retval = "V_SgCaseOptionStmt"; break;
        case 280: retval = "V_SgCastExp"; break;
        case 281: retval = "V_SgCatchOptionStmt"; break;
        case 282: retval = "V_SgCatchStatementSeq"; break;
        case 283: retval = "V_SgCharVal"; break;
        case 284: retval = "V_SgClassDecl_attr"; break;
        case 285: retval = "V_SgClassDeclaration"; break;
        case 286: retval = "V_SgClassDefinition"; break;
        case 287: retval = "V_SgClassNameRefExp"; break;
        case 288: retval = "V_SgClassSymbol"; break;
        case 289: retval = "V_SgClassType"; break;
        case 290: retval = "V_SgClinkageDeclarationStatement"; break;
        case 291: retval = "V_SgClinkageEndStatement"; break;
        case 292: retval = "V_SgClinkageStartStatement"; break;
        case 293: retval = "V_SgCloseStatement"; break;
        case 294: retval = "V_SgColonShapeExp"; break;
        case 295: retval = "V_SgCommaOpExp"; break;
        case 296: retval = "V_SgCommonBlock"; break;
        case 297: retval = "V_SgCommonBlockObject"; break;
        case 298: retval = "V_SgCommonSymbol"; break;
        case 299: retval = "V_SgComplexVal"; break;
        case 300: retval = "V_SgComprehension"; break;
        case 302: retval = "V_SgCompoundAssignOp"; break;
        case 303: retval = "V_SgCompoundInitializer"; break;
        case 304: retval = "V_SgCompoundLiteralExp"; break;
        case 305: retval = "V_SgComputedGotoStatement"; break;
        case 306: retval = "V_SgConcatenationOp"; break;
        case 307: retval = "V_SgConditionalExp"; break;
        case 308: retval = "V_SgConjugateOp"; break;
        case 309: retval = "V_SgConstVolatileModifier"; break;
        case 310: retval = "V_SgConstructorInitializer"; break;
        case 311: retval = "V_SgContainsStatement"; break;
        case 312: retval = "V_SgContinueStmt"; break;
        case 313: retval = "V_SgCtorInitializerList"; break;
        case 314: retval = "V_SgDataStatementGroup"; break;
        case 315: retval = "V_SgDataStatementObject"; break;
        case 316: retval = "V_SgDataStatementValue"; break;
        case 317: retval = "V_SgDeadIfDirectiveStatement"; break;
        case 318: retval = "V_SgDeallocateStatement"; break;
        case 319: retval = "V_SgDeclarationModifier"; break;
        case 320: retval = "V_SgDeclarationStatement"; break;
        case 321: retval = "V_SgDeclType"; break;
        case 322: retval = "V_SgDefaultOptionStmt"; break;
        case 323: retval = "V_SgDefaultSymbol"; break;
        case 324: retval = "V_SgDefineDirectiveStatement"; break;
        case 325: retval = "V_SgDeleteExp"; break;
        case 326: retval = "V_SgDerivedTypeStatement"; break;
        case 327: retval = "V_SgDesignatedInitializer"; break;
        case 328: retval = "V_SgDictionaryComprehension"; break;
        case 329: retval = "V_SgDictionaryExp"; break;
        case 330: retval = "V_SgDimensionObject"; break;
        case 332: retval = "V_SgDirectedGraphEdge"; break;
        case 334: retval = "V_SgDirectory"; break;
        case 335: retval = "V_SgDirectoryList"; break;
        case 336: retval = "V_SgDivAssignOp"; break;
        case 337: retval = "V_SgDivideOp"; break;
        case 338: retval = "V_SgDoWhileStmt"; break;
        case 339: retval = "V_SgDotExp"; break;
        case 340: retval = "V_SgDotStarOp"; break;
        case 341: retval = "V_SgDoubleVal"; break;
        case 342: retval = "V_SgElaboratedTypeModifier"; break;
        case 343: retval = "V_SgElementwiseOp"; break;
        case 344: retval = "V_SgElementwiseAddOp"; break;
        case 345: retval = "V_SgElementwiseDivideOp"; break;
        case 346: retval = "V_SgElementwiseLeftDivideOp"; break;
        case 347: retval = "V_SgElementwiseMultiplyOp"; break;
        case 348: retval = "V_SgElementwisePowerOp"; break;
        case 349: retval = "V_SgElementwiseSubtractOp"; break;
        case 350: retval = "V_SgElseDirectiveStatement"; break;
        case 351: retval = "V_SgElseWhereStatement"; break;
        case 352: retval = "V_SgElseifDirectiveStatement"; break;
        case 353: retval = "V_SgEmptyDirectiveStatement"; break;
        case 354: retval = "V_SgEndfileStatement"; break;
        case 355: retval = "V_SgEndifDirectiveStatement"; break;
        case 356: retval = "V_SgEntryStatement"; break;
        case 357: retval = "V_SgEnumDeclaration"; break;
        case 358: retval = "V_SgEnumFieldSymbol"; break;
        case 359: retval = "V_SgEnumSymbol"; break;
        case 360: retval = "V_SgEnumType"; break;
        case 361: retval = "V_SgEnumVal"; break;
        case 362: retval = "V_SgEqualityOp"; break;
        case 363: retval = "V_SgEquivalenceStatement"; break;
        case 364: retval = "V_SgErrorDirectiveStatement"; break;
        case 365: retval = "V_SgExecStatement"; break;
        case 366: retval = "V_SgExponentiationOp"; break;
        case 367: retval = "V_SgExponentiationAssignOp"; break;
        case 368: retval = "V_SgExprListExp"; break;
        case 369: retval = "V_SgExprStatement"; break;
        case 370: retval = "V_SgExpression"; break;
        case 371: retval = "V_SgExpressionRoot"; break;
        case 372: retval = "V_SgFile"; break;
        case 373: retval = "V_SgFileList"; break;
        case 374: retval = "V_SgFloatVal"; break;
        case 375: retval = "V_SgFlushStatement"; break;
        case 376: retval = "V_SgForAllStatement"; break;
        case 377: retval = "V_SgForInitStatement"; break;
        case 378: retval = "V_SgForStatement"; break;
        case 379: retval = "V_SgFormatItem"; break;
        case 380: retval = "V_SgFormatItemList"; break;
        case 381: retval = "V_SgFormatStatement"; break;
        case 382: retval = "V_SgFortranDo"; break;
        case 383: retval = "V_SgFortranIncludeLine"; break;
        case 384: retval = "V_SgFortranNonblockedDo"; break;
        case 385: retval = "V_SgFuncDecl_attr"; break;
        case 386: retval = "V_SgFunctionCallExp"; break;
        case 387: retval = "V_SgFunctionDeclaration"; break;
        case 388: retval = "V_SgFunctionDefinition"; break;
        case 389: retval = "V_SgFunctionModifier"; break;
        case 390: retval = "V_SgFunctionParameterList"; break;
        case 391: retval = "V_SgFunctionParameterRefExp"; break;
        case 392: retval = "V_SgFunctionParameterTypeList"; break;
        case 393: retval = "V_SgFunctionRefExp"; break;
        case 394: retval = "V_SgFunctionSymbol"; break;
        case 395: retval = "V_SgFunctionType"; break;
        case 396: retval = "V_SgFunctionTypeSymbol"; break;
        case 397: retval = "V_SgFunctionTypeTable"; break;
        case 398: retval = "V_SgTypeTable"; break;
        case 399: retval = "V_SgGlobal"; break;
        case 400: retval = "V_SgGotoStatement"; break;
        case 401: retval = "V_SgGraph"; break;
        case 402: retval = "V_SgGraphEdge"; break;
        case 403: retval = "V_SgGraphEdgeList"; break;
        case 404: retval = "V_SgGraphNode"; break;
        case 405: retval = "V_SgGraphNodeList"; break;
        case 406: retval = "V_SgGreaterOrEqualOp"; break;
        case 407: retval = "V_SgGreaterThanOp"; break;
        case 408: retval = "V_SgIOItemExpression"; break;
        case 409: retval = "V_SgIOStatement"; break;
        case 410: retval = "V_SgIdentDirectiveStatement"; break;
        case 411: retval = "V_SgIfDirectiveStatement"; break;
        case 412: retval = "V_SgIfStmt"; break;
        case 413: retval = "V_SgIfdefDirectiveStatement"; break;
        case 414: retval = "V_SgIfndefDirectiveStatement"; break;
        case 415: retval = "V_SgImagPartOp"; break;
        case 416: retval = "V_SgImplicitStatement"; break;
        case 417: retval = "V_SgImpliedDo"; break;
        case 418: retval = "V_SgImportStatement"; break;
        case 419: retval = "V_SgIncidenceDirectedGraph"; break;
        case 420: retval = "V_SgIncidenceUndirectedGraph"; break;
        case 421: retval = "V_SgIncludeDirectiveStatement"; break;
        case 422: retval = "V_SgIncludeNextDirectiveStatement"; break;
        case 423: retval = "V_SgInitializedName"; break;
        case 424: retval = "V_SgInitializer"; break;
        case 425: retval = "V_SgInquireStatement"; break;
        case 426: retval = "V_SgIntKeyedBidirectionalGraph"; break;
        case 427: retval = "V_SgIntVal"; break;
        case 428: retval = "V_SgIntegerDivideOp"; break;
        case 429: retval = "V_SgIntegerDivideAssignOp"; break;
        case 430: retval = "V_SgInterfaceBody"; break;
        case 431: retval = "V_SgHeaderFileBody"; break;
        case 432: retval = "V_SgInterfaceStatement"; break;
        case 433: retval = "V_SgInterfaceSymbol"; break;
        case 434: retval = "V_SgIntrinsicSymbol"; break;
        case 435: retval = "V_SgIsOp"; break;
        case 436: retval = "V_SgIsNotOp"; break;
        case 437: retval = "V_SgIorAssignOp"; break;
        case 438: retval = "V_SgKeyDatumPair"; break;
        case 439: retval = "V_SgCudaKernelExecConfig"; break;
        case 440: retval = "V_SgCudaKernelCallExp"; break;
        case 441: retval = "V_SgLabelRefExp"; break;
        case 442: retval = "V_SgLabelStatement"; break;
        case 443: retval = "V_SgJavaLabelStatement"; break;
        case 444: retval = "V_SgLabelSymbol"; break;
        case 445: retval = "V_SgJavaLabelSymbol"; break;
        case 446: retval = "V_SgLambdaCapture"; break;
        case 447: retval = "V_SgLambdaCaptureList"; break;
        case 448: retval = "V_SgLambdaExp"; break;
        case 449: retval = "V_SgLambdaRefExp"; break;
        case 450: retval = "V_SgLeftDivideOp"; break;
        case 451: retval = "V_SgLessOrEqualOp"; break;
        case 452: retval = "V_SgLessThanOp"; break;
        case 453: retval = "V_SgLineDirectiveStatement"; break;
        case 454: retval = "V_SgLinemarkerDirectiveStatement"; break;
        case 455: retval = "V_SgLinkageModifier"; break;
        case 456: retval = "V_SgListComprehension"; break;
        case 457: retval = "V_SgListExp"; break;
        case 458: retval = "V_SgLocatedNode"; break;
        case 459: retval = "V_SgLocatedNodeSupport"; break;
        case 460: retval = "V_SgLongDoubleVal"; break;
        case 461: retval = "V_SgLongIntVal"; break;
        case 462: retval = "V_SgLongLongIntVal"; break;
        case 463: retval = "V_SgLshiftAssignOp"; break;
        case 464: retval = "V_SgLshiftOp"; break;
        case 465: retval = "V_SgMagicColonExp"; break;
        case 466: retval = "V_SgMatrixExp"; break;
        case 467: retval = "V_SgMatrixTransposeOp"; break;
        case 468: retval = "V_SgMatlabForStatement"; break;
        case 469: retval = "V_SgMemberFunctionDeclaration"; break;
        case 470: retval = "V_SgMemberFunctionRefExp"; break;
        case 471: retval = "V_SgMemberFunctionSymbol"; break;
        case 472: retval = "V_SgMemberFunctionType"; break;
        case 473: retval = "V_SgMembershipOp"; break;
        case 474: retval = "V_SgMicrosoftAttributeDeclaration"; break;
        case 475: retval = "V_SgMinusAssignOp"; break;
        case 476: retval = "V_SgMinusMinusOp"; break;
        case 477: retval = "V_SgMinusOp"; break;
        case 478: retval = "V_SgModAssignOp"; break;
        case 479: retval = "V_SgModOp"; break;
        case 480: retval = "V_SgModifier"; break;
        case 481: retval = "V_SgModifierNodes"; break;
        case 482: retval = "V_SgModifierType"; break;
        case 483: retval = "V_SgModuleStatement"; break;
        case 484: retval = "V_SgModuleSymbol"; break;
        case 485: retval = "V_SgMultAssignOp"; break;
        case 486: retval = "V_SgMultiplyOp"; break;
        case 487: retval = "V_SgName"; break;
        case 488: retval = "V_SgNameGroup"; break;
        case 489: retval = "V_SgNamedType"; break;
        case 490: retval = "V_SgNamelistStatement"; break;
        case 491: retval = "V_SgNamespaceAliasDeclarationStatement"; break;
        case 492: retval = "V_SgNamespaceDeclarationStatement"; break;
        case 493: retval = "V_SgNamespaceDefinitionStatement"; break;
        case 494: retval = "V_SgNamespaceSymbol"; break;
        case 495: retval = "V_SgNaryOp"; break;
        case 496: retval = "V_SgNaryBooleanOp"; break;
        case 497: retval = "V_SgNaryComparisonOp"; break;
        case 498: retval = "V_SgNewExp"; break;
        case 499: retval = "V_SgNode"; break;
        case 500: retval = "V_SgNoexceptOp"; break;
        case 501: retval = "V_SgNotEqualOp"; break;
        case 502: retval = "V_SgNotOp"; break;
        case 503: retval = "V_SgNonMembershipOp"; break;
        case 504: retval = "V_SgNullExpression"; break;
        case 505: retval = "V_SgNullptrValExp"; break;
        case 506: retval = "V_SgNullStatement"; break;
        case 507: retval = "V_SgNullifyStatement"; break;
        case 508: retval = "V_SgOmpAtomicStatement"; break;
        case 509: retval = "V_SgOmpBarrierStatement"; break;
        case 510: retval = "V_SgOmpCriticalStatement"; break;
        case 511: retval = "V_SgOmpClauseBodyStatement"; break;
        case 512: retval = "V_SgOmpBodyStatement"; break;
        case 513: retval = "V_SgOmpDoStatement"; break;
        case 514: retval = "V_SgOmpFlushStatement"; break;
        case 515: retval = "V_SgOmpForStatement"; break;
        case 516: retval = "V_SgOmpMasterStatement"; break;
        case 517: retval = "V_SgOmpOrderedStatement"; break;
        case 518: retval = "V_SgOmpParallelStatement"; break;
        case 519: retval = "V_SgOmpSectionStatement"; break;
        case 520: retval = "V_SgOmpSectionsStatement"; break;
        case 521: retval = "V_SgOmpSingleStatement"; break;
        case 522: retval = "V_SgOmpTaskStatement"; break;
        case 523: retval = "V_SgOmpTaskwaitStatement"; break;
        case 524: retval = "V_SgOmpThreadprivateStatement"; break;
        case 525: retval = "V_SgOmpWorkshareStatement"; break;
        case 526: retval = "V_SgOmpTargetStatement"; break;
        case 527: retval = "V_SgOmpTargetDataStatement"; break;
        case 528: retval = "V_SgOmpSimdStatement"; break;
        case 529: retval = "V_SgOmpClause"; break;
        case 530: retval = "V_SgOmpBeginClause"; break;
        case 531: retval = "V_SgOmpCollapseClause"; break;
        case 532: retval = "V_SgOmpCopyinClause"; break;
        case 533: retval = "V_SgOmpCopyprivateClause"; break;
        case 534: retval = "V_SgOmpDefaultClause"; break;
        case 535: retval = "V_SgOmpEndClause"; break;
        case 536: retval = "V_SgOmpExpressionClause"; break;
        case 537: retval = "V_SgOmpFirstprivateClause"; break;
        case 538: retval = "V_SgOmpIfClause"; break;
        case 539: retval = "V_SgOmpDeviceClause"; break;
        case 540: retval = "V_SgOmpLastprivateClause"; break;
        case 541: retval = "V_SgOmpNowaitClause"; break;
        case 542: retval = "V_SgOmpNumThreadsClause"; break;
        case 543: retval = "V_SgOmpOrderedClause"; break;
        case 544: retval = "V_SgOmpPrivateClause"; break;
        case 545: retval = "V_SgOmpReductionClause"; break;
        case 546: retval = "V_SgOmpScheduleClause"; break;
        case 547: retval = "V_SgOmpSharedClause"; break;
        case 548: retval = "V_SgOmpUntiedClause"; break;
        case 549: retval = "V_SgOmpVariablesClause"; break;
        case 550: retval = "V_SgOmpMapClause"; break;
        case 551: retval = "V_SgOmpSafelenClause"; break;
        case 552: retval = "V_SgOmpLinearClause"; break;
        case 553: retval = "V_SgOmpUniformClause"; break;
        case 554: retval = "V_SgOmpAlignedClause"; break;
        case 555: retval = "V_SgOpenclAccessModeModifier"; break;
        case 556: retval = "V_SgOpenStatement"; break;
        case 557: retval = "V_SgOptions"; break;
        case 558: retval = "V_SgOrOp"; break;
        case 559: retval = "V_SgParameterStatement"; break;
        case 560: retval = "V_SgPartialFunctionModifierType"; break;
        case 561: retval = "V_SgPartialFunctionType"; break;
        case 562: retval = "V_SgPassStatement"; break;
        case 563: retval = "V_SgPlusAssignOp"; break;
        case 564: retval = "V_SgPlusPlusOp"; break;
        case 565: retval = "V_SgPntrArrRefExp"; break;
        case 566: retval = "V_SgPointerAssignOp"; break;
        case 567: retval = "V_SgPointerDerefExp"; break;
        case 568: retval = "V_SgPointerMemberType"; break;
        case 569: retval = "V_SgPointerType"; break;
        case 570: retval = "V_SgPowerOp"; break;
        case 571: retval = "V_SgPragma"; break;
        case 572: retval = "V_SgPragmaDeclaration"; break;
        case 573: retval = "V_SgPrintStatement"; break;
        case 574: retval = "V_SgProcedureHeaderStatement"; break;
        case 575: retval = "V_SgProgramHeaderStatement"; break;
        case 576: retval = "V_SgProject"; break;
        case 577: retval = "V_SgPseudoDestructorRefExp"; break;
        case 578: retval = "V_SgPythonGlobalStmt"; break;
        case 579: retval = "V_SgPythonPrintStmt"; break;
        case 580: retval = "V_SgQualifiedName"; break;
        case 581: retval = "V_SgQualifiedNameType"; break;
        case 582: retval = "V_SgRangeExp"; break;
        case 583: retval = "V_SgReadStatement"; break;
        case 584: retval = "V_SgRealPartOp"; break;
        case 585: retval = "V_SgRefExp"; break;
        case 586: retval = "V_SgReferenceType"; break;
        case 587: retval = "V_SgRenamePair"; break;
        case 588: retval = "V_SgRenameSymbol"; break;
        case 589: retval = "V_SgReturnStmt"; break;
        case 590: retval = "V_SgRewindStatement"; break;
        case 591: retval = "V_SgRshiftAssignOp"; break;
        case 592: retval = "V_SgRshiftOp"; break;
        case 593: retval = "V_SgRvalueReferenceType"; break;
        case 594: retval = "V_SgJavaUnsignedRshiftAssignOp"; break;
        case 595: retval = "V_SgJavaUnsignedRshiftOp"; break;
        case 596: retval = "V_SgScopeOp"; break;
        case 597: retval = "V_SgScopeStatement"; break;
        case 598: retval = "V_SgSequenceStatement"; break;
        case 599: retval = "V_SgSetComprehension"; break;
        case 600: retval = "V_SgShortVal"; break;
        case 601: retval = "V_SgSizeOfOp"; break;
        case 602: retval = "V_SgAlignOfOp"; break;
        case 603: retval = "V_SgJavaInstanceOfOp"; break;
        case 604: retval = "V_SgSourceFile"; break;
        case 605: retval = "V_SgSpawnStmt"; break;
        case 606: retval = "V_SgJavaThrowStatement"; break;
        case 607: retval = "V_SgJavaForEachStatement"; break;
        case 608: retval = "V_SgJavaSynchronizedStatement"; break;
        case 609: retval = "V_SgJavaParameterizedType"; break;
        case 610: retval = "V_SgJavaWildcardType"; break;
        case 611: retval = "V_SgSpecialFunctionModifier"; break;
        case 612: retval = "V_SgStatement"; break;
        case 613: retval = "V_SgStaticAssertionDeclaration"; break;
        case 614: retval = "V_SgStmtDeclarationStatement"; break;
        case 615: retval = "V_SgStatementExpression"; break;
        case 616: retval = "V_SgStatementFunctionStatement"; break;
        case 617: retval = "V_SgStopOrPauseStatement"; break;
        case 618: retval = "V_SgStorageModifier"; break;
        case 619: retval = "V_SgStringConversion"; break;
        case 620: retval = "V_SgStringKeyedBidirectionalGraph"; break;
        case 621: retval = "V_SgStringVal"; break;
        case 622: retval = "V_SgSubscriptExpression"; break;
        case 623: retval = "V_SgSubtractOp"; break;
        case 624: retval = "V_SgSupport"; break;
        case 625: retval = "V_SgSwitchStatement"; break;
        case 626: retval = "V_SgSymbol"; break;
        case 627: retval = "V_SgSymbolTable"; break;
        case 628: retval = "V_SgTemplateArgument"; break;
        case 629: retval = "V_SgTemplateArgumentList"; break;
        case 630: retval = "V_SgTemplateDeclaration"; break;
        case 631: retval = "V_SgTemplateClassDeclaration"; break;
        case 632: retval = "V_SgTemplateClassSymbol"; break;
        case 633: retval = "V_SgTemplateFunctionDeclaration"; break;
        case 634: retval = "V_SgTemplateFunctionRefExp"; break;
        case 635: retval = "V_SgTemplateFunctionSymbol"; break;
        case 636: retval = "V_SgTemplateMemberFunctionDeclaration"; break;
        case 637: retval = "V_SgTemplateMemberFunctionRefExp"; break;
        case 638: retval = "V_SgTemplateMemberFunctionSymbol"; break;
        case 639: retval = "V_SgTemplateTypedefDeclaration"; break;
        case 640: retval = "V_SgTemplateTypedefSymbol"; break;
        case 641: retval = "V_SgTemplateVariableDeclaration"; break;
        case 642: retval = "V_SgTemplateVariableSymbol"; break;
        case 643: retval = "V_SgTemplateClassDefinition"; break;
        case 644: retval = "V_SgTemplateFunctionDefinition"; break;
        case 645: retval = "V_SgTemplateInstantiationDecl"; break;
        case 646: retval = "V_SgTemplateInstantiationDefn"; break;
        case 647: retval = "V_SgTemplateInstantiationDirectiveStatement"; break;
        case 648: retval = "V_SgTemplateInstantiationFunctionDecl"; break;
        case 649: retval = "V_SgTemplateInstantiationMemberFunctionDecl"; break;
        case 650: retval = "V_SgTemplateInstantiationTypedefDeclaration"; break;
        case 651: retval = "V_SgTemplateParameter"; break;
        case 652: retval = "V_SgTemplateParameterVal"; break;
        case 653: retval = "V_SgTemplateParameterList"; break;
        case 654: retval = "V_SgTemplateSymbol"; break;
        case 655: retval = "V_SgTemplateType"; break;
        case 656: retval = "V_SgThisExp"; break;
        case 657: retval = "V_SgTypeTraitBuiltinOperator"; break;
        case 658: retval = "V_SgSuperExp"; break;
        case 659: retval = "V_SgThrowOp"; break;
        case 660: retval = "V_SgToken"; break;
        case 661: retval = "V_SgTryStmt"; break;
        case 662: retval = "V_SgTupleExp"; break;
        case 663: retval = "V_SgType"; break;
        case 664: retval = "V_SgTypeBool"; break;
        case 665: retval = "V_SgTypeChar"; break;
        case 666: retval = "V_SgTypeComplex"; break;
        case 667: retval = "V_SgTypeDefault"; break;
        case 668: retval = "V_SgTypeExpression"; break;
        case 669: retval = "V_SgTypeLabel"; break;
        case 670: retval = "V_SgTypeDouble"; break;
        case 671: retval = "V_SgTypeEllipse"; break;
        case 672: retval = "V_SgTypeFloat"; break;
        case 673: retval = "V_SgTypeGlobalVoid"; break;
        case 674: retval = "V_SgTypeIdOp"; break;
        case 675: retval = "V_SgTypeImaginary"; break;
        case 676: retval = "V_SgTypeInt"; break;
        case 677: retval = "V_SgTypeLong"; break;
        case 678: retval = "V_SgTypeLongDouble"; break;
        case 679: retval = "V_SgTypeLongLong"; break;
        case 680: retval = "V_SgTypeModifier"; break;
        case 681: retval = "V_SgTypeMatrix"; break;
        case 682: retval = "V_SgTypeTuple"; break;
        case 683: retval = "V_SgTypeNullptr"; break;
        case 684: retval = "V_SgTypeOfType"; break;
        case 685: retval = "V_SgTypeShort"; break;
        case 686: retval = "V_SgTypeSigned128bitInteger"; break;
        case 687: retval = "V_SgTypeSignedChar"; break;
        case 688: retval = "V_SgTypeSignedInt"; break;
        case 689: retval = "V_SgTypeSignedLong"; break;
        case 690: retval = "V_SgTypeSignedLongLong"; break;
        case 691: retval = "V_SgTypeSignedShort"; break;
        case 692: retval = "V_SgTypeString"; break;
        case 693: retval = "V_SgTypeUnknown"; break;
        case 694: retval = "V_SgTypeUnsigned128bitInteger"; break;
        case 695: retval = "V_SgTypeUnsignedChar"; break;
        case 696: retval = "V_SgTypeUnsignedInt"; break;
        case 697: retval = "V_SgTypeUnsignedLong"; break;
        case 698: retval = "V_SgTypeUnsignedLongLong"; break;
        case 699: retval = "V_SgTypeUnsignedShort"; break;
        case 700: retval = "V_SgTypeVoid"; break;
        case 701: retval = "V_SgTypeWchar"; break;
        case 702: retval = "V_SgTypedefDeclaration"; break;
        case 703: retval = "V_SgTypedefSeq"; break;
        case 704: retval = "V_SgTypedefSymbol"; break;
        case 705: retval = "V_SgTypedefType"; break;
        case 706: retval = "V_SgUPC_AccessModifier"; break;
        case 707: retval = "V_SgUnaryAddOp"; break;
        case 708: retval = "V_SgUnaryOp"; break;
        case 709: retval = "V_SgUndefDirectiveStatement"; break;
        case 710: retval = "V_SgUndirectedGraphEdge"; break;
        case 711: retval = "V_SgUnknownArrayOrFunctionReference"; break;
        case 712: retval = "V_SgUnknownFile"; break;
        case 714: retval = "V_SgUnparse_Info"; break;
        case 715: retval = "V_SgUnsignedCharVal"; break;
        case 716: retval = "V_SgUnsignedIntVal"; break;
        case 717: retval = "V_SgUnsignedLongLongIntVal"; break;
        case 718: retval = "V_SgUnsignedLongVal"; break;
        case 719: retval = "V_SgUnsignedShortVal"; break;
        case 720: retval = "V_SgUntypedNode"; break;
        case 721: retval = "V_SgUntypedExpression"; break;
        case 722: retval = "V_SgUntypedUnaryOperator"; break;
        case 723: retval = "V_SgUntypedBinaryOperator"; break;
        case 724: retval = "V_SgUntypedValueExpression"; break;
        case 725: retval = "V_SgUntypedArrayReferenceExpression"; break;
        case 726: retval = "V_SgUntypedOtherExpression"; break;
        case 727: retval = "V_SgUntypedFunctionCallOrArrayReferenceExpression"; break;
        case 728: retval = "V_SgUntypedStatement"; break;
        case 729: retval = "V_SgUntypedNamedStatement"; break;
        case 730: retval = "V_SgUntypedAssignmentStatement"; break;
        case 731: retval = "V_SgUntypedFunctionCallStatement"; break;
        case 732: retval = "V_SgUntypedBlockStatement"; break;
        case 733: retval = "V_SgUntypedOtherStatement"; break;
        case 734: retval = "V_SgUntypedDeclarationStatement"; break;
        case 735: retval = "V_SgUntypedInitializedName"; break;
        case 736: retval = "V_SgUntypedImplicitDeclaration"; break;
        case 737: retval = "V_SgUntypedVariableDeclaration"; break;
        case 738: retval = "V_SgUntypedProgramHeaderDeclaration"; break;
        case 739: retval = "V_SgUntypedFunctionDeclaration"; break;
        case 740: retval = "V_SgUntypedSubroutineDeclaration"; break;
        case 741: retval = "V_SgUntypedReferenceExpression"; break;
        case 742: retval = "V_SgUntypedType"; break;
        case 743: retval = "V_SgUntypedArrayType"; break;
        case 744: retval = "V_SgUntypedAttribute"; break;
        case 745: retval = "V_SgUntypedFile"; break;
        case 746: retval = "V_SgUntypedScope"; break;
        case 747: retval = "V_SgUntypedFunctionScope"; break;
        case 748: retval = "V_SgUntypedModuleScope"; break;
        case 749: retval = "V_SgUntypedGlobalScope"; break;
        case 750: retval = "V_SgUntypedModuleDeclaration"; break;
        case 751: retval = "V_SgUntypedStatementList"; break;
        case 752: retval = "V_SgUntypedDeclarationStatementList"; break;
        case 753: retval = "V_SgUntypedFunctionDeclarationList"; break;
        case 754: retval = "V_SgUntypedInitializedNameList"; break;
        case 755: retval = "V_SgUpcBarrierStatement"; break;
        case 756: retval = "V_SgUpcBlocksizeofExpression"; break;
        case 757: retval = "V_SgUpcElemsizeofExpression"; break;
        case 758: retval = "V_SgUpcFenceStatement"; break;
        case 759: retval = "V_SgUpcForAllStatement"; break;
        case 760: retval = "V_SgUpcLocalsizeofExpression"; break;
        case 761: retval = "V_SgUpcMythread"; break;
        case 762: retval = "V_SgUpcNotifyStatement"; break;
        case 763: retval = "V_SgUpcThreads"; break;
        case 764: retval = "V_SgUpcWaitStatement"; break;
        case 765: retval = "V_SgUseStatement"; break;
        case 766: retval = "V_SgUserDefinedBinaryOp"; break;
        case 767: retval = "V_SgUserDefinedUnaryOp"; break;
        case 768: retval = "V_SgUsingDeclarationStatement"; break;
        case 769: retval = "V_SgUsingDirectiveStatement"; break;
        case 770: retval = "V_SgValueExp"; break;
        case 771: retval = "V_SgVarArgCopyOp"; break;
        case 772: retval = "V_SgVarArgEndOp"; break;
        case 773: retval = "V_SgVarArgOp"; break;
        case 774: retval = "V_SgVarArgStartOneOperandOp"; break;
        case 775: retval = "V_SgVarArgStartOp"; break;
        case 776: retval = "V_SgVarRefExp"; break;
        case 777: retval = "V_SgVariableDeclaration"; break;
        case 778: retval = "V_SgVariableDefinition"; break;
        case 779: retval = "V_SgVariableSymbol"; break;
        case 780: retval = "V_SgVariantExpression"; break;
        case 781: retval = "V_SgVariantStatement"; break;
        case 782: retval = "V_SgWaitStatement"; break;
        case 783: retval = "V_SgWarningDirectiveStatement"; break;
        case 784: retval = "V_SgWithStatement"; break;
        case 785: retval = "V_SgWcharVal"; break;
        case 786: retval = "V_SgWhereStatement"; break;
        case 787: retval = "V_SgWhileStmt"; break;
        case 788: retval = "V_SgWriteStatement"; break;
        case 789: retval = "V_SgXorAssignOp"; break;
        case 790: retval = "V_SgYieldExpression"; break;
        case 791: retval = "V_Sg_File_Info"; break;
        case 792: retval = "V_SgTypeCAFTeam"; break;
        case 793: retval = "V_SgCAFWithTeamStatement"; break;
        case 794: retval = "V_SgCAFCoExpression"; break;
        case 795: retval = "V_SgCallExpression"; break;
        case 796: retval = "V_SgTypeCrayPointer"; break;
        case 797: retval = "V_SgJavaImportStatement"; break;
        case 798: retval = "V_SgJavaPackageDeclaration"; break;
        case 799: retval = "V_SgJavaPackageStatement"; break;
        case 800: retval = "V_SgJavaImportStatementList"; break;
        case 801: retval = "V_SgJavaClassDeclarationList"; break;
        case 802: retval = "V_SgJavaMemberValuePair"; break;
        case 803: retval = "V_SgJavaAnnotation"; break;
        case 804: retval = "V_SgJavaMarkerAnnotation"; break;
        case 805: retval = "V_SgJavaSingleMemberAnnotation"; break;
        case 806: retval = "V_SgJavaNormalAnnotation"; break;
        case 807: retval = "V_SgJavaTypeExpression"; break;
        case 808: retval = "V_SgJavaQualifiedType"; break;
        case 809: retval = "V_SgClassExp"; break;
        case 810: retval = "V_SgJavaUnionType"; break;
        case 811: retval = "V_SgJavaParameterType"; break;
        case 812: retval = "V_SgAsyncStmt"; break;
        case 813: retval = "V_SgFinishStmt"; break;
        case 814: retval = "V_SgAtStmt"; break;
        case 815: retval = "V_SgHereExp"; break;
        case 817: retval = "V_SgNumVariants"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(VariantT)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VariantT::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VirtualBinCFG::EdgeConditionKind is defined at git_rose_development/src/frontend/SageIII/virtualCFG/virtualBinCFG.h:16
/** Converts an enum of type VirtualBinCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualBinCFG_EdgeConditionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "eckUnconditional"; break;
        case 1: retval = "eckTrue"; break;
        case 2: retval = "eckFalse"; break;
        case 3: retval = "eckCaseLabel"; break;
        case 4: retval = "eckDefault"; break;
    }
    if (retval.empty()) {
        char buf[96];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(VirtualBinCFG::EdgeConditionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualBinCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// VirtualCFG::EdgeConditionKind is defined at git_rose_development/src/frontend/SageIII/virtualCFG/virtualCFG.h:48
/** Converts an enum of type VirtualCFG::EdgeConditionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyVirtualCFG_EdgeConditionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "eckUnconditional"; break;
        case 1: retval = "eckTrue"; break;
        case 2: retval = "eckFalse"; break;
        case 3: retval = "eckCaseLabel"; break;
        case 4: retval = "eckDefault"; break;
        case 5: retval = "eckDoConditionPassed"; break;
        case 6: retval = "eckDoConditionFailed"; break;
        case 7: retval = "eckForallIndicesInRange"; break;
        case 8: retval = "eckForallIndicesNotInRange"; break;
        case 9: retval = "eckComputedGotoCaseLabel"; break;
        case 10: retval = "eckArithmeticIfLess"; break;
        case 11: retval = "eckArithmeticIfEqual"; break;
        case 12: retval = "eckArithmeticIfGreater"; break;
        case 13: retval = "eckInterprocedural"; break;
    }
    if (retval.empty()) {
        char buf[93];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(VirtualCFG::EdgeConditionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "VirtualCFG::EdgeConditionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// WarningType is defined at git_rose_development/src/midend/astProcessing/AstAttributeMechanism.C:21
/** Converts an enum of type WarningType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyWarningType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "HAS_MEMORY_LEAK"; break;
        case 1: retval = "HAS_UNKNOWN_OWNERSHIP"; break;
        case 2: retval = "HAS_NULL_COPY"; break;
        case 3: retval = "HAS_SELF_COPY"; break;
        case 4: retval = "HAS_NO_CLASS_NAME"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(WarningType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "WarningType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86BranchPrediction is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:105
/** Converts an enum of type X86BranchPrediction to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86BranchPrediction(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_branch_prediction_none"; break;
        case 1: retval = "x86_branch_prediction_taken"; break;
        case 2: retval = "x86_branch_prediction_not_taken"; break;
    }
    if (retval.empty()) {
        char buf[83];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86BranchPrediction)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86BranchPrediction::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Exception is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:121
/** Converts an enum of type X86Exception to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Exception(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_exception_int"; break;
        case 1: retval = "x86_exception_sysenter"; break;
        case 2: retval = "x86_exception_syscall"; break;
        case 3: retval = "x86_exception_de"; break;
        case 4: retval = "x86_exception_db"; break;
        case 5: retval = "x86_exception_bp"; break;
        case 6: retval = "x86_exception_of"; break;
        case 7: retval = "x86_exception_br"; break;
        case 8: retval = "x86_exception_ud"; break;
        case 9: retval = "x86_exception_nm"; break;
        case 10: retval = "x86_exception_df"; break;
        case 11: retval = "x86_exception_ts"; break;
        case 12: retval = "x86_exception_np"; break;
        case 13: retval = "x86_exception_ss"; break;
        case 14: retval = "x86_exception_gp"; break;
        case 15: retval = "x86_exception_pf"; break;
        case 16: retval = "x86_exception_mf"; break;
        case 17: retval = "x86_exception_ac"; break;
        case 18: retval = "x86_exception_mc"; break;
        case 19: retval = "x86_exception_xm"; break;
    }
    if (retval.empty()) {
        char buf[76];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86Exception)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Exception::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Flag is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:83
/** Converts an enum of type X86Flag to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Flag(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_flag_cf"; break;
        case 2: retval = "x86_flag_pf"; break;
        case 4: retval = "x86_flag_af"; break;
        case 6: retval = "x86_flag_zf"; break;
        case 7: retval = "x86_flag_sf"; break;
        case 8: retval = "x86_flag_tf"; break;
        case 9: retval = "x86_flag_if"; break;
        case 10: retval = "x86_flag_df"; break;
        case 11: retval = "x86_flag_of"; break;
        case 12: retval = "x86_flag_iopl"; break;
        case 14: retval = "x86_flag_nt"; break;
        case 16: retval = "x86_flag_rf"; break;
        case 17: retval = "x86_flag_vm"; break;
        case 18: retval = "x86_flag_ac"; break;
        case 19: retval = "x86_flag_vif"; break;
        case 20: retval = "x86_flag_vip"; break;
        case 21: retval = "x86_flag_id"; break;
    }
    if (retval.empty()) {
        char buf[71];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86Flag)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Flag::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86Flags is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:74
/** Converts an enum of type X86Flags to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86Flags(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_flags_status"; break;
        case 1: retval = "x86_flags_fpstatus"; break;
        case 2: retval = "x86_flags_fptag"; break;
        case 3: retval = "x86_flags_fpctl"; break;
        case 4: retval = "x86_flags_mxcsr"; break;
    }
    if (retval.empty()) {
        char buf[72];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86Flags)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86Flags::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86GeneralPurposeRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:41
/** Converts an enum of type X86GeneralPurposeRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86GeneralPurposeRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_gpr_ax"; break;
        case 1: retval = "x86_gpr_cx"; break;
        case 2: retval = "x86_gpr_dx"; break;
        case 3: retval = "x86_gpr_bx"; break;
        case 4: retval = "x86_gpr_sp"; break;
        case 5: retval = "x86_gpr_bp"; break;
        case 6: retval = "x86_gpr_si"; break;
        case 7: retval = "x86_gpr_di"; break;
        case 8: retval = "x86_gpr_r8"; break;
        case 9: retval = "x86_gpr_r9"; break;
        case 10: retval = "x86_gpr_r10"; break;
        case 11: retval = "x86_gpr_r11"; break;
        case 12: retval = "x86_gpr_r12"; break;
        case 13: retval = "x86_gpr_r13"; break;
        case 14: retval = "x86_gpr_r14"; break;
        case 15: retval = "x86_gpr_r15"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86GeneralPurposeRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86GeneralPurposeRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86InstructionKind is defined at git_rose_development/src/frontend/Disassemblers/AssemblerX86Init.h:22
/** Converts an enum of type X86InstructionKind to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionKind(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_unknown_instruction"; break;
        case 1: retval = "x86_aaa"; break;
        case 2: retval = "x86_aad"; break;
        case 3: retval = "x86_aam"; break;
        case 4: retval = "x86_aas"; break;
        case 5: retval = "x86_adc"; break;
        case 6: retval = "x86_add"; break;
        case 7: retval = "x86_addpd"; break;
        case 8: retval = "x86_addps"; break;
        case 9: retval = "x86_addsd"; break;
        case 10: retval = "x86_addss"; break;
        case 11: retval = "x86_addsubpd"; break;
        case 12: retval = "x86_addsubps"; break;
        case 13: retval = "x86_and"; break;
        case 14: retval = "x86_andnpd"; break;
        case 15: retval = "x86_andnps"; break;
        case 16: retval = "x86_andpd"; break;
        case 17: retval = "x86_andps"; break;
        case 18: retval = "x86_arpl"; break;
        case 19: retval = "x86_blendpd"; break;
        case 20: retval = "x86_blendps"; break;
        case 21: retval = "x86_blendvpd"; break;
        case 22: retval = "x86_blendvps"; break;
        case 23: retval = "x86_bound"; break;
        case 24: retval = "x86_bsf"; break;
        case 25: retval = "x86_bsr"; break;
        case 26: retval = "x86_bswap"; break;
        case 27: retval = "x86_bt"; break;
        case 28: retval = "x86_btc"; break;
        case 29: retval = "x86_btr"; break;
        case 30: retval = "x86_bts"; break;
        case 31: retval = "x86_call"; break;
        case 32: retval = "x86_cbw"; break;
        case 33: retval = "x86_cdq"; break;
        case 34: retval = "x86_cdqe"; break;
        case 35: retval = "x86_clc"; break;
        case 36: retval = "x86_cld"; break;
        case 37: retval = "x86_clflush"; break;
        case 38: retval = "x86_clgi"; break;
        case 39: retval = "x86_cli"; break;
        case 40: retval = "x86_clts"; break;
        case 41: retval = "x86_cmc"; break;
        case 42: retval = "x86_cmova"; break;
        case 43: retval = "x86_cmovae"; break;
        case 44: retval = "x86_cmovb"; break;
        case 45: retval = "x86_cmovbe"; break;
        case 46: retval = "x86_cmove"; break;
        case 47: retval = "x86_cmovg"; break;
        case 48: retval = "x86_cmovge"; break;
        case 49: retval = "x86_cmovl"; break;
        case 50: retval = "x86_cmovle"; break;
        case 51: retval = "x86_cmovne"; break;
        case 52: retval = "x86_cmovno"; break;
        case 53: retval = "x86_cmovns"; break;
        case 54: retval = "x86_cmovo"; break;
        case 55: retval = "x86_cmovpe"; break;
        case 56: retval = "x86_cmovpo"; break;
        case 57: retval = "x86_cmovs"; break;
        case 58: retval = "x86_cmp"; break;
        case 59: retval = "x86_cmppd"; break;
        case 60: retval = "x86_cmpps"; break;
        case 61: retval = "x86_cmpsb"; break;
        case 62: retval = "x86_cmpsd"; break;
        case 63: retval = "x86_cmpsq"; break;
        case 64: retval = "x86_cmpss"; break;
        case 65: retval = "x86_cmpsw"; break;
        case 66: retval = "x86_cmpxchg"; break;
        case 67: retval = "x86_cmpxchg16b"; break;
        case 68: retval = "x86_cmpxchg8b"; break;
        case 69: retval = "x86_comisd"; break;
        case 70: retval = "x86_comiss"; break;
        case 71: retval = "x86_cpuid"; break;
        case 72: retval = "x86_cqo"; break;
        case 73: retval = "x86_crc32"; break;
        case 74: retval = "x86_cvtdq2pd"; break;
        case 75: retval = "x86_cvtdq2ps"; break;
        case 76: retval = "x86_cvtpd2dq"; break;
        case 77: retval = "x86_cvtpd2pi"; break;
        case 78: retval = "x86_cvtpd2ps"; break;
        case 79: retval = "x86_cvtpi2pd"; break;
        case 80: retval = "x86_cvtpi2ps"; break;
        case 81: retval = "x86_cvtps2dq"; break;
        case 82: retval = "x86_cvtps2pd"; break;
        case 83: retval = "x86_cvtps2pi"; break;
        case 84: retval = "x86_cvtsd2si"; break;
        case 85: retval = "x86_cvtsd2ss"; break;
        case 86: retval = "x86_cvtsi2sd"; break;
        case 87: retval = "x86_cvtsi2ss"; break;
        case 88: retval = "x86_cvtss2sd"; break;
        case 89: retval = "x86_cvtss2si"; break;
        case 90: retval = "x86_cvttpd2dq"; break;
        case 91: retval = "x86_cvttpd2pi"; break;
        case 92: retval = "x86_cvttps2dq"; break;
        case 93: retval = "x86_cvttps2pi"; break;
        case 94: retval = "x86_cvttsd2si"; break;
        case 95: retval = "x86_cvttss2si"; break;
        case 96: retval = "x86_cwd"; break;
        case 97: retval = "x86_cwde"; break;
        case 98: retval = "x86_daa"; break;
        case 99: retval = "x86_das"; break;
        case 100: retval = "x86_dec"; break;
        case 101: retval = "x86_div"; break;
        case 102: retval = "x86_divpd"; break;
        case 103: retval = "x86_divps"; break;
        case 104: retval = "x86_divsd"; break;
        case 105: retval = "x86_divss"; break;
        case 106: retval = "x86_dppd"; break;
        case 107: retval = "x86_dpps"; break;
        case 108: retval = "x86_emms"; break;
        case 109: retval = "x86_enter"; break;
        case 110: retval = "x86_extractps"; break;
        case 111: retval = "x86_extrq"; break;
        case 112: retval = "x86_f2xm1"; break;
        case 113: retval = "x86_fabs"; break;
        case 114: retval = "x86_fadd"; break;
        case 115: retval = "x86_faddp"; break;
        case 116: retval = "x86_farcall"; break;
        case 117: retval = "x86_farjmp"; break;
        case 118: retval = "x86_fbld"; break;
        case 119: retval = "x86_fbstp"; break;
        case 120: retval = "x86_fchs"; break;
        case 121: retval = "x86_fcmovb"; break;
        case 122: retval = "x86_fcmovbe"; break;
        case 123: retval = "x86_fcmove"; break;
        case 124: retval = "x86_fcmovnb"; break;
        case 125: retval = "x86_fcmovnbe"; break;
        case 126: retval = "x86_fcmovne"; break;
        case 127: retval = "x86_fcmovnu"; break;
        case 128: retval = "x86_fcmovu"; break;
        case 129: retval = "x86_fcom"; break;
        case 130: retval = "x86_fcomi"; break;
        case 131: retval = "x86_fcomip"; break;
        case 132: retval = "x86_fcomp"; break;
        case 133: retval = "x86_fcompp"; break;
        case 134: retval = "x86_fcos"; break;
        case 135: retval = "x86_fdecstp"; break;
        case 136: retval = "x86_fdiv"; break;
        case 137: retval = "x86_fdivp"; break;
        case 138: retval = "x86_fdivr"; break;
        case 139: retval = "x86_fdivrp"; break;
        case 140: retval = "x86_femms"; break;
        case 141: retval = "x86_ffree"; break;
        case 142: retval = "x86_fiadd"; break;
        case 143: retval = "x86_ficom"; break;
        case 144: retval = "x86_ficomp"; break;
        case 145: retval = "x86_fidiv"; break;
        case 146: retval = "x86_fidivr"; break;
        case 147: retval = "x86_fild"; break;
        case 148: retval = "x86_fimul"; break;
        case 149: retval = "x86_fincstp"; break;
        case 150: retval = "x86_fist"; break;
        case 151: retval = "x86_fistp"; break;
        case 152: retval = "x86_fisttp"; break;
        case 153: retval = "x86_fisub"; break;
        case 154: retval = "x86_fisubr"; break;
        case 155: retval = "x86_fld"; break;
        case 156: retval = "x86_fld1"; break;
        case 157: retval = "x86_fldcw"; break;
        case 158: retval = "x86_fldenv"; break;
        case 159: retval = "x86_fldl2e"; break;
        case 160: retval = "x86_fldl2t"; break;
        case 161: retval = "x86_fldlg2"; break;
        case 162: retval = "x86_fldln2"; break;
        case 163: retval = "x86_fldpi"; break;
        case 164: retval = "x86_fldz"; break;
        case 165: retval = "x86_fmul"; break;
        case 166: retval = "x86_fmulp"; break;
        case 167: retval = "x86_fnclex"; break;
        case 168: retval = "x86_fninit"; break;
        case 169: retval = "x86_fnop"; break;
        case 170: retval = "x86_fnsave"; break;
        case 171: retval = "x86_fnstcw"; break;
        case 172: retval = "x86_fnstenv"; break;
        case 173: retval = "x86_fnstsw"; break;
        case 174: retval = "x86_fpatan"; break;
        case 175: retval = "x86_fprem"; break;
        case 176: retval = "x86_fprem1"; break;
        case 177: retval = "x86_fptan"; break;
        case 178: retval = "x86_frndint"; break;
        case 179: retval = "x86_frstor"; break;
        case 180: retval = "x86_fscale"; break;
        case 181: retval = "x86_fsin"; break;
        case 182: retval = "x86_fsincos"; break;
        case 183: retval = "x86_fsqrt"; break;
        case 184: retval = "x86_fst"; break;
        case 185: retval = "x86_fstp"; break;
        case 186: retval = "x86_fsub"; break;
        case 187: retval = "x86_fsubp"; break;
        case 188: retval = "x86_fsubr"; break;
        case 189: retval = "x86_fsubrp"; break;
        case 190: retval = "x86_ftst"; break;
        case 191: retval = "x86_fucom"; break;
        case 192: retval = "x86_fucomi"; break;
        case 193: retval = "x86_fucomip"; break;
        case 194: retval = "x86_fucomp"; break;
        case 195: retval = "x86_fucompp"; break;
        case 196: retval = "x86_fwait"; break;
        case 197: retval = "x86_fxam"; break;
        case 198: retval = "x86_fxch"; break;
        case 199: retval = "x86_fxrstor"; break;
        case 200: retval = "x86_fxsave"; break;
        case 201: retval = "x86_fxtract"; break;
        case 202: retval = "x86_fyl2x"; break;
        case 203: retval = "x86_fyl2xp1"; break;
        case 204: retval = "x86_getsec"; break;
        case 205: retval = "x86_haddpd"; break;
        case 206: retval = "x86_haddps"; break;
        case 207: retval = "x86_hlt"; break;
        case 208: retval = "x86_hsubpd"; break;
        case 209: retval = "x86_hsubps"; break;
        case 210: retval = "x86_idiv"; break;
        case 211: retval = "x86_imul"; break;
        case 212: retval = "x86_in"; break;
        case 213: retval = "x86_inc"; break;
        case 214: retval = "x86_insb"; break;
        case 215: retval = "x86_insd"; break;
        case 216: retval = "x86_insertps"; break;
        case 217: retval = "x86_insertq"; break;
        case 218: retval = "x86_insw"; break;
        case 219: retval = "x86_int"; break;
        case 220: retval = "x86_int1"; break;
        case 221: retval = "x86_int3"; break;
        case 222: retval = "x86_into"; break;
        case 223: retval = "x86_invd"; break;
        case 224: retval = "x86_invept"; break;
        case 225: retval = "x86_invlpg"; break;
        case 226: retval = "x86_invlpga"; break;
        case 227: retval = "x86_invvpid"; break;
        case 228: retval = "x86_iret"; break;
        case 229: retval = "x86_ja"; break;
        case 230: retval = "x86_jae"; break;
        case 231: retval = "x86_jb"; break;
        case 232: retval = "x86_jbe"; break;
        case 233: retval = "x86_jcxz"; break;
        case 234: retval = "x86_je"; break;
        case 235: retval = "x86_jecxz"; break;
        case 236: retval = "x86_jg"; break;
        case 237: retval = "x86_jge"; break;
        case 238: retval = "x86_jl"; break;
        case 239: retval = "x86_jle"; break;
        case 240: retval = "x86_jmp"; break;
        case 241: retval = "x86_jmpe"; break;
        case 242: retval = "x86_jne"; break;
        case 243: retval = "x86_jno"; break;
        case 244: retval = "x86_jns"; break;
        case 245: retval = "x86_jo"; break;
        case 246: retval = "x86_jpe"; break;
        case 247: retval = "x86_jpo"; break;
        case 248: retval = "x86_jrcxz"; break;
        case 249: retval = "x86_js"; break;
        case 250: retval = "x86_lahf"; break;
        case 251: retval = "x86_lar"; break;
        case 252: retval = "x86_lddqu"; break;
        case 253: retval = "x86_ldmxcsr"; break;
        case 254: retval = "x86_lds"; break;
        case 255: retval = "x86_lea"; break;
        case 256: retval = "x86_leave"; break;
        case 257: retval = "x86_les"; break;
        case 258: retval = "x86_lfence"; break;
        case 259: retval = "x86_lfs"; break;
        case 260: retval = "x86_lgdt"; break;
        case 261: retval = "x86_lgs"; break;
        case 262: retval = "x86_lidt"; break;
        case 263: retval = "x86_lldt"; break;
        case 264: retval = "x86_lmsw"; break;
        case 265: retval = "x86_lock"; break;
        case 266: retval = "x86_lodsb"; break;
        case 267: retval = "x86_lodsd"; break;
        case 268: retval = "x86_lodsq"; break;
        case 269: retval = "x86_lodsw"; break;
        case 270: retval = "x86_loop"; break;
        case 271: retval = "x86_loopnz"; break;
        case 272: retval = "x86_loopz"; break;
        case 273: retval = "x86_lsl"; break;
        case 274: retval = "x86_lss"; break;
        case 275: retval = "x86_ltr"; break;
        case 276: retval = "x86_lzcnt"; break;
        case 277: retval = "x86_maskmovq"; break;
        case 278: retval = "x86_maxpd"; break;
        case 279: retval = "x86_maxps"; break;
        case 280: retval = "x86_maxsd"; break;
        case 281: retval = "x86_maxss"; break;
        case 282: retval = "x86_mfence"; break;
        case 283: retval = "x86_minpd"; break;
        case 284: retval = "x86_minps"; break;
        case 285: retval = "x86_minsd"; break;
        case 286: retval = "x86_minss"; break;
        case 287: retval = "x86_monitor"; break;
        case 288: retval = "x86_mov"; break;
        case 289: retval = "x86_movapd"; break;
        case 290: retval = "x86_movaps"; break;
        case 291: retval = "x86_movbe"; break;
        case 292: retval = "x86_movd"; break;
        case 293: retval = "x86_movddup"; break;
        case 294: retval = "x86_movdq2q"; break;
        case 295: retval = "x86_movdqa"; break;
        case 296: retval = "x86_movdqu"; break;
        case 297: retval = "x86_movhlps"; break;
        case 298: retval = "x86_movhpd"; break;
        case 299: retval = "x86_movhps"; break;
        case 300: retval = "x86_movlhps"; break;
        case 301: retval = "x86_movlpd"; break;
        case 302: retval = "x86_movlps"; break;
        case 303: retval = "x86_movmskpd"; break;
        case 304: retval = "x86_movmskps"; break;
        case 305: retval = "x86_movntdq"; break;
        case 306: retval = "x86_movntdqa"; break;
        case 307: retval = "x86_movnti"; break;
        case 308: retval = "x86_movntpd"; break;
        case 309: retval = "x86_movntps"; break;
        case 310: retval = "x86_movntq"; break;
        case 311: retval = "x86_movntsd"; break;
        case 312: retval = "x86_movntss"; break;
        case 313: retval = "x86_movq"; break;
        case 314: retval = "x86_movq2dq"; break;
        case 315: retval = "x86_movsb"; break;
        case 316: retval = "x86_movsd"; break;
        case 317: retval = "x86_movsd_sse"; break;
        case 318: retval = "x86_movshdup"; break;
        case 319: retval = "x86_movsldup"; break;
        case 320: retval = "x86_movsq"; break;
        case 321: retval = "x86_movss"; break;
        case 322: retval = "x86_movsw"; break;
        case 323: retval = "x86_movsx"; break;
        case 324: retval = "x86_movsxd"; break;
        case 325: retval = "x86_movupd"; break;
        case 326: retval = "x86_movups"; break;
        case 327: retval = "x86_movzx"; break;
        case 328: retval = "x86_mpsadbw"; break;
        case 329: retval = "x86_mul"; break;
        case 330: retval = "x86_mulpd"; break;
        case 331: retval = "x86_mulps"; break;
        case 332: retval = "x86_mulsd"; break;
        case 333: retval = "x86_mulss"; break;
        case 334: retval = "x86_mwait"; break;
        case 335: retval = "x86_neg"; break;
        case 336: retval = "x86_nop"; break;
        case 337: retval = "x86_not"; break;
        case 338: retval = "x86_or"; break;
        case 339: retval = "x86_orpd"; break;
        case 340: retval = "x86_orps"; break;
        case 341: retval = "x86_out"; break;
        case 342: retval = "x86_outs"; break;
        case 343: retval = "x86_outsb"; break;
        case 344: retval = "x86_outsd"; break;
        case 345: retval = "x86_outsw"; break;
        case 346: retval = "x86_pabsb"; break;
        case 347: retval = "x86_pabsd"; break;
        case 348: retval = "x86_pabsw"; break;
        case 349: retval = "x86_packssdw"; break;
        case 350: retval = "x86_packsswb"; break;
        case 351: retval = "x86_packusdw"; break;
        case 352: retval = "x86_packuswb"; break;
        case 353: retval = "x86_paddb"; break;
        case 354: retval = "x86_paddd"; break;
        case 355: retval = "x86_paddq"; break;
        case 356: retval = "x86_paddsb"; break;
        case 357: retval = "x86_paddsw"; break;
        case 358: retval = "x86_paddusb"; break;
        case 359: retval = "x86_paddusw"; break;
        case 360: retval = "x86_paddw"; break;
        case 361: retval = "x86_palignr"; break;
        case 362: retval = "x86_pand"; break;
        case 363: retval = "x86_pandn"; break;
        case 364: retval = "x86_pause"; break;
        case 365: retval = "x86_pavgb"; break;
        case 366: retval = "x86_pavgusb"; break;
        case 367: retval = "x86_pavgw"; break;
        case 368: retval = "x86_pblendvb"; break;
        case 369: retval = "x86_pblendw"; break;
        case 370: retval = "x86_pcmpeqb"; break;
        case 371: retval = "x86_pcmpeqd"; break;
        case 372: retval = "x86_pcmpeqq"; break;
        case 373: retval = "x86_pcmpeqw"; break;
        case 374: retval = "x86_pcmpestri"; break;
        case 375: retval = "x86_pcmpestrm"; break;
        case 376: retval = "x86_pcmpgtb"; break;
        case 377: retval = "x86_pcmpgtd"; break;
        case 378: retval = "x86_pcmpgtq"; break;
        case 379: retval = "x86_pcmpgtw"; break;
        case 380: retval = "x86_pcmpistri"; break;
        case 381: retval = "x86_pcmpistrm"; break;
        case 382: retval = "x86_pextrb"; break;
        case 383: retval = "x86_pextrd"; break;
        case 384: retval = "x86_pextrq"; break;
        case 385: retval = "x86_pextrw"; break;
        case 386: retval = "x86_pf2id"; break;
        case 387: retval = "x86_pf2iw"; break;
        case 388: retval = "x86_pfacc"; break;
        case 389: retval = "x86_pfadd"; break;
        case 390: retval = "x86_pfcmpeq"; break;
        case 391: retval = "x86_pfcmpge"; break;
        case 392: retval = "x86_pfcmpgt"; break;
        case 393: retval = "x86_pfmax"; break;
        case 394: retval = "x86_pfmin"; break;
        case 395: retval = "x86_pfmul"; break;
        case 396: retval = "x86_pfnacc"; break;
        case 397: retval = "x86_pfpnacc"; break;
        case 398: retval = "x86_pfrcp"; break;
        case 399: retval = "x86_pfrcpit1"; break;
        case 400: retval = "x86_pfrcpit2"; break;
        case 401: retval = "x86_pfrsqit1"; break;
        case 402: retval = "x86_pfrsqrt"; break;
        case 403: retval = "x86_pfsub"; break;
        case 404: retval = "x86_pfsubr"; break;
        case 405: retval = "x86_phaddd"; break;
        case 406: retval = "x86_phaddsw"; break;
        case 407: retval = "x86_phaddw"; break;
        case 408: retval = "x86_phminposuw"; break;
        case 409: retval = "x86_phsubd"; break;
        case 410: retval = "x86_phsubsw"; break;
        case 411: retval = "x86_phsubw"; break;
        case 412: retval = "x86_pi2fd"; break;
        case 413: retval = "x86_pi2fw"; break;
        case 414: retval = "x86_pinsrb"; break;
        case 415: retval = "x86_pinsrd"; break;
        case 416: retval = "x86_pinsrq"; break;
        case 417: retval = "x86_pinsrw"; break;
        case 418: retval = "x86_pmaddubsw"; break;
        case 419: retval = "x86_pmaddwd"; break;
        case 420: retval = "x86_pmaxsb"; break;
        case 421: retval = "x86_pmaxsd"; break;
        case 422: retval = "x86_pmaxsw"; break;
        case 423: retval = "x86_pmaxub"; break;
        case 424: retval = "x86_pmaxud"; break;
        case 425: retval = "x86_pmaxuw"; break;
        case 426: retval = "x86_pminsb"; break;
        case 427: retval = "x86_pminsd"; break;
        case 428: retval = "x86_pminsw"; break;
        case 429: retval = "x86_pminub"; break;
        case 430: retval = "x86_pminud"; break;
        case 431: retval = "x86_pminuw"; break;
        case 432: retval = "x86_pmovmskb"; break;
        case 433: retval = "x86_pmovsxbd"; break;
        case 434: retval = "x86_pmovsxbq"; break;
        case 435: retval = "x86_pmovsxbw"; break;
        case 436: retval = "x86_pmovsxdq"; break;
        case 437: retval = "x86_pmovsxwd"; break;
        case 438: retval = "x86_pmovsxwq"; break;
        case 439: retval = "x86_pmovzxbd"; break;
        case 440: retval = "x86_pmovzxbq"; break;
        case 441: retval = "x86_pmovzxbw"; break;
        case 442: retval = "x86_pmovzxdq"; break;
        case 443: retval = "x86_pmovzxwd"; break;
        case 444: retval = "x86_pmovzxwq"; break;
        case 445: retval = "x86_pmuldq"; break;
        case 446: retval = "x86_pmulhrsw"; break;
        case 447: retval = "x86_pmulhrw"; break;
        case 448: retval = "x86_pmulhuw"; break;
        case 449: retval = "x86_pmulhw"; break;
        case 450: retval = "x86_pmulld"; break;
        case 451: retval = "x86_pmullw"; break;
        case 452: retval = "x86_pmuludq"; break;
        case 453: retval = "x86_pop"; break;
        case 454: retval = "x86_popa"; break;
        case 455: retval = "x86_popad"; break;
        case 456: retval = "x86_popcnt"; break;
        case 457: retval = "x86_popf"; break;
        case 458: retval = "x86_popfd"; break;
        case 459: retval = "x86_popfq"; break;
        case 460: retval = "x86_por"; break;
        case 461: retval = "x86_prefetch"; break;
        case 462: retval = "x86_prefetchnta"; break;
        case 463: retval = "x86_prefetcht0"; break;
        case 464: retval = "x86_prefetcht1"; break;
        case 465: retval = "x86_prefetcht2"; break;
        case 466: retval = "x86_prefetchw"; break;
        case 467: retval = "x86_psadbw"; break;
        case 468: retval = "x86_pshufb"; break;
        case 469: retval = "x86_pshufd"; break;
        case 470: retval = "x86_pshufhw"; break;
        case 471: retval = "x86_pshuflw"; break;
        case 472: retval = "x86_pshufw"; break;
        case 473: retval = "x86_psignb"; break;
        case 474: retval = "x86_psignd"; break;
        case 475: retval = "x86_psignw"; break;
        case 476: retval = "x86_pslld"; break;
        case 477: retval = "x86_pslldq"; break;
        case 478: retval = "x86_psllq"; break;
        case 479: retval = "x86_psllw"; break;
        case 480: retval = "x86_psrad"; break;
        case 481: retval = "x86_psraq"; break;
        case 482: retval = "x86_psraw"; break;
        case 483: retval = "x86_psrld"; break;
        case 484: retval = "x86_psrldq"; break;
        case 485: retval = "x86_psrlq"; break;
        case 486: retval = "x86_psrlw"; break;
        case 487: retval = "x86_psubb"; break;
        case 488: retval = "x86_psubd"; break;
        case 489: retval = "x86_psubq"; break;
        case 490: retval = "x86_psubsb"; break;
        case 491: retval = "x86_psubsw"; break;
        case 492: retval = "x86_psubusb"; break;
        case 493: retval = "x86_psubusw"; break;
        case 494: retval = "x86_psubw"; break;
        case 495: retval = "x86_pswapd"; break;
        case 496: retval = "x86_ptest"; break;
        case 497: retval = "x86_punpckhbw"; break;
        case 498: retval = "x86_punpckhdq"; break;
        case 499: retval = "x86_punpckhqdq"; break;
        case 500: retval = "x86_punpckhwd"; break;
        case 501: retval = "x86_punpcklbw"; break;
        case 502: retval = "x86_punpckldq"; break;
        case 503: retval = "x86_punpcklqdq"; break;
        case 504: retval = "x86_punpcklwd"; break;
        case 505: retval = "x86_push"; break;
        case 506: retval = "x86_pusha"; break;
        case 507: retval = "x86_pushad"; break;
        case 508: retval = "x86_pushf"; break;
        case 509: retval = "x86_pushfd"; break;
        case 510: retval = "x86_pushfq"; break;
        case 511: retval = "x86_pxor"; break;
        case 512: retval = "x86_rcl"; break;
        case 513: retval = "x86_rcpps"; break;
        case 514: retval = "x86_rcpss"; break;
        case 515: retval = "x86_rcr"; break;
        case 516: retval = "x86_rdmsr"; break;
        case 517: retval = "x86_rdpmc"; break;
        case 518: retval = "x86_rdtsc"; break;
        case 519: retval = "x86_rdtscp"; break;
        case 520: retval = "x86_rep_insb"; break;
        case 521: retval = "x86_rep_insd"; break;
        case 522: retval = "x86_rep_insw"; break;
        case 523: retval = "x86_rep_lodsb"; break;
        case 524: retval = "x86_rep_lodsd"; break;
        case 525: retval = "x86_rep_lodsq"; break;
        case 526: retval = "x86_rep_lodsw"; break;
        case 527: retval = "x86_rep_movsb"; break;
        case 528: retval = "x86_rep_movsd"; break;
        case 529: retval = "x86_rep_movsq"; break;
        case 530: retval = "x86_rep_movsw"; break;
        case 531: retval = "x86_rep_outsb"; break;
        case 532: retval = "x86_rep_outsd"; break;
        case 533: retval = "x86_rep_outsw"; break;
        case 534: retval = "x86_rep_stosb"; break;
        case 535: retval = "x86_rep_stosd"; break;
        case 536: retval = "x86_rep_stosq"; break;
        case 537: retval = "x86_rep_stosw"; break;
        case 538: retval = "x86_repe_cmpsb"; break;
        case 539: retval = "x86_repe_cmpsd"; break;
        case 540: retval = "x86_repe_cmpsq"; break;
        case 541: retval = "x86_repe_cmpsw"; break;
        case 542: retval = "x86_repe_scasb"; break;
        case 543: retval = "x86_repe_scasd"; break;
        case 544: retval = "x86_repe_scasq"; break;
        case 545: retval = "x86_repe_scasw"; break;
        case 546: retval = "x86_repne_cmpsb"; break;
        case 547: retval = "x86_repne_cmpsd"; break;
        case 548: retval = "x86_repne_cmpsq"; break;
        case 549: retval = "x86_repne_cmpsw"; break;
        case 550: retval = "x86_repne_scasb"; break;
        case 551: retval = "x86_repne_scasd"; break;
        case 552: retval = "x86_repne_scasq"; break;
        case 553: retval = "x86_repne_scasw"; break;
        case 554: retval = "x86_ret"; break;
        case 555: retval = "x86_retf"; break;
        case 556: retval = "x86_rol"; break;
        case 557: retval = "x86_ror"; break;
        case 558: retval = "x86_roundpd"; break;
        case 559: retval = "x86_roundps"; break;
        case 560: retval = "x86_roundsd"; break;
        case 561: retval = "x86_roundss"; break;
        case 562: retval = "x86_rsm"; break;
        case 563: retval = "x86_rsqrtps"; break;
        case 564: retval = "x86_rsqrtss"; break;
        case 565: retval = "x86_sahf"; break;
        case 566: retval = "x86_salc"; break;
        case 567: retval = "x86_sar"; break;
        case 568: retval = "x86_sbb"; break;
        case 569: retval = "x86_scasb"; break;
        case 570: retval = "x86_scasd"; break;
        case 571: retval = "x86_scasq"; break;
        case 572: retval = "x86_scasw"; break;
        case 573: retval = "x86_seta"; break;
        case 574: retval = "x86_setae"; break;
        case 575: retval = "x86_setb"; break;
        case 576: retval = "x86_setbe"; break;
        case 577: retval = "x86_sete"; break;
        case 578: retval = "x86_setg"; break;
        case 579: retval = "x86_setge"; break;
        case 580: retval = "x86_setl"; break;
        case 581: retval = "x86_setle"; break;
        case 582: retval = "x86_setne"; break;
        case 583: retval = "x86_setno"; break;
        case 584: retval = "x86_setns"; break;
        case 585: retval = "x86_seto"; break;
        case 586: retval = "x86_setpe"; break;
        case 587: retval = "x86_setpo"; break;
        case 588: retval = "x86_sets"; break;
        case 589: retval = "x86_sfence"; break;
        case 590: retval = "x86_sgdt"; break;
        case 591: retval = "x86_shl"; break;
        case 592: retval = "x86_shld"; break;
        case 593: retval = "x86_shr"; break;
        case 594: retval = "x86_shrd"; break;
        case 595: retval = "x86_shufpd"; break;
        case 596: retval = "x86_shufps"; break;
        case 597: retval = "x86_sidt"; break;
        case 598: retval = "x86_skinit"; break;
        case 599: retval = "x86_sldt"; break;
        case 600: retval = "x86_smsw"; break;
        case 601: retval = "x86_sqrtpd"; break;
        case 602: retval = "x86_sqrtps"; break;
        case 603: retval = "x86_sqrtsd"; break;
        case 604: retval = "x86_sqrtss"; break;
        case 605: retval = "x86_stc"; break;
        case 606: retval = "x86_std"; break;
        case 607: retval = "x86_stgi"; break;
        case 608: retval = "x86_sti"; break;
        case 609: retval = "x86_stmxcsr"; break;
        case 610: retval = "x86_stos"; break;
        case 611: retval = "x86_stosb"; break;
        case 612: retval = "x86_stosd"; break;
        case 613: retval = "x86_stosq"; break;
        case 614: retval = "x86_stosw"; break;
        case 615: retval = "x86_str"; break;
        case 616: retval = "x86_sub"; break;
        case 617: retval = "x86_subpd"; break;
        case 618: retval = "x86_subps"; break;
        case 619: retval = "x86_subsd"; break;
        case 620: retval = "x86_subss"; break;
        case 621: retval = "x86_swapgs"; break;
        case 622: retval = "x86_syscall"; break;
        case 623: retval = "x86_sysenter"; break;
        case 624: retval = "x86_sysexit"; break;
        case 625: retval = "x86_sysret"; break;
        case 626: retval = "x86_test"; break;
        case 627: retval = "x86_ucomisd"; break;
        case 628: retval = "x86_ucomiss"; break;
        case 629: retval = "x86_ud2"; break;
        case 630: retval = "x86_unpckhpd"; break;
        case 631: retval = "x86_unpckhps"; break;
        case 632: retval = "x86_unpcklpd"; break;
        case 633: retval = "x86_unpcklps"; break;
        case 634: retval = "x86_verr"; break;
        case 635: retval = "x86_verw"; break;
        case 636: retval = "x86_vmcall"; break;
        case 637: retval = "x86_vmclear"; break;
        case 638: retval = "x86_vmlaunch"; break;
        case 639: retval = "x86_vmload"; break;
        case 640: retval = "x86_vmmcall"; break;
        case 641: retval = "x86_vmoff"; break;
        case 642: retval = "x86_vmptrld"; break;
        case 643: retval = "x86_vmptrst"; break;
        case 644: retval = "x86_vmread"; break;
        case 645: retval = "x86_vmresume"; break;
        case 646: retval = "x86_vmrun"; break;
        case 647: retval = "x86_vmsave"; break;
        case 648: retval = "x86_vmwrite"; break;
        case 649: retval = "x86_vmxoff"; break;
        case 650: retval = "x86_vmxon"; break;
        case 651: retval = "x86_wait"; break;
        case 652: retval = "x86_wbinvd"; break;
        case 653: retval = "x86_wrmsr"; break;
        case 654: retval = "x86_xadd"; break;
        case 655: retval = "x86_xchg"; break;
        case 656: retval = "x86_xgetbv"; break;
        case 657: retval = "x86_xlatb"; break;
        case 658: retval = "x86_xor"; break;
        case 659: retval = "x86_xorpd"; break;
        case 660: retval = "x86_xorps"; break;
        case 661: retval = "x86_xrstor"; break;
        case 662: retval = "x86_xsave"; break;
        case 663: retval = "x86_xsetbv"; break;
        case 664: retval = "x86_last_instruction"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86InstructionKind)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionKind::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86InstructionSize is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:9
/** Converts an enum of type X86InstructionSize to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86InstructionSize(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_insnsize_none"; break;
        case 1: retval = "x86_insnsize_16"; break;
        case 2: retval = "x86_insnsize_32"; break;
        case 3: retval = "x86_insnsize_64"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86InstructionSize)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86InstructionSize::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86RegisterClass is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:17
/** Converts an enum of type X86RegisterClass to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RegisterClass(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_regclass_gpr"; break;
        case 1: retval = "x86_regclass_segment"; break;
        case 2: retval = "x86_regclass_cr"; break;
        case 3: retval = "x86_regclass_dr"; break;
        case 4: retval = "x86_regclass_st"; break;
        case 5: retval = "x86_regclass_xmm"; break;
        case 6: retval = "x86_regclass_ip"; break;
        case 7: retval = "x86_regclass_flags"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86RegisterClass)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RegisterClass::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86RepeatPrefix is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:113
/** Converts an enum of type X86RepeatPrefix to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86RepeatPrefix(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_repeat_none"; break;
        case 1: retval = "x86_repeat_repne"; break;
        case 2: retval = "x86_repeat_repe"; break;
    }
    if (retval.empty()) {
        char buf[79];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86RepeatPrefix)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86RepeatPrefix::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86SegmentRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:30
/** Converts an enum of type X86SegmentRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86SegmentRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_segreg_es"; break;
        case 1: retval = "x86_segreg_cs"; break;
        case 2: retval = "x86_segreg_ss"; break;
        case 3: retval = "x86_segreg_ds"; break;
        case 4: retval = "x86_segreg_fs"; break;
        case 5: retval = "x86_segreg_gs"; break;
        case 16: retval = "x86_segreg_none"; break;
    }
    if (retval.empty()) {
        char buf[82];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86SegmentRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86SegmentRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// X86StRegister is defined at git_rose_development/src/frontend/Disassemblers/InstructionEnumsX86.h:61
/** Converts an enum of type X86StRegister to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringifyX86StRegister(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "x86_st_0"; break;
        case 1: retval = "x86_st_1"; break;
        case 2: retval = "x86_st_2"; break;
        case 3: retval = "x86_st_3"; break;
        case 4: retval = "x86_st_4"; break;
        case 5: retval = "x86_st_5"; break;
        case 6: retval = "x86_st_6"; break;
        case 7: retval = "x86_st_7"; break;
        case 8: retval = "x86_st_nregs"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(X86StRegister)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "X86StRegister::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// __ptrace_request is defined at git_rose_development/src/frontend/Disassemblers/BinaryDebugger.C:10
/** Converts an enum of type __ptrace_request to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify__ptrace_request(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PTRACE_ATTACH"; break;
        case 1: retval = "PTRACE_CONT"; break;
        case 2: retval = "PTRACE_DETACH"; break;
        case 3: retval = "PTRACE_GETREGS"; break;
        case 4: retval = "PTRACE_GETFPREGS"; break;
        case 5: retval = "PTRACE_KILL"; break;
        case 6: retval = "PTRACE_SETREGS"; break;
        case 7: retval = "PTRACE_SINGLESTEP"; break;
        case 8: retval = "PTRACE_TRACEME"; break;
        case 9: retval = "PTRACE_PEEKUSER"; break;
    }
    if (retval.empty()) {
        char buf[80];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(__ptrace_request)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "__ptrace_request::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::edge_dbg_data_t is defined at git_rose_development/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:358
/** Converts an enum of type boost::edge_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_edge_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "edge_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[86];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(boost::edge_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::edge_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::graph_dbg_data_t is defined at git_rose_development/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:361
/** Converts an enum of type boost::graph_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_graph_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "graph_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(boost::graph_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::graph_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_callgraph_t is defined at git_rose_development/src/midend/programAnalysis/CallGraphAnalysisMySQL/Callgraph.h:34
/** Converts an enum of type boost::vertex_callgraph_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_callgraph_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_callgraph"; break;
    }
    if (retval.empty()) {
        char buf[89];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(boost::vertex_callgraph_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_callgraph_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_classhierarchy_t is defined at git_rose_development/src/midend/programAnalysis/CallGraphAnalysisMySQL/Classhierarchy.h:32
/** Converts an enum of type boost::vertex_classhierarchy_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_classhierarchy_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_classhierarchy"; break;
    }
    if (retval.empty()) {
        char buf[94];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(boost::vertex_classhierarchy_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_classhierarchy_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// boost::vertex_dbg_data_t is defined at git_rose_development/src/midend/programAnalysis/sideEffectAnalysis/SqliteDatabaseGraph.h:355
/** Converts an enum of type boost::vertex_dbg_data_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_boost_vertex_dbg_data_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "vertex_dbg_data"; break;
    }
    if (retval.empty()) {
        char buf[88];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(boost::vertex_dbg_data_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "boost::vertex_dbg_data_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// controlEnum is defined at git_rose_development/src/roseExtensions/dataStructureTraversal/exampleTest.C:4
/** Converts an enum of type controlEnum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_controlEnum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "BEGGINING_OF_ENUM"; break;
        case 1: retval = "typeInt"; break;
        case 2: retval = "typeChar"; break;
        case 3: retval = "typeTestStruct"; break;
        case 4: retval = "END_OF_ENUM"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(controlEnum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "controlEnum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// defaultEnumFunctionType is defined at git_rose_development/src/midend/programTransformation/implicitCodeGeneration/defaultFunctionGenerator.C:18
/** Converts an enum of type defaultEnumFunctionType to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_defaultEnumFunctionType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_unknown"; break;
        case 1: retval = "e_constructor"; break;
        case 2: retval = "e_destructor"; break;
        case 3: retval = "e_copy_constructor"; break;
        case 4: retval = "e_assignment_operator"; break;
        case 5: retval = "e_last_type"; break;
    }
    if (retval.empty()) {
        char buf[87];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(defaultEnumFunctionType)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "defaultEnumFunctionType::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// klt_tile_desc_t::tile_kind_e is defined at git_rose_development/src/midend/KLT/include/KLT/RTL/tile.h:7
/** Converts an enum of type klt_tile_desc_t::tile_kind_e to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_klt_tile_desc_t_tile_kind_e(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_tile_static"; break;
        case 1: retval = "e_tile_dynamic"; break;
    }
    if (retval.empty()) {
        char buf[92];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(klt_tile_desc_t::tile_kind_e)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "klt_tile_desc_t::tile_kind_e::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// language_enum is defined at git_rose_development/src/roseSupport/utility_functions.C:533
/** Converts an enum of type language_enum to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_language_enum(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "e_none"; break;
        case 1: retval = "e_c"; break;
        case 2: retval = "e_cxx"; break;
        case 3: retval = "e_fortran"; break;
        case 4: retval = "e_last_language"; break;
    }
    if (retval.empty()) {
        char buf[77];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(language_enum)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "language_enum::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// omp_sched_t is defined at git_rose_development/src/frontend/SageIII/omp.h:20
/** Converts an enum of type omp_sched_t to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_omp_sched_t(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 1: retval = "omp_sched_static"; break;
        case 2: retval = "omp_sched_dynamic"; break;
        case 3: retval = "omp_sched_guided"; break;
        case 4: retval = "omp_sched_auto"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(omp_sched_t)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "omp_sched_t::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ops is defined at git_rose_development/src/frontend/ECJ_ROSE_Connection/JavaParserActionROSE.C:4086
/** Converts an enum of type ops to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_ops(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "ERROR_OPERATOR"; break;
        case 2: retval = "AND"; break;
        case 3: retval = "OR"; break;
        case 4: retval = "LESS"; break;
        case 5: retval = "LESS_EQUAL"; break;
        case 6: retval = "GREATER"; break;
        case 7: retval = "GREATER_EQUAL"; break;
        case 8: retval = "XOR"; break;
        case 9: retval = "DIVIDE"; break;
        case 10: retval = "LEFT_SHIFT"; break;
        case 13: retval = "MINUS"; break;
        case 14: retval = "PLUS"; break;
        case 15: retval = "MULTIPLY"; break;
        case 16: retval = "REMAINDER"; break;
        case 17: retval = "RIGHT_SHIFT"; break;
        case 19: retval = "UNSIGNED_RIGHT_SHIFT"; break;
        case 100: retval = "OR_OR"; break;
        case 101: retval = "AND_AND"; break;
        case 102: retval = "LAST_OPERATOR"; break;
    }
    if (retval.empty()) {
        char buf[67];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ops)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ops::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// ssa_unfiltered_cfg::ReachingDef::Type is defined at git_rose_development/src/midend/programAnalysis/ssaUnfilteredCfg/reachingDefUnfilteredCfg.h:20
/** Converts an enum of type ssa_unfiltered_cfg::ReachingDef::Type to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_ssa_unfiltered_cfgReachingDefType(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 0: retval = "PHI_FUNCTION"; break;
        case 1: retval = "ORIGINAL_DEF"; break;
        case 2: retval = "EXPANDED_DEF"; break;
        case 3: retval = "EXTERNAL_DEF"; break;
    }
    if (retval.empty()) {
        char buf[101];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(ssa_unfiltered_cfg::ReachingDef::Type)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "ssa_unfiltered_cfg::ReachingDef::Type::" + retval;
    }
    return retval;
}

// DO NOT EDIT -- This function was automatically generated by $ROSE_SOURCE/scripts/stringify.pl.
// yytokentype is defined at frontend/SageIII/ompparser.hh:48
/** Converts an enum of type yytokentype to a string.
 *
 *  If the supplied value is not a member of the enumeration type then the returned string will look like a C type cast but
 *  no warning will be generated.  If the @p canonic argument is true (default is false) then the returned string will
 *  include the canonic name of the enumeration type.  If the @p strip argument is non-null and the enum member name begins
 *  with those letters, then those letters are removed from the name. */
std::string
stringify_yytokentype(int n, const char *strip/*=NULL*/, bool canonic/*=false*/)
{
    std::string retval;
    switch (n) {
        case 258: retval = "OMP"; break;
        case 259: retval = "PARALLEL"; break;
        case 260: retval = "IF"; break;
        case 261: retval = "NUM_THREADS"; break;
        case 262: retval = "ORDERED"; break;
        case 263: retval = "SCHEDULE"; break;
        case 264: retval = "STATIC"; break;
        case 265: retval = "DYNAMIC"; break;
        case 266: retval = "GUIDED"; break;
        case 267: retval = "RUNTIME"; break;
        case 268: retval = "SECTIONS"; break;
        case 269: retval = "SINGLE"; break;
        case 270: retval = "NOWAIT"; break;
        case 271: retval = "SECTION"; break;
        case 272: retval = "FOR"; break;
        case 273: retval = "MASTER"; break;
        case 274: retval = "CRITICAL"; break;
        case 275: retval = "BARRIER"; break;
        case 276: retval = "ATOMIC"; break;
        case 277: retval = "FLUSH"; break;
        case 278: retval = "TARGET"; break;
        case 279: retval = "UPDATE"; break;
        case 280: retval = "DIST_DATA"; break;
        case 281: retval = "BLOCK"; break;
        case 282: retval = "DUPLICATE"; break;
        case 283: retval = "CYCLIC"; break;
        case 284: retval = "THREADPRIVATE"; break;
        case 285: retval = "PRIVATE"; break;
        case 286: retval = "COPYPRIVATE"; break;
        case 287: retval = "FIRSTPRIVATE"; break;
        case 288: retval = "LASTPRIVATE"; break;
        case 289: retval = "SHARED"; break;
        case 290: retval = "DEFAULT"; break;
        case 291: retval = "NONE"; break;
        case 292: retval = "REDUCTION"; break;
        case 293: retval = "COPYIN"; break;
        case 294: retval = "TASK"; break;
        case 295: retval = "TASKWAIT"; break;
        case 296: retval = "UNTIED"; break;
        case 297: retval = "COLLAPSE"; break;
        case 298: retval = "AUTO"; break;
        case 299: retval = "DECLARE"; break;
        case 300: retval = "DATA"; break;
        case 301: retval = "DEVICE"; break;
        case 302: retval = "MAP"; break;
        case 303: retval = "ALLOC"; break;
        case 304: retval = "TO"; break;
        case 305: retval = "FROM"; break;
        case 306: retval = "TOFROM"; break;
        case 307: retval = "SIMD"; break;
        case 308: retval = "SAFELEN"; break;
        case 309: retval = "ALIGNED"; break;
        case 310: retval = "LINEAR"; break;
        case 311: retval = "UNIFORM"; break;
        case 312: retval = "INBRANCH"; break;
        case 313: retval = "NOTINBRANCH"; break;
        case 314: retval = "MPI"; break;
        case 315: retval = "MPI_ALL"; break;
        case 316: retval = "MPI_MASTER"; break;
        case 317: retval = "TARGET_BEGIN"; break;
        case 318: retval = "TARGET_END"; break;
        case 319: retval = "LOGAND"; break;
        case 320: retval = "LOGOR"; break;
        case 321: retval = "SHLEFT"; break;
        case 322: retval = "SHRIGHT"; break;
        case 323: retval = "PLUSPLUS"; break;
        case 324: retval = "MINUSMINUS"; break;
        case 325: retval = "PTR_TO"; break;
        case 326: retval = "LE_OP2"; break;
        case 327: retval = "GE_OP2"; break;
        case 328: retval = "EQ_OP2"; break;
        case 329: retval = "NE_OP2"; break;
        case 330: retval = "RIGHT_ASSIGN2"; break;
        case 331: retval = "LEFT_ASSIGN2"; break;
        case 332: retval = "ADD_ASSIGN2"; break;
        case 333: retval = "SUB_ASSIGN2"; break;
        case 334: retval = "MUL_ASSIGN2"; break;
        case 335: retval = "DIV_ASSIGN2"; break;
        case 336: retval = "MOD_ASSIGN2"; break;
        case 337: retval = "AND_ASSIGN2"; break;
        case 338: retval = "XOR_ASSIGN2"; break;
        case 339: retval = "OR_ASSIGN2"; break;
        case 340: retval = "LEXICALERROR"; break;
        case 341: retval = "IDENTIFIER"; break;
        case 342: retval = "ICONSTANT"; break;
        case 343: retval = "EXPRESSION"; break;
        case 344: retval = "ID_EXPRESSION"; break;
    }
    if (retval.empty()) {
        char buf[75];
#ifndef _MSC_VER
        int nprint __attribute__((unused)) = snprintf(buf, sizeof buf, "(yytokentype)%d", n);
#else
        int nprint = 0; assert(0);
#endif
        assert(nprint < (int)sizeof buf);
        retval = buf;
    } else {
        if (strip && !strncmp(strip, retval.c_str(), strlen(strip)))
            retval = retval.substr(strlen(strip));
        if (canonic)
            retval = "yytokentype::" + retval;
    }
    return retval;
}

} //namespace
